AcWing 125. 耍杂技的牛    原题链接    中等
作者：    洛希krist ,  2019-04-07 17:36:55 ,  阅读 1422

11


3
农民约翰的N头奶牛（编号为1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。

奶牛们不是非常有创意，只提出了一个杂技表演：

叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。

奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。

这N头奶牛中的每一头都有着自己的重量Wi以及自己的强壮程度Si。

一头牛只撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。

您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。

输入格式
第一行输入整数N，表示奶牛数量。

接下来N行，每行输入两个整数，表示牛的重量和强壮程度，第i行表示第i头牛的重量Wi以及它的强壮程度Si。

输出格式
输出一个整数，表示最大风险值的最小可能值。

数据范围
1≤N≤50000,
1≤Wi≤10,000,
1≤Si≤1,000,000,000

输入样例：
3
10 3
2 5
3 3
输出样例：
2
(贪心)
思路: 与国王游戏的贪心策略相似， 我们先分析每头牛的危险值 = 他前面牛的w(重量值)和 - 自身的s(强壮值)，要使每头牛的危险值最小，这显然是与w 和 s同时相关，所以先 yy 出一种做法按 每头牛的w + s进行升序排序(题见多了可能就会有这种题感)。接下来进行数学分析证明:

牛	交换前	交换后
ii	
∑j=1i−1wj−si
∑j=1i−1wj−si
∑j=1i−1wj+wi+1−si
∑j=1i−1wj+wi+1−si
i+1i+1	
∑j=1iwj−si+1
∑j=1iwj−si+1
∑j=1i−1wj−si+1
∑j=1i−1wj−si+1
其他牛的危险值显然不变，所以分析交换前后这两头牛中最大的危险值即可。
将上述式子进行化简，每个式子减去 ∑i−1j=1wj∑j=1i−1wj得到如下式子

牛	交换前	交换后
ii	
−si
−si
wi+1−si
wi+1−si
i+1i+1	
wi−si+1
wi−si+1
−si+1
−si+1
由于s, w都是正数，wi−si+1>−si+1wi−si+1>−si+1 , wi+1−si>−siwi+1−si>−si
比较wi−si+1wi−si+1, wi+1−siwi+1−si即可

当wi−si+1>=wi+1−siwi−si+1>=wi+1−si，即 wi+si>=wi+1+si+1wi+si>=wi+1+si+1时, 交换后更优

当wi−si+1<wi+1−siwi−si+1<wi+1−si，即 wi+si<wi+1+si+1wi+si<wi+1+si+1时, 交换前更优

所以得到做法: 按每头牛的 w + s 进行排序, 当存在逆序时就进行交换(即升序排序)，
然后根据题意算出每头牛的危险值记录其中的最大值即可

代码:

#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef pair<int, int> PII;
const int N = 5e4 + 5;
PII a[N];
int main()
{
    int n;
    cin >> n;
    for(int i = 0; i < n; i ++ )
    {
        int x, y;
        scanf("%d %d", &x, &y);
        a[i].first = x + y;
        a[i].second = y;
    }
    sort(a, a + n);
    ll res = -1e18, sum = 0;
    for(int i = 0; i < n; i ++ )
    {
        sum -= a[i].second;
        res = max(res, sum);
        sum += a[i].first;
    }
    cout << res << endl;
    return 0;
}

作者：洛希krist
链接：https://www.acwing.com/solution/content/845/

#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 50010;

int n;
PII cow[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int s, w;
        scanf("%d%d", &w, &s);
        cow[i] = {w + s, w};
    }

    sort(cow, cow + n);

    int res = -2e9, sum = 0;
    for (int i = 0; i < n; i ++ )
    {
        int s = cow[i].first - cow[i].second, w = cow[i].second;
        res = max(res, sum - s);
        sum += w;
    }

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/79282/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 104. 货仓选址的贪心策略    原题链接    简单
作者：    烛之武 ,  2020-02-03 17:46:06 ,  阅读 603

5


绝对值贪心
从几何的观点考虑（从绝对值不等式的角度考虑也可以）



时间复杂度 O(N)O(N)
C++ 代码
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std ;

typedef long long LL ;
const int N = 100010 ;

int q[N] ;
int n ;

int main(){
    cin >> n ;

    for(int i=1;i<=n;i++){
        cin >> q[i] ;
    }

    sort(q+1,q+1+n) ;
    LL res = 0 ;

    for(int i=1;i<=n;i++){
        res += abs(q[i]-q[(n+1)/2]) ;
    }

    cout << res << endl ;

    return 0 ;
}


作者：烛之武
链接：https://www.acwing.com/solution/content/8130/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int q[N];

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

    sort(q, q + n);

    int res = 0;
    for (int i = 0; i < n; i ++ ) res += abs(q[i] - q[n / 2]);

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/79277/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


算法分析
安排他们的打水顺序才能使所有人的等待时间之和最小，则需要将打水时间最短的人先打水
证明：
不妨设

(1)i1i1 ≠ i2i2 ≠ i3i3 ≠ … ≠ inin
(2)i1i1~inin属于[1,n][1,n]
(3)t1t1 < t2t2 < t3t3 <… < tntn,

1、由i的任意性，打水的时间总和为ti1ti1 * (n - 1) + ti2ti2 * (n - 2) + … + tintin * (n - n)
=n * (ti1ti1 + ti2ti2 +… + tintin) - (ti1ti1 * 1 + ti2ti2 * 2 + … + tintin * n)

2、即相当于求 ti1ti1 * 1 + ti2ti2 * 2 + … + tintin * n 的最大值

3、假设ti1ti1 , ti2ti2 ,… , tintin是按自然顺序排好序时是最大值，即TmaxTmax = t1t1 * 1 + t2t2 * 2 + … + tntn
4、任意选择两项ta∗xta∗x,tb∗(x+c)tb∗(x+c),且tata < tbtb,c > 0,交换tata,tbtb位置得到tb∗xtb∗x,ta∗(x+c)ta∗(x+c) ,同时交换后不会对其他项造成影响
由于tata * x + tbtb * (x + c) = tata * x + tbtb * x + tbtb * c > tata * x + tbtb * x + tata * c = tbtb * x + tata * (x + c),即交换之后比原来的值更小.由于选取的任意性可得假设成立.

时间复杂度 O(nlogn)O(nlogn)
Java 代码
import java.util.*;


public class Main{

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        int n = scan.nextInt();
        int[] a = new int[n + 1];
        for(int i = 1;i <= n;i++)
        {
            a[i] = scan.nextInt();
        }
        Arrays.sort(a);
        long res = 0;
        for(int i = 1;i <= n;i++)
        {
            res += (a[i] * (n - i));
        }
        System.out.println(res);

    }

}

作者：小呆呆
链接：https://www.acwing.com/solution/content/5943/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int t[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &t[i]);

    sort(t, t + n);
    reverse(t, t + n);

    LL res = 0;
    for (int i = 0; i < n; i ++ ) res += t[i] * i;

    printf("%lld\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/79272/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 148. 合并果子    原题链接    简单
作者：    yxc ,  2019-07-30 17:17:36 ,  阅读 826

9


1
算法
(贪心,哈夫曼树,堆,优先队列) O(nlogn)O(nlogn)
经典哈夫曼树的模型，每次合并重量最小的两堆果子即可。

时间复杂度
使用小根堆维护所有果子，每次弹出堆顶的两堆果子，并将其合并，合并之后将两堆重量之和再次插入小根堆中。

每次操作会将果子的堆数减一，一共操作 n−1n−1 次即可将所有果子合并成1堆。每次操作涉及到2次堆的删除操作和1次堆的插入操作，计算量是 O(logn)O(logn)。因此总时间复杂度是 O(nlogn)O(nlogn)。

C++ 代码
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);

    priority_queue<int, vector<int>, greater<int>> heap;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        heap.push(x);
    }

    int res = 0;
    while (heap.size() > 1)
    {
        int a = heap.top(); heap.pop();
        int b = heap.top(); heap.pop();
        res += a + b;
        heap.push(a + b);
    }

    printf("%d\n", res);
    return 0;
}

作者：yxc
链接：https://www.acwing.com/solution/content/3258/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 907. 区间覆盖    原题链接    简单
作者：    松鼠爱葡萄 ,  2020-07-24 15:20:44 ,  阅读 139

5


1
算法分析
将所有区间按照左端点从小到大进行排序

从前往后枚举每个区间，在所有能覆盖start的区间中，选择右端点的最大区间，然后将start更新成右端点的最大值

这一步用到了贪心决策

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    int st, ed;
    scanf("%d%d", &st, &ed);
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    int res = 0;
    bool success = false;
    for (int i = 0; i < n; i ++ )
    {
        int j = i, r = -2e9;
        while (j < n && range[j].l <= st)
        {
            r = max(r, range[j].r);
            j ++ ;
        }

        if (r < st)
        {
            res = -1;
            break;
        }

        res ++ ;
        if (r >= ed)
        {
            success = true;
            break;
        }

        st = r;
        i = j - 1; 
    }

    if (!success) res = -1;
    printf("%d\n", res);

    return 0;
}

作者：松鼠爱葡萄
链接：https://www.acwing.com/solution/content/16980/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    int st, ed;
    scanf("%d%d", &st, &ed);
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    int res = 0;
    bool success = false;
    for (int i = 0; i < n; i ++ )
    {
        int j = i, r = -2e9;
        while (j < n && range[j].l <= st)
        {
            r = max(r, range[j].r);
            j ++ ;
        }

        if (r < st)
        {
            res = -1;
            break;
        }

        res ++ ;
        if (r >= ed)
        {
            success = true;
            break;
        }

        st = r;
        i = j - 1;
    }

    if (!success) res = -1;
    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/65087/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 906. 区间分组    原题链接    简单
作者：    小呆呆 ,  2019-11-05 23:54:40 ,  阅读 748

5


2
算法分析
1、将所有区间按左端点从小到大排序

2、从前往后枚举每个区间，判断能否将其放到某个现有的组中，即是否存在当前区间的的左端点L > 任意组中右端点的最小值的组

如果不存在这样的组，则开新组，然后再将其放进组中
如果存在这样的组，则将其放在符合条件的组中，并更新当前组的右端点的值
3、为了不用每次选择组时都遍历所有组，可以通过小根堆来维护所有组中的尾端

证明：
1、按照上述存放，一定是一种合法的方案，则Ans <= cnt

2、由于分了cnt个组，则说明一定存在cnt个区间含有公共点，则一定至少开cnt个组，则Ans >= cnt
综合1、2可推出Ans == cnt

时间复杂度 O(nlogn)O(nlogn)
Java 代码
import java.util.*;
public class Main{
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        List<PIIs> list = new ArrayList<PIIs>();
        int n = scan.nextInt();
        for(int i = 0;i < n;i++)
        {
            int L = scan.nextInt();
            int R = scan.nextInt();
            list.add(new PIIs(L,R));
        }
        //按左端点排序
        Collections.sort(list);
        //通过小根堆维护每组的尾端
        Queue<Integer> minheap = new PriorityQueue<Integer>();
        for(PIIs item : list)
        {
            if(minheap.isEmpty() || minheap.peek() >= item.getFirst())
                minheap.add(item.getSecond());
            else 
            {
                //更新小根堆
                minheap.poll();
                minheap.add(item.getSecond());
            }
        }
        System.out.println(minheap.size());

    }

}



class PIIs implements Comparable<PIIs>{
    private int first;
    private int second;

    public int getFirst()
    {
        return this.first;
    }
    public int getSecond()
    {
        return this.second;
    }
    public PIIs(int first,int second)
    {
        this.first = first;
        this.second = second;
    }

    @Override
    public int compareTo(PIIs o) {
        // TODO 自动生成的方法存根
        return Integer.compare(first, o.first);
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/5898/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    priority_queue<int, vector<int>, greater<int>> heap;
    for (int i = 0; i < n; i ++ )
    {
        auto r = range[i];
        if (heap.empty() || heap.top() >= r.l) heap.push(r.r);
        else
        {
            heap.pop();
            heap.push(r.r);
        }
    }

    printf("%d\n", heap.size());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/65079/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 908. 最大不相交区间数量    原题链接    简单
作者：    墨染空 ,  2019-08-31 20:51:26 ,  阅读 621

4


(贪心) O(nlogn)O(nlogn)
这道题也可以按左端点最小到大排序。



即排完序后的线段，在数组位置靠前线段左端点 < 数组位置靠后线段的左端点。
即对于每个线段ii，要找到一个jj使得，Li>Rj(loclast+1<=j<i)Li>Rj(loclast+1<=j<i)，所以我们搞个前缀minmin就行了。

注释：这里的loclastloclast指上一个选的线段的位置。

C++ 代码
#include <cstdio>
#include <iostream>
#include <algorithm>

using namespace std;
typedef pair<int, int> PII;
const int N = 100005;
int n;
PII s[N];
int main(){
    scanf("%d", &n);

    for(int i = 1; i <= n; i++)
        scanf("%d%d", &s[i].first, &s[i].second);

    sort(s + 1, s + 1 + n);

    int ans = 1, maxR = s[1].second;
    for(int i = 2; i <= n; i++){
        if(s[i].first <= maxR) maxR = min(maxR, s[i].second);
        else ans++, maxR = s[i].second;
    }
    printf("%d\n", ans);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/solution/content/4276/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return r < W.r;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &range[i].l, &range[i].r);

    sort(range, range + n);

    int res = 0, ed = -2e9;
    for (int i = 0; i < n; i ++ )
        if (ed < range[i].l)
        {
            res ++ ;
            ed = range[i].r;
        }

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/65075/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 905. 区间选点    原题链接    简单
作者：    松鼠爱葡萄 ,  2020-07-24 10:06:04 ,  阅读 158

8


3
算法分析
将每个区间按照右端点从小到大进行排序

从前往后枚举区间，end值初始化为无穷小

如果本次区间不能覆盖掉上次区间的右端点， ed < range[i].l

说明需要选择一个新的点， res ++ ; ed = range[i].r;



如果本次区间可以覆盖掉上次区间的右端点，则进行下一轮循环
时间复杂度 O(nlogn)O(nlogn)
证明
证明ans<=cnt ：cnt 是一种可行方案， ans是可行方案的最优解，也就是最小值。

证明ans>=cnt ： cnt可行方案是一个区间集合，区间从小到大排序，两两之间不相交。

所以覆盖每一个区间至少需要cnt个点。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return r < W.r;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &range[i].l, &range[i].r);

    sort(range, range + n);

    int res = 0, ed = -2e9;
    for (int i = 0; i < n; i ++ )
        if (ed < range[i].l)
        {
            res ++ ;
            ed = range[i].r;
        }

    printf("%d\n", res);

    return 0;
}

作者：松鼠爱葡萄
链接：https://www.acwing.com/solution/content/16905/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return r < W.r;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &range[i].l, &range[i].r);

    sort(range, range + n);

    int res = 0, ed = -2e9;
    for (int i = 0; i < n; i ++ )
        if (range[i].l > ed)
        {
            res ++ ;
            ed = range[i].r;
        }

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/65062/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 901. 滑雪    原题链接    简单
作者：    itdef ,  2019-10-13 22:15:17 ,  阅读 826

8


题目描述
给定一个R行C列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
在给定矩阵中，一条可行的滑行轨迹为24-17-2-1。

在给定矩阵中，最长的滑行轨迹为25-24-23-…-3-2-1，沿途共经过25个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

输入格式
第一行包含两个整数R和C。

接下来R行，每行包含C个整数，表示完整的二维矩阵。

输出格式
输出一个整数，表示可完成的最长滑雪长度。

数据范围
1≤R,C≤300,
0≤矩阵中整数≤10000

输入样例：
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
输出样例：
25
算法1
一开始 写的常规DFS
但是在某些数据 超时。果然没那么简单

代码

#include <iostream>
#include <vector>

using namespace std;

const int N = 310;
int n,m;
int maxlen = -1;
vector<vector<int>>  vv;

int addx[] = {1,-1,0,0};
int addy[] = {0,0,1,-1};

void dfs(int x,int y,int len)
{
    if(len > maxlen) maxlen = len;

    for(int i = 0;i < 4;i++){
        int newx = x + addx[i];
        int newy = y + addy[i];

        if(newx >=0 && newx < n && newy >=0 && newy < m &&
            vv[newx][newy] < vv[x][y])
        {
            dfs(newx,newy,len+1);        
        }
    }
}


int main()
{
    cin >> n >> m;

    for(int i = 0; i < n;i++){
        vector<int> v;
        vv.push_back(v);
        for(int j = 0;j< m;j++){
            int t =0;
            cin >> t;
            vv[i].push_back(t);    
        }
    }


    for(int i = 0; i < n;i++){
        for(int j = 0;j < m;j++){
            int len =0;
            dfs(i,j,len);
        }
    }

    cout << maxlen+1  << endl;

    return 0;
}

算法2
使用记忆化数组 记录每个点的最大滑动长度
遍历每个点作为起点
然后检测该点四周的点 如果可以滑动到其他的点
那么该点的最大滑动长度 就是其他可以滑到的点的滑动长度+1
dp[i][j] = max(dp[i][j-1], dp[i][j+1],dp[i-1][j],dp[i+1][j])

由于滑雪是必须滑到比当前低的点 所以不会存在一个点多次进入的问题
如果该点的dp[][] 不为初始化值 那么就说明计算过 不必再次计算。

按照上述公式 代码如下 AC

#include <iostream>

using namespace std;

const int N = 310;
int R,C;

int arr[N][N];
int dp[N][N];

int maxlen = -1;

int addx[] = {1,-1,0,0};
int addy[] = {0,0,1,-1};

int  Dfs(int x,int y)
{
    if(dp[x][y] != 0) return dp[x][y];


     for(int i = 0;i < 4;i++){
        int newx = x + addx[i];
        int newy = y + addy[i];

        if(newx >=0 && newx < C && newy >=0 && newy < R &&
            arr[newx][newy] < arr[x][y])
        {
            dp[x][y] = max(dp[x][y], Dfs(newx,newy) +1);
        }
    }
    return dp[x][y];
}

int main()
{
    ios::sync_with_stdio(false);

  cin >> R >>C;

  for(int i = 0; i < R;i++){
      for(int j=0;j<C;j++){
        cin >> arr[i][j];    
      }
  }

  for(int i = 0; i < R;i++){
      for(int j = 0;j< C;j++){
        int len = Dfs(i,j);   
        maxlen = max(maxlen,len);
      }
  }  

  cout << maxlen +1  << endl;

    return 0;
}

作者：itdef
链接：https://www.acwing.com/solution/content/5280/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 310;

int n, m;
int g[N][N];
int f[N][N];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

int dp(int x, int y)
{
    int &v = f[x][y];
    if (v != -1) return v;

    v = 1;
    for (int i = 0; i < 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a >= 1 && a <= n && b >= 1 && b <= m && g[x][y] > g[a][b])
            v = max(v, dp(a, b) + 1);
    }

    return v;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            scanf("%d", &g[i][j]);

    memset(f, -1, sizeof f);

    int res = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            res = max(res, dp(i, j));

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/64186/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 285. 没有上司的舞会 - 不用建图    原题链接    简单
作者：    Jayfeather ,  2019-09-22 17:11:56 ,  阅读 1079

13


2
题目描述
选了某个节点就不能选父节点和子节点。求最大权值和。

样例
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
0 0
5
算法1
(树形DP) O(n)O(n)
题解里的人都建图了啊，但是这题明明可以不用这么麻烦的……

本题稍加思索即可得出为树形dp。

每个人只有两种状态，则设dp[0][i]dp[0][i]为第ii个人不来，他的下属所能获得的最大快乐值；dp[1][i]dp[1][i]为第ii个人来，他的下属所能获得的最大快乐值。

所以容易推出状态转移方程：

dp[0][i]=∑u=sonsmax(dp[1][u],dp[0][u])dp[0][i]=∑u=sonsmax(dp[1][u],dp[0][u])当前节点不选，那么子节点随意

dp[1][i]=∑u=sonsdp[0][u]+happy[i]dp[1][i]=∑u=sonsdp[0][u]+happy[i]当前节点选，子节点不能选

分析可得，每个人的状态要在下属的状态更新完了才能更新，所以用类似拓扑的方法，只记录每个子节点的父亲，最后从所有入度为00的点开始跑就行了。在更新每个子节点时顺便让父节点加上自己的权值，最后访问父节点时权值已经更新好了，就可以省去建图的麻烦。

C++ 代码
#include <iostream>
#include <cstdio>
using namespace std;
int dp[2][6010];//dp解释见上
int f[2][6010];//f[0]为父亲，f[1]为高兴值
int ind[6010];//入度
int vis[6010];//访问标记
int root;//树的根
void dfs(int u){//递归从后往前更新
    if(!u) return;
    vis[u]=1;//已访问
    root=u;//最后一个访问到的一定是根，所以一直更新根就行了
    dp[0][f[0][u]]+=max(dp[1][u]+f[1][u],dp[0][u]);//给父亲更新
    dp[1][f[0][u]]+=dp[0][u];
    ind[f[0][u]]--;//更新完一个子节点
    if(!ind[f[0][u]]) dfs(f[0][u]);//在所有子节点更新后再更新（入度为0）
}
int main(){
    int n=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&f[1][i]);
    int a,b;
    for(int i=1;i<n;i++){
        scanf("%d%d",&a,&b);
        f[0][a]=b;//保存节点信息
        ind[b]++;
    }
    for(int i=1;i<=n;i++)
        if(!vis[i]&&!ind[i])//没有被访问过，没有入度，说明是叶子节点
            dfs(i);
    printf("%d\n",max(dp[0][root],dp[1][root]+f[1][root]));//取根节点两种方案的最大值
    return 0;
}

作者：Jayfeather
链接：https://www.acwing.com/solution/content/4757/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 6010;

int n;
int h[N], e[N], ne[N], idx;
int happy[N];
int f[N][2];
bool has_fa[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    f[u][1] = happy[u];

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        dfs(j);

        f[u][1] += f[j][0];
        f[u][0] += max(f[j][0], f[j][1]);
    }
}

int main()
{
    scanf("%d", &n);

    for (int i = 1; i <= n; i ++ ) scanf("%d", &happy[i]);

    memset(h, -1, sizeof h);
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(b, a);
        has_fa[a] = true;
    }

    int root = 1;
    while (has_fa[root]) root ++ ;

    dfs(root);

    printf("%d\n", max(f[root][0], f[root][1]));

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/64190/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 91. 最短Hamilton路径    原题链接    简单
作者：    数学家是我理想 ,  2019-02-18 21:39:26 ,  阅读 1938

10


5
博客地址：wmathor
NP Hard问题，暴力时间复杂度O(n∗n!)O(n∗n!)
这题正解其实是利用状压DP的方法来做，状态转移方程为

dp[i][j] = min{dp[i][j], dp[i - (1 << j)][k] + map[k][j]}
其中map数组为权值，map[k][j]是点k到点j的权值

dp[i][j]表示当前已经走过点的集合为i，移动到j。所以这个状态转移方程就是找一个中间点k，将已经走过点的集合i中去除掉j（表示j不在经过的点的集合中），然后再加上从k到j的权值

问题在于如何表达已经走过点的集合i，其实很简单，假如走过0,1,4这三个点，我们用二进制10011就可以表示，2,3没走过所以是0

那么走过点的集合i中去除掉点j也很容易表示i - (1 << j)，比方说i是{0,1,4}，j是1，那么i = 10011，(1 << j) = 10，i - (1 << j) = 10001

那么问题的答案就应该是dp[01....111][n-1]，表示0~n-1都走过，且当前移动到n-1这个点

分析一下时间复杂度，n为20的时候，外层循环(1<<20)，内层循环20，所以整体时间复杂度O(20∗220)O(20∗220)，这比O(n∗n!)O(n∗n!)快多了

import java.util.Scanner;

public class Main {
    static int[][] dp = new int[1 << 20][20];
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        int n = cin.nextInt();
        int[][] map = new int[n][n];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                map[i][j] = cin.nextInt();
        for (int i = 0; i < (1 << n); i++) 
            for (int j = 0; j < n; j++)
                dp[i][j] = Integer.MAX_VALUE >> 1;
        dp[1][0] = 0;
        for (int i = 0; i < (1 << n); i++) // 二进制枚举走过的点的集合
            for(int j = 0; j < n; j++)
                if ((i >> j & 1) == 1)
                    for (int k = 0; k < n; k++) 
                        if ((i - (1 << j) >> k & 1) == 1)
                            dp[i][j] = Math.min(dp[i][j], dp[i - (1 << j)][k] + map[j][k]);
        System.out.println(dp[(1 << n) - 1][n - 1]);
    }
}

作者：数学家是我理想
链接：https://www.acwing.com/solution/content/1037/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20, M = 1 << N;

int n;
int w[N][N];
int f[M][N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            cin >> w[i][j];

    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;

    for (int i = 0; i < 1 << n; i ++ )
        for (int j = 0; j < n; j ++ )
            if (i >> j & 1)
                for (int k = 0; k < n; k ++ )
                    if (i >> k & 1)
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + w[k][j]);

    cout << f[(1 << n) - 1][n - 1];

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/64193/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 291. 本题关键点总结    原题链接    中等
作者：    FishToucher ,  2019-10-21 12:53:00 ,  阅读 1759

24


7
 1. 所谓的状态压缩DP，就是用二进制数保存状态。为什么不直接用数组记录呢？因为用一个二进制数记录方便作位运算。前面做过的八皇后，八数码，也用到了状态压缩。

 2. 本题等价于找到所有横放 1 X 2 小方格的方案数，因为所有横放确定了，那么竖放方案是唯一的。

 3. 用f[i][j]记录第i列第j个状态。j状态位等于1表示上一列有横放格子，本列有格子捅出来。转移方程很简单，本列的每一个状态都由上列所有“合法”状态转移过来f[i][j] += f[i - 1][k]

 4. 两个转移条件： i 列和 i - 1列同一行不同时捅出来 ； 本列捅出来的状态j和上列捅出来的状态k求或，得到上列是否为奇数空行状态，奇数空行不转移。

 5. 初始化条件f[0][0] = 1，第0列只能是状态0，无任何格子捅出来。返回f[m][0]。第m + 1列不能有东西捅出来。

#include<bits/stdc++.h>
using namespace std;
const int N = 12, M = 1 << N;
int st[M];
long long f[N][M];


int main(){
    int n, m;
    while (cin >> n >> m && (n || m)){

        for (int i = 0; i < 1 << n; i ++){
            int cnt = 0;
            st[i] = true;
            for (int j = 0; j < n; j ++)
                if (i >> j & 1){
                    if (cnt & 1) st[i] = false; // cnt 为当前已经存在多少个连续的0
                    cnt = 0;
                }
                else cnt ++;
            if (cnt & 1) st[i] = false; // 扫完后要判断一下最后一段有多少个连续的0
        }

        memset(f, 0, sizeof f);
        f[0][0] = 1;
        for (int i = 1; i <= m; i ++)
            for (int j = 0; j < 1 << n; j ++)
                for (int k = 0; k < 1 << n; k ++)
                    if ((j & k) == 0 && (st[j | k])) 
                    // j & k == 0 表示 i 列和 i - 1列同一行不同时捅出来
                    // st[j | k] == 1 表示 在 i 列状态 j， i - 1 列状态 k 的情况下是合法的.
                        f[i][j] += f[i - 1][k];      
        cout << f[m][0] << endl;
    }
    return 0;
}

作者：FishToucher
链接：https://www.acwing.com/solution/content/5121/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 12, M = 1 << N;

int n, m;
long long f[N][M];
bool st[M];

int main()
{
    while (cin >> n >> m, n || m)
    {
        for (int i = 0; i < 1 << n; i ++ )
        {
            int cnt = 0;
            st[i] = true;
            for (int j = 0; j < n; j ++ )
                if (i >> j & 1)
                {
                    if (cnt & 1) st[i] = false;
                    cnt = 0;
                }
                else cnt ++ ;
            if (cnt & 1) st[i] = false;
        }

        memset(f, 0, sizeof f);
        f[0][0] = 1;
        for (int i = 1; i <= m; i ++ )
            for (int j = 0; j < 1 << n; j ++ )
                for (int k = 0; k < 1 << n; k ++ )
                    if ((j & k) == 0 && st[j | k])
                        f[i][j] += f[i - 1][k];

        cout << f[m][0] << endl;
    }
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/64200/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 338. 用提高课的方式打开基础课acwing338计数问题    原题链接    简单
作者：    aleihentai ,  2019-10-27 22:07:47 ,  阅读 1576

37


22
题目描述
给定两个整数 a 和 b，求 a 和 b 之间的所有数字中0~9的出现次数。

样例
注意到样例里面有个坑是第一个数有可能大于第二个

1 10
44 497
346 542
1199 1748
1496 1403
1004 503
1714 190
1317 854
1976 494
1001 1960
0 0
数位DP树形统计方法
参考资料：算法提高班
手写笔记






C++ 代码
#include <iostream>
#include <vector>

using namespace std;

int base[10];
int f[10][10];
int g[10][10];

void init()
{
    base[0] = 1;
    for(int i = 1 ; i <= 9 ; i++) base[i] = base[i-1]*10;

    //从00……0 - 99……9 的各位数字有多少个，其中i为数字个数（包含前导零）
    for(int i = 0 ; i <= 9 ; i++) f[1][i] = 1;
    for(int i = 2 ; i <= 9 ; i++)
        for(int j = 0 ; j <= 9 ; j++)
            f[i][j] = f[i-1][j]*10 + base[i-1];

    //从1 - 99……9 的各位数字有多少个，其中i为数字个数（不包含前导零）
    for(int i = 1 ; i <= 9 ; i++) g[1][i] = 1;//循环从1开始
    for(int i = 2 ; i <= 9 ; i++) {
        g[i][0] = g[i-1][0] + f[i-1][0]*9;
        for(int j = 1 ; j <= 9 ; j++)
            g[i][j] = g[i-1][j] + f[i-1][j]*9 + base[i-1];
    }
}

vector<int> dp(int n)
{
    vector<int> ans(10,0); //记录答案
    if(n<=0) return ans; //边界条件

    vector<int> nums;
    while(n) nums.push_back(n%10), n/=10;

    vector<int> last(10,0); //记录前缀中各个数字个数

    //统计1 - 99……9(n-1个9)里面各个数字有多少个
    for(int i = 0 ; i <= 9 ; i++) ans[i] = g[nums.size()-1][i];
    //统计大于10……0(n-1个0) 的树里各个数字有多少个
    for(int i = nums.size()-1 ; i >=0 ; i--) {
        //循环变量i可以表示剩下的数字有多少个
        int x = nums[i];
        for(int j = i==nums.size()-1 ; j < x ; j++) { //第一次循环不能有0
            //前缀部分
            for(int k = 0 ; k <= 9 ; k++)
                ans[k] += last[k] * base[i];
            //当前位置部分
            ans[j] += base[i];
            //后缀部分
            for(int k = 0 ; k <= 9 ; k++)
                ans[k] += f[i][k];
        }
        //更新前缀计数器
        last[x] ++;

        //统计叶子节点（这个数本身）
        if(!i) for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k];
    }
    return ans;
}

vector<int> ask(int a, int b)
{
    auto x = dp(b);
    auto y = dp(a-1);
    vector<int> ans;
    for(int i = 0 ; i <= 9 ; i++) ans.push_back(x[i]-y[i]);
    return ans;
}

void print(vector<int> ans)
{
    for(auto x:ans) printf("%d ",x);
    puts("");
}

bool check(int x)
{
    auto t = ask(x,x);
    vector<int> cnt(10,0);
    while(x) cnt[x%10]++,x/=10;
    for(int i = 0 ; i <= 9 ; i++)
        if(cnt[i] != t[i])
            return false;
    return true;
}

int main()
{
    init();

    //这里是一个DEBUG函数
    // for(int i = 1 ; i <= 1000000 ; i*=10) {
    //     if(!check(i))
    //         printf("ERROR:%d\n",i);
    // }

    int a,b;
    while(cin >> a >> b, a||b) {
        if(a>b) swap(a,b);
        auto t = ask(a,b);
        print(t);
    }

    return 0;
}

作者：aleihentai
链接：https://www.acwing.com/solution/content/4934/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 10;

/*

001~abc-1, 999

abc
    1. num[i] < x, 0
    2. num[i] == x, 0~efg
    3. num[i] > x, 0~999

*/

int get(vector<int> num, int l, int r)
{
    int res = 0;
    for (int i = l; i >= r; i -- ) res = res * 10 + num[i];
    return res;
}

int power10(int x)
{
    int res = 1;
    while (x -- ) res *= 10;
    return res;
}

int count(int n, int x)
{
    if (!n) return 0;

    vector<int> num;
    while (n)
    {
        num.push_back(n % 10);
        n /= 10;
    }
    n = num.size();

    int res = 0;
    for (int i = n - 1 - !x; i >= 0; i -- )
    {
        if (i < n - 1)
        {
            res += get(num, n - 1, i + 1) * power10(i);
            if (!x) res -= power10(i);
        }

        if (num[i] == x) res += get(num, i - 1, 0) + 1;
        else if (num[i] > x) res += power10(i);
    }

    return res;
}

int main()
{
    int a, b;
    while (cin >> a >> b , a)
    {
        if (a > b) swap(a, b);

        for (int i = 0; i <= 9; i ++ )
            cout << count(b, i) - count(a - 1, i) << ' ';
        cout << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/64211/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 900. 整数划分 （求方案数、朴素做法 、等价变形 ）    原题链接    简单
作者：    Wilson79 ,  2019-10-03 15:55:35 ,  阅读 1323

17


3
来源：900. 整数划分

题目描述
一个正整数n可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中n1≥n2≥…≥nk,k≥1n=n1+n2+…+nk，其中n1≥n2≥…≥nk,k≥1。

我们将这样的一种表示称为正整数n的一种划分。

现在给定一个正整数n，请你求出n共有多少种不同的划分方法。

输入格式
共一行，包含一个整数n。

输出格式
共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对10^9+7取模。

数据范围
1≤n≤1000

输入样例:
5

输出样例:
7

思路：把1,2,3, … n分别看做n个物体的体积，这n个物体均无使用次数限制，问恰好能装满总体积为n的背包的总方案数（完全背包问题变形）

初值问题：
求最大值时，当都不选时，价值显然是 0
而求方案数时，当都不选时，方案数是 1（即前 i 个物品都不选的情况也是一种方案），所以需要初始化为 1
即：for (int i = 0; i <= n; i ++) f[i][0] = 1;
等价变形后： f[0] = 1

状态计算：

f[i][j]f[i][j] 表示前i个整数（1,2…,i）恰好拼成j的方案数
求方案数：把集合选0个i，1个i，2个i，…全部加起来
f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;
f[i][j - i] = f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;
因此 f[i][j]=f[i−1][j]+f[i][j−i];f[i][j]=f[i−1][j]+f[i][j−i]; (这一步类似完全背包的推导）

朴素做法

// f[i][j] = f[i - 1][j] + f[i][j - i]
#include <iostream>

using namespace std;

const int N = 1e3 + 7, mod = 1e9 + 7;

int f[N][N];

int main() {
    int n;
    cin >> n;

    for (int i = 0; i <= n; i ++) {
        f[i][0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案
    }

    for (int i = 1; i <= n; i ++) {
        for (int j = 0; j <= n; j ++) {
            f[i][j] = f[i - 1][j] % mod; // 特殊 f[0][0] = 1
            if (j >= i) f[i][j] = (f[i - 1][j] + f[i][j - i]) % mod;
        }
    }

    cout << f[n][n] << endl;
}
等价变形

// f[i][j] = f[i - 1][j] + f[i][j - i]
#include <iostream>

using namespace std;

const int N = 1e3 + 7, mod = 1e9 + 7;

int f[N];

int main() {
    int n;
    cin >> n;


    f[0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案

    for (int i = 1; i <= n; i ++) {
        for (int j = i; j <= n; j ++) {
            f[j] = (f[j] + f[j - i]) % mod;
        }
    }

    cout << f[n] << endl;
}

作者：Wilson79
链接：https://www.acwing.com/solution/content/2954/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

完全背包解法
状态表示：
f[i][j]表示只从1~i中选，且总和等于j的方案数

状态转移方程:
f[i][j] = f[i - 1][j] + f[i][j - i];

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, mod = 1e9 + 7;

int n;
int f[N];

int main()
{
    cin >> n;

    f[0] = 1;
    for (int i = 1; i <= n; i ++ )
        for (int j = i; j <= n; j ++ )
            f[j] = (f[j] + f[j - i]) % mod;

    cout << f[n] << endl;

    return 0;
}
其他算法
状态表示：
f[i][j]表示总和为i，总个数为j的方案数

状态转移方程：
f[i][j] = f[i - 1][j - 1] + f[i - j][j];

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, mod = 1e9 + 7;

int n;
int f[N][N];

int main()
{
    cin >> n;

    f[1][1] = 1;
    for (int i = 2; i <= n; i ++ )
        for (int j = 1; j <= i; j ++ )
            f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod;

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = (res + f[n][i]) % mod;

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/62496/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 282. 石子合并    原题链接    简单
作者：    TaoZex ,  2019-05-29 12:21:25 ,  阅读 2308

20


7
更新：图源自算法基础课程讲解



具有明显的阶段性（相邻的合并），所以只能区间dp，不能贪心

#include<bits/stdc++.h>
using namespace std;

const int N=310,INF=0x3f3f3f3f;
int f[N][N];
int s[N];
int n;

int main(){
    cin>>n;
    memset(f,INF,sizeof(f));     //记得初始化
    for(int i=1;i<=n;i++){
         cin>>s[i];
         f[i][i]=0;             //初始化
    }
    for(int i=1;i<=n;i++) s[i]+=s[i-1];

    for(int len=2;len<=n;len++){
        for(int l=1;l+len-1<=n;l++){
            int r=l+len-1;
            for(int k=l;k<r;k++){
                f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]);
            }    
        }
    }
    cout<<f[1][n]<<endl;
    return 0;
}
另一种区间划分方式：

#include<bits/stdc++.h>
using namespace std;

const int N=310;
int f[N][N],a[N],s[N];
int n;


int main(){
    cin>>n;
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n;i++){
         cin>>a[i];
         s[i]=s[i-1]+a[i];
         f[i][i]=0;
    }

    for(int len=2;len<=n;len++){
        for(int l=1;l+len-1<=n;l++){
            int r=l+len-1;
            for(int k=l+1;k<=r;k++){
                f[l][r]=min(f[l][r],f[l][k-1]+f[k][r]+s[r]-s[l-1]);
            }
        }
    }

    cout<<f[1][n]<<endl;
} 

作者：TaoZex
链接：https://www.acwing.com/solution/content/2296/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <iostream>
#include <algorithm>

using namespace std;

const int N = 310;

int n;
int s[N];
int f[N][N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &s[i]);

    for (int i = 1; i <= n; i ++ ) s[i] += s[i - 1];

    for (int len = 2; len <= n; len ++ )
        for (int i = 1; i + len - 1 <= n; i ++ )
        {
            int l = i, r = i + len - 1;
            f[l][r] = 1e8;
            for (int k = l; k < r; k ++ )
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
        }

    printf("%d\n", f[1][n]);
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/58545/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 899. 编辑距离    原题链接    简单
作者：    小纸条o--o ,  2019-07-14 07:58:16 ,  阅读 817

3


题目描述
blablabla

样例
blablabla
动态数组dp[word1.length+1][word2.length+1]

dp[i][j]表示从word1前i个字符转换到word2前j个字符最少的步骤数。

假设word1现在遍历到字符x，word2遍历到字符y（word1当前遍历到的长度为i，word2为j）。

以下两种可能性：

x==y，那么不用做任何编辑操作，所以dp[i][j] = dp[i-1][j-1]

x != y

(1) 在word1插入y， 那么dp[i][j] = dp[i][j-1] + 1

(2) 在word1删除x， 那么dp[i][j] = dp[i-1][j] + 1

(3) 把word1中的x用y来替换，那么dp[i][j] = dp[i-1][j-1] + 1

最少的步骤就是取这三个中的最小值。

最后返回 dp[word1.length+1][word2.length+1] 即可。

java 代码
import java.util.*;

public class Main {
    public static int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();

        // len1+1, len2+1, because finally return dp[len1][len2]
        int[][] dp = new int[len1 + 1][len2 + 1];

        for (int i = 0; i <= len1; i++)
            dp[i][0] = i;

        for (int j = 0; j <= len2; j++)
            dp[0][j] = j;


        //iterate though, and check last char
        for (int i = 1; i <= len1; i++) {
            char c1 = word1.charAt(i-1);
            for (int j = 1; j <= len2; j++) {
                char c2 = word2.charAt(j-1);

                //if last two chars equal
                if (c1 == c2) {
                    //update dp value for +1 length
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    int replace = dp[i-1][j-1] + 1;
                    int insert = dp[i-1][j] + 1;
                    int delete = dp[i][j-1] + 1;

                    int min = Math.min(replace, insert);
                    min = Math.min(min,delete);
                    dp[i][j] = min;
                }
            }
        }

        return dp[len1][len2];
    }

    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int n=scanner.nextInt();
        int m=scanner.nextInt();
        String strs[]=new String[n];
        for (int i = 0; i < n; i++) {
            strs[i]=scanner.next();
        }
        while(m--!=0){
            String s=scanner.next();
            int a=scanner.nextInt();
            int ans=0;
            for (int i = 0; i <n ; i++) {
               if(a>=minDistance(strs[i],s))
                   ans++;
            }
            System.out.println(ans);
        }
    }
}

作者：小纸条o--o
链接：https://www.acwing.com/solution/content/2619/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>
#include <string.h>

using namespace std;

const int N = 15, M = 1010;

int n, m;
int f[N][N];
char str[M][N];

int edit_distance(char a[], char b[])
{
    int la = strlen(a + 1), lb = strlen(b + 1);

    for (int i = 0; i <= lb; i ++ ) f[0][i] = i;
    for (int i = 0; i <= la; i ++ ) f[i][0] = i;

    for (int i = 1; i <= la; i ++ )
        for (int j = 1; j <= lb; j ++ )
        {
            f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1);
            f[i][j] = min(f[i][j], f[i - 1][j - 1] + (a[i] != b[j]));
        }

    return f[la][lb];
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%s", str[i] + 1);

    while (m -- )
    {
        char s[N];
        int limit;
        scanf("%s%d", s + 1, &limit);

        int res = 0;
        for (int i = 0; i < n; i ++ )
            if (edit_distance(str[i], s) <= limit)
                res ++ ;

        printf("%d\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/62479/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 902. 最短编辑距离    原题链接    简单
作者：    Shadow ,  2019-10-27 21:09:24 ,  阅读 984

44


11
yxc：动态规划是吧
就是对爆搜的优化嘛
//来自算法基础课

1.状态表示 ：f[i][j]
集合：将a[1~i]变成b[1~j]的操作方式
属性：min
2.状态计算 ：从最后一步考虑
有三种操作，所以有三个子集
ok子集划分完了
考虑状态转移的时候
先考虑如果我没有进行这个操作应该是什么状态
然后考虑你进行这一步操作之后会对你下一个状态造成什么影响
然后再加上之前状态表示中你决策出来的那个DP属性
这样就可以自然而然地搞出来转移方程啦

1)删除操作：把a[i]删掉之后a[1~i]和b[1~j]匹配
            所以之前要先做到a[1~(i-1)]和b[1~j]匹配
            f[i-1][j] + 1
2)插入操作：插入之后a[i]与b[j]完全匹配，所以插入的就是b[j] 
            那填之前a[1~i]和b[1~(j-1)]匹配
            f[i][j-1] + 1 
3)替换操作：把a[i]改成b[j]之后想要a[1~i]与b[1~j]匹配 
            那么修改这一位之前，a[1~(i-1)]应该与b[1~(j-1)]匹配
            f[i-1][j-1] + 1
            但是如果本来a[i]与b[j]这一位上就相等，那么不用改，即
            f[i-1][j-1] + 0

好的那么f[i][j]就由以上三个可能状态转移过来，取个min
细节问题：初始化怎么搞
先考虑有哪些初始化嘛
1.你看看在for遍历的时候需要用到的但是你事先没有的
（往往就是什么0啊1啊之类的）就要预处理 
2.如果要找min的话别忘了INF
  要找有负数的max的话别忘了-INF

ok对应的： 
1.f[0][i]如果a初始长度就是0，那么只能用插入操作让它变成b
  f[i][0]同样地，如果b的长度是0，那么a只能用删除操作让它变成b
2.f[i][j] = INF //虽说这里没有用到，但是把考虑到的边界都写上还是保险
最后代码
#include<bits/stdc++.h>
using namespace std;
const int INF = 2e9;
const int N = 2333;
int lena,lenb,f[N][N];
char a[N],b[N];

int main() {
    scanf("%d%s",&lena,a+1);
    scanf("%d%s",&lenb,b+1);
    for(register int i=1; i<=lena; i++) 
        for(register int j=1; j<=lenb; j++) 
            f[i][j] = INF;

    for(register int i=1; i<=lena; i++) f[i][0] = i;
    for(register int i=1; i<=lenb; i++) f[0][i] = i;

    for(register int i=1; i<=lena; i++) {
        for(register int j=1; j<=lenb; j++) {
            f[i][j] = min(f[i-1][j]+1,f[i][j-1]+1);
            if(a[i]==b[j]) f[i][j] = min(f[i][j],f[i-1][j-1]);
            else f[i][j] = min(f[i][j],f[i-1][j-1]+1);
        }
    }
    printf("%d\n",f[lena][lenb]);
    return 0;
}

作者：Shadow
链接：https://www.acwing.com/solution/content/5607/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
char a[N], b[N];
int f[N][N];

int main()
{
    scanf("%d%s", &n, a + 1);
    scanf("%d%s", &m, b + 1);

    for (int i = 0; i <= m; i ++ ) f[0][i] = i;
    for (int i = 0; i <= n; i ++ ) f[i][0] = i;

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1);
            if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]);
            else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1);
        }

    printf("%d\n", f[n][m]);

    return 0;
}


作者：yxc
链接：https://www.acwing.com/activity/content/code/content/62472/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 897. 最长公共子序列    原题链接    简单
作者：    yuechen ,  2020-02-06 01:07:40 ,  阅读 1059

30


13
问题分析
我觉得这题的状态分成两半考虑比较方便，按两个序列末尾的字符是不是相等来区分。

如果两个字符相等，就可以直接转移到f[i-1][j-1]，不相等的话，两个字符一定有一个可以抛弃，可以对f[i-1][j],f[i][j-1]两种状态取max来转移。


代码
#include <iostream>
using namespace std;
const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];
int main() {
  cin >> n >> m >> a + 1 >> b + 1;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      if (a[i] == b[j]) {
        f[i][j] = f[i - 1][j - 1] + 1;
      } else {
        f[i][j] = max(f[i - 1][j], f[i][j - 1]);
      }
    }
  }
  cout << f[n][m] << '\n';
  return 0;
}

作者：yuechen
链接：https://www.acwing.com/solution/content/8111/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
char a[N], b[N];
int f[N][N];

int main()
{
    scanf("%d%d", &n, &m);
    scanf("%s%s", a + 1, b + 1);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
        }

    printf("%d\n", f[n][m]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/58527/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 896. 最长上升子序列 II    原题链接    简单
作者：    233 ,  2019-08-13 16:45:35 ,  阅读 1699

36


17
C++ 代码
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int main(void) {
    int n; cin >> n;
    vector<int>arr(n);
    for (int i = 0; i < n; ++i)cin >> arr[i];

    vector<int>stk;//模拟堆栈
    stk.push_back(arr[0]);

    for (int i = 1; i < n; ++i) {
        if (arr[i] > stk.back())//如果该元素大于栈顶元素,将该元素入栈
            stk.push_back(arr[i]);
        else//替换掉第一个大于或者等于这个数字的那个数
            *lower_bound(stk.begin(), stk.end(), arr[i]) = arr[i];
    }
    cout << stk.size() << endl;
    return 0;
}
/*
例 n: 7
arr : 3 1 2 1 8 5 6

stk : 3

1 比 3 小
stk : 1

2 比 1 大
stk : 1 2

1 比 2 小
stk : 1 2

8 比 2 大
stk : 1 2 8

5 比 8 小
stk : 1 2 5

6 比 5 大
stk : 1 2 5 6

stk 的长度就是最长递增子序列的长度

*/

作者：233
链接：https://www.acwing.com/solution/content/3783/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int a[N];
int q[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);

    int len = 0;
    for (int i = 0; i < n; i ++ )
    {
        int l = 0, r = len;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (q[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1);
        q[r + 1] = a[i];
    }

    printf("%d\n", len);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/62458/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 895. 最长上升子序列    原题链接    简单
作者：    VictorWu ,  2019-09-24 14:04:35 ,  阅读 1812

17


6
最长上升子序列解题报告
给定一个长度为N的数列(w[N])，求数值严格单调递增的子序列的长度最长是多少。

样例
输入格式
第一行包含整数N。

第二行包含N个整数，表示完整序列。

输出格式
输出一个整数，表示最大长度。

数据范围
1 ≤ N ≤ 1000，
−1e9 ≤ 数列中的数 ≤ 1e9

输入样例：

7
3 1 2 1 8 5 6
输出样例：

4
算法1
(动态规划) O(n2)O(n2)
状态表示：f[i]表示从第一个数字开始算，以w[i]结尾的最大的上升序列。(以w[i]结尾的所有上升序列中属性为最大值的那一个)

状态计算（集合划分）：j∈(0,1,2,..,i-1), 在w[i] > w[j]时，
f[i] = max(f[i], f[j] + 1)。
有一个边界，若前面没有比i小的，f[i]为1（自己为结尾）。

最后在找f[i]的最大值。

时间复杂度
O(n2)O(n2) 状态数(nn) * 转移数(nn)
C++ 代码
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int w[N], f[N];

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> w[i];

    int mx = 1;    // 找出所计算的f[i]之中的最大值，边算边找
    for (int i = 0; i < n; i++) {
        f[i] = 1;    // 设f[i]默认为1，找不到前面数字小于自己的时候就为1
        for (int j = 0; j < i; j++) {
            if (w[i] > w[j]) f[i] = max(f[i], f[j] + 1);    // 前一个小于自己的数结尾的最大上升子序列加上自己，即+1
        }
        mx = max(mx, f[i]);
    }

    cout << mx << endl;
    return 0;
}
算法2
(动态规划 + 二分) O(nlogn)O(nlogn)
状态表示：f[i]表示长度为i的最长上升子序列，末尾最小的数字。(长度为i的最长上升子序列所有结尾中，结尾最小min的) 即长度为i的子序列末尾最小元素是什么。

状态计算：对于每一个w[i], 如果大于f[cnt-1](下标从0开始，cnt长度的最长上升子序列，末尾最小的数字)，那就cnt+1，使得最长上升序列长度+1，当前末尾最小元素为w[i]。 若w[i]小于等于f[cnt-1],说明不会更新当前的长度，但之前末尾的最小元素要发生变化，找到第一个 大于或等于 (这里不能是大于) w[i]，更新以那时候末尾的最小元素。

f[i]一定以一个单调递增的数组，所以可以用二分法来找第一个大于或等于w[i]的数字。

时间复杂度
O(nlogn)O(nlogn) 状态数(nn) * 转移数(lognlogn)
C++ 代码
#include <iostream>

using namespace std;

const int N = 1010;
int n, cnt;
int w[N], f[N];

int main() {
    cin >> n;
    for (int i = 0 ; i < n; i++) cin >> w[i];

    f[cnt++] = w[0];
    for (int i = 1; i < n; i++) {
        if (w[i] > f[cnt-1]) f[cnt++] = w[i];
        else {
            int l = 0, r = cnt - 1;
            while (l < r) {
                int mid = (l + r) >> 1;
                if (f[mid] >= w[i]) r = mid;
                else l = mid + 1;
            }
            f[r] = w[i];
        }
    }
    cout << cnt << endl;
    return 0;
}

作者：VictorWu
链接：https://www.acwing.com/solution/content/4807/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n;
int a[N], f[N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);

    for (int i = 1; i <= n; i ++ )
    {
        f[i] = 1; // 只有a[i]一个数
        for (int j = 1; j < i; j ++ )
            if (a[j] < a[i])
                f[i] = max(f[i], f[j] + 1);
    }

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = max(res, f[i]);

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/58497/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 898. 数字三角形    原题链接    简单
作者：    TaoZex ,  2019-08-06 10:54:47 ,  阅读 1141

6


2
#include<bits/stdc++.h>
using namespace std;

const int N=510,INF=0x3f3f3f3f;
int f[N][N];
int a[N][N];

int main(){
    int n;
    cin>>n;

    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            cin>>a[i][j];
        }
    }

    for(int i=1;i<=n;i++){             
        for(int j=0;j<=i+1;j++){          //因为有负数，所以应该将两边也设为-INF
            f[i][j]=-INF;
        }
    }

    f[1][1]=a[1][1];
    for(int i=2;i<=n;i++){
        for(int j=1;j<=i;j++){
            f[i][j]=a[i][j]+max(f[i-1][j-1],f[i-1][j]);
        }
    }

    int res=-INF;
    for(int i=1;i<=n;i++) res=max(res,f[n][i]);
    cout<<res<<endl;
}
也可以倒序dp，更简单些，因为倒序不需要考虑边界问题

#include<bits/stdc++.h>
using namespace std;

const int N=510;
int f[N][N];
int n;

int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            cin>>f[i][j];
        }
    }

    for(int i=n;i>=1;i--){
        for(int j=i;j>=1;j--){
            f[i][j]=max(f[i+1][j],f[i+1][j+1])+f[i][j];
        }
    }
    cout<<f[1][1]<<endl;
}

作者：TaoZex
链接：https://www.acwing.com/solution/content/3485/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, INF = 1e9;

int n;
int a[N][N];
int f[N][N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= i; j ++ )
            scanf("%d", &a[i][j]);

    for (int i = 0; i <= n; i ++ )
        for (int j = 0; j <= i + 1; j ++ )
            f[i][j] = -INF;

    f[1][1] = a[1][1];
    for (int i = 2; i <= n; i ++ )
        for (int j = 1; j <= i; j ++ )
            f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);

    int res = -INF;
    for (int i = 1; i <= n; i ++ ) res = max(res, f[n][i]);

    printf("%d\n", res);
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/58479/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 9. 分组背包问题    原题链接    中等
作者：    TaoZex ,  2019-08-06 09:39:32 ,  阅读 2241

22


3


#include<bits/stdc++.h>
using namespace std;

const int N=110;
int f[N][N];  //只从前i组物品中选，当前体积小于等于j的最大值
int v[N][N],w[N][N],s[N];   //v为体积，w为价值，s代表第i组物品的个数
int n,m,k;

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>s[i];
        for(int j=0;j<s[i];j++){
            cin>>v[i][j]>>w[i][j];  //读入
        }
    }

    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            f[i][j]=f[i-1][j];  //不选
            for(int k=0;k<s[i];k++){
                if(j>=v[i][k])     f[i][j]=max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);  
            }
        }
    }
    cout<<f[n][m]<<endl;
}
因为只用到了第i-1列，所以可以仿照01背包的套路逆向枚举体积

#include<bits/stdc++.h>
using namespace std;

const int N=110;
int f[N];
int v[N][N],w[N][N],s[N];
int n,m,k;

int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++){
        cin>>s[i];
        for(int j=0;j<s[i];j++){
            cin>>v[i][j]>>w[i][j];
        }
    }

    for(int i=0;i<n;i++){
        for(int j=m;j>=0;j--){
            for(int k=0;k<s[i];k++){    //for(int k=s[i];k>=1;k--)也可以
                if(j>=v[i][k])     f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);  
            }
        }
    }
    cout<<f[m]<<endl;
}

作者：TaoZex
链接：https://www.acwing.com/solution/content/3483/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m;
int v[N][N], w[N][N], s[N];
int f[N];

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ )
    {
        cin >> s[i];
        for (int j = 0; j < s[i]; j ++ )
            cin >> v[i][j] >> w[i][j];
    }

    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= 0; j -- )
            for (int k = 0; k < s[i]; k ++ )
                if (v[i][k] <= j)
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);

    cout << f[m] << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/57845/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include<bits/stdc++.h>
using namespace std;
int main()
{
    int N,V,v[1001],w[1001],dp[2001],s[1001]
    int a[25000],b[25000];  //2的12次方大于2000，也就是说一个数最多可以拆成12个，故数组容量乘12 
    cin>>N>>V;        
    memset(dp,0,sizeof(dp));
    for(int i=0;i<N;i++)
     cin>>v[i]>>w[i]>>s[i];
    int total=0;  
    for(int i=0;i<N;i++)
    {
        for(int j=1;j<s[i];j<<=1)//二进制拆分 
         {
            a[total]=j*w[i];//存价值 
            b[total++]=j*v[i];//存容量 
            s[i]-=j;
         }
         if(s[i])//当s[i]>0; 
         {
             a[total]=s[i]*w[i];
             b[total++]=s[i]*v[i];
         }
    }
    for(int i=0;i<total;i++)//01背包 
     for(int j=V;j>=b[i];j--)
      dp[j]=max(dp[j],dp[j-b[i]]+a[i]);
    cout<<dp[V];
    return 0;
}

作者：llll
链接：https://www.acwing.com/solution/content/1024/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 5. 多重背包问题 II
作者：    yxc ,  2019-07-12 21:58:03 ,  阅读 1419

12


#include <iostream>
#include <algorithm>

using namespace std;

const int N = 12010, M = 2010;

int n, m;
int v[N], w[N];
int f[M];

int main()
{
    cin >> n >> m;

    int cnt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1;
        while (k <= s)
        {
            cnt ++ ;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if (s > 0)
        {
            cnt ++ ;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }

    n = cnt;

    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/57846/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 4. 多重背包问题 I(一看就会，懒人专用)+saber精简代码    原题链接    简单
作者：    7年级的蒟蒻 ,  2020-06-07 23:09:41 ,  阅读 1299

10


1
题目描述
有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

输出格式
输出一个整数，表示最大价值。

数据范围
0<N,V≤100
0<vi,wi,si≤100

样例
输入样例
4 5
1 2 3
2 4 1
3 4 3
4 5 2
输出样例：
10
算法
(把多重背包拆成01背包)很香
C++ 代码
#include <bits/stdc++.h>
using namespace std;
int a[10005],b[10005];
int main()
{
    int t=0,n,m,dp[10005]={ },w,v,s;
    cin>>n>>m;
    while(n--)
    {
    cin>>v>>w>>s;
    while(s--)
    {a[++t]=v;
    b[t]=w;}//死拆，把多重背包拆成01背包
    }
    for(int i=1;i<=t;i++)
    for(int j=m;j>=a[i];j--)
    dp[j]=max(dp[j-a[i]]+b[i],dp[j]);//直接套01背包的板子
    cout<<dp[m]<<endl;
    return 0;
}
saber代码（有更短的私聊我）压行不算

#include <bits/stdc++.h>
using namespace std;
main()
{
    int dp[1005],n,t,v,w,s;
    cin>>n>>t;
    while(n--)
    {
    cin>>v>>w>>s;
    for(int i=1;i<=s;i++)
    for(int j=t;j>=w;j--)
    dp[j]=max(dp[j],dp[j-w]+v);
    }
    cout<<dp[t];
}

作者：7年级的蒟蒻
链接：https://www.acwing.com/solution/content/13873/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i] >> s[i];

    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j <= m; j ++ )
            for (int k = 0; k <= s[i] && k * v[i] <= j; k ++ )
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);

    cout << f[n][m] << endl;
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/57826/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 3. 完全背包问题--一维动态规划转移过程模拟    原题链接    简单
作者：    polaris ,  2019-08-19 22:00:45 ,  阅读 5296

36


8
先上代码，和01背包问题的解法有略微的改动，区别在于遍历体积 jj 时从逆序改为顺序，在上一题中有我关于01背包问题的理解。
Python3 代码
if __name__ == '__main__':
    n, m = map(int, input().split())
    dp = [0] * (m + 1)
    v, w = [0], [0]
    for i in range(1, n + 1):
        line = list(map(int, input().split()))
        v.append(line[0])
        w.append(line[1])
        for j in range(v[i], m + 1):
            dp[j] = max(dp[j], dp[j - v[i]] + w[i])
    print(dp[m])
上一篇代码中，解释过，逆序是为了保证更新当前状态时，用到的状态是上一轮的状态，保证每个物品只有一次或零次;
在这里，因为每个物品可以取任意多次，所以不再强求用上一轮的状态，即本轮放过的物品，在后面还可以再放;

不妨按照思路，模拟一遍过程。

首先dp数组初始化全为0：给定物品种类有4种，包最大体积为5，数据来源于题目的输入
v[1] = 1, w[1] = 2
v[2] = 2, w[2] = 4
v[3] = 3, w[3] = 4
v[4] = 4, w[4] = 5

i = 1 时： j从v[1]到5
dp[1] = max(dp[1],dp[0]+w[1]) = w[1] = 2 (用了一件物品1）
dp[2] = max(dp[2],dp[1]+w[1]) = w[1] + w[1] = 4（用了两件物品1）
dp[3] = max(dp[3],dp[2]+w[1]) = w[1] + w[1] + w[1] = 6（用了三件物品1）
dp[4] = max(dp[4],dp[3]+w[1]) = w[1] + w[1] + w[1] + w[1] = 8（用了四件物品1）
dp[5] = max(dp[3],dp[2]+w[1]) = w[1] + w[1] + w[1] + w[1] + w[1] = 10（用了五件物品）

i = 2 时：j从v[2]到5
dp[2] = max(dp[2],dp[0]+w[2]) = w[1] + w[1] = w[2] =  4（用了两件物品1或者一件物品2）
dp[3] = max(dp[3],dp[1]+w[2]) = 3 * w[1] = w[1] + w[2] =  6（用了三件物品1，或者一件物品1和一件物品2）
dp[4] = max(dp[4],dp[2]+w[2]) = 4 * w[1] = dp[2] + w[2] =  8（用了四件物品1或者，两件物品1和一件物品2或两件物品2）
dp[5] = max(dp[5],dp[3]+w[2]) = 5 * w[1] = dp[3] + w[2] =  10（用了五件物品1或者，三件物品1和一件物品2或一件物品1和两件物品2）

i = 3时：j从v[3]到5
dp[3] = max(dp[3],dp[0]+w[3]) = dp[3] = 6 # 保持第二轮的状态 
dp[4] = max(dp[4],dp[1]+w[3]) = dp[4] = 8 # 保持第二轮的状态 
dp[5] = max(dp[5],dp[2]+w[3]) = dp[4] = 10 # 保持第二轮的状态

i = 4时：j从v[4]到5
dp[4] = max(dp[4],dp[0]+w[4]) = dp[4] = 10 # 保持第三轮的状态
dp[5] = max(dp[5],dp[1]+w[4]) = dp[5] = 10 # 保持第三轮的状态

上面模拟了完全背包的全部过程，也可以看出，最后一轮的dp[m]即为最终的返回结果。
上述代码可以进行简化
根据模拟过程可以发现，遍历每一轮i时，用到的v[i]和w[i]只来自本轮的输入，并且之后不会再用到，因此不用创建数组来存这两个值。

if __name__ == '__main__':
    n, m = map(int, input().split())
    dp = [0] * (m + 1)
    for i in range(1, n + 1):
        v, w = map(int, input().split())
        for j in range(v, m + 1):
            dp[j] = max(dp[j], dp[j - v] + w)
    print(dp[m])

作者：polaris
链接：https://www.acwing.com/solution/content/3986/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i ++ )
        for (int j = v[i]; j <= m; j ++ )
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/57825/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 2. 01背包问题（状态转移方程讲解）    原题链接    简单
作者：    深蓝 ,  2019-04-05 22:15:11 ,  阅读 13568

88


29
算法1
二维数组+动规
状态转移方程：
定义f[i][j]:前i个物品，背包容量j下的最优解

1）当前背包容量不够（j < w[i]），为前i-1个物品最优解：f[i][j] = f[i-1][j]
2）当前背包容量够，判断选与不选第i个物品
选：f[i][j] = f[i-1][j-w[i]] + v[i]
不选：f[i][j] = f[i-1][j]

C++ 代码
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 1005;
int w[MAXN];    // 重量 
int v[MAXN];    // 价值 
int f[MAXN][MAXN];  // f[i][j], j重量下前i个物品的最大价值 

int main() 
{
    int n, m;   
    cin >> n >> m;
    for(int i = 1; i <= n; ++i) 
        cin >> w[i] >> v[i];

    for(int i = 1; i <= n; ++i) 
        for(int j = 1; j <= m; ++j)
        {
            //  当前重量装不进，价值等于前i-1个物品
            if(j < w[i]) 
                f[i][j] = f[i-1][j];
            // 能装，需判断 
            else    
                f[i][j] = max(f[i-1][j], f[i-1][j-w[i]] + v[i]);
        }           

    cout << f[n][m];
    return 0;
}
优化
(动规+一维数组)
状态转移方程为：f[j] = max(f[j], f[j-w[i]] + v[i]

C++ 代码
for(int i = 1; i <= n; ++i)
{
    for(int j = m; j >= 0; --j) 
        if(j >= w[i])
            f[j] = max(f[j], f[j-w[i]] + v[i]);
} 
注意枚举j必须从m开始
评论里有同学指出一维数组的简化版本，这里不修改原始代码，供大家参考。

作者：深蓝
链接：https://www.acwing.com/solution/content/1374/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/57785/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 894. 拆分-Nim游戏    原题链接    简单
作者：    Anoxia_3 ,  2020-05-14 20:00:25 ,  阅读 228

1


相比于集合-Nim，这里的每一堆可以变成不大于原来那堆的任意大小的两堆
即a[i]a[i]可以拆分成(b[i],b[j])(b[i],b[j]),为了避免重复规定b[i]>=b[j]b[i]>=b[j],即：a[i]>=b[i]>=b[j]a[i]>=b[i]>=b[j]
相当于一个局面拆分成了两个局面，由SG函数理论，多个独立局面的SGSG值，等于这些局面SGSG值的异或和。
因此需要存储的状态就是sg(b[i])sg(b[i])^sg(b[j])sg(b[j])（与集合-Nim的唯一区别）

C++ 代码
#include <iostream>
#include <cstring>
#include <unordered_set>

using namespace std;

const int N = 110;

int n;
int f[N];

int sg(int x)
{
    if(f[x] != -1) return f[x];

    unordered_set<int> S;
    for(int i = 0 ; i < x ; i++)
        for(int j = 0 ; j <= i ; j++)//规定j不大于i，避免重复
            S.insert(sg(i) ^ sg(j));//相当于一个局面拆分成了两个局面，由SG函数理论，多个独立局面的SG值，
                                   //等于这些局面SG值的异或和

    for(int i = 0 ; ; i++)
        if(!S.count(i))
            return f[x] = i;
}

int main()
{
    memset(f , -1 , sizeof f);

    cin >> n;
    int res = 0;
    while(n--)
    {
        int x;
        cin >> x;
        res ^= sg(x);
    }

    if(res) puts("Yes");
    else puts("No");
    return 0;
}

作者：Anoxia_3
链接：https://www.acwing.com/solution/content/13193/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_set>

using namespace std;

const int N = 110;


int n;
int f[N];


int sg(int x)
{
    if (f[x] != -1) return f[x];

    unordered_set<int> S;
    for (int i = 0; i < x; i ++ )
        for (int j = 0; j <= i; j ++ )
            S.insert(sg(i) ^ sg(j));

    for (int i = 0;; i ++ )
        if (!S.count(i))
            return f[x] = i;
}


int main()
{
    cin >> n;

    memset(f, -1, sizeof f);

    int res = 0;
    while (n -- )
    {
        int x;
        cin >> x;
        res ^= sg(x);
    }

    if (res) puts("Yes");
    else puts("No");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53564/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 893. 集合-Nim游戏    原题链接    简单
作者：    Anoxia_3 ,  2020-05-14 19:23:29 ,  阅读 203

6


1
将每一个h[i]h[i]的所有方案看做是一张有向图，例

若S=[2,5],h=10S=[2,5],h=10,则有如下展开形式：


mex()：mex()：设集合S是一个非负整数集合，定义mex(S)mex(S)为求出不属于S的最小非负整数的运算，即：mes(S)=min[x],其中xmes(S)=min[x],其中x属于自然数，且xx不属于SS（用人话说就是不存在SS集合中的数中，最小的那个数）

SG()：SG()：在有向图中，对于每个节点xx，设从xx出发共有kk条有向边，分别达到节点y1，y2……yky1，y2……yk，定义SG(x)SG(x)为xx的后继节点的SGSG值构成的集合执行mex()mex()运算后的值
即：SG(x)=mex(SG(y1),SG(y2)…SG(yk))SG(x)=mex(SG(y1),SG(y2)…SG(yk))；（用人话说就是比后继节点的SGSG都小的值）
特别的整个图GG的SGSG值被定义为起点ss的SGSG值，即SG(G)=SG(s)SG(G)=SG(s)
上图标红的值就是每一个节点的SGSG值
性质：1.SG(k)有k个后继节点，且分别是0—k−1。1.SG(k)有k个后继节点，且分别是0—k−1。
          2.非0可以走向0          2.非0可以走向0
          3.0只能走向非0          3.0只能走向非0

定理：
对于一个图GG，如果SG(G)!=0SG(G)!=0，则先手必胜，反之必败

证明：
若SG(G)=!0SG(G)=!0，
1.根据性质2，先手必可以走向0，
2.因此留给后手的是0，根据性质2，后手只能走向非0
3.以此类推，后手始终无法走向0，后手永远处于非0，当先手到达终点的0时，先手获胜
（由此我们可以知道，有些事是命中注定的~~~）
反之同理，必败

定理：
对于n个图，如果SG(G1)SG(G1) ^ SG(G2)SG(G2) ^ … SG(Gn)!=0SG(Gn)!=0 ,则先手必胜，反之必败

证明（类似与Nim游戏）：
①当SG(Gi)=0SG(Gi)=0 时 ， xor=0xor=0 ， 显然先手必败
（PS：结束状态必是状态①，但状态①不一定是结束状态）

②当xor=x!=0xor=x!=0 时，因为肯定存在一个SG(xi)SG(xi)^x <SG(xi)<SG(xi),而根据SG()SG()的性质1可知，SG(k)SG(k)可以走到0−k−10−k−1的任何一个状态，
因此，必定可以从SG(xi)−>SG(xi)SG(xi)−>SG(xi)^xx ， 于是使得xor=0xor=0
  
③当xor=0xor=0时，当移动任何一个节点时，对应的SGSG值必然减小，可以证明：xor!=0xor!=0
下证：xor!=0xor!=0
假设:xor=0xor=0,则说明移动的那个节点的值并没有变化，即从SG(k)SG(k)变成了kk，但是这与SGSG函数的性质1相矛盾，因此不成立

证得：若先手面对的状态是xor!=0xor!=0,则先手方总能使xor=0xor=0，即使后手面对的永远是必败态直到结束状态①，因此先手必胜！
反之，必败！

C++ 代码
#include <iostream>
#include <unordered_set>
#include <cstring>

using namespace std;

const int N = 110 , M = 10010;

int n , m;
int s[N] , f[M];

int sg(int x)
{
    if(f[x] != -1) return f[x];//记忆化搜索，如果f[x]已经被计算过，则直接返回

    unordered_set<int> S;//用一个哈希表来存每一个局面能到的所有情况，便于求mex

    for(int i = 0 ; i < m ; i++)
        if(x >= s[i]) S.insert(sg(x - s[i]));//如果可以减去s[i]，则添加到S中

    for(int i = 0 ; ; i++)//求mex()，即找到最小并不在原集合中的数
        if(!S.count(i)) return f[x] = i;

}

int main()
{
    cin >> m;
    for(int i = 0 ; i < m ; i++)    cin >> s[i];

    memset(f , -1 , sizeof f);

    cin >> n;
    int res = 0;
    while(n--)
    {
        int x;
        cin >> x;
        res ^= sg(x);
    }


    if(res) puts("Yes");
    else puts("No");
    return 0;
}

作者：Anoxia_3
链接：https://www.acwing.com/solution/content/13191/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_set>

using namespace std;

const int N = 110, M = 10010;

int n, m;
int s[N], f[M];


int sg(int x)
{
    if (f[x] != -1) return f[x];

    unordered_set<int> S;
    for (int i = 0; i < m; i ++ )
    {
        int sum = s[i];
        if (x >= sum) S.insert(sg(x - sum));
    }

    for (int i = 0; ; i ++ )
        if (!S.count(i))
            return f[x] = i;
}


int main()
{
    cin >> m;
    for (int i = 0; i < m; i ++ ) cin >> s[i];
    cin >> n;

    memset(f, -1, sizeof f);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int x;
        cin >> x;
        res ^= sg(x);
    }

    if (res) puts("Yes");
    else puts("No");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53562/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 892. 台阶-Nim游戏    原题链接    简单
作者：    Anoxia_3 ,  2020-05-14 15:58:05 ,  阅读 195

3


此时我们需要将奇数台阶看做一个经典的Nim游戏，如果先手时奇数台阶上的值的异或值为0，则先手必败，反之必胜

证明：
先手时，如果奇数台阶异或非0，根据经典Nim游戏，先手总有一种方式使奇数台阶异或为0，于是先手留了技术台阶异或为0的状态给后手
于是轮到后手：
①当后手移动偶数台阶上的石子时，先手只需将对手移动的石子继续移到下一个台阶，这样奇数台阶的石子相当于没变，于是留给后手的又是奇数台阶异或为0的状态
②当后手移动奇数台阶上的石子时，留给先手的奇数台阶异或非0，根据经典Nim游戏，先手总能找出一种方案使奇数台阶异或为0
因此无论后手如何移动，先手总能通过操作把奇数异或为0的情况留给后手，当奇数台阶全为0时，只留下偶数台阶上有石子。
（核心就是：先手总是把奇数台阶异或为0的状态留给对面，即总是将必败态交给对面）

因为偶数台阶上的石子要想移动到地面，必然需要经过偶数次移动，又因为奇数台阶全0的情况是留给后手的，因此先手总是可以将石子移动到地面，当将最后一个（堆）石子移动到地面时，后手无法操作，即后手失败。

因此如果先手时奇数台阶上的值的异或值为非0，则先手必胜，反之必败！

C++ 代码
#include <iostream>

using namespace std;

int main()
{
    int res = 0;
    int n;
    cin >> n;

    for(int i = 1 ; i <= n ; i++)
    {
        int x;
        cin >> x;
        if(i % 2) res ^= x;
    }

    if(res) puts("Yes");
    else puts("No");
    return 0;
}

作者：Anoxia_3
链接：https://www.acwing.com/solution/content/13187/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int main()
{
    int n;
    scanf("%d", &n);

    int res = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int x;
        scanf("%d", &x);
        if (i & 1) res ^= x;
    }

    if (res) puts("Yes");
    else puts("No");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53528/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 891. Nim游戏    原题链接    简单
作者：    qiaoxinwei ,  2020-06-05 00:00:00 ,  阅读 332

10


2
若一个游戏满足：

由两名玩家交替行动
在游戏进行的任意时刻，可以执行的合法行动与轮到哪位玩家无关
不能行动的玩家判负
则称该游戏为一个公平组合游戏。

尼姆游戏（NIM）属于公平组合游戏，但常见的棋类游戏，比如围棋就不是公平组合游戏，因为围棋交战双方分别只能落黑子和白子，胜负判定也比较负责，不满足条件2和3。

题目描述
给定nn堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。
问如果两人都采用最优策略，先手是否必胜。

例如：有两堆石子，第一堆有2个，第二堆有3个，先手必胜。

操作步骤：
1. 先手从第二堆拿走1个，此时第一堆和第二堆数目相同
2. 无论后手怎么拿，先手都在另外一堆石子中取走相同数量的石子即可。

必胜状态和必败状态
在解决这个问题之前，先来了解两个名词：

必胜状态，先手进行某一个操作，留给后手是一个必败状态时，对于先手来说是一个必胜状态。即先手可以走到某一个必败状态。
必败状态，先手无论如何操作，留给后手都是一个必胜状态时，对于先手来说是一个必败状态。即先手走不到任何一个必败状态。
结论
假设nn堆石子，石子数目分别是a1,a2,…,ana1,a2,…,an，如果a1⊕a2⊕…⊕an≠0a1⊕a2⊕…⊕an≠0，先手必胜；否则先手必败。

证明
操作到最后时，每堆石子数都是00，0⊕0⊕…0=00⊕0⊕…0=0
在操作过程中，如果 a1⊕a2⊕…⊕an=x≠0a1⊕a2⊕…⊕an=x≠0。那么玩家必然可以通过拿走某一堆若干个石子将异或结果变为0。
证明：不妨设x的二进制表示中最高一位1在第k位，那么在a1,a2,…,ana1,a2,…,an中，必然有一个数aiai，它的第k为时1，且ai⊕x<aiai⊕x<ai，那么从第ii堆石子中拿走(ai−ai⊕x(ai−ai⊕x)个石子，第ii堆石子还剩ai−(ai−ai⊕x)=ai⊕xai−(ai−ai⊕x)=ai⊕x，此时a1⊕a2⊕…⊕ai⊕x⊕…⊕an=x⊕x=0a1⊕a2⊕…⊕ai⊕x⊕…⊕an=x⊕x=0。
在操作过程中，如果 a1⊕a2⊕…⊕an=0a1⊕a2⊕…⊕an=0，那么无论玩家怎么拿，必然会导致最终异或结果不为00。
反证法：假设玩家从第ii堆石子拿走若干个，结果仍是00。不妨设还剩下a′a′个，因为不能不拿，所以0≤a′<ai0≤a′<ai，且a1⊕a2⊕…⊕a′⊕…⊕an=0a1⊕a2⊕…⊕a′⊕…⊕an=0。那么(a1⊕a2⊕…⊕ai⊕…an)⊕(a1⊕a2⊕…⊕a′⊕…⊕an)=ai⊕a′=0(a1⊕a2⊕…⊕ai⊕…an)⊕(a1⊕a2⊕…⊕a′⊕…⊕an)=ai⊕a′=0，则 ai=a′ai=a′，与假设0≤a′<ai0≤a′<ai矛盾。
基于上述三个证明：
1. 如果先手面对的局面是a1⊕a2⊕…⊕an≠0a1⊕a2⊕…⊕an≠0，那么先手总可以通过拿走某一堆若干个石子，将局面变成a1⊕a2⊕…⊕an=0a1⊕a2⊕…⊕an=0。如此重复，最后一定是后手面临最终没有石子可拿的状态。先手必胜。
2. 如果先手面对的局面是a1⊕a2⊕…⊕an=0a1⊕a2⊕…⊕an=0，那么无论先手怎么拿，都会将局面变成a1⊕a2⊕…⊕an≠0a1⊕a2⊕…⊕an≠0，那么后手总可以通过拿走某一堆若干个石子，将局面变成a1⊕a2⊕…⊕an=0a1⊕a2⊕…⊕an=0。如此重复，最后一定是先手面临最终没有石子可拿的状态。先手必败。

c++代码
#include <iostream>
#include <cstdio>
using namespace std;

/*
先手必胜状态：先手操作完，可以走到某一个必败状态
先手必败状态：先手操作完，走不到任何一个必败状态
先手必败状态：a1 ^ a2 ^ a3 ^ ... ^an = 0
先手必胜状态：a1 ^ a2 ^ a3 ^ ... ^an ≠ 0
*/

int main(){
    int n;
    scanf("%d", &n);
    int res = 0;
    for(int i = 0; i < n; i++) {
        int x;
        scanf("%d", &x);
        res ^= x;
    }
    if(res == 0) puts("No");
    else puts("Yes");
}

作者：qiaoxinwei
链接：https://www.acwing.com/solution/content/14269/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;


int main()
{
    int n;
    scanf("%d", &n);

    int res = 0;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        res ^= x;
    }

    if (res) puts("Yes");
    else puts("No");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53517/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 890. 能被整除的数    原题链接    简单
作者：    wuog ,  2019-08-07 12:56:40 ,  阅读 878

5


1
题目描述
给定一个整数n和m个不同的质数p1,p2,…,pm。

请你求出1~n中能被p1,p2,…,pm中的至少一个数整除的整数有多少个。

输入格式
第一行包含整数n和m。

第二行包含m个质数。

输出格式
输出一个整数，表示满足条件的整数的个数。

数据范围
1≤m≤16,
1≤n,pi≤109

样例
输入样例：
10 2
2 3
输出样例：
7
算法1
模板
题解
假设我们现在有5个数，上面分别标号了0,1,2,3,4代表这些小球的权值,现在要像你求出这些小球的权值可以组成的所有情况。
我们用二进制的思维来考虑这个问题，因为有5个数，所以我们用5个比特位来分别标记数存在还是不存在，对于这样一种情况，比如我们现在要选择2，3的倍数，别是2,3,4数，那么我们用二进制1表是当前的数存在，用0表示当前数不存在

二进制下标 4 3 2 1 0
二进制 1 1 1 0 0
小球状态 存在 存在 存在 不存在 bu存在
我们可以用5个比特位来表示这种情况，如果数全部选择的话那么二进制表示就是11111,二进制的11111转化为十进制数字就是31，这个数字正好就是2^5−1，那么我们可以用从0~(2^5−1)这些数表示完所有的选取状态(因为这个范围内的二进制数情况正好包括了这些选取状况).

for (int i = 1; i < 1 << m; i ++ )
    //  i<1<<m   组合数  2^m-1  

    {

        int t = 1, s = 0;

        for (int j = 0; j < m; j ++ )//遍历二进制的每一位

            if (i >> j & 1)//判断二进制第j位是否存在
            {
                if ((LL)t * p[j] > n)
                {
                    t = -1;
                    break;
                }
                t *= p[j];
                s ++ ;
            }

        if (t != -1)
        {

            if (s % 2) res += n / t;
            else res -= n / t;

        }
    }
C++ 代码

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 20;

int p[N];


int main()
{
    int n, m;
    cin >> n >> m;

    for (int i = 0; i < m; i ++ ) cin >> p[i];

    int res = 0;

    for (int i = 1; i < 1 << m; i ++ )
    {

        int t = 1, s = 0;

        for (int j = 0; j < m; j ++ )
            if (i >> j & 1)
            {
                if ((LL)t * p[j] > n)
                {
                    t = -1;
                    break;
                }
                t *= p[j];
                s ++ ;
            }

        if (t != -1)
        {

            if (s % 2) res += n / t;
            else res -= n / t;

        }
    }

    cout << res << endl;

    return 0;
}

作者：wuog
链接：https://www.acwing.com/solution/content/3522/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 20;

int p[N];


int main()
{
    int n, m;
    cin >> n >> m;

    for (int i = 0; i < m; i ++ ) cin >> p[i];

    int res = 0;
    for (int i = 1; i < 1 << m; i ++ )
    {
        int t = 1, s = 0;
        for (int j = 0; j < m; j ++ )
            if (i >> j & 1)
            {
                if ((LL)t * p[j] > n)
                {
                    t = -1;
                    break;
                }
                t *= p[j];
                s ++ ;
            }

        if (t != -1)
        {
            if (s % 2) res += n / t;
            else res -= n / t;
        }
    }

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53410/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 889. 满足条件的01序列    原题链接    简单
作者：    番茄酱 ,  2020-02-22 16:44:50 ,  阅读 507

14


3
题目描述：给定 nn 个 00 和 nn 个 11，它们将按照某种顺序排成长度为 2n2n 的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 00 的个数都不少于 11 的个数的序列有多少个。答案对 109+7109+7 取模。

数据范围：1≤n≤1051≤n≤105
组合计数，卡特兰数

解法
将 0101 序列置于坐标系中，起点定于原点。若 00 表示向右走，11 表示向上走，那么任何前缀中 00 的个数不少于 11 的个数就转化为，路径上的任意一点，横坐标大于等于纵坐标。题目所求即为这样的合法路径数量。

下图中，表示从 (0,0)(0,0) 走到 (n,n)(n,n) 的路径，在绿线及以下表示合法，若触碰红线即不合法。



由图可知，任何一条不合法的路径（如黑色路径），都对应一条从 (0,0)(0,0) 走到 (n−1,n+1)(n−1,n+1) 的一条路径（如灰色路径）。而任何一条 (0,0)(0,0) 走到 (n−1,n+1)(n−1,n+1) 的路径，也对应了一条从 (0,0)(0,0) 走到 (n,n)(n,n) 的不合法路径。

答案如图，即卡特兰数。

#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 200010, mod = 1e9 + 7;

int n;
int fact[N], infact[N];

int ksm(int a, int k) {
    int res = 1;
    while (k) {
        if (k & 1) res = (LL)res * a % mod;
        a = (LL)a * a % mod;
        k >>= 1;
    }
    return res;
}

void init() {
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; i++) {
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * ksm(i, mod - 2) % mod;
    }
}

int main() {
    init();
    cin >> n;
    int res = (LL)fact[2 * n] * infact[n] % mod * infact[n] % mod * ksm(n + 1, mod - 2) % mod;
    cout << res << endl;
    return 0;
}

作者：番茄酱
链接：https://www.acwing.com/solution/content/8907/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010, mod = 1e9 + 7;


int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}


int main()
{
    int n;
    cin >> n;

    int a = n * 2, b = n;
    int res = 1;
    for (int i = a; i > a - b; i -- ) res = (LL)res * i % mod;

    for (int i = 1; i <= b; i ++ ) res = (LL)res * qmi(i, mod - 2, mod) % mod;

    res = (LL)res * qmi(n + 1, mod - 2, mod) % mod;

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53407/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 888. 求组合数 IV    原题链接    简单
作者：    TaoZex ,  2019-08-14 12:41:00 ,  阅读 612

4



对阶乘分解质因数之后（用图中的技巧分解n！），用高精度相乘即可对阶乘分解质因数之后（用图中的技巧分解n！），用高精度相乘即可
#include<bits/stdc++.h>
using namespace std;

const int N=5010;
int primes[N],cnt;
bool st[N];
int sum[N];

vector<int> mul(vector<int> a,int b){
    vector<int> c;
    int t=0;

    for(int i=0;i<a.size();i++){
        t+=a[i]*b;
        c.push_back(t%10);
        t/=10;
    }

    while(t){
        c.push_back(t%10);
        t/=10;
    }
    return c;
}

int get(int n,int p){
    int res=0;
    while(n){
        res+=n/p;
        n/=p;
    }
    return res;
}

void get_primes(int n){
    for(int i=2;i<=n;i++){
        if(!st[i]) primes[cnt++]=i;
        for(int j=0;primes[j]<=n/i;j++){
            st[primes[j]*i]=true;
            if(i%primes[j]==0) break;
        }
    }
}

int main(){
    int a,b;
    cin>>a>>b;

    get_primes(a);

    for(int i=0;i<cnt;i++){
        int p=primes[i];
        sum[i]=get(a,p)-get(b,p)-get(a-b,p);
    }

    vector<int> res;
    res.push_back(1);

    for(int i=0;i<cnt;i++){
        for(int j=0;j<sum[i];j++){
            res=mul(res,primes[i]);
        }
    }

    for(int i=res.size()-1;i>=0;i--) cout<<res[i];
    cout<<endl;
}

作者：TaoZex
链接：https://www.acwing.com/solution/content/3830/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;


const int N = 5010;

int primes[N], cnt;
int sum[N];
bool st[N];


void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}


int get(int n, int p)
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}


vector<int> mul(vector<int> a, int b)
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }
    return c;
}


int main()
{
    int a, b;
    cin >> a >> b;

    get_primes(a);

    for (int i = 0; i < cnt; i ++ )
    {
        int p = primes[i];
        sum[i] = get(a, p) - get(a - b, p) - get(b, p);
    }

    vector<int> res;
    res.push_back(1);

    for (int i = 0; i < cnt; i ++ )
        for (int j = 0; j < sum[i]; j ++ )
            res = mul(res, primes[i]);

    for (int i = res.size() - 1; i >= 0; i -- ) printf("%d", res[i]);
    puts("");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53401/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 887. 求组合数 III    原题链接    简单
作者：    嘤嘤嘤0 ,  2019-10-14 18:03:36 ,  阅读 552

7


2
有两个点，第一个是lucaslucas定理的公式，另外一个是求CbaCab的函数
LucasLucas定理：Cba≡Cb%pa%p∗Cbpap(modp)Cab≡Ca%pb%p∗Capbp(modp)
为什么可以这样求解CbaCab:
Cba=a!(a−b)!∗b!=a∗(a−1)∗(a−2)∗…∗(a−b+1)∗(a−b)∗…∗1(a−b)∗(a−b−1)∗…∗1∗b!=a∗(a−1)∗(a−2)∗…(a−b+1)b!Cab=a!(a−b)!∗b!=a∗(a−1)∗(a−2)∗…∗(a−b+1)∗(a−b)∗…∗1(a−b)∗(a−b−1)∗…∗1∗b!=a∗(a−1)∗(a−2)∗…(a−b+1)b!
因此就可以递推的每次乘aa然后除以bb, 因为从aa到a−b+1a−b+1, 所以就是乘bb次
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
inline int sd(int &n) { return scanf("%d", &n); }
inline int sld(ll &n) { return scanf("%lld", &n); }
const int inf = 0x3f3f3f3f;
const int maxn = 1e6 + 6;

ll poww(ll a, ll b, ll p){
    ll res = 1 % p;
    while(b){
        if(b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

ll C(ll a, ll b, ll p){
    ll res = 1;
    for(int i = 1, j = a;i <= b;++i, --j){
        res = res * j % p;
        res = res * poww(i, p - 2, p) % p;
    }
    return res % p;
}

ll lucas(ll a, ll b, ll p){
    if(a < p && b < p) return C(a, b, p);
    return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}

int main(){
    int n; sd(n);
    while(--n >= 0){
        ll a, b; sld(a), sld(b);
        ll p; sld(p);
        cout << lucas(a, b, p) << endl;
    }

    return 0;
}

作者：嘤嘤嘤0
链接：https://www.acwing.com/solution/content/5244/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;


int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}


int C(int a, int b, int p)
{
    if (b > a) return 0;

    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2, p) % p;
    }
    return res;
}


int lucas(LL a, LL b, int p)
{
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}


int main()
{
    int n;
    cin >> n;

    while (n -- )
    {
        LL a, b;
        int p;
        cin >> a >> b >> p;
        cout << lucas(a, b, p) << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53399/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 886. 费马小定理， 快速冥， 求组合数 II    原题链接    简单
作者：    acw_weian ,  2020-07-16 09:59:24 ,  阅读 213

7


1



import java.io.*;
class Main{
    static BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
    static int N = 100010, p = (int) 1e9 + 7;
    static int[] fact = new int[N], infact = new int[N];

    public static int qmi(int a, int k, int p){
        long res = 1;
        while( k > 0){
            if( (k & 1) != 0 ) res = res * a % p;
            a =(int) ((long) a * a % p);
            k >>= 1;
        }
        return (int) res;
    }

    public static void main(String[] args) throws Exception{
        int t = Integer.valueOf(read.readLine());
        fact[0] = infact[0] = 1;
        for(int i = 1; i < N; i++){
            fact[i] =(int) ((long)fact[i - 1] * i % p);
            infact[i] = (int) ((long) infact[i - 1] * qmi(i, p - 2, p ) % p);
        }

        while(t -- > 0){
            String[] ss = read.readLine().split(" ");
            int a = Integer.valueOf(ss[0]);
            int b = Integer.valueOf(ss[1]);
            int res = (int) ((long) fact[a] * infact[a - b] % p * infact[b] % p);
            System.out.println(res);
        }
    }

}

作者：acw_weian
链接：https://www.acwing.com/solution/content/16482/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010, mod = 1e9 + 7;


int fact[N], infact[N];


int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}


int main()
{
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; i ++ )
    {
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    }


    int n;
    scanf("%d", &n);
    while (n -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        printf("%d\n", (LL)fact[a] * infact[b] % mod * infact[a - b] % mod);
    }

    return 0;
}


作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53394/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 885. 求组合数 I    原题链接    简单
作者：    TaoZex ,  2019-08-14 12:17:29 ,  阅读 707

2


C a b 表示从a个苹果中选择b个苹果，假设有一个苹果分开，这个苹果就有选和不选两种方案，分别那么从剩下的a-1个苹果中选择b-1和b个，即 C a-1 b-1 和C a-1 b

数据范围
1≤n≤10000,
1≤b≤a≤2000
n方的复杂度

#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7,N=2010;
int n;
int c[N][N];

void init(){
    for(int i=0;i<N;i++){
        for(int j=0;j<=i;j++){
            if(!j) c[i][j]=1;
            else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
        }
    }
}

int main(){
    init();

    cin>>n;
    while(n--){
        int a,b;
        cin>>a>>b;

        cout<<c[a][b]<<endl;
    }
}

作者：TaoZex
链接：https://www.acwing.com/solution/content/3823/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2010, mod = 1e9 + 7;


int c[N][N];


void init()
{
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j <= i; j ++ )
            if (!j) c[i][j] = 1;
            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
}


int main()
{
    int n;

    init();

    scanf("%d", &n);

    while (n -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);

        printf("%d\n", c[a][b]);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53393/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 884. 高斯消元解异或线性方程组 C++    原题链接    简单
作者：    adorhorriable ,  2020-07-30 21:09:30 ,  阅读 111

2


因为异或运算相当于不进位的加法运算，所以整个过程相对高斯消元来讲要简单一些。

#include<bits/stdc++.h>
using namespace std;

const int N = 110;
int n;
int g[N][N];

int gauss()
{
    int r=0,c;
    for(int c=0;c<n;c++)   //按列进行枚举
    {
        int t = r;     //找到非0行，用t进行存储
        for(int i=r;i<n;i++)
            if(g[i][c])
                t=i;

        if(!g[t][c]) continue; //没有找到1，继续下一层循环

        for(int i=c;i<=n;i++) swap(g[r][i],g[t][i]);  //把第r行的数与第t行交换。

        for(int i=r+1;i<n;i++)    //用r行把下面所有行的当前列消成0
            if(g[i][c])
                for(int j=n;j>=c;j--)
                    g[i][j] ^= g[r][j];
        r++;
    }
    if(r<n)
    {
        for(int i=r;i<n;i++)
        {
            if(g[i][n]) return 2;
        }
        return 1;
    }

    for(int i=n-1;i>=0;i--)
    {
        for(int j=i+1;j<n;j++)
        {
            g[i][n] ^= g[i][j ]* g[j][n];
        }
    }
    return 0;
}
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n+1;j++)
        {
            cin>>g[i][j];
        }
    }

    int t = gauss();
    if(t==0)
    {
        for(int i=0;i<n;i++)
        {
            cout<<g[i][n]<<endl;
        }
    }
    else if(t==1) puts("Multiple sets of solutions");
    else puts("No solution");
    return 0;
}

作者：adorhorriable
链接：https://www.acwing.com/solution/content/17380/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;


int n;
int a[N][N];


int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )
            if (a[i][c])
                t = i;

        if (!a[t][c]) continue;

        for (int i = c; i <= n; i ++ ) swap(a[r][i], a[t][i]);
        for (int i = r + 1; i < n; i ++ )
            if (a[i][c])
                for (int j = n; j >= c; j -- )
                    a[i][j] ^= a[r][j];

        r ++ ;
    }

    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (a[i][n])
                return 2;
        return 1;
    }

    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] ^= a[i][j] * a[j][n];

    return 0;
}


int main()
{
    cin >> n;

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n + 1; j ++ )
            cin >> a[i][j];

    int t = gauss();

    if (t == 0)
    {
        for (int i = 0; i < n; i ++ ) cout << a[i][n] << endl;
    }
    else if (t == 1) puts("Multiple sets of solutions");
    else puts("No solution");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53391/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 883. 高斯消元解线性方程组    原题链接    简单
作者：    清南 ,  2019-11-28 17:25:08 ,  阅读 884

19


3
Acwing 883. 高斯消元解线性方程组
高斯消元 O(n3)O(n3)
通过初等行变换 把 增广矩阵 化为 阶梯型矩阵 并回代 得到方程的解

适用于求解 包含nn 个方程，nn 个未知数的多元线性方程组

例如该方程组
⎧⎩⎨⎪⎪⎪⎪a11x1+a21x1+⋮an1x1+a12x2+…+a22x2+…+⋮an2x2+…+a1nxn=a2nxn=⋮annxn=b1b2⋮bn
{a11x1+a12x2+…+a1nxn=b1a21x1+a22x2+…+a2nxn=b2⋮⋮⋮⋮an1x1+an2x2+…+annxn=bn
增广矩阵为
⎛⎝⎜⎜⎜⎜a11a21⋮an1a12a22⋮an2⋯⋯⋮⋯a1na2n⋮annb1b2⋮bn⎞⎠⎟⎟⎟⎟
(a11a12⋯a1nb1a21a22⋯a2nb2⋮⋮⋮⋮⋮an1an2⋯annbn)
接下来的所有操作都用该增广矩阵，代替原方程组
前置知识：初等行（列）变换

把某一行乘一个非00的数 (方程的两边同时乘上一个非00数不改变方程的解)
交换某两行 (交换两个方程的位置)
把某行的若干倍加到另一行上去 （把一个方程的若干倍加到另一个方程上去）
接下来，运用初等行变换，把增广矩阵，变为阶梯型矩阵

阶梯型矩阵
⎛⎝⎜⎜⎜⎜a11a12a2i⋯a2(i+1)a1na2n⋮annb1b2⋮bn⎞⎠⎟⎟⎟⎟
(a11a12⋯a1nb1a2ia2(i+1)a2nb2⋮⋮annbn)

阶梯型矩阵并不一定非要长成这个样子，还可以是好多种其他形式



最后再把阶梯型矩阵从下到上回代到第一层即可得到方程的解

算法步骤
枚举每一列c，

找到当前列绝对值最大的一行
用初等行变换(2) 把这一行换到最上面（未确定阶梯型的行，并不是第一行）
用初等行变换(1) 将该行的第一个数变成 11 （其余所有的数字依次跟着变化）
用初等行变换(3) 将下面所有行的当且列的值变成 00
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 110;
const double eps = 1e-6;

int n;
double a[N][N];


int gauss()
{
    int c, r;// c 代表 列 col ， r 代表 行 row
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;// 先找到当前这一列，绝对值最大的一个数字所在的行号
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps) continue;// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行

        for (int i = c; i < n + 1; i ++ ) swap(a[t][i], a[r][i]);//// 把当前这一行，换到最上面（不是第一行，是第 r 行）去
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];// 把当前这一行的第一个数，变成 1， 方程两边同时除以 第一个数，必须要到着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算
        for (int i = r + 1; i < n; i ++ )// 把当前列下面的所有数，全部消成 0
            if (fabs(a[i][c]) > eps)// 如果非0 再操作，已经是 0就没必要操作了
                for (int j = n; j >= c; j -- )// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0];
                    a[i][j] -= a[r][j] * a[i][c];

        r ++ ;// 这一行的工作做完，换下一行
    }

    if (r < n)// 说明剩下方程的个数是小于 n 的，说明不是唯一解，判断是无解还是无穷多解
    {// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0
        for (int i = r; i < n; i ++ )// 
            if (fabs(a[i][n]) > eps)// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解。
                return 2;
        return 1;// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程
    }
    // 唯一解 ↓，从下往上回代，得到方程的解
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[j][n] * a[i][j];//因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出

    return 0;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n + 1; j ++ )
            cin >> a[i][j];

    int t = gauss();

    if (t == 0)
    {
        for (int i = 0; i < n; i ++ ) printf("%.2lf\n", a[i][n]);
    }
    else if (t == 1) puts("Infinite group solutions");
    else puts("No solution");

    return 0;
}

作者：清南
链接：https://www.acwing.com/solution/content/5151/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 110;
const double eps = 1e-6;

int n;
double a[N][N];


int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps) continue;

        for (int i = c; i < n + 1; i ++ ) swap(a[t][i], a[r][i]);
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];

        for (int i = r + 1; i < n; i ++ )
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];

        r ++ ;
    }

    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2;
        return 1;
    }

    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[j][n] * a[i][j];

    return 0;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n + 1; j ++ )
            cin >> a[i][j];

    int t = gauss();

    if (t == 0)
    {
        for (int i = 0; i < n; i ++ ) printf("%.2lf\n", a[i][n]);
    }
    else if (t == 1) puts("Infinite group solutions");
    else puts("No solution");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53389/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 204. 表达整数的奇怪方式    原题链接    困难
作者：    墨染空 ,  2019-08-20 13:38:48 ,  阅读 1594

55


19
我作为一个初中蒟蒻，听y大视频听了5遍还不懂，快哭了。然后终于（好像）搞懂，写成题解加深一下记忆…

1. 将式子等价转换
对于每两个式子（我们考虑将其合并）：

x≡m1(% a1)x≡m1(% a1)
x≡m2(% a2)x≡m2(% a2)
则有：

x=k1∗a1+m1x=k1∗a1+m1
x=k2∗a2+m2x=k2∗a2+m2
进一步：

k1∗a1+m1=k2∗a2+m2k1∗a1+m1=k2∗a2+m2
移项：

k1∗a1−k2∗a2=m2−m1k1∗a1−k2∗a2=m2−m1
也就是：

① k1∗a1+k2∗(−a2)=m2−m1k1∗a1+k2∗(−a2)=m2−m1
也就是我们需要找到一个最小的k1,k2k1,k2，使得等式成立（因为要求xx最小，而aa和mm都是正数）。

2. 用扩展欧几里得算法找出一组解
我们已知a1,m1,a2,m2a1,m1,a2,m2，可以用扩展欧几里得算法算出一个k′1,k′2k1′,k2′使得：

k′1∗a1+k′2∗(−a2)=gcd(a1,−a2)k1′∗a1+k2′∗(−a2)=gcd(a1,−a2)
无解判断：
若gcd(a1,−a2)∤m2−m1gcd(a1,−a2)∤m2−m1，则无解。

我们设d=gcd(a1,−a2),y=(m2−m1)dd=gcd(a1,−a2),y=(m2−m1)d
承接上文，我们只需让k1,k2k1,k2分别扩大yy倍，则可以找到一个k1,k2k1,k2满足①式：

k1=k′1∗y,k2=k′2∗yk1=k1′∗y,k2=k2′∗y
3. 找到最小正整数解
我们知道一个性质：

②k1=k1+k∗a2dk1=k1+k∗a2d
k2=k2+k∗a1dk2=k2+k∗a1d
kk为任意整数，这时新的k1,k2k1,k2仍满足①式。

证明：
将新的k1,k2k1,k2带入式子得:

(k1+k∗a2d)∗a1+(k2+k∗a1d)∗(−a2)=m2−m1(k1+k∗a2d)∗a1+(k2+k∗a1d)∗(−a2)=m2−m1
拆出来：

k1∗a1+k∗a2∗a1d+k2∗(−a2)+k∗a1∗(−a2)d=m2−m1k1∗a1+k∗a2∗a1d+k2∗(−a2)+k∗a1∗(−a2)d=m2−m1
交换一下顺序，把负号拆出来：

k1∗a1+k2∗(−a2)+k∗a2∗a1d−k∗a1∗a2d=m2−m1k1∗a1+k2∗(−a2)+k∗a2∗a1d−k∗a1∗a2d=m2−m1
那个同加同减可以消掉：

k1∗a1+k2∗(−a2)=m2−m1k1∗a1+k2∗(−a2)=m2−m1
这个式子和①是一样的，因①成立，故此式也成立。

要找一个最小的非负整数解，我们只需要让

k1=k1% abs(a2d)k1=k1% abs(a2d)
k2=k2% abs(a1d)k2=k2% abs(a1d)
即可找到当前最小的k1,k2k1,k2的解，即此时的kk为00。

QQ：此处为什么要取绝对值呢

AA：因为不知道a2da2d的正负性，我们在原基础上要尽量减多个abs(a2d)abs(a2d)，使其为正整数且最小。

4. 等效替代：
由②式带入

新的xx为：

x=(k1+k∗a2d)∗a1+m1x=(k1+k∗a2d)∗a1+m1
=k1∗a1+m1+k∗a2∗a1d=k1∗a1+m1+k∗a2∗a1d
=k1∗a1+m1+k∗lcm(a1,a2)=k1∗a1+m1+k∗lcm(a1,a2) ③

QQ:这里，kk都为00了，为什么还要算呢？

AA:因为这只是前两个式子得最小kk，有可能遇到下一个式子后面被迫要扩大

在③中，我们设a0=lcm(a1,a2),m0=k1∗a1+m1a0=lcm(a1,a2),m0=k1∗a1+m1
那么：

③ =k∗a0+m0=k∗a0+m0

这个形式与一开始我们分解的形式是不是特别像呢？

没错！假设之后又来了一个a3,m3a3,m3
我们只需要继续找：

x=k∗a0+m0=k3∗(−a3)+m3x=k∗a0+m0=k3∗(−a3)+m3，那么问题又回到了第一步。

5. 总结
我们的做法相当于每次考虑合并两个式子，将这nn个式子合并n−1n−1次后变为一个式子。最后剩下的式子就满足我们的答案。

注意：

lcm(a1,a2)lcm(a1,a2)和%a2d%a2d，需要取绝对值。又因为d=gcd(a1,−a2)d=gcd(a1,−a2)，我们不知道a1a1的正负性（可能是上一步推过来的）。

%a2d%a2d，需要取绝对值， 膜负数的话，不会取到正解；

#include <cstdio>
#include <iostream>
using namespace std;
typedef long long LL;
int n;
LL exgcd(LL a, LL b, LL &x, LL &y){
    if(b == 0){
        x = 1, y = 0;
        return a;
    }

    LL d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
LL inline mod(LL a, LL b){
    return ((a % b) + b) % b;
}
int main(){
    scanf("%d", &n);
    LL a1, m1;
    scanf("%lld%lld", &a1, &m1);
    for(int i = 1; i < n; i++){
        LL a2, m2, k1, k2;
        scanf("%lld%lld", &a2, &m2);
        LL d = exgcd(a1, -a2, k1, k2);
        if((m2 - m1) % d){ puts("-1"); return 0; }
        k1 = mod(k1 * (m2 - m1) / d, abs(a2 / d));
        m1 = k1 * a1 + m1;
        a1 = abs(a1 / d * a2);
    }
    printf("%lld\n", m1);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/solution/content/3539/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;


LL exgcd(LL a, LL b, LL &x, LL &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }

    LL d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}


int main()
{
    int n;
    cin >> n;

    LL x = 0, m1, a1;
    cin >> m1 >> a1;
    for (int i = 0; i < n - 1; i ++ )
    {
        LL m2, a2;
        cin >> m2 >> a2;
        LL k1, k2;
        LL d = exgcd(m1, -m2, k1, k2);
        if ((a2 - a1) % d)
        {
            x = -1;
            break;
        }

        k1 *= (a2 - a1) / d;
        k1 = (k1 % (m2/d) + m2/d) % (m2/d);

        x = k1 * m1 + a1;

        LL m = abs(m1 / d * m2);
        a1 = k1 * m1 + a1;
        m1 = m;
    }

    if (x != -1) x = (x % m1 + m1) % m1;

    cout << x << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/53307/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 878. 线性同余方程关于最后结果处理的证明    原题链接    简单
作者：    AC_Jobim ,  2020-04-09 00:03:59 ,  阅读 281

9


2
关于最后结果的处理

字写得有点丑，请见谅

C++ AC代码
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<stack>
using namespace std;
int N,M;

int exgcd(int a,int b,int &x,int &y){
    if(b==0){
        x = 1,y = 0;
        return a;
    }
    int d = exgcd(b,a%b,x,y);
    int tmp = x;
    x = y;
    y = tmp -a/b*y;
    return d;
}

int main(){
    int i,j,k;

    cin>>N;
    for(i = 1;i<=N;i++){
        int a,b,m;
        scanf("%d %d %d",&a,&b,&m);
        int x,y;
        int d = exgcd(a,m,x,y);
        if(b%d==0){
            int t = b/d;
            printf("%d\n",((long long)x*t%(m/d)+(m/d))%(m/d));
        }
        else
            printf("impossible\n");
    }
    return 0;
}



}


作者：AC_Jobim
链接：https://www.acwing.com/solution/content/11231/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;


int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}


int main()
{
    int n;
    scanf("%d", &n);
    while (n -- )
    {
        int a, b, m;
        scanf("%d%d%d", &a, &b, &m);

        int x, y;
        int d = exgcd(a, m, x, y);
        if (b % d) puts("impossible");
        else printf("%d\n", (LL)b / d * x % m);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/50248/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 877. 扩展欧几里得算法    原题链接    简单
作者：    zeroAC ,  2020-02-13 12:41:22 ,  阅读 740

20


9
题目描述
给定nn对正整数ai,biai,bi，对于每对数，求出一组xi,yixi,yi，使其满足aixi+biyi=gcd(ai,bi)aixi+biyi=gcd(ai,bi)。

输入格式
第一行包含整数nn。

接下来nn行，每行包含两个整数ai,biai,bi。

输出格式
输出共nn行，对于每组ai,biai,bi，求出一组满足条件的xi,yixi,yi，每组结果占一行。

本题答案不唯一，输出任意满足条件的xi,yixi,yi均可。

数据范围
1≤n≤105,1≤n≤105,
1≤ai,bi≤2∗1091≤ai,bi≤2∗109
输入样例：
2
4 6
8 18
输出样例：
-1 1
-2 1
1. 扩展欧几里得
用于求解方程 ax+by=gcd(a,b)ax+by=gcd(a,b) 的解

当 b=0b=0 时 ax+by=aax+by=a 故而 x=1,y=0x=1,y=0
当 b≠0b≠0 时

因为
gcd(a,b)=gcd(b,a%b)
gcd(a,b)=gcd(b,a%b)
而
bx′+(a%b)y′=gcd(b,a%b)
bx′+(a%b)y′=gcd(b,a%b)
bx′+(a−⌊a/b⌋∗b)y′=gcd(b,a%b)
bx′+(a−⌊a/b⌋∗b)y′=gcd(b,a%b)
ay′+b(x′−⌊a/b⌋∗y′)=gcd(b,a%b)=gcd(a,b)
ay′+b(x′−⌊a/b⌋∗y′)=gcd(b,a%b)=gcd(a,b)
故而

x=y′,y=x′−⌊a/b⌋∗y′
x=y′,y=x′−⌊a/b⌋∗y′
因此可以采取递归算法 先求出下一层的x′x′和y′y′ 再利用上述公式回代即可

2. 对于更一般的方程 ax+by=cax+by=c
设 d=gcd(a,b)d=gcd(a,b) 则其有解当且仅当 d|cd|c
求解方法如下:

用扩展欧几里得求出 ax0+by0=dax0+by0=d 的解

则a(x0∗c/d)+b(y0∗c/d)=ca(x0∗c/d)+b(y0∗c/d)=c
故而特解为 x′=x0∗c/d,y′=y0∗c/dx′=x0∗c/d,y′=y0∗c/d
而通解 = 特解 + 齐次解

而齐次解即为方程 ax+by=0ax+by=0的解

故而通解为 x=x′+k∗b/d,x=y′−k∗a/dk∈𝕫x=x′+k∗b/d,x=y′−k∗a/dk∈z
3.应用: 求解一次同余方程 ax≡b(modm)ax≡b(modm)
则等价于求

ax=m∗(−y)+b
ax=m∗(−y)+b
ax+my=b
ax+my=b

有解条件为 gcd(a,m)|bgcd(a,m)|b,然后用扩展欧几里得求解即可

特别的 当 b=1b=1 且 aa与mm互质时 则所求的xx即为aa的逆元

C++ 代码
#include<bits/stdc++.h>
using namespace std;
int exgcd(int a, int b, int &x, int &y){//返回gcd(a,b) 并求出解(引用带回)
    if(b==0){
        x = 1, y = 0;
        return a;
    }
    int x1,y1,gcd;
    gcd = exgcd(b, a%b, x1, y1);
    x = y1, y = x1 - a/b*y1;
    return gcd; 
}
int main(){
    int n,a,b,x,y;
    cin>>n;
    while(n--){
        cin>>a>>b;
        exgcd(a,b,x,y);
        cout<<x<<" "<<y<<endl;
    }
    return 0;
}

作者：zeroAC
链接：https://www.acwing.com/solution/content/1393/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main()
{
    int n;
    scanf("%d", &n);

    while (n -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        int x, y;
        exgcd(a, b, x, y);
        printf("%d %d\n", x, y);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/50245/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 876. 快速幂求逆元    原题链接    简单
作者：    Hz ,  2019-07-28 23:43:50 ,  阅读 935

24


9
当n为质数时，可以用快速幂求逆元：
a / b ≡ a * x (mod n)
两边同乘b可得 a ≡ a * b * x (mod n)
即 1 ≡ b * x (mod n)
同 b * x ≡ 1 (mod n)
由费马小定理可知，当n为质数时
b ^ (n - 1) ≡ 1 (mod n)
拆一个b出来可得 b * b ^ (n - 2) ≡ 1 (mod n)
故当n为质数时，b的乘法逆元 x = b ^ (n - 2)

当n不是质数时，可以用扩展欧几里得算法求逆元：
a有逆元的充要条件是a与p互质，所以gcd(a, p) = 1
假设a的逆元为x，那么有a * x ≡ 1 (mod p)
等价：ax + py = 1
exgcd(a, p, x, y)

快速幂求逆元
#include <iostream>
using namespace std;
typedef long long LL;

LL qmi(int a, int b, int p)
{
    LL res = 1;
    while(b){
        if(b & 1) res = res * a % p;
        a = (LL)a * a % p;
        b >>= 1;
    }
    return res;
}

int main()
{
    int n; cin >> n;
    while(n --){
        int a, p;
        cin >> a >> p;
        if(a % p == 0) puts("impossible");
        else cout << qmi(a, p - 2, p) << endl;
    }
    return 0;
}
扩展欧几里得算法求逆元
#include <iostream>
using namespace std;
typedef long long LL;
int n;

int exgcd(int a, int b, int &x, int &y)
{
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}


int main()
{
    cin >> n;
    while (n --)
    {
        int a, p, x, y;
        // if (a < p) swap(a, p);
        cin >>  a >> p;
        int d = exgcd(a, p, x, y);
        if (d == 1) cout << ((LL)x + p) % p << endl;//保证x是正数
        else puts("impossible");

    }
    return 0;
}


作者：Hz
链接：https://www.acwing.com/solution/content/3054/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;


LL qmi(int a, int b, int p)
{
    LL res = 1;
    while (b)
    {
        if (b & 1) res = res * a % p;
        a = a * (LL)a % p;
        b >>= 1;
    }
    return res;
}


int main()
{
    int n;
    scanf("%d", &n);
    while (n -- )
    {
        int a, p;
        scanf("%d%d", &a, &p);
        if (a % p == 0) puts("impossible");
        else printf("%lld\n", qmi(a, p - 2, p));
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/50238/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 875. 快速幂    原题链接    简单
作者：    蒟蒻芦苇 ,  2020-08-06 23:12:58 ,  阅读 135

4


这是蒟蒻的第5篇题解。欢迎点赞，欢迎大佬来喷。
这是一道very经典的题目，我们可以用个递归和分治解决。
这时，一些初学者就会说：“这题一个pow，然后一%不香吗？”如果你想到这点，那就错了。
基于数据范围，所以本题不可能用暴力解决。那么我们可以用分治的思想分析一下指数的运算，推导出下列递归公式
x^y的三种情况：
1.1 如果y=0
2.xx^(y-1) 如果y为奇数
3.(x^2)^(y div 2) 如果y为偶数
同时，对于模运算有一个重要结论：AB%K=(A%K)*(B%K)%K
就这样，我们就可以用快速幂的递归思想，去快速计算b^p%k的值。去避免高精度。
下面是我们的代码：

#include<bits/stdc++.h>
using namespace std;
long b,p,k,n;//本题要开long
long mod(long a,long n,long k){
    if(n==0) return 1%k;
    if(n==1) return a%k;//先特判一下
    long y=mod(a,n/2,k);
    if(n%2==0) return y*y%k;//上面剩下的两种情况：奇偶
    else return (((y*y)%k)*a)%k;
}
int main(){
    cin>>n;
    while(n--){//while循环读入，n不等于0就不结束
        cin>>b>>p>>k;
        b=b%k;//先缩小个b的数据
        cout<<mod(b,p,k)<<endl;//直接调用函数
    }
    return 0;
}
完美撒花！(^▽^)
OK！本篇题解就到这了！首尾呼应：
欢迎点赞，欢迎大佬来喷。

作者：蒟蒻芦苇
链接：https://www.acwing.com/solution/content/17085/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;


LL qmi(int a, int b, int p)
{
    LL res = 1 % p;
    while (b)
    {
        if (b & 1) res = res * a % p;
        a = a * (LL)a % p;
        b >>= 1;
    }
    return res;
}


int main()
{
    int n;
    scanf("%d", &n);
    while (n -- )
    {
        int a, b, p;
        scanf("%d%d%d", &a, &b, &p);
        printf("%lld\n", qmi(a, b, p));
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/50237/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 874. 筛法求欧拉函数    原题链接    简单
作者：    番茄酱 ,  2019-08-22 17:17:44 ,  阅读 753

9


2
题目描述
给定一个正整数nn，求11~nn中每个数的欧拉函数之和。
数据范围：1≤n≤1061≤n≤106
11~NN中与NN互质的数的个数被称为欧拉函数，记为ϕ(N)ϕ(N)。
若在算数基本定理中，N=pα11pα22···pαkkN=p1α1p2α2···pkαk，则：
ϕ(N)=N∗p1−1p1∗p2−1p2∗…∗pk−1pkϕ(N)=N∗p1−1p1∗p2−1p2∗…∗pk−1pk
线性筛法同时求欧拉函数
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1000010;

int primes[N], cnt;
int phi[N];
bool st[N];

void get_eulers(int n)
{
    phi[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        if (!st[i])
        {
            primes[cnt++] = i;
            phi[i] = i - 1; 
        }
        for (int j = 0; primes[j] <= n / i; j++)
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0)
            {
                phi[primes[j] * i] = phi[i] * primes[j]; 
                break;
            }
            phi[primes[j] * i] = phi[i] * (primes[j] - 1);
        }
    }
}

int main()
{
    int n;
    cin >> n;

    get_eulers(n);

    LL res = 0;
    for (int i = 1; i <= n; i++) res += phi[i];
    printf("%lld\n", res);

    return 0;
}
代码解释：
质数ii的欧拉函数即为phi[i] = i - 1：1 ~ i−1i−1均与ii互质，共i−1i−1个。
phi[primes[j] * i]分为两种情况：
① i % primes[j] == 0时：primes[j]是i的最小质因子，也是primes[j] * i的最小质因子，因此1 - 1 / primes[j]这一项在phi[i]中计算过了，只需将基数NN修正为primes[j]倍，最终结果为phi[i] * primes[j]。
② i % primes[j] != 0：primes[j]不是i的质因子，只是primes[j] * i的最小质因子，因此不仅需要将基数NN修正为primes[j]倍，还需要补上1 - 1 / primes[j]这一项，因此最终结果phi[i] * (primes[j] - 1)。

作者：番茄酱
链接：https://www.acwing.com/solution/content/3952/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1000010;


int primes[N], cnt;
int euler[N];
bool st[N];


void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}


int main()
{
    int n;
    cin >> n;

    get_eulers(n);

    LL res = 0;
    for (int i = 1; i <= n; i ++ ) res += euler[i];

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/49995/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 873. 欧拉函数    原题链接    简单
作者：    Sundae ,  2020-02-18 14:44:28 ,  阅读 565

17


6
欧拉函数
对于正整数nn,欧拉函数是小于或等于nn的正整数中与nn互质的数的数目，记作φ(n)φ(n).
φ(1)=1φ(1)=1
求n的欧拉值
首先， 欧拉函数是一个积性函数，当m,nm,n互质时，φ(mn)=φ(m)∗φ(n)φ(mn)=φ(m)∗φ(n)
根据唯一分解定理知 n=pa11∗pa22∗…∗paxxn=p1a1∗p2a2∗…∗pxax
因此 φ(n)=φ(pa11)∗…∗φ(paxx)φ(n)=φ(p1a1)∗…∗φ(pxax)
对于任意一项 φ(pass)=pass−p(as−1)sφ(psas)=psas−ps(as−1)
从定义出发 φ(pass)φ(psas)等于小于或等于passpsas的正整数中与passpsas互质的数的数目

从11到passpsas中共有passpsas个数字

其中与passpsas不互质的有ps,2ps,…,psas−1∗psps,2ps,…,psas−1∗ps ,共psas−1psas−1项

所以 φ(pass)φ(psas) = passpsas - psas−1=pass∗(1−1ps)psas−1=psas∗(1−1ps)
因此

φ(n)=φ(pa11)∗…∗φ(paxx)
φ(n)=φ(p1a1)∗…∗φ(pxax)
=(pa11−p1a1−1)∗…∗(paxx−pxax−1)
=(p1a1−p1a1−1)∗…∗(pxax−pxax−1)
=pa11∗(1−1p1)∗pa22∗(1−1p2)∗…∗paxx∗(1−1px)
=p1a1∗(1−1p1)∗p2a2∗(1−1p2)∗…∗pxax∗(1−1px)
=pa11∗pa22∗…∗paxx∗(1−1p1)∗(1−1p2)∗…∗(1−1px)
=p1a1∗p2a2∗…∗pxax∗(1−1p1)∗(1−1p2)∗…∗(1−1px)
=n∗∏i=1x(1−1pi)

作者：Sundae
链接：https://www.acwing.com/solution/content/8702/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 873. 数论-欧拉函数    原题链接    简单
作者：    Struggle ,  2020-09-29 14:01:14 ,  阅读 21

2


题型:给定一个正整数n,求1-n中与n互质的数的个数

欧拉公式(求1-n中与n互质的数的个数)
若n可写成f(n)=aα11∗aα22∗…∗aαkk=∏i=1k(aαii)(a1,a2,…,ak均为质数)
若n可写成f(n)=a1α1∗a2α2∗…∗akαk=∏i=1k(aiαi)(a1,a2,…,ak均为质数)
euler(n)=n∗(a1−1)a1∗(a2−1)a2∗…∗(ak−1)ak=n∗∏i=1k(ai−1)ai
euler(n)=n∗(a1−1)a1∗(a2−1)a2∗…∗(ak−1)ak=n∗∏i=1k(ai−1)ai

证明:

①首先去掉a1,a2,…,aka1,a2,…,ak的倍数
此时euler(n)=1−na1−na2−…−nakeuler(n)=1−na1−na2−…−nak
①的推导可能是存在问题的,若在1-n中存在一个数x,是ai和aj(i,j∈[1,n]且i≠j)的公倍数,那么在①中就多减了一次ai和aj公倍数个数ai和aj(i,j∈[1,n]且i≠j)的公倍数,那么在①中就多减了一次ai和aj公倍数个数,此时需给①推导的euler函数加上一次ai和ajai和aj的公倍数个数
②euler(n)=1−na1−na2−…−nak+na1∗a2+na1∗a3+…+nak−1∗akeuler(n)=1−na1−na2−…−nak+na1∗a2+na1∗a3+…+nak−1∗ak
②的推导可能也是存在问题的,若在1-n中可能存在一个数x,是ai和aj和at(i,j,t∈[1,n]且i≠j≠t)的公倍数,那么在①中就减了三次ai和aj和at的公倍数,在ai和aj和at(i,j,t∈[1,n]且i≠j≠t)的公倍数,那么在①中就减了三次ai和aj和at的公倍数,在
②中加了三次ai和aj和atai和aj和at的公倍数个数,最后函数euler等于没减ai和aj和atai和aj和at的公倍数,此时需要加上ai和aj和atai和aj和at的公倍数个数
③euler(n)=1−na1−na2−…−nak+na1∗a2+na1∗a3+…+nak−1∗ak−na1∗a2∗a3−na1∗a2∗a4−euler(n)=1−na1−na2−…−nak+na1∗a2+na1∗a3+…+nak−1∗ak−na1∗a2∗a3−na1∗a2∗a4−
…−nak−2∗ak−1∗ak…−nak−2∗ak−1∗ak
依此类推有
euler(n)=n∗(a1−1)a1∗(a2−1)a2∗…∗(ak−1)ak=n∗∏i=1k(ai−1)ai
euler(n)=n∗(a1−1)a1∗(a2−1)a2∗…∗(ak−1)ak=n∗∏i=1k(ai−1)ai

代码(C++)

#include<iostream>
using namespace std;
int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        int x,res;
        cin>>x;
        res=x;
        for(int i=2;i<=x/i;i++)
        {
            if(x%i==0)
            {
                while(x%i==0)
                    x/=i;
                res=res/i*(i-1);
            }
        }
        if(x>1) res=res/x*(x-1);
        cout<<res<<endl;
    }
}

作者：Struggle
链接：https://www.acwing.com/solution/content/21569/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>

using namespace std;


int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}


int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        cin >> x;
        cout << phi(x) << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/49992/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 872. 最大公约数（第N篇关于STL的题解）    原题链接    简单
作者：    有猷 ,  2020-01-18 18:42:04 ,  阅读 388

7


1
本人蒟蒻，题解如果有问题（肯定有）,希望大家在评论区中指出，谢谢。

本题的做法：
直接用辗转相除法求解
使用STL中的__gcd函数
本题解主要介绍的是STL做法，__gcd()函数其实和手写的GCD函数用法一样，就是方便一些
（注意！函数前面有两个下划线哦。即：是“__gcd”而不是“_gcd”）
STL代码如下：

#include<bits/stdc++.h>//万能头文件
using namespace std;//这句话一定不能忘哦！
int n,a,b;
int main() {
    cin >> n;
    while(n--){
        cin >> a >> b;
        cout << __gcd(a,b) << endl;//调用STL函数
    }
    return 0;
}
在这里，也贴一下欧几里得算法的c++代码：

#include<bits/stdc++.h>
using namespace std;
int n,a,b;
int gcd(int x,int y){
    if(x < y)swap(x,y);
    if(x % y == 0)return y;
    return gcd(y,x % y);
}
int main() {
    cin >> n;
    while(n--){
        cin >> a >> b;
        cout << gcd(a,b) << endl;
    }
    return 0;
}

作者：有猷
链接：https://www.acwing.com/solution/content/7612/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;


int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}


int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        printf("%d\n", gcd(a, b));
    }

    return 0;
}

AcWing 871. 约数之和    原题链接    简单
作者：    TaoZex ,  2019-08-13 18:30:31 ,  阅读 642

5




#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int mod=1e9+7;

unordered_map<int,int> primes;
int main(){
    int n;
    cin>>n;

    while(n--){
        int x;
        cin>>x;

        for(int i=2;i<=x/i;i++){
            while(x%i==0){
                x/=i;
                primes[i]++;
            }
        } 
        if(x>1) primes[x]++;           //注意是x>1
    }

    ll res=1;
    for(auto prime:primes){           
        int p=prime.first,a=prime.second;
        ll t=1;
        while(a--) t=(t*p+1)%mod;         //求出 p0一直加到p的k的次方 的和
        res=res*t%mod;
    }
    cout<<res<<endl;
}

作者：TaoZex
链接：https://www.acwing.com/solution/content/3801/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 110, mod = 1e9 + 7;

int main()
{
    int n;
    cin >> n;

    unordered_map<int, int> primes;

    while (n -- )
    {
        int x;
        cin >> x;

        for (int i = 2; i <= x / i; i ++ )
            while (x % i == 0)
            {
                x /= i;
                primes[i] ++ ;
            }

        if (x > 1) primes[x] ++ ;
    }

    LL res = 1;
    for (auto p : primes)
    {
        LL a = p.first, b = p.second;
        LL t = 1;
        while (b -- ) t = (t * a + 1) % mod;
        res = res * t % mod;
    }

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/49985/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 870. 约数个数    原题链接    简单
作者：    清南 ,  2019-10-01 20:32:16 ,  阅读 1142

14


6
约数推导
N=ans=d=pα11∗pα22∗⋯∗pαkk(α1+1)(α2+1)…(αk+1)因为任何一个约数d可以表示成pβ11∗pβ22∗⋯∗pβkk,0≤βi≤αi每一项的βi如果不同，那么约数d就不相同（算数基本定理，每个数的因式分解是唯一的）所以n的约数就跟βi的选法是一一对应的β1一共有0∼α1种选法β2一共有0∼α2种选法…βk一共有0∼αk种选法乘法原理，一共有ans个约数
N=p1α1∗p2α2∗⋯∗pkαkans=(α1+1)(α2+1)…(αk+1)因为任何一个约数d可以表示成d=p1β1∗p2β2∗⋯∗pkβk,0≤βi≤αi每一项的βi如果不同，那么约数d就不相同（算数基本定理，每个数的因式分解是唯一的）所以n的约数就跟βi的选法是一一对应的β1一共有0∼α1种选法β2一共有0∼α2种选法…βk一共有0∼αk种选法乘法原理，一共有ans个约数
代码

#include <bits/stdc++.h>
using namespace std;
typedef long long LL; 
const int mod = 1e9 + 7;
int main(){
    int n,x;
    LL ans = 1;
    unordered_map<int,int> hash;
    cin >> n;
    while(n--){
        cin >> x;
        for(int i = 2;i <= x/i; ++i){
            while(x % i == 0){
                x /= i;
                hash[i] ++;
            }
        }
        if(x > 1) hash[x] ++;
    }
    for(auto i : hash) ans = ans*(i.second + 1) % mod;
    cout << ans;
    return 0;
}

作者：清南
链接：https://www.acwing.com/solution/content/4969/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <algorithm>
#include <unordered_map>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 110, mod = 1e9 + 7;

int main()
{
    int n;
    cin >> n;

    unordered_map<int, int> primes;

    while (n -- )
    {
        int x;
        cin >> x;

        for (int i = 2; i <= x / i; i ++ )
            while (x % i == 0)
            {
                x /= i;
                primes[i] ++ ;
            }

        if (x > 1) primes[x] ++ ;
    }

    LL res = 1;
    for (auto p : primes) res = res * (p.second + 1) % mod;

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/49983/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 869. 试除法求约数    原题链接    简单
作者：    weixiao ,  2019-12-09 21:43:53 ,  阅读 495

2


2
题目描述
给定n个正整数,对于每个整数请你按照从小到大的顺序输出它的所有约数。

样例
输入:2 6 8
输出:
1 2 3 6
1 2 4 8
思想:试除法(判断每个数能否被n整除)
时间复杂度:O(sqrt(n))

c++代码

#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
int n;
vector<int> get_divisors(int n){
    vector<int> res;
    for(int i=1;i<=n/i;i++){
        if(n%i==0){
            res.push_back(i);
            if(i!=n/i) res.push_back(n/i);//当i*i=n时,只放一遍
        } 
    }
    sort(res.begin(),res.end());
    return res;
}
int main(){
    cin>>n;
    while(n--){
        int a;
        cin>>a;
        auto res=get_divisors(a);
        for(auto t:res) cout<<t<<" ";
        cout<<endl;
    }
    return 0;
}

作者：weixiao
链接：https://www.acwing.com/solution/content/6903/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}

int main()
{
    int n;
    cin >> n;

    while (n -- )
    {
        int x;
        cin >> x;
        auto res = get_divisors(x);

        for (auto x : res) cout << x << ' ';
        cout << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/49976/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 868. 筛质数    原题链接    简单
作者：    竹林正在青 ,  2019-08-13 09:35:47 ,  阅读 1429

20


11
#include <iostream>
using namespace std;
const int N = 1e6+10;

int prime[N], cnt;
bool st[N];

//朴素筛法-O(nlogn)
void get_primes(int x) {
    for(int i = 2; i <= n; i++) {
        if(!st[i]) prime[cnt++] = i;
        for(int j = i+i; j <= n; j += i) 
            st[j] = true;
    }
}

//埃式筛法-O(nloglogn)
void get_primes(int n) {
    for(int i = 2; i <= n; i++) {
        if(!st[i]){ 
            prime[cnt++] = i;
            for(int j = i; j <= n; j += i)
                st[j] = true;
        }
    } 
}

//线性筛法-O(n), n = 1e7的时候基本就比埃式筛法快一倍了
//算法核心：x仅会被其最小质因子筛去
void get_prime(int x) {
    for(int i = 2; i <= x; i++) {
        if(!st[i]) prime[cnt++] = i;
        for(int j = 0; prime[j] <= x / i; j++) {
            //对于任意一个合数x，假设pj为x最小质因子，当i<x/pj时，一定会被筛掉
            st[prime[j]*i] = true;
            if(i % prime[j] == 0) break;
            /*
            1.i%pj == 0, pj定为i最小质因子，pj也定为pj*i最小质因子
            2.i%pj != 0, pj定小于i的所有质因子，所以pj也为pj*i最小质因子
            */
        }
    }
} 

int main() {
    int x;
    cin >> x;
    get_primes(x);
    cout << cnt << endl;
    return 0;
}

作者：竹林正在青
链接：https://www.acwing.com/solution/content/3776/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

朴素筛法
#include <iostream>
#include <algorithm>

using namespace std;

const int N= 1000010;

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}

int main()
{
    int n;
    cin >> n;

    get_primes(n);

    cout << cnt << endl;

    return 0;
}
线性筛法
#include <iostream>
#include <algorithm>

using namespace std;

const int N= 1000010;

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int main()
{
    int n;
    cin >> n;

    get_primes(n);

    cout << cnt << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/49975/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

cWing 867. 分解质因数    原题链接    简单
作者：    高数 ,  2020-03-10 10:54:12 ,  阅读 750

9


根据算术基本定理，不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。
n=p1^a1 * p2^a2 *p3^a3.....pn^an
比如一个数16 在分解时先找到2这个质因子，然后由于16/2后还可以/2，所以会在2这个质因子上产生次方
不优化版本：从2~n 找到能整除的因子然后算次方
提前不满意这个不优化版本
这里有个性质：n中最多只含有一个大于sqrt(n)的因子。证明通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。证毕
于是我们发现最多只有一个大于sqrt(n)的因子，对其进行优化。先考虑比sqrt(n)小的，代码和质数的判定类似
最后如果n还是>1，说明这就是大于sqrt(n)的唯一质因子，输出即可。

C++
#include<iostream>
#include<algorithm>
using namespace std;
int main(void)
{
    int n;cin>>n;
    while(n--)
    {
        int a;cin>>a;
        for(int i=2;i<=a/i;i++)
        {
            if(a%i==0)
            {
                int s=0;
                while(a%i==0)
                {
                    a/=i;
                    s++;
                }
                cout<<i<<" "<<s<<endl;  
            }

        }
        if(a>1) cout<<a<<' '<<1<<endl; ///
        cout<<endl;
    }
return 0;    
}

作者：高数
链接：https://www.acwing.com/solution/content/9813/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        cin >> x;
        divide(x);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/49974/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 866. 试除法判定质数    原题链接    简单
作者：    人生真是寂寞如雪啊 ,  2019-12-16 12:36:38 ,  阅读 587

3


2
#include <iostream>

using namespace std;

bool is_prime(int x) {
    if (x < 2) 
      return false;
//列出i较小的因数
    for (int i = 2; i <= x / i; i ++ )
//且是i的因数        
        if (x % i == 0)
            return false;
    return true;
}
int main() {
  int n,ai;
  cin >> n;
  while(n--) {
    cin >> ai;
    bool res = is_prime(ai);
    if (res)
      cout << "Yes"<<endl;
    else 
      cout << "No" << endl;
  }
  return 0;
}

作者：人生真是寂寞如雪啊
链接：https://www.acwing.com/solution/content/7064/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}

int main()
{
    int n;
    cin >> n;

    while (n -- )
    {
        int x;
        cin >> x;
        if (is_prime(x)) puts("Yes");
        else puts("No");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/49970/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 861. 二分图的最大匹配    原题链接    简单
作者：    在线白给 ,  2019-10-15 13:58:09 ,  阅读 984

24


14
导读：什么是最大匹配？
要了解匈牙利算法必须先理解下面的概念：

匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。

最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。

下面是一些补充概念：

完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。

交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。

增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替 路称为增广路（agumenting path）。

匈牙利算法
不讲算法证明(我也不会)。

用一个转载的例子来讲解匈牙利算法的流程。

代码实现匈牙利算法
首先是存图模板

//邻接表写法，存稀疏图
int h[N],ne[N],e[N],idx;
//n1,n2分别是两个点集的点的个数
int n1,n2,m;
void add(int a , int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void init()
{
    memset(h,-1,sizeof h);
}
//存边只存一边就行了，虽然是无向图。
for(int i = 0 ; i < n1 ; i ++)
{
    int a,b;
    cin>>a>>b;
    add(a,b);
}
接下来看算法模板(c++)

//match[j]=a,表示女孩j的现有配对男友是a
int match[N];
//st[]数组我称为临时预定数组，st[j]=a表示一轮模拟匹配中，女孩j被男孩a预定了。
int st[N];

//这个函数的作用是用来判断,如果加入x来参与模拟配对,会不会使匹配数增多
int find(int x)
{
    //遍历自己喜欢的女孩
    for(int i = h[x] ; i != -1 ;i = ne[i])
    {
        int j = e[i];
        if(!st[j])//如果在这一轮模拟匹配中,这个女孩尚未被预定
        {
            st[j] = true;//那x就预定这个女孩了
            //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功,更新match
            if(!match[j]||find(match[j]))
            {
                match[j] = x;
                return true;
            }

        }
    }
    //自己中意的全部都被预定了。配对失败。
    return false;
}

//记录最大匹配
int res = 0;
for(int i = 1; i <= n1 ;i ++)
{  
    //因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化
    memset(st,false,sizeof st);
    if(find(i)) 
        res++;
}  
下面用一个gif动图来演示这个整个配对的递归过程：


练习例题： 二分图的最大匹配

AC代码

#include<iostream>
#include<cstring>
using namespace std;
const int N = 510 , M = 100010;
int n1,n2,m;
int h[N],ne[M],e[M],idx;
bool st[N];
int match[N];

void add(int a , int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void init()
{
    memset(h,-1,sizeof h);
}

int find(int x)
{
    //遍历自己喜欢的女孩
    for(int i = h[x] ; i != -1 ;i = ne[i])
    {
        int j = e[i];
        if(!st[j])//如果在这一轮模拟匹配中,这个女孩尚未被预定
        {
            st[j] = true;//那x就预定这个女孩了
            //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功
            if(!match[j]||find(match[j]))
            {
                match[j] = x;
                return true;
            }

        }
    }
    //自己中意的全部都被预定了。配对失败。
    return false;
}
int main()
{
    init();
    cin>>n1>>n2>>m;
    while(m--)
    {
        int a,b;
        cin>>a>>b;
        add(a,b);
    }


    int res = 0;
    for(int i = 1; i <= n1 ;i ++)
    {  
         //因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化
          memset(st,false,sizeof st);
        if(find(i)) 
          res++;
    }  

    cout<<res<<endl;
}

作者：在线白给
链接：https://www.acwing.com/solution/content/5334/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, M = 100010;

int n1, n2, m;
int h[N], e[M], ne[M], idx;
int match[N];
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

int main()
{
    scanf("%d%d%d", &n1, &n2, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }

    int res = 0;
    for (int i = 1; i <= n1; i ++ )
    {
        memset(st, false, sizeof st);
        if (find(i)) res ++ ;
    }

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/48814/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 860. 染色法判定二分图    原题链接    简单
作者：    小呆呆 ,  2019-11-17 16:37:29 ,  阅读 1006

9


5
奇数环：由奇数条边形成的一个环

二分图：当且仅当图中不含有奇数环，两个集合内部的内部没有边

算法1
使用bfs

约定染的颜色有1颜色和2颜色


时间复杂度 O(m+n)O(m+n)
Java 代码
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class Main {
    static int n;
    static int m;
    static int N = 100010;
    static int M = 200010;
    static int[] h = new int[N];
    static int[] e = new int[M];
    static int[] ne = new int[M];
    static int idx = 0;
    static int[] color = new int[N];//共1和2两种不同的颜色
    static boolean[] st = new boolean[N];
    public static void add(int a,int b)
    {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx ++;
    }
    public static boolean bfs()
    {
        Queue<Integer> queue = new LinkedList<Integer>();
        for(int i = 1;i <= n;i++)
        {
            //若该点为未色
            if(color[i] == 0)
            {
                color[i] = 1;
                queue.add(i);
                while(!queue.isEmpty())
                {
                    int t = queue.poll();
                    for(int j = h[t] ;j != -1;j = ne[j])
                    {
                        int k = e[j];
                        if(color[k] == 0)
                        {
                            color[k] = 3 - color[t];
                            queue.add(k);
                        }
                        else if(color[k] == color[t]) return false;
                    }
                }
            }
        }
        return true;


    }
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] str1 = reader.readLine().split(" ");
        n = Integer.parseInt(str1[0]);
        m = Integer.parseInt(str1[1]);
        Arrays.fill(h, -1);
        while(m -- > 0)
        {
            String[] str2 = reader.readLine().split(" ");
            int a = Integer.parseInt(str2[0]);
            int b = Integer.parseInt(str2[1]);
            add(a,b);
            add(b,a);
        }

        if(bfs()) System.out.println("Yes");
        else System.out.println("No");


    }

}

算法2
使用dfs（注意：在这里使用java会直接爆栈hh）

dfs(u,c)表示把u号点染色成c颜色，并且判断从u号点开始染其他相连的点是否染成功
时间复杂度 O(m+n)O(m+n)
Java 代码
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {
    static int n;
    static int m;
    static int N = 100010;
    static int M = 200010;
    static int[] h = new int[N];
    static int[] e = new int[M];
    static int[] ne = new int[M];
    static int idx = 0;
    static int[] color = new int[N];//共1和2两种不同的颜色
    static boolean[] st = new boolean[N];
    public static void add(int a,int b)
    {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx ++;
    }
    //dfs(u,c)表示把u号点染色成c颜色，并且判断从u号点开始染其他相连的点是否成功
    public static boolean dfs(int u,int c)
    {
        color[u] = c;
        for(int i = h[u];i != -1;i = ne[i])
        {
            int j = e[i];
            if(color[j] == 0)
            {
                if(!dfs(j,3 - c)) return false;
            }
            else if(color[j] == c) return false;//颜色重复
        }
        return true;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] str1 = reader.readLine().split(" ");
        n = Integer.parseInt(str1[0]);
        m = Integer.parseInt(str1[1]);
        Arrays.fill(h, -1);
        while(m -- > 0)
        {
            String[] str2 = reader.readLine().split(" ");
            int a = Integer.parseInt(str2[0]);
            int b = Integer.parseInt(str2[1]);
            add(a,b);
            add(b,a);
        }
        boolean flag = true;//标记是否染色成功
        for(int i = 1;i <= n;i++)
        {
            //若未染色
            if(color[i] == 0)
            {
                if(!dfs(i,1)) 
                {
                    flag = false;
                    break;
                }
            }
        }
        if(flag) System.out.println("Yes");
        else System.out.println("No");
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/6347/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 860. 染色法判定二分图    原题链接    简单
作者：    gyh ,  2019-10-13 23:18:22 ,  阅读 721

9


4
染色法
将所有点分成两个集合，使得所有边只出现在集合之间，就是二分图
二分图：一定不含有奇数环，可能包含长度为偶数的环， 不一定是连通图
dfs版本
代码思路：
染色可以使用1和2区分不同颜色，用0表示未染色
遍历所有点，每次将未染色的点进行dfs, 默认染成1或者2
由于某个点染色成功不代表整个图就是二分图,因此只有某个点染色失败才能立刻break/return
染色失败相当于至少存在2个点染了相同的颜色
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 1e5 + 10, M = 2e5 + 10; // 无向图, 所以最大边数是2倍
int e[M], ne[M], h[N], idx;
int st[N];

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

bool dfs(int u, int color) {
    st[u] = color;

    for(int i = h[u]; i != -1; i = ne[i]){
        int j = e[i];
        if(!st[j]) {
            if(!dfs(j, 3 - color)) return false;
        }else if(st[j] == color) return false;
    }

    return true;
}

int main(){
    int n, m;
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);
    while (m --){
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b,a);  // 无向图
    }

    bool flag = true;
    for(int i = 1; i <= n; i ++){
        if(!st[i]){
            if(!dfs(i, 1)){
                flag = false;
                break;
            }
        }
    }

    if(flag) puts("Yes");
    else puts("No");
    return 0;
}
bfs版本
代码思路
颜色 1 和 2 表示不同颜色, 0 表示 未染色
定义queue是存PII，表示 <点编号, 颜色>,
同理，遍历所有点, 将未染色的点都进行bfs
队列初始化将第i个点入队, 默认颜色可以是1或2
while (队列不空)
每次获取队头t, 并遍历队头t的所有邻边
若邻边的点未染色则染上与队头t相反的颜色，并添加到队列
若邻边的点已经染色且与队头t的颜色相同, 则返回false
C++ 代码
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
const int N = 1e5 + 10, M = 2e5 + 10;
typedef pair<int, int> PII;

int e[M], ne[M], h[N], idx;
int n, m;
int st[N];

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

bool bfs(int u){
    int hh = 0, tt = 0;
    PII q[N];
    q[0] = {u, 1};
    st[u] = 1;

    while(hh <= tt){
        auto t = q[hh ++];
        int ver = t.first, c = t.second;

        for (int i = h[ver]; i != -1; i = ne[i]){
            int j = e[i];

            if(!st[j])
            {
                st[j] = 3 - c;
                q[++ tt] = {j, 3 - c};
            }
            else if(st[j] == c) return false;
        }
    }

    return true;
}

int main(){
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);
    while(m --){
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a); // 无向图
    }

    int flag = true;
    for(int i = 1; i <= n; i ++) {
        if (!st[i]){
            if(!bfs(i)){
                flag = false;
                break;
            }
        }
    }

    if (flag) puts("Yes");
    else puts("No");
    return 0;
}

作者：gyh
链接：https://www.acwing.com/solution/content/5281/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 200010;

int n, m;
int h[N], e[M], ne[M], idx;
int color[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool dfs(int u, int c)
{
    color[u] = c;

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!color[j])
        {
            if (!dfs(j, 3 - c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }

    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (!color[i])
        {
            if (!dfs(i, 1))
            {
                flag = false;
                break;
            }
        }

    if (flag) puts("Yes");
    else puts("No");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/48778/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 859. Kruskal算法求最小生成树    原题链接    简单
作者：    松鼠爱葡萄 ,  2020-06-05 10:01:47 ,  阅读 202

5


2
Kruskal算法 (解决稀疏图) O(mlog(m))O(mlog(m))
将所有边按照权重从小到大排序 O(mlog(m))O(mlog(m))
枚举每条边(a, b， 权重c) O(m)O(m)
      if a, b 两点不连通

            将a, b边加入集合中
第二步与 连通块中点的数量 相似

使用并查集，查询两个结点是否属于一个集合， 合并两个结点

代码
#include<iostream>
#include<algorithm>

using namespace std;
const int N = 1e5 + 10, M = 2e5 + 10, INF = 0x3f3f3f3f;
int n, m;
int p[N];

struct Edge {
    int a, b, w;

    bool operator<(const Edge &e) const {
        return w < e.w;
    }
} es[M];

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal() {
    int cnt = 0, res = 0;

    sort(es, es + m);

    for (int i = 1; i <= n; i++) p[i] = i;

    for (int i = 0; i < m; i++) {
        int a = es[i].a, b = es[i].b, w = es[i].w;
        a = find(a), b = find(b);
        if (a != b) {
            p[a] = b;
            res += w;
            cnt++;
        }
    }

    if (cnt < n - 1) return INF;
    else return res;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        es[i] = {a, b, w};
    }

    int t = kruskal();
    if (t == INF) cout << "impossible";
    else cout << t;
}

作者：松鼠爱葡萄
链接：https://www.acwing.com/solution/content/14276/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 200010, INF = 0x3f3f3f3f;

int n, m;
int p[N];

struct Edge
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}

int main()
{
    scanf("%d%d", &n, &m);

    for (int i = 0; i < m; i ++ )
    {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        edges[i] = {a, b, w};
    }

    int t = kruskal();

    if (t == INF) puts("impossible");
    else printf("%d\n", t);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/48773/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 858. Prim算法求最小生成树    原题链接    简单
作者：    竹林正在青 ,  2019-08-12 10:28:57 ,  阅读 1346

11


3
/*
S:当前已经在联通块中的所有点的集合
1. dist[i] = inf
2. for n 次
    t<-S外离S最近的点
    利用t更新S外点到S的距离
    st[t] = true
n次迭代之后所有点都已加入到S中
联系：Dijkstra算法是更新到起始点的距离，Prim是更新到集合S的距离
*/
#include <iostream>
#include <cstring>
using namespace std;
const int N = 510, INF = 0x3f3f3f3f;

int n, m;
int g[N][N], dist[N];
//邻接矩阵存储所有边
//dist存储其他点到S的距离
bool st[N];

int prim() {
    //如果图不连通返回INF, 否则返回res
    memset(dist, INF, sizeof dist);
    int res = 0;

    for(int i = 0; i < n; i++) {
        int t = -1;
        for(int j = 1; j <= n; j++) 
            if(!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        //寻找离集合S最近的点        
        if(i && dist[t] == INF) return INF;
        //判断是否连通，有无最小生成树

        if(i) res += dist[t];
        //cout << i << ' ' << res << endl;
        st[t] = true;
        //更新最新S的权值和

        for(int j = 1; j <= n; j++) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}

int main() {
    cin >> n >> m;
    int u, v, w;

    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            if(i ==j) g[i][j] = 0;
            else g[i][j] = INF;

    while(m--) {
        cin >> u >> v >> w;
        g[u][v] = g[v][u] = min(g[u][v], w);
    }
    int t = prim();
    //临时存储防止执行两次函数导致最后仅返回0
    if(t == INF) puts("impossible");
    else cout << t << endl;
}

作者：竹林正在青
链接：https://www.acwing.com/solution/content/1825/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, INF = 0x3f3f3f3f;

int n, m;
int g[N][N];
int dist[N];
bool st[N];


int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}


int main()
{
    scanf("%d%d", &n, &m);

    memset(g, 0x3f, sizeof g);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        g[a][b] = g[b][a] = min(g[a][b], c);
    }

    int t = prim();

    if (t == INF) puts("impossible");
    else printf("%d\n", t);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/48767/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 854. Floyd求最短路    原题链接    简单
作者：    竹林正在青 ,  2019-12-13 15:19:12 ,  阅读 949

17


15
多源汇最短路问题-具有多个源点
Floyd算法 O(n^3)-动态规划
给定一个n个点m条边的有向图，图中可能存在重边和自环，边权可能为负数。

再给定k个询问，每个询问包含两个整数x和y，表示查询从点x到点y的最短距离，如果路径不存在，则输出“impossible”。

数据保证图中不存在负权回路。

输入格式
第一行包含三个整数n，m，k

接下来m行，每行包含三个整数x，y，z，表示点x和点y之间存在一条有向边，边长为z。

接下来k行，每行包含两个整数x，y，表示询问点x到点y的最短距离。

输出格式
共k行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出“impossible”。

数据范围
1≤n≤2001≤n≤200
1≤k≤n21≤k≤n2
1≤m≤200001≤m≤20000
图中涉及边长绝对值均不超过10000。

输入样例：
3 3 2
1 2 1
2 3 2
1 3 1
2 1
1 3
输出样例：
impossible
1
代码：
#include <iostream>
using namespace std;

const int N = 210, M = 2e+10, INF = 1e9;

int n, m, k, x, y, z;
int d[N][N];

void floyd() {
    for(int k = 1; k <= n; k++)
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main() {
    cin >> n >> m >> k;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            if(i == j) d[i][j] = 0;
            else d[i][j] = INF;
    while(m--) {
        cin >> x >> y >> z;
        d[x][y] = min(d[x][y], z);
        //注意保存最小的边
    }
    floyd();
    while(k--) {
        cin >> x >> y;
        if(d[x][y] > INF/2) puts("impossible");
        //由于有负权边存在所以约大过INF/2也很合理
        else cout << d[x][y] << endl;
    }
    return 0;
}



文字性复习
Dijkstra-朴素O(n^2)

初始化距离数组, dist[1] = 0, dist[i] = inf;
for n次循环 每次循环确定一个min加入S集合中，n次之后就得出所有的最短距离
将不在S中dist_min的点->t
t->S加入最短路集合
用t更新到其他点的距离
Dijkstra-堆优化O(mlogm)

利用邻接表，优先队列
在priority_queue[HTML_REMOVED], greater[HTML_REMOVED] > heap;中将返回堆顶
利用堆顶来更新其他点，并加入堆中类似宽搜
Bellman_fordO(nm)

注意连锁想象需要备份, struct Edge{inta,b,c} Edge[M];
初始化dist, 松弛dist[x.b] = min(dist[x.b], backup[x.a]+x.w);
松弛k次，每次访问m条边
Spfa O(n)~O(nm)

利用队列优化仅加入修改过的地方
for k次
for 所有边利用宽搜模型去优化bellman_ford算法
更新队列中当前点的所有出边
Floyd O(n^3)

初始化d
k, i, j 去更新d

作者：竹林正在青
链接：https://www.acwing.com/solution/content/6976/
来源：AcWing


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 210, INF = 1e9;

int n, m, Q;
int d[N][N];

void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main()
{
    scanf("%d%d%d", &n, &m, &Q);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        d[a][b] = min(d[a][b], c);
    }

    floyd();

    while (Q -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);

        int t = d[a][b];
        if (t > INF / 2) puts("impossible");
        else printf("%d\n", t);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/48531/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 852. spfa判断负环    原题链接    简单
作者：    小呆呆 ,  2019-11-17 00:55:03 ,  阅读 862

10


2
算法分析
使用spfa算法解决是否存在负环问题

1、dist[x] 记录当前1到x的最短距离

2、cnt[x] 记录当前最短路的边数，初始每个点到1号点的距离为0，只要他能再走n步，即cnt[x] >= n,则表示该图中一定存在负环，由于从1到x至少经过n条边时，则说明图中至少有n + 1个点，表示一定有点是重复使用

3、若dist[j] > dist[t] + w[i],则表示从t点走到j点能够让权值变少，因此进行对该点j进行更新，并且对应cnt[j] = cnt[t] + 1,往前走一步

注意：该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点


时间复杂度 一般：O(m)O(m) 最坏：O(nm)O(nm)
参考文献
Java 代码
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class Main {
    static int n;
    static int m;
    static int N = 2010;
    static int M = 10010;
    static int[] h = new int[N];
    static int[] e = new int[M];
    static int[] ne = new int[M];
    static int[] w = new int[M];
    static int idx = 0;
    static int[] dist = new int[N];//记录当前1到x的最短距离
    static int[] cnt = new int[N];//从1到点到x经过的边数 
    static boolean[] st = new boolean[N];

    public static void add(int a,int b,int c)
    {
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx ++;

    }
    public static boolean spfa()
    {
        Queue<Integer> queue = new LinkedList<Integer>();
        //将所有点进入队列
        for(int i = 1;i <= n;i++)
        {
            queue.add(i);
            st[i] = true;
        }
        while(!queue.isEmpty())
        {
            int t = queue.poll();
            st[t] = false;
            for(int i = h[t]; i != -1;i = ne[i])
            {
                int j = e[i];
                if(dist[j] > dist[t] + w[i])
                {
                    dist[j] = dist[t] + w[i];
                    cnt[j] = cnt[t] + 1; 

                    if(cnt[j] >= n) return true;
                    if(!st[j])
                    {
                        queue.add(j);
                        st[j] = true;
                    }


                }
            }
        }
        return false;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] str1 = reader.readLine().split(" ");
        n = Integer.parseInt(str1[0]);
        m = Integer.parseInt(str1[1]);
        Arrays.fill(h, -1);
        while(m -- > 0)
        {
            String[] str2 = reader.readLine().split(" ");
            int a = Integer.parseInt(str2[0]);
            int b = Integer.parseInt(str2[1]);
            int c = Integer.parseInt(str2[2]);
            add(a,b,c);
        }
        if(spfa()) System.out.println("Yes");
        else System.out.println("No");
    }

}

作者：小呆呆
链接：https://www.acwing.com/solution/content/6336/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 852. spfa判断负环    原题链接    简单
作者：    TaoZex ,  2019-08-05 12:31:07 ,  阅读 881

3


1
cnt数组表示到达当前这个点最短路的边数，如果cnt[x]>=n,说明至少经过了n条边，即n+1个点，由抽屉原理可知显然有两个点重复，即存在负环

#include<bits/stdc++.h>
using namespace std;

const int N=2010,M=10010;
int h[N],e[M],ne[M],w[M],idx;
bool st[N];
int d[N],cnt[N];  //cnt数组表示到达当前这个点最短路的边数
int n,m;

void add(int a,int b,int c){
    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

bool spfa(){
    memset(d,0,sizeof(d));    //本题可以不做初始化
    memset(cnt,0,sizeof(cnt));    
    memset(st,false,sizeof(st));

    queue<int> q;
    for(int i=1;i<=n;i++){     //判整个图的负环要将每个节点都加入
        st[i]=true;
        q.push(i);
    }

    while(!q.empty()){
        int t=q.front();
        q.pop();

        st[t]=false;
        for(int i=h[t];~i;i=ne[i]){
            int j=e[i];
            if(d[j]>d[t]+w[i]){
                d[j]=d[t]+w[i];
                cnt[j]=cnt[t]+1;

                if(cnt[j]>=n) return true;
                if(!st[j]){
                    st[j]=true;
                    q.push(j);
                }
            }
        }
    }

    return false;
}

int main(){
    cin>>n>>m;
    memset(h,-1,sizeof(h));
    while(m--){
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
    }

    if(spfa()) puts("Yes");
    else puts("No");
}

作者：TaoZex
链接：https://www.acwing.com/solution/content/3438/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 2010, M = 10010;

int n, m;
int h[N], w[M], e[M], ne[M], idx;
int dist[N], cnt[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool spfa()
{
    queue<int> q;

    for (int i = 1; i <= n; i ++ )
    {
        st[i] = true;
        q.push(i);
    }

    while (q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;

                if (cnt[j] >= n) return true;
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    if (spfa()) puts("Yes");
    else puts("No");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/48499/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 851. spfa求最短路    原题链接    简单
作者：    小呆呆 ,  2019-11-16 15:05:21 ,  阅读 1217

23


5
算法分析
1、什么是spfa算法？
SPFA 算法是 Bellman-Ford算法 的队列优化算法的别称，通常用于求含负权边的单源最短路径，以及判负权环。SPFA一般情况复杂度是O(m)O(m) 最坏情况下复杂度和朴素 Bellman-Ford 相同，为O(nm)O(nm)。

bellman-ford算法操作如下：
for n次
for 所有边 a,b,w (松弛操作)
dist[b] = min(dist[b],back[a] + w)

spfa算法对第二行中所有边进行松弛操作进行了优化，原因是在bellman—ford算法中，即使该点的最短距离尚未更新过，但还是需要用尚未更新过的值去更新其他点，由此可知，该操作是不必要的，我们只需要找到更新过的值去更新其他点即可。

2、spfa算法步骤
queue <– 1
while queue 不为空
 (1) t <– 队头
 queue.pop()
 (2)用 t 更新所有出边 t –> b，权值为w
 queue <– b (若该点被更新过，则拿该点更新其他点)

时间复杂度 一般：O(m)O(m) 最坏：O(nm)O(nm)
n为点数，m为边数

3、spfa也能解决权值为正的图的最短距离问题，且一般情况下比Dijkstra算法还好
Java 代码
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class Main {
    static int N = 100010;
    static int n;
    static int m;
    static int[] h = new int[N];
    static int[] e = new int[N];
    static int[] ne = new int[N];
    static int[] w = new int[N];
    static int idx = 0;
    static int[] dist = new int[N];
    static boolean[] st = new boolean[N]; //标记是否在队列中
    static int INF = 0x3f3f3f3f;
    public static void add(int a,int b,int c)
    {
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx ++;
    }
    public static int spfa()
    {
        Arrays.fill(dist, INF);
        Queue<Integer> queue = new LinkedList<Integer>();
        dist[1] = 0;
        queue.add(1);
        st[1] = true;//标记1号点在队列中
        while(!queue.isEmpty())
        {
            int t = queue.poll();
            st[t] = false;
            for(int i = h[t];i != -1;i = ne[i])
            {
                int j = e[i];//获取点编号
                //若该点被更新过，则加入队列中
                if(dist[j] > dist[t] + w[i])
                {
                    dist[j] = dist[t] + w[i];
                    //判断该点是否已经在队列中
                    if(!st[j])
                    {
                        queue.add(j);
                        st[j] = true;//标记已加入队列
                    }
                }

            }
        }
        return dist[n];
    }
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] str1 = reader.readLine().split(" ");
        n = Integer.parseInt(str1[0]);
        m = Integer.parseInt(str1[1]);
        Arrays.fill(h, -1);
        while(m -- > 0)
        {
            String[] str2 = reader.readLine().split(" ");
            int a = Integer.parseInt(str2[0]);
            int b = Integer.parseInt(str2[1]);
            int c = Integer.parseInt(str2[2]);
            add(a,b,c);
        }
        int t = spfa();
        if(t == 0x3f3f3f3f) System.out.println("impossible");
        else System.out.println(t);

    }


作者：小呆呆
链接：https://www.acwing.com/solution/content/6325/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010;

int n, m;
int h[N], w[N], e[N], ne[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    int t = spfa();

    if (t == 0x3f3f3f3f) puts("impossible");
    else printf("%d\n", t);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/48498/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 853. 有边数限制的最短路    原题链接    简单
作者：    小呆呆 ,  2019-11-16 14:35:56 ,  阅读 1384

32


7
算法分析
1、问题：为什么Dijkstra不能使用在含负权的图中？
分析：如图所示：
若通过Dijkstra算法可以求出从1号点到达4号点所需的步数为3(每次选择离源点最短距离的点更新其他点)
但实际上从1号点到达4号点所需步数为1 (1 –> 2 –> 3),因此不能使用Dijkstra解决含负权图的问题


2、什么是bellman - ford算法？
Bellman - ford算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在n-1次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。
(通俗的来讲就是：假设1号点到n号点是可达的，每一个点同时向指向的方向出发，更新相邻的点的最短距离，通过循环n-1次操作，若图中不存在负环，则1号点一定会到达n号点，若图中存在负环，则在n-1次松弛后一定还会更新)

3、bellman - ford算法的具体步骤
for n次
for 所有边 a,b,w (松弛操作)
dist[b] = min(dist[b],back[a] + w)

注意：back[]数组是上一次迭代后dist[]数组的备份，由于是每个点同时向外出发，因此需要对dist[]数组进行备份，若不进行备份会因此发生串联效应，影响到下一个点

4、在下面代码中，是否能到达n号点的判断中需要进行if(dist[n] > INF/2)判断，而并非是if(dist[n] == INF)判断，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，dist[n]大于某个与INF相同数量级的数即可
5、bellman - ford算法擅长解决有边数限制的最短路问题
时间复杂度 O(nm)O(nm)
其中n为点数，m为边数

Java 代码
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {

    static int N = 510;
    static int M = 100010;
    static int n;//总点数
    static int m;//总边数
    static int k;//最多经过k条边
    static int[] dist = new int[N];//从1到点到n号点的距离
    static Node[] list = new Node[M];//结构体
    static int INF = 0x3f3f3f3f;
    static int[] back = new int[N];//备份dist数组
    public static void bellman_ford()
    {
        Arrays.fill(dist, INF);

        dist[1] = 0;
        for(int i = 0;i < k;i++)
        {
            back = Arrays.copyOf(dist, n + 1);//由于是从1开始存到n
            for(int j = 0;j < m;j++)
            {
                Node node = list[j];
                int a = node.a;
                int b = node.b;
                int c = node.c;
                dist[b] = Math.min(dist[b], back[a] + c);
            }
        }
        if(dist[n] > INF/2) System.out.println("impossible");
        else System.out.println(dist[n]);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] str1 = reader.readLine().split(" ");
        n = Integer.parseInt(str1[0]);
        m = Integer.parseInt(str1[1]);
        k = Integer.parseInt(str1[2]);
        for(int i = 0;i < m;i++)
        {
            String[] str2 = reader.readLine().split(" ");
            int a = Integer.parseInt(str2[0]);
            int b = Integer.parseInt(str2[1]);
            int c = Integer.parseInt(str2[2]);
            list[i] = new Node(a,b,c);
        }
        bellman_ford();

    }

}
class Node
{
    int a, b, c;
    public Node(int a,int b,int c)
    {
        this.a = a;
        this.b = b;
        this.c = c;
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/6320/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, M = 10010;

struct Edge
{
    int a, b, c;
}edges[M];

int n, m, k;
int dist[N];
int last[N];

void bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);

    dist[1] = 0;
    for (int i = 0; i < k; i ++ )
    {
        memcpy(last, dist, sizeof dist);
        for (int j = 0; j < m; j ++ )
        {
            auto e = edges[j];
            dist[e.b] = min(dist[e.b], last[e.a] + e.c);
        }
    }
}

int main()
{
    scanf("%d%d%d", &n, &m, &k);

    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        edges[i] = {a, b, c};
    }

    bellman_ford();

    if (dist[n] > 0x3f3f3f3f / 2) puts("impossible");
    else printf("%d\n", dist[n]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/48523/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 850. 朴素Dijkstra与堆优化Dijkstra总结    原题链接    简单
作者：    optimjie ,  2019-11-25 16:21:20 ,  阅读 1132

12


7
朴素Dijkstra与堆优化Dijkstra总结，初学算法如有错误还望指正。
更好的阅读体验

Dijkstra
朴素版dijkstra适合稠密图
思路
集合S为已经确定最短路径的点集。
1. 初始化距离
一号结点的距离为零，其他结点的距离设为无穷大（看具体的题）。
2. 循环n次，每一次将集合S之外距离最短X的点加入到S中去（这里的距离最短指的是距离1号点最近。点X的路径一定最短，基于贪心，严格证明待看）。然后用点X更新X邻接点的距离。
时间复杂度分析
寻找路径最短的点：O(n^2)

加入集合S：O(n)

更新距离：O(m)

所以总的时间复杂度为O(n^2)

具体问题
稠密图用邻接矩阵存。

#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N = 510, M = 10010; // y总增大数据范围了吧M改到100010就能ac了

int g[N][N], dist[N];
bool visited[N];

int n, m;

int dijkstra()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    for(int i = 1; i <= n; i++)
    {
        int t = -1;
        for(int j = 1; j <= n; j++)
        {
            if(!visited[j] && (t == -1 || dist[j] < dist[t]))
                t = j;
        }
        visited[t] = true;
        for(int j = 1; j <= n; j++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
    if(dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(g, 0x3f, sizeof(g));
    while (m--)
    {
        int x, y, c;
        scanf("%d%d%d", &x, &y, &c);
        g[x][y] = min(g[x][y], c);
    }
    cout << dijkstra() << endl;
    return 0;
}
堆优化版dijkstra适合稀疏图
思路
堆优化版的dijkstra是对朴素版dijkstra进行了优化，在朴素版dijkstra中时间复杂度最高的寻找距离最短的点O(n^2)可以使用最小堆优化。
1. 一号点的距离初始化为零，其他点初始化成无穷大。
2. 将一号点放入堆中。
3. 不断循环，直到堆空。每一次循环中执行的操作为：
    弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。
    用该点更新临界点的距离，若更新成功就加入到堆中。
时间复杂度分析
寻找路径最短的点：O(n)

加入集合S：O(n)

更新距离：O(mlogn)

具体问题
#include<iostream>
#include<cstring>
#include<queue>

using namespace std;

typedef pair<int, int> PII;

const int N = 100010; // 把N改为150010就能ac

// 稀疏图用邻接表来存
int h[N], e[N], ne[N], idx;
int w[N]; // 用来存权重
int dist[N];
bool st[N]; // 如果为true说明这个点的最短路径已经确定

int n, m;

void add(int x, int y, int c)
{
    w[idx] = c; // 有重边也不要紧，假设1->2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中
    e[idx] = y; // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并
    ne[idx] = h[x]; // 标记st为true，所以下一次弹出3+x会continue不会向下执行。
    h[x] = idx++;
}

int dijkstra()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[0] = 1;
    priority_queue<PII, vector<PII>, greater<PII>> heap; // 定义一个小根堆
    // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时    
    // 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。
    heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序
    while(heap.size())
    {
        PII k = heap.top(); // 取不在集合S中距离最短的点
        heap.pop();
        int ver = k.second, distance = k.first;

        if(st[ver]) continue;
        st[ver] = true;

        for(int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。
            if(dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({ dist[j], j });
            }
        }
    }
    if(dist[n] == 0x3f3f3f3f) return -1;
    else return dist[n];
}

int main()
{
    memset(h, -1, sizeof(h));
    scanf("%d%d", &n, &m);

    while (m--)
    {
        int x, y, c;
        scanf("%d%d%d", &x, &y, &c);
        add(x, y, c);
    }

    cout << dijkstra() << endl;

    return 0;
}

作者：optimjie
链接：https://www.acwing.com/solution/content/6554/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

typedef pair<int, int> PII;

const int N = 1e6 + 10;

int n, m;
int h[N], w[N], e[N], ne[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[ver] + w[i])
            {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    cout << dijkstra() << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/48493/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 849. Dijkstra求最短路 I    原题链接    简单
作者：    Ni ,  2019-11-03 16:22:52 ,  阅读 2103

45


24
有之前宽搜和深搜的基础 再听了y总的课 就感觉思路特别清晰了

最近复习了下Dijkstra 发现之前的理解还是有些不太到位
所以更新了一下 希望能帮助一起学算法的小伙伴理清思路

Dijkstra 的整体思路比较清晰
即进行n（n为n的个数）次迭代去确定每个点到起点的最小值 最后输出的终点的即为我们要找的最短路的距离

所以按照这个思路除了存储图外我们还需要存储两个量

dist[n] //用于存储每个点到起点的最短距离
st[n]   //用于在更新最短距离时 判断当前的点的最短距离是否确定 是否需要更新

每次迭代的过程中我们都先找到当前未确定的最短距离的点中距离最短的点
（至于为什么是这样那么这就涉及到Dijkstra算法的具体数学证明了 有兴趣的同学可以百度一下）

int t=-1;       //将t设置为-1 因为Dijkstra算法适用于不存在负权边的图
for(int j=1;j<=n;j++)
{
    if(!st[j]&&(t==-1||dist[t]>dist[j])    //该步骤即寻找还未确定最短路的点中路径最短的点
        t=j;
}
通过上述操作当前我们的t代表就是剩余未确定最短路的点中 路径最短的点
而与此同时该点的最短路径也已经确定我们将该点标记

st[t]=true;

然后用这个去更新其余未确定点的最短距离

for(int j=1;j<=n;j++)
    dist[j]=min(dist[j],dist[t]+g[t][j]);
//这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离
//但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响
//当然你也可以在循环判断条件里加上if(!st[i])
//这里j从1开始只是为了代码的简洁

进行n次迭代后最后就可以确定每个点的最短距离
然后再根据题意输出相应的 要求的最短距离

以下为完整代码

#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N=510;

int g[N][N];    //为稠密阵所以用邻接矩阵存储
int dist[N];    //用于记录每一个点距离第一个点的距离
bool st[N];     //用于记录该点的最短距离是否已经确定

int n,m;

int Dijkstra()
{
    memset(dist, 0x3f,sizeof dist);     //初始化距离  0x3f代表无限大

    dist[1]=0;  //第一个点到自身的距离为0

    for(int i=0;i<n;i++)      //有n个点所以要进行n次 迭代
    {
        int t=-1;       //t存储当前访问的点

        for(int j=1;j<=n;j++)   //这里的j代表的是从1号点开始
            if(!st[j]&&(t==-1||dist[t]>dist[j]))     
                t=j;

        st[t]=true;   

        for(int j=1;j<=n;j++)           //依次更新每个点所到相邻的点路径值
            dist[j]=min(dist[j],dist[t]+g[t][j]);
    }

    if(dist[n]==0x3f3f3f3f) return -1;  //如果第n个点路径为无穷大即不存在最低路径
    return dist[n];
}
int main()
{
    cin>>n>>m;

    memset(g,0x3f,sizeof g);    //初始化图 因为是求最短路径
                                //所以每个点初始为无限大

    while(m--)
    {
        int x,y,z;
        cin>>x>>y>>z;
        g[x][y]=min(g[x][y],z);     //如果发生重边的情况则保留最短的一条边
    }

    cout<<Dijkstra()<<endl;
    return 0;
}

作者：Ni
链接：https://www.acwing.com/solution/content/5806/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510;

int n, m;
int g[N][N];
int dist[N];
bool st[N];

int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(g, 0x3f, sizeof g);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);

        g[a][b] = min(g[a][b], c);
    }

    printf("%d\n", dijkstra());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/48488/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 848. 有向图的拓扑序列    原题链接    简单
作者：    itdef ,  2019-08-27 14:48:43 ,  阅读 1480

7


题目描述
给定一个n个点m条边的有向图，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出-1。

若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。

输入格式
第一行包含两个整数n和m

接下来m行，每行包含两个整数x和y，表示点x和点y之间存在一条有向边(x, y)。

输出格式
共一行，如果存在拓扑序列，则输出拓扑序列。

否则输出-1。

数据范围
1≤n,m≤105

样例
输入样例：
3 3
1 2
2 3
1 3
输出样例：
1 2 3
算法1
拓扑排序流程为BFS 流程如下
1 首先找到第一个入度为0 的点 放入待处理队列，记录答案拓扑数组中 拓扑的必要条件
2 然后从该点连接的各个点 做以下操作：
2.1 删除该边后，查看从该点连接的的点的入度
2.2 如果入度为0 那么该点放入待处理队列，记录答案拓扑数组中， 再次进行BFS 直到待处理队列为空

C++ 代码

#include <iostream>

#include <iostream>
#include <vector>
#include <queue>


using namespace std;

int n, m;
vector<vector<int>> outvec(100010, vector<int>());      //入度记录
vector<int> invec(100010, 0);;    //出度记录

int main()
{
    cin >> n >> m;

    for (int i = 0; i < m; i++) {
        int start; int end;
        cin >> start >> end;
        invec[end]++;
        outvec[start].push_back(end);
    }
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        //找到第一个入度为0的点
        if (invec[i] == 0) {
            q.push(i);
        }
    }

    vector<int>  ret;
    while (!q.empty()) {
        int idx = q.front();
        q.pop();

        ret.push_back(idx);

        //抹掉这个点的所有出度边 与入度计数
        for (auto& e : outvec[idx]) {
            if (e != -1) {
                invec[e]--; //该点入度减1

                if (invec[e] == 0) {
                    q.push(e);
                }
                e = -1;  //抹掉该边
            }
        }
    }

    if(ret.size() == n)
        for (auto& e : ret) {
            cout << e << " ";
        }
    else
        cout << -1;



    return 0;
}

感谢评论区朋友指出 所有入度为0的点应该都放入队列

作者：itdef
链接：https://www.acwing.com/solution/content/4196/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], idx;
int d[N];
int q[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool topsort()
{
    int hh = 0, tt = -1;

    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    return tt == n - 1;
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);

        d[b] ++ ;
    }

    if (!topsort()) puts("-1");
    else
    {
        for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);
        puts("");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/47106/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 847. 图中点的层次 详细注释    原题链接    简单
作者：    松鼠爱葡萄 ,  2020-05-23 10:34:40 ,  阅读 245

7


3


#include <cstring>
#include <iostream>

using namespace std;

const int N=1e5+10;

int h[N], e[N], idx, ne[N];
int d[N]; //存储每个节点离起点的距离  d[1]=0
int n, m; //n个节点m条边
int q[N]; //存储层次遍历序列 0号节点是编号为1的节点

void add(int a, int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

int bfs()
{
    int hh=0,tt=0;

    q[0]=1; //0号节点是编号为1的节点

    memset(d,-1,sizeof d);

    d[1]=0; //存储每个节点离起点的距离

    //当我们的队列不为空时
    while(hh<=tt)
    {
        //取出队列头部节点
        int t=q[hh++];

        //遍历t节点的每一个邻边
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            //如果j没有被扩展过
            if(d[j]==-1)
            {
                d[j]=d[t]+1; //d[j]存储j节点离起点的距离，并标记为访问过
                q[++tt] = j; //把j结点 压入队列
            }
        }
    }

    return d[n];
}

int main()
{
    cin>>n>>m;
    memset(h,-1,sizeof h);
    for(int i=0;i<m;i++)
    {
        int a,b;
        cin>>a>>b;
        add(a,b);
    }

    cout<<bfs()<<endl;
}

作者：松鼠爱葡萄
链接：https://www.acwing.com/solution/content/13514/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], idx;
int d[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int bfs()
{
    memset(d, -1, sizeof d);

    queue<int> q;
    d[1] = 0;
    q.push(1);

    while (q.size())
    {
        int t = q.front();
        q.pop();

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (d[j] == -1)
            {
                d[j] = d[t] + 1;
                q.push(j);
            }
        }
    }

    return d[n];
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }

    cout << bfs() << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/47104/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 846. 树的重心    原题链接    简单
作者：    Ni ,  2019-11-01 20:11:17 ,  阅读 1660

18


1
树的重心
感觉这题把之前基础课学的很多知识都用起来了

C++ 代码
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N=1e5+10;

//用链表结构存储每个点的边

int h[N];   //h[]用于存储每个点的头节点
int e[2*N];   //用于存储元素    因为是无向图 所以是双向边 应该乘2
int ne[2*N];    //存储链表的next值
int idx=0;
int n;
int ans=N;  //记录重心子树的最小值

bool st[N];  //记录该点是否已经查找过

void add(int a,int b)       //将b插入a中 a作为根 所以处在链表的最后
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
int dfs(int u)       //dfs过程寻找根的连通的点
{
    int size=0;    //存放连通块中点的个数的最大值

   st[u]=true;  //  该点已经走过

   int sum=0;       //sum用于记录根子树的个数

   for(int i=h[u];i!=-1;i=ne[i])
   {
       int j=e[i];
       if(!st[j])
       { 
            int s=dfs(j);
            size=max(size,s);
            sum+=s;
       }
   }
   size=max(size,n-sum-1);  //通过画图可得n-m 即总的节点-根的子树 即为剩余的连通节点值
                            //而size为当前为根的子树的个数 通过比较确认连通块中点的最大数
    ans=min(ans,size); 
   return sum+1;        //return sum+1 是因为sum初始化为0 而当前这个点即根也算是该连通块内的一点

}

int main()
{   
    memset(h,-1,sizeof h);  //初始化h[]表 -1表示空

    scanf("%d",&n);



    for(int i=0;i<n-1;i++)  //注意这里应该n-1，
    {               //有些奇怪但是 仔细想想就明白 n是表示点的个数 而每行是输入两个点之间的边所以只需输入n-1行即可
        int a,b;
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);
    }
    dfs(1);


    cout<<ans<<endl;


    return 0;
}

作者：Ni
链接：https://www.acwing.com/solution/content/5773/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = N * 2;

int n;
int h[N], e[M], ne[M], idx;
int ans = N;
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int dfs(int u)
{
    st[u] = true;

    int size = 0, sum = 0;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (st[j]) continue;

        int s = dfs(j);
        size = max(size, s);
        sum += s;
    }

    size = max(size, n - sum - 1);
    ans = min(ans, size);

    return sum + 1;
}

int main()
{
    scanf("%d", &n);

    memset(h, -1, sizeof h);

    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }

    dfs(1);

    printf("%d\n", ans);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/47105/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 845. 八数码【BFS/康托展开】    原题链接    困难
作者：    滑稽_ωﾉ ,  2019-06-16 23:26:10 ,  阅读 1984

25


10
题目描述
在一个3×3的网格中，1~8这8个数字和一个“X”恰好不重不漏地分布在这3×3的网格中。

例如：

1 2 3
X 4 6
7 5 8
在游戏过程中，可以把“X”与其上、下、左、右四个方向之一的数字交换（如果存在）。

我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：

1 2 3
4 5 6
7 8 X
例如，示例中图形就可以通过让“X”先后与右、下、右三个方向的数字交换成功得到正确排列。

交换过程如下：

1 2 3      1 2 3      1 2 3      1 2 3
X 4 6  ->  4 X 6  ->  4 5 6  ->  4 5 6
7 5 8      7 5 8      7 X 8      7 8 X
现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。

输入样例：
2  3  4  1  5  x  7  6  8 
输出样例：
19
分析
本题求最少步数，所以应当用bfs来做

首先定义一个能表示矩阵状态的结构体，每次把由当前状态更新的合法的新状态压入队列

如果状态为目标状态，那么返回步数，如果更新不到目标状态，返回-1

我们可以想到，这个3*3的矩阵可以表示为一个长度为9的字符串

但是我们知道，bfs需要把遍历过的状态标记，以防止死循环

那么，如何开辟一个数组
使得这个数组中的元素，能够和矩阵的所有状态（长度为9的字符串的全排列）一一对应
这才是难点
全排列哈希
我们熟知的数一般都是常进制数，所谓常进制数就是该数的每一位都是常数进制的

kk进制数上的每一位都逢kk进一，第ii位的位权是kiki
这里要介绍一种变进制数，用来表示字符串的排列状态

这种数的第ii位逢ii进一，第ii位的位权是i!i!
用d[i]d[i]来表示一个变进制数第ii位上的数字

一个nn位变进制数的值就为∑n−1i=0∑i=0n−1 d[i]×i!d[i]×i!
这是一个最大的9位变进制数

876543210
它对应的十进制数为

8 × 8! + 7 × 7! + 6 × 6! + …… + 1 × 1! + 0 × 0! = 9! - 1 = 362879
我们可以找到一个9位变进制数，与一个9位无重复串的某种排列一一对应

用d[i]d[i]表示字符串中的第ii位与其前面的字符组成的逆序对个数

字符串的一种排列对应的变进制数的值为∑n−1i=0∑i=0n−1 d[i]×i!d[i]×i!
这是字符串123x46758的与d[i]d[i]的对应关系

  i     0 1 2 3 4 5 6 7 8
s[i]    1 2 3 x 4 6 7 5 8
d[i]    0 0 0 0 1 1 1 3 1
它对应的变进制数的值为

1 × 4! + 1 × 5! + 1 × 6! + 3 × 7! + 1 × 8! = 56304
因此可以用以下函数求字符串的一种排列对应的哈希值

int permutation_hash(char s[], int n)       //求长度为n的字符串某种排列的哈希值
{
    int ans = 0;
    for(int i = 0; i < n; i ++)
    {
        int d = 0;
        for(int j = 0; j < i; j ++)
            if(s[j] > s[i])  d ++;          //求s[i]与其前面的字符组成的逆序对个数
        ans += d * fact[i];
    }
    return ans;
}
n不能太大，通常不超过12，否则会溢出
时间复杂度为O(n²)
全排列哈希 + BFS
C++ 代码
#include<cstring>
#include<iostream>
#include<queue>
using namespace std;

int fact[9];
bool vis[362880];

int permutation_hash(char s[])          //求长度为9的字符串某种排列的哈希值
{
    int ans = 0;
    for(int i = 0; i < 9; i ++)
    {
        int d = 0;
        for(int j = 0; j < i; j ++)
            if(s[j] > s[i])  d ++;      //求s[i]与其前面的字符组成的逆序对个数
        ans += d * fact[i];
    }
    return ans;
}

typedef struct{
    char s[10];
    int step;
    int k;          //'x'在第k位
}Point;

int dx[4] = {-1, 0, 1, 0};
int dy[4] = { 0,-1, 0, 1};
int bfs(Point p)
{
    vis[permutation_hash(p.s)] = true;
    queue<Point> q;
    q.push(p);
    while(!q.empty())
    {
        p = q.front();
        q.pop();
        /*
        printf("%d ",p.step);       //print调试法
        puts(p.s);
        */
        if(!strcmp(p.s , "12345678x"))  return p.step;

        int x = p.k / 3;      //'x'的行数
        int y = p.k % 3;      //'x'的列数
        Point next;
        next.step = p.step + 1;
        for(int i = 0; i < 4; i ++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if(nx >= 0 && nx <= 2 && ny >= 0 && ny <= 2)
            {
                next.k = nx * 3 + ny;           //求出'x'在字符串中的的新位置

                strcpy(next.s, p.s);
                next.s[9] = 0;
                next.s[p.k] = p.s[next.k];      //先用即将和'x'交换的字符覆盖'x'之前的位置
                next.s[next.k] = 'x';           //再给'x'的新位置赋值'x'

                int hash = permutation_hash(next.s);
                if(!vis[hash])
                {
                    vis[hash] = true;
                    q.push(next);
                }
            }
        }
    }
    return -1;
}

int main()
{
    fact[0] = 1;
    for(int i = 1; i < 9; i ++)  fact[i] = fact[i - 1] * i;    //预处理fact[i] = i!

    char c[2],str[10];
    Point start;
    for(int i = 0; i < 9; i ++)
    {
        scanf("%s",&c);
        if(c[0] == 'x')  start.k = i;
        start.s[i] = c[0];
    }
    start.s[9] = 0;
    start.step = 0;
    printf("%d",bfs(start));
    return 0;
}

作者：滑稽_ωﾉ
链接：https://www.acwing.com/solution/content/2481/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <queue>

using namespace std;

int bfs(string state)
{
    queue<string> q;
    unordered_map<string, int> d;

    q.push(state);
    d[state] = 0;

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    string end = "12345678x";
    while (q.size())
    {
        auto t = q.front();
        q.pop();

        if (t == end) return d[t];

        int distance = d[t];
        int k = t.find('x');
        int x = k / 3, y = k % 3;
        for (int i = 0; i < 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < 3 && b >= 0 && b < 3)
            {
                swap(t[a * 3 + b], t[k]);
                if (!d.count(t))
                {
                    d[t] = distance + 1;
                    q.push(t);
                }
                swap(t[a * 3 + b], t[k]);
            }
        }
    }

    return -1;
}

int main()
{
    char s[2];

    string state;
    for (int i = 0; i < 9; i ++ )
    {
        cin >> s;
        state += *s;
    }

    cout << bfs(state) << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/48146/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 844. 走迷宫    原题链接    简单
作者：    Wilson79 ,  2019-07-14 12:48:16 ,  阅读 2281

11


2
问题1：走迷宫——边的权值相同
给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。

最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。

数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。

输入格式

第一行包含两个整数n和m。

接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。

输出格式

输出一个整数，表示从左上角移动至右下角的最少移动次数。

数据范围

1≤n,m≤100

样例
输入样例：
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
输出样例：
8
算法
(BFS)
C++ 代码
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> PII;

const int N = 1e2 + 7;
int g[N][N], d[N][N];
int n, m;


int bfs() {
    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
    queue <PII> q;

    for (auto &v : d) 
        for (auto &x : v) {
            x = - 1;
        }

    d[0][0] = 0;
    q.push({0, 0});

    while (!q.empty()) {
        auto t = q.front();
        q.pop();

        for (int i = 0; i < 4; i++) {
            int x = t.first + dx[i], y = t.second + dy[i];

            if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1) {
                d[x][y] = d[t.first][t.second]  + 1;
                q.push({x, y});
            }
        }

    }


        return d[n - 1][m - 1];
}


int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> g[i][j];
        }
    }

    cout << bfs() << endl;

    return 0;
}
问题2:走迷宫升级版——边的权值不同
单点时限: 2.0 sec
内存限制: 256 MB
一天，sunny 不小心进入了一个迷宫，不仅很难寻找出路，而且有的地方还有怪物，但是 sunny 有足够的能力杀死怪物，但是需要一定的时间，但是 sunny 想早一点走出迷宫，所以请你帮助他计算出最少的时间走出迷宫，输出这个最少时间。

我们规定每走一格需要时间单位 1, 杀死怪物也需要时间 1, 如果不能走到出口，则输出 impossible. 每次走只能是上下左右 4 个方向。

输入格式
每次首先 2 个数 n,m (0<n,m≤200)，代表迷宫的高和宽，然后 n 行，每行 m 个字符。

S 代码你现在所在的位置。
T 代表迷宫的出口。
# 代表墙，你是不能走的。
X 代表怪物。
. 代表路，可以走。
处理到文件结束。

输出格式
输出最少的时间走出迷宫。不能走出输出 impossible。

样例
输入样例：
4 4
S.X.
#..#
..#.
X..T
4 4
S.X.
#..#
..#.
X.#T
输出样例：
6
impossible
算法
(BFS + 优先队列)
题意：走迷宫，求最短路径，上下左右走一格花费1，走到有怪的格子花费2.

思路：将每一点的坐标和由起点到该点的距离存入结构体.
由起点开始，将该点存入优先队列，以到起点的距离dis为优先级，每次取出dis最小的，向外扩散。
相当于第一轮得出所有到起点距离为1的点，第二轮得出所有到起点距离为2的点。
注意：对普通的最短路问题，由于每个各自的花费相同，因此每次存入的点优先级都相同.
故不需要使用优先队列，但本题存在有无怪物的区别，每次存入的格子的优先级可能不同，故使用优先队列。

C++ 代码

#include<stdio.h>
#include<queue>
#include<iostream>
using namespace std;
char maze[201][201];
int sx, sy, tx, ty;
//左右上下4个方向
int dx[4] = { 1,0,-1,0 };
int dy[4] = { 0,1,0,-1 };
int m, n;

struct node {
    int x,  y, dis;
};

bool operator < (const node & a, const node & b) {
    return a.dis > b.dis;
}

void bfs() {
    priority_queue<node> que;
    node st { sx,sy,0 };
    maze[sx][sy] = '#';
    que.push(st);

    while (!que.empty()) {
        node p = que.top();
        que.pop();
        //若已找到，则退出
        if (p.x == tx && p.y == ty) {
            cout << p.dis << endl;
            return;
        }
        for (int i = 0; i < 4; ++i) {
            int nx = p.x + dx[i];
            int ny = p.y + dy[i];
            node np{ nx,ny, 0};

            if (nx >= 0 && nx < n&&ny >= 0 && ny < m&&maze[nx][ny] != '#') {
                if (maze[nx][ny] == 'X')
                    np.dis = p.dis + 2;
                else
                    np.dis = p.dis + 1;
                maze[np.x][np.y] = '#';
                que.push(np);

            }
        }
    }
    printf("impossible\n");
}
int main() {
    while (cin>>n>>m) {
        for (int i = 0; i < n; i++)
            scanf("%s", maze[i]);
        for(int i=0; i<n; i++)
            for (int j = 0; j < m; j++) {
                if (maze[i][j] == 'S')
                    sx = i, sy = j;
                else if (maze[i][j] == 'T')
                    tx = i, ty = j;
            }
        bfs();
    }
    return 0;
}

作者：Wilson79
链接：https://www.acwing.com/solution/content/2078/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

typedef pair<int, int> PII;

const int N = 110;

int n, m;
int g[N][N], d[N][N];

int bfs()
{
    queue<PII> q;

    memset(d, -1, sizeof d);
    d[0][0] = 0;
    q.push({0, 0});

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        for (int i = 0; i < 4; i ++ )
        {
            int x = t.first + dx[i], y = t.second + dy[i];

            if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1)
            {
                d[x][y] = d[t.first][t.second] + 1;
                q.push({x, y});
            }
        }
    }

    return d[n - 1][m - 1];
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            cin >> g[i][j];

    cout << bfs() << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/47098/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 843. n-皇后问题（按行枚举或按每个元素枚举）    原题链接    中等
作者：    Wilson79 ,  2019-07-14 12:57:44 ,  阅读 2040

22


5
题目描述
n-皇后问题是指将 n 个皇后放在 n∗n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

现在给定整数n，请你输出所有的满足条件的棋子摆法。

输入格式

共一行，包含整数n。

输出格式

每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。

其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。

每个方案输出完成后，输出一个空行。

数据范围

1≤n≤9

样例
输入样例：
4
输出样例：
.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
算法1
(按行枚举) O(n!)O(n!)
解释说明

对角线 dg[u+i]dg[u+i]，反对角线udg[n−u+i]udg[n−u+i]中的下标 u+iu+i和 n−u+in−u+i 表示的是截距

下面的(x,y)(x,y)相当于(u,i)(u,i)
（1）反对角线 y=x+by=x+b, 截距 b=y−xb=y−x，因为我们要把 bb 当做数组下标，所以 bb 不能是负的，所以我们 +n+n，保证是结果是正的
（2）而对角线 y=−x+by=−x+b, 截距是 b=y+xb=y+x，这里截距一定是正的，所以不需要加偏移量

核心目的：找一些合法的下标来表示dgdg或udgudg是否被标记过，所以如果你愿意，你取 udg[n+n−u+i]udg[n+n−u+i] 也可以，只要所有(u,i)(u,i)对可以映射过去就行

C++ 代码
#include <iostream>
using namespace std;
const int N = 20;

// bool数组用来判断搜索的下一个位置是否可行
// col列，dg对角线，udg反对角线
// g[N][N]用来存路径

int n;
char g[N][N];
bool col[N], dg[N], udg[N];

void dfs(int u)
{
    // u == n 表示已经搜了n行，故输出这条路径
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) puts(g[i]);   // 等价于cout << g[i] << endl;
        puts("");  // 换行
        return;
    }

    //对n个位置按行搜索
    for (int i = 0; i < n; i ++ )
        // 剪枝(对于不满足要求的点，不再继续往下搜索)              udg[n - u + i]，+n是为了保证大于0
        if (!col[i] && !dg[u + i] && !udg[n - u + i])
        {
            g[u][i] = 'Q';
            col[i] = dg[u + i] = udg[n - u + i] = true;
            dfs(u + 1);
            // 恢复现场 这步很关键
            col[i] = dg[u + i] = udg[n - u + i] = false;
            g[u][i] = '.';

        }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';

    dfs(0);

    return 0;
}   
算法2
(按每个元素枚举) O(2的n2次)O(2的n2次)
时间复杂度分析：每个位置都有两种情况，总共有n^2个位置

C++ 代码
// 不同搜索顺序 时间复杂度不同  所以搜索顺序很重要！
#include <iostream>
using namespace std;
const int N = 20;

// 因为是一个个搜索，所以加了row
int n;
char g[N][N];
bool row[N], col[N], dg[N], udg[N];

// s表示已经放上去的皇后个数
void dfs(int x, int y, int s)
{
    // 处理超出边界的情况
    if (y == n) y = 0, x ++ ;

    // 说明已经放好了n个皇后，表示枚举完 n^2 个了
    if (x == n)
    {
        if (s == n)
        {
            for (int i = 0; i < n; i ++ ) puts(g[i]);
            puts("");
        }
        return;
    }

    // 不放皇后  就往下搜下一个位置
    dfs(x, y + 1, s);

    // 放皇后
    if (!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n])
    {
        g[x][y] = 'Q';
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        dfs(x, y + 1, s + 1);
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
        g[x][y] = '.';
    }
}


int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';

    dfs(0, 0, 0);

    return 0;
}

作者：Wilson79
链接：https://www.acwing.com/solution/content/2820/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
22


2
第一种搜索顺序
#include <iostream>

using namespace std;

const int N = 10;

int n;
bool row[N], col[N], dg[N * 2], udg[N * 2];
char g[N][N];

void dfs(int x, int y, int s)
{
    if (s > n) return;
    if (y == n) y = 0, x ++ ;

    if (x == n)
    {
        if (s == n)
        {
            for (int i = 0; i < n; i ++ ) puts(g[i]);
            puts("");
        }
        return;
    }

    g[x][y] = '.';
    dfs(x, y + 1, s);

    if (!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n])
    {
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        g[x][y] = 'Q';
        dfs(x, y + 1, s + 1);
        g[x][y] = '.';
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
    }
}

int main()
{
    cin >> n;

    dfs(0, 0, 0);

    return 0;
}
第二种搜索顺序
#include <iostream>

using namespace std;

const int N = 20;

int n;
char g[N][N];
bool col[N], dg[N], udg[N];

void dfs(int u)
{
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) puts(g[i]);
        puts("");
        return;
    }

    for (int i = 0; i < n; i ++ )
        if (!col[i] && !dg[u + i] && !udg[n - u + i])
        {
            g[u][i] = 'Q';
            col[i] = dg[u + i] = udg[n - u + i] = true;
            dfs(u + 1);
            col[i] = dg[u + i] = udg[n - u + i] = false;
            g[u][i] = '.';
        }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';

    dfs(0);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/47097/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。




AcWing 842. 排列数字    原题链接    简单
作者：    goontry ,  2019-06-11 00:38:41 ,  阅读 1724

9


4
自问自答
通过以下问题，加深对dfs的理解。

自问
dfs进行递归，表示的意义？
如何加深对dfs的理解（求法）？
为何回溯时，进行现场的恢复？
自答
此题中dfs表示的含义是：求出从第u行到最后一行的所有path。
dfs的求法：根据通项公式的含义，假设已知第u+1行到最后一行的所有path，综合1和2得出：path[u] 与 path[u+1] 合并后，即为dfs的解。
回溯的特征是：递归的最外层是一个循环。因为一次dfs得到的是所有的path。每一次都是从当前现场中去取得剩下未访问的元素。（这一块自己画个图就很容易理解）。
反证：如果不进行现场的恢复，则在第一次完成深搜后，所有元素都已经被访问过了。这样在回溯到上一层时，上层的现场中的状态都被下层更改了，数据就会乱套。
#include <iostream>
using namespace std;
const int N = 10;

int path[N];
bool st[N];
int n;

// 计算u->n的所经过的路径path
void dfs(int u) 
{
    // 边界条件
    if (u == n) 
    {
        for (int i = 0; i < n; i++) printf("%d ", path[i]);
        puts("");
        return;
    }
    else 
    {
        for (int i = 1; i <= n; i++) 
        {
            if (!st[i]) 
            {
                path[u] = i;
                st[i] = true;
                dfs(u+1); // 回溯之后，为何要恢复现场？
                path[u] = 0;
                st[i] = false;
            }
        }
    }
}

int main()
{
    scanf("%d", &n);
    dfs(0);
    return 0;
}

作者：goontry
链接：https://www.acwing.com/solution/content/2440/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>

using namespace std;

const int N = 10;

int n;
int path[N];

void dfs(int u, int state)
{
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) printf("%d ", path[i]);
        puts("");

        return;
    }

    for (int i = 0; i < n; i ++ )
        if (!(state >> i & 1))
        {
            path[u] = i + 1;
            dfs(u + 1, state + (1 << i));
        }
}

int main()
{
    scanf("%d", &n);

    dfs(0, 0);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/47087/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 841. 字符串哈希    原题链接    简单
作者：    Ni ,  2019-10-25 10:46:54 ,  阅读 1380

10


3
字符哈希串的意思 其实就是将字符串的前缀转换为数来存值
由于每位的权值是不一样的 所以每个前缀值都对应着唯一的一种字符串
所以相减后的值也应该是唯一的 从而利用相减后的值可以判断字符串的区间段是否相等
当然具体还有很多细节需要注意
请看以下代码

C++ 代码
#include<iostream>
using namespace std;

typedef unsigned long long ULL;     //由于前缀值的值会很大 所以应该将数组中的数据定义为ULL型

const int N=1e5+10;
const int  P=131;       //P为权重
                        //131为经验值 即P=131或13331时 哈希冲突的可能性最小

int n,m;

char str[N];
ULL h[N];              //h[]存放字符串的前缀值
ULL p[N];             //p[]存放各个位数的相应权值

ULL get(int l,int r)
{
    return h[r]-h[l-1]*p[r-l+1];        //这步其实是将h[l-1]左移
}                                       //其目的事实上是为了将h[l-1]的高位与h[r]相对齐从而才可以未完成计算
int main()
{
    scanf("%d%d%s",&n,&m,str+1);

    p[0]=1;                         //注意这步千万不要忘了 最开始的权值必须赋值为1 否则接下来就会出错
    for(int i=1;i<=n;i++)
    {
        p[i]=p[i-1]*P;              //计算每个位上的相应权值
        h[i]=h[i-1]*P+str[i];       //计算字符串前缀值
                                    //最新加入的数的权值为p的0次 所以直接加上str[i]即可
    }
    while(m--)
    {
        int l1,r1,l2,r2;
        scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
        if(get(l1,r1)==get(l2,r2)) puts("Yes");
        else puts("No");
    }

    return 0;
}

作者：Ni
链接：https://www.acwing.com/solution/content/5553/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

typedef unsigned long long ULL;

const int N = 100010, P = 131;

int n, m;
char str[N];
ULL h[N], p[N];

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf("%d%d", &n, &m);
    scanf("%s", str + 1);

    p[0] = 1;
    for (int i = 1; i <= n; i ++ )
    {
        h[i] = h[i - 1] * P + str[i];
        p[i] = p[i - 1] * P;
    }

    while (m -- )
    {
        int l1, r1, l2, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2);

        if (get(l1, r1) == get(l2, r2)) puts("Yes");
        else puts("No");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/45313/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
