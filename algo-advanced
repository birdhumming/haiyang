〔manim | 算法 | 数据结构〕 完全理解并深入应用树状数组 | 支持多种动态维护区间操作

https://www.bilibili.com/video/BV1pE41197Qj

https://github.com/Tony031218

鹤翔万里
Tony031218

https://tony031218.github.io/


AcWing 90. 64位整数乘法    原题链接    简单

题目描述
求 a 乘 b 对 p 取模的值。
数据范围
1≤a,b,p≤10^18

样例
输入样例：
3
4
5
输出样例：
2
算法1
(二进制思想) O(logn)O(logn)
如果直接计算a乘b这会超过 long long 的最大范围，所以采用类似于快速幂的思想
把 b写成二进制形式，然后如果某位上为1就加上它a*（2^n）次方（n与这位的位置有关）
并且每次计算后取模就可以了

例：计算 3*7

7的二进制 111
3*(2^0)=3
3*(2^1)=6
3*(2^2)=12

观察可发现每次的可由前一次*2推出(记得取模)

时间复杂度分析：logn

C++ 代码
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
int main()
{
    ll a,b,p,res;
    cin>>a>>b>>p;
    res=0;
    while(b)
    {
        if(b&1)
            res=(res+a)%p;
        b>>=1;
        a=2*a%p;
    }
    cout<<res<<endl;
    return 0;
}

作者：洛希krist
链接：https://www.acwing.com/solution/content/844/
 

#include <cstdio>

typedef long long LL;

LL qadd(LL a, LL b, LL p)
{
    LL res = 0;
    while (b)
    {
        if (b & 1) res = (res + a) % p;
        a = (a + a) % p;
        b >>= 1;
    }
    return res;
}

int main()
{
    LL a, b, p;
    scanf("%lld%lld%lld", &a, &b, &p);
    printf("%lld\n", qadd(a, b, p));

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/200703/
来源：AcWing


AcWing 95. 费解的开关    原题链接    中等
作者：    Vizdl ,  2019-01-16 23:12:22 ,  阅读 1768

3


1
题目描述
如题:发现书上有更好的题解,思路还是太复杂了,但是写都写了就留在这吧= = 有兴趣的话可以看看。

样例
这个样例对应的输出是2



1
11101
11101
11110
11111
11111
这个样例对应的输出是2
算法1
(经过一些优化的dfs,结果超时)
一开始的思路是,既然这个是5X5,那么我应该可以直接dfs吧（？？？没看清题目的我）
但我还是做了一些减少计算量的操作（几乎没起到什么作用）
在我的仔细分析之下,我发现:
/*
* 每次只需要改变0或者身边(上下左右)有0的1
* 因为如若附近都没有0,那么只能让这次修改的
* 浪费一次修补回来的机会。
* 所以在这里我只改上下左右或中间有0的节点…
/
于是我就着这个思路写了一个巨长又臭的代码,不想看的直接跳过吧。。。

public class acwing95 {
    /**
     * 每次只需要改变0或者身边(上下左右)有0的1
     * 因为如若附近都没有0,那么只能让这次修改的
     * 浪费一次修补回来的机会。
     * 所以在这里我只改上下左右或中间有0的节点...
     */
    static int[][] matrix;
    static boolean[][] has;
    public static void main (String[] args){
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        scanner.nextLine();
        matrix = new int[5][5];
        for (int i = 0; i < m; i++) {
            has = new boolean[5][5];
            for (int j = 0; j < 5; j++) {
                char[] ch = scanner.nextLine().toCharArray();
                for (int k = 0; k < 5; k++) {
                    matrix[j][k] = ch[k] - '0';
                }
            }
            if (scanner.hasNextLine()) {
                scanner.nextLine();
            }
            int res = dfs (1);
            System.out.println(res);
        }
    }

    public static int dfs (int times) {
        if (isRight()) {
            return times - 1;
        }
        if (times == 7) {
            return -1;
        }
        int res = -1;
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 5; j++) {
                if (isValid(i, j)) {
                    change(i, j);
                    has[i][j] = true;
                    int r = dfs (times + 1);
                    change(i, j);
                    has[i][j] = false;
                    if (r != -1 && (res == -1 || res > r)) {
                        res = r;
                    }
                }
            }
        }
        return res;
    }
    //判断目前矩阵是否全为1
    public static boolean isRight () {
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 5; j++) {
                if (matrix[i][j] != 1) {
                    return false;
                }
            }
        }return true;
    }
    //判断当前输入的坐标是不是有效坐标（这个操作好像并没有减低我的计算量,可能因为矩阵太小了。。。）
    public static boolean isValid (int i, int j) {
        return !has[i][j] && (matrix[i][j] == 0 || (i + 1 < 5 && matrix[i + 1][j] == 0) || (j + 1 < 5 && matrix[i][j + 1] == 0)
                || (i > 0 && matrix[i - 1][j] == 0) || (j > 0 && matrix[i][j - 1] == 0));
    }
    //输入一个坐标,将它和它上下左右改变一下位置
    public static void change (int i, int j) {
        matrix[i][j] = matrix[i][j] != 0 ? 0 : 1;
        if (i > 0) {
            matrix[i - 1][j] = matrix[i - 1][j] != 0 ? 0 : 1;
        }
        if (j > 0) {
            matrix[i][j - 1] = matrix[i][j - 1] != 0 ? 0 : 1;
        }
        if (i + 1 < 5) {
            matrix[i + 1][j] = matrix[i + 1][j] != 0 ? 0 : 1;
        }
        if (j + 1 < 5) {
            matrix[i][j + 1] = matrix[i][j + 1] != 0 ? 0 : 1;
        }return;
    }
}
算法2
(这次是AC的算法了:广度优先搜索+状态压缩+dp) O(1)O(1) : 25^6 hhh
吸取了上一次的教训,我首先想到的是,我一定要用dp来写这道题目,
因为只要我用了dp,那么无论输入的n为多少,我都不用管因为我能直
接找到当前的状态直接得出结果！
这里用二进制数表示矩阵的状态(如若对这个不是很理解可以先看看哔哩哔哩y神昨晚录播的第三道题),
恰好这个矩阵只有25个节点且每个节点
只有0或1两种状态。
这时候我想到了我写过的另一道题目,这道题也是这种类型的(一个拼图游戏的问题)。。。
这种类型的题目可以利用广度优先搜索,从成功的状态,来逆推所有能成功到达的状态
恰巧这个只能推六次,所以我就弄了个界定层次的一个end（整型）,来判断当前处于第几层
因为广度优先搜索具有寻找最短路径的那个特点,在这里正好用得上。也就是说,这个节点只要载入
就一定会是最小的次数。
到这里就基本上没什么问题了,我就直接贴代码了。代码上会对函数功能进行注解
时间复杂度分析：25^6

Java 代码
import java.util.*;

/**
 * acwing 95 费解的开关
 * 2019年1月15日21:20:17
 * @author HP
 *
 */

public class Main {
    /**
     * 首先可以明确的是,一个状态如若最少点击三个不同的点能全部为1
     * 那么,与点击这三个点的顺序是无关的。
     * 这里采用状态压缩,将矩阵用一个整型表示。
     * 然后利用广度优先搜索,全是1的状态下往回点
     * dp内元素先默认为-1,然后如若在六次之内能到达
     * 的元素都会进入队列中,并且赋都会最小次数的值（bfs找单源最短路径也是利用了这个性质）
     * 如若dp数组中已经有所有结果了,那么之后的无论是多少组数据都可以直接通过了。
     */
    static int[] dp;
    static int n = 1 << 25;
    static boolean[] has;
    public static void main (String[] args){
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        scanner.nextLine();
        dp = new int[n];
        has = new boolean[n];
        Arrays.fill(dp, -1);
        dp[n - 1] = 0;
        has[n - 1] = true;
        LinkedList<Integer> queue = new LinkedList<Integer>();
        queue.add(n - 1);
        int times = 0;
        int end = n - 1;
        while (!queue.isEmpty() && times < 7) {
            int val = queue.poll();
            dp[val] = times;
            for (int i = 0; i < 5; i++) {
                for (int j = 0; j < 5; j++) {
                    int num = change(val, i, j);
                    if (!has[num]) {
                        queue.add(num);
                        has[num] = true;
                    }
                }
            }
            if (end == val) {
                times++;
                end = queue.getLast();
            }
        }
        for (int i = 0; i < m; i++) {
            int matrix = 0;
            for (int j = 0; j < 5; j++) {
                char[] ch = scanner.nextLine().toCharArray();
                for (int k = 0; k < 5; k++) {
                    matrix += ((ch[k] - '0') << (j * 5 + k));
                }
            }
            if (scanner.hasNextLine()) {
                scanner.nextLine();
            }
            System.out.println(dp[matrix]);
        }
    }

    /**
     * 给出一个代表5X5矩阵的数
     * 按照费解的开关定义的那样
     * 去操作后会生成另一个代表
     * 5X5矩阵的数,并返回。
     * @param val
     * @param i
     * @param j
     * @return
     */
    public static int change (int val, int i, int j) {
        //(val >> i * 5 + j) & 1 : 代表的是当前的i,j坐标对应位置的位
        //如若这个位置是1,则减去1为0,如若这个位置是0,则减去-1为1;
        val -= (1 & (val >> i * 5 + j)) != 0 ? 1 << i * 5 + j : -(1 << i * 5 + j);
        if (i > 0) {
            val -= (1 & (val >> (i - 1) * 5 + j)) != 0 ? 1 << (i - 1) * 5 + j : -(1 << (i - 1) * 5 + j);
        }
        if (j > 0) {
            val -= (1 & (val >> i * 5 + j - 1)) != 0 ? 1 << i * 5 + j - 1 : -(1 << i * 5 + j - 1);
        }
        if (i < 4) {
            val -= (1 & (val >> (i + 1) * 5 + j)) != 0 ? 1 << (i + 1) * 5 + j : -(1 << (i + 1) * 5 + j);
        }
        if (j < 4) {
            val -= (1 & (val >> i * 5 + j + 1)) != 0 ? 1 << i * 5 + j + 1 : -(1 << i * 5 + j + 1);
        }return val;
    }
}

作者：Vizdl
链接：https://www.acwing.com/solution/content/786/
 


#include <cstdio>
#include <cstring>

using namespace std;

const int N = 6;

char g[N][N], bg[N][N];
int dx[5] = {-1, 0, 1, 0, 0}, dy[5] = {0, 1, 0, -1, 0};

void turn(int x, int y)  // 按一下第x行第y列的开关
{
    for (int i = 0; i < 5; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a < 0 || a >= 5 || b < 0 || b >= 5) continue;
        g[a][b] ^= 1;
    }
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        for (int i = 0; i < 5; i ++ ) scanf("%s", bg[i]);

        int res = 10;
        for (int op = 0; op < 32; op ++ )
        {
            int cnt = 0;
            memcpy(g, bg, sizeof g);
            // 操作第一行的开关
            for (int i = 0; i < 5; i ++ )
                if (op >> i & 1)
                {
                    turn(0, i);
                    cnt ++ ;
                }

            // 递推出第1~4行开关的状态
            for (int i = 0; i < 4; i ++ )
                for (int j = 0; j < 5; j ++ )
                    if (g[i][j] == '0')
                    {
                        turn(i + 1, j);
                        cnt ++ ;
                    }

            // 检查最后一行灯是否全亮
            bool success = true;
            for (int i = 0; i < 5; i ++ )
                if (g[4][i] == '0')
                    success = false;
            if (success && res > cnt) res = cnt;
        }

        if (res > 6) res = -1;
        printf("%d\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/200737/
 

AcWing 97. 约数之和    原题链接    困难
作者：    CB ,  2019-02-02 16:54:43 ,  阅读 972

6


wrong 做法
看到这个题，最开始的想法是想通过乘法快速幂先求出A的B次方，然后再利用二分的思想求结果的约数，最后将约数加和取模
，但是很不幸，木有通过，wrong answer。顿觉此题不能蛮做，有简便方法。

C++ 代码
//感觉是一道综合题,先用快速幂求出A的B次方，然后再求ret的的约数，然后再求结果

#include<iostream>
using namespace std;
#include<set>

typedef long long ll;
ll a,b,sum;
set<int> s;

ll quick(ll a,ll b)
{
    // ll e=1;
    //定义幺元
    ll ret=1;
    while(b)
    {
        if(b&1) ret=ret*a;
        a=a*a;
        b>>=1;
    }
    return ret;
}

int main(){
    cin>>a>>b;
    ll ret=quick(a,b);
    for(ll i=1;i*i<ret;i++)
    {
        if(ret%i==0) s.insert(i),s.insert(ret/i);
    }

    //ll s=0;
    set<int>::iterator it=s.begin();
    while(it!=s.end())
    {   
        sum=(sum+(*it))%9901;
        it++;
    }
    cout<<sum<<endl;
    return 0;
}
灿神的思路（“又是一道小学奥数题.........”）
C++ 代码
//灿神做法
#include<iostream>
using namespace std;
const int mod=9901;

//快速幂
int quick(int a,int b)
{
    int res=1;
    a=a%mod;
    while(b)
    { 
        if(b&1) res=(res*a)%mod;
        a=(a*a)%mod;
        b>>=1;
    }
    return res;
}

//sum函数用来求某个数的幂次项的等比数列的和
int sum(int p,int k)
{
    //k如果是奇数的话，从0到k即为偶数个数
    if(k==0) return 1;
    //k是偶数的时候，则我们(k-1)是奇数，即(k-1)项是偶数,则我们可以把第k项
    //单独把p拿出来,然后对(k-1)再调用sum
    if(k%2==0)
    {
        //这里少了个p的0次方，所以把1加上
        return (p%mod*sum(p,k-1)+1)%mod;
    }
    //否则k如果是奇数，则质因数有(k+1)即偶数项，就去套我们的公式
    return (1+quick(p,k/2+1))*sum(p,k/2)%mod;
}

int main(){

    int A,B;
    cin>>A>>B;
    int res=1;

    //这里是想看i是不是质因数，以及得出i的幂次
    //比如，对于12，可以分解成2^2*3
    for(int i=2;i<=A;i++)
    {
        int s=0;
        //这里的操作是求当我们的质因数是i的时候，它的质因数的幂次项能到几
        while(A%i==0)
        {
            s++;
            A/=i;
        }
        //i,s即相当于我们的质因数以及它的幂次项，即pk和k
        if(s) res=res*sum(i,s*B)%mod;
    }
    //ifA为0的话，那么res=0，。。。。？？？A什么时候为0呢？？？？？
    if(!A) res=0;
    cout<<res<<endl;
    return 0;
}

作者：CB
链接：https://www.acwing.com/solution/content/933/
 

#include <cstdio>

const int mod = 9901;

int qmi(int a, int k)
{
    int res = 1;
    a %= mod;
    while (k)
    {
        if (k & 1) res = res * a % mod;
        a = a * a % mod;
        k >>= 1;
    }
    return res;
}

int sum(int p, int k)
{
    if (k == 1) return 1;
    if (k % 2 == 0) return (1 + qmi(p, k / 2)) * sum(p, k / 2) % mod;
    return (sum(p, k - 1) + qmi(p, k - 1)) % mod;
}

int main()
{
    int a, b;
    scanf("%d%d", &a, &b);

    int res = 1;
    // 对a分解质因数
    for (int i = 2; i * i <= a; i ++ )
        if (a % i == 0)
        {
            int s = 0;
            while (a % i == 0)
            {
                a /= i, s ++ ;
            }
            res = res * sum(i, b * s + 1) % mod;
        }

    if (a > 1) res = res * sum(a, b + 1) % mod;
    if (a == 0) res = 0;

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/200776/
 

AcWing 98. 分形之城    原题链接    困难
作者：    秦淮岸灯火阑珊 ,  2019-01-20 08:13:42 ,  阅读 2439

17


6
题目描述
城市的规划在城市建设中是个大问题。

不幸的是，很多城市在开始建设的时候并没有很好的规划，城市规模扩大之后规划不合理的问题就开始显现。

而这座名为 Fractal 的城市设想了这样的一个规划方案，如下图所示：



当城区规模扩大之后，Fractal 的解决方案是把和原来城区结构一样的区域按照图中的方式建设在城市周围，提升城市的等级。

对于任意等级的城市，我们把正方形街区从左上角开始按照道路标号。

虽然这个方案很烂，Fractal 规划部门的人员还是想知道，如果城市发展到了等级 N，编号为 A 和 B 的两个街区的直线距离是多少。

街区的距离指的是街区的中心点之间的距离，每个街区都是边长为 10 米的正方形。

输入格式
第一行输入正整数n，表示测试数据的数目。

以下n行，输入n组测试数据，每组一行。

每组数据包括三个整数 N,A,B, 表示城市等级以及两个街区的编号，整数之间用空格隔开。

输出格式
一共输出n行数据，每行对应一组测试数据的输出结果，结果四舍五入到整数。

数据范围
1≤N≤311≤N≤31
1≤A,B≤22N1≤A,B≤22N
1≤n≤10001≤n≤1000
输入样例：

3 
1 1 2 
2 16 1 
3 4 33 
输出样例：

10 
30 
50 
递归+分治+数学坐标系公式+找规律
递归+分治好理解，因为这个题目中最显著的特点就是，不断地重复旋转复制，也就是NN级城市，可以由44个N−1N−1级城市构造，因此我们每次可以不断地分形N−1N−1级，将问题范围不断地缩小即可
这道题目的数学坐标公式，其实一共有两个，一个是高中的数学函数，旋转，这是一个难点，其实可以通过找规律，求解，第二公式则是欧几里得距离公式。(x1−x2)2−(y1−y2)2‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾√(x1−x2)2−(y1−y2)2
最难的就是如何旋转这个正方形 找规律。
总的来说这道题目数学知识较多，考察画图能力，解法自然，数据毒瘤，相信可以给你的NOIP一个有利的一脚。

左上角：我们可以发现，左上角的N−1N−1级矩阵其实就是等级为N−1N−1，也就是上一个矩阵，顺时针旋转90°90°，那么既然如此的话，我们就可以综合yxc老师上课所讲的公式(补充:也就是旋转矩阵,属于大学的线性代数内容)，得出转移后的矩阵中的一点坐标从(x,y)(x,y)变为(y,x)(y,x)
左下角：同左上角，它则是逆时针旋转90°90°而且还要水平翻转，也即是沿着XX轴对称，原本逆时针后为(y,−x)(y,−x)，然后要对称,xx坐标不变，yy坐标取反，所以坐标为(−y,−x)(−y,−x) 也就是所谓的(2×len−1−y,len−1−x)(2×len−1−y,len−1−x) 最难理解的坐标，具体可以画图理解
右上角和右下角：通过N=2N=2级图发现，其实和N=1N=1是一样的，并没有旋转，只是平移，则右上角坐标为(x,y+len)(x,y+len)，右下角坐标为(x+len,y+len)(x+len,y+len)
总的来说以上四种转移，都可以通过画图理解
还有本题数据毒瘤，四舍五入最好是double类型，而且整数类型一定要是long long，否则容易WA！
易错点：公式使用，double型浮点数精度问题，输出格式化问题,还有@墨辛大佬指出的问题。
C++ 代码
以下为ACwingAc代码
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define PLL pair<ll,ll>
PLL calc(ll n,ll m)
{
    if (n==0)
        return make_pair(0,0);
    ll len=1LL<<(n-1),cnt=1LL<<(2*n-2);
    PLL pos=calc(n-1,m%cnt);
    ll x=pos.first,y=pos.second;
    ll z=m/cnt;
    if (z==0)
        return make_pair(y,x);
    if (z==1)
        return make_pair(x,y+len);
    if (z==2)
        return make_pair(x+len,y+len);
    return make_pair(2*len-1-y,len-1-x);
}
int main()
{
    //ios::sync_with_stdio(false);
    int t;
    cin>>t;
    while(t--)
    {
        ll n,a,b;
        cin>>n>>a>>b;
        PLL x=calc(n,a-1);
        PLL y=calc(n,b-1);
        ll dx=x.first-y.first,dy=x.second-y.second;
        double ans=(sqrt(dx*dx+dy*dy)*10);
        printf("%0.lf\n",ans);
    }
    return 0;
}
//以下为POJ&Acwing Ac代码
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
#define ll long long
#define PLL pair<ll,ll>
PLL calc(ll n,ll m)
{
    if (n==0)
        return make_pair(0,0);
    ll len=1LL<<(n-1),cnt=1LL<<(2*n-2);
    PLL pos=calc(n-1,m%cnt);
    ll x=pos.first,y=pos.second;
    ll z=m/cnt;
    if (z==0)
        return make_pair(y,x);
    if (z==1)
        return make_pair(x,y+len);
    if (z==2)
        return make_pair(x+len,y+len);
    return make_pair(2*len-1-y,len-1-x);
}
int main()
{
    //ios::sync_with_stdio(false);
    int t;
    scanf("%d",&t);
    while(t--)
    {
        ll n,a,b;
        scanf("%lld%lld%lld",&n,&a,&b);
        PLL x=calc(n,a-1);
        PLL y=calc(n,b-1);
        ll dx=x.first-y.first,dy=x.second-y.second;
        double ans=(sqrt(double(dx*dx+dy*dy))*10);
        printf("%0.lf\n",ans);
    }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/814/
来源：AcWing


分析
本题看懂题目花费了大量的时间，后面理解题意如下：
等级一：4个点，等级2:16个点，等级3:64个点。。。至于贯穿这些点的线，是城市编号增长的顺序。
分析从等级一如何到等级2：首先，原来的城区设为A，A顺时针旋转90度再关于中间翻转一下得到等级2的左上角城区，A向右平移得到右上角的城区，A向右平移再向下平移得到右下角的城区，至于左下角城区，一会再说。
数学知识：
我们知道，两点之间距离的平方是对应横纵坐标距离之差的平方和。
坐标旋转公式：比如第一象限的点（1,2），顺时针旋转90度得到的点在第四象限，也就是（2，-1），逆时针旋转90度得到的点在第二象限，也就是（-2,1）。更一般的，（x，y）顺时针旋转90度得到（y，-x），逆时针得到 （-y，x）。（这里yxc大佬在视频里好像把两个弄反了，虽然程序结果正确，但是的确是把顺时针、逆时针旋转的坐标公式写反了）。
最重要的是确定坐标原点以及坐标系，大多数人都是按照二维数组的思想，把左上角第一个点作为原点，往下的方向作为x轴正方向，往右的方向作为y轴正方向，然后旋转都是绕左上角第一个点旋转，这样造成的问题就是左下角的城区在计算坐标时，逆时针旋转会转偏了，不容易计算。
个人浅见是按照各个城区中心为坐标原点。

刚开始一直是以城区一的中心为原点，然后图一的四个点坐标分别为：（-1,1），（1,1），（1,-1），（-1,-1）左上角：（x，y）关于原点顺时针90度旋转得到（y，-x）再关于y轴轴对称变换得到（-y，-x）；右上角：（x，y）向右平移2len个单位得到（x+2len，y），注意这里的len在代码中有定义；右下角：（x，y）向右平移2len个单位得到（x+2len，y）再向下平移2len个单位得到（x+2len，y-2len）；左下角：（x，y）逆时针旋转90度得到 （-y，x），再关于y轴轴对称变换得到（y，x），注意这里四个点的中心是旋转中心，所以只是换了方向，本质四个点还在原地，最后再向下平移2len得到（y，x-2len）.
以上是以第一行第一列的点为坐标原点（旋转中心）经坐标变换得到其他城区的点的，但是并不能ac，因为图一这样旋转变换得到图二没问题，但是图二绕原来的旋转中心再转就会转歪，后面坐标便不对了。解决办法就是一轮坐标变换后便改变坐标原点（旋转中心），比如等级一经坐标变换后得到等级二的四个坐标后立刻调整坐标原点（旋转中心）为等级二的中心，再推出等级三坐标，继续调整坐标原点，以此类推。
上面的调整坐标原点是向右下角移动，具体操作为调整原来的坐标，横坐标减小len，纵坐标增加len，也就是在上面推出的坐标后面对横纵坐标再次变换，注意必须先坐标转换再移动坐标原点，即得到左上角：（-y，-x）改变坐标得到（-y-len，-x+len）；右上角：（x+2len，y）变成（x+len，y+len）；右下角：（x+2len，y-2len）变成 （x+len，y-len）；左下角：（y，x-2len）变成（y-len，x-len）.
注意点：
1.代码中坐标公式是两步得到，第一步旋转平移，第二步移动原点。
2.虽然主题代码和yxc大佬一样，但是输出时是乘以5，看上面我写的关于等级一的四个坐标便可理解，原点不同。

C++ 代码
#include <iostream>
#include <cmath>
#include <cstdio>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> pll;

pll calc(ll n,ll m){
    if(n == 0)  return {0,0};//递归边界
    ll len = 1ll << (n-1),cnt = 1ll << (2 * n - 2);
    pll pos = calc(n-1,m%cnt);//上一个等级的坐标信息
    ll x = pos.first,y = pos.second;
    ll z = m / cnt;//处在城区的哪个角
    if(z == 0)  return {-y-len,-x+len};
    if(z == 1)  return {x + len,y+len};
    if(z == 2)  return {x + len,y - len};
    return {y-len,x - len};
}

int main(){
    int T;
    cin>>T;
    while(T--){
        ll N,A,B;
        cin>>N>>A>>B;
        pll ac = calc(N,A - 1);
        pll bc = calc(N,B - 1);
        double x = ac.first - bc.first;
        double y = ac.second - bc.second;
        printf("%.0lf\n",sqrt(x*x+y*y)*5);
    }
    return 0;
}

作者：昂昂累世士
链接：https://www.acwing.com/solution/content/996/
 

算法分析&C++11代码
1. 以每个图形的中心点作为原点；
2. 当前坐标在图形中的位置可以由序号所在小图形（左上/右上/左下/右下）和该点在对应小图形中的位置决定！
左上角和左下角的小图形需要翻转,而右上角的和右下角的不变，之后将小图形的坐标原点变换到当前大图形的坐标原点上；
左上角的需要进行顺时针 90° 旋转后沿 Y 轴对称，（x，y）—>（y，-x） —>（-y，-x）
左下角的需要进行逆时针 90° 旋转后沿 Y 轴对称，（x，y）—>（-y，x）—>（y，x）
右上角和右下角的保持不变，（x，y）
进行坐标原点变换，为避免出现小数，采用 len = 1 << ( level - 1 ) ，level为当前图形级别；此时变换的单位长度应是 len / 2 才对，但是为此处避免出现小数，抽出边长 10 的 2 作为因子，之后计算距离后只需要乘以 5 即可。
如左上角（-y，-x）—>（-y - len，-x + len），右上/左下/右下坐标原点变换后依次为 （x + len，y + len）， （y - len，x - len）， （x + len，y - len）
3.递归结束于 level == 0 ，此时 x = 0，y = 0
4.计算两点距离，结果乘以（ 10 / 2 ，前面已经为不出现小数乘过一个 2 ）
#include <cmath>
#include <iostream>
// #define debug
using namespace std;
using Long = long long int;
using Longpair = pair<Long, Long>;
Longpair findindex(int level, Long dis)
{
    if (!level)
        return {0LL, 0LL};
    auto len{1 << (level - 1)};
    auto space{1LL << (2 * level - 2)};
    auto diss{findindex(level - 1, dis % space)};
    auto x{diss.first}, y{diss.second};
    switch (dis / space)
    {
    case 0LL:
        return {-y - len, -x + len};
    case 1LL:
        return {x + len, y + len};
    case 2LL:
        return {x + len, y - len};
    case 3LL:
        return {y - len, x - len};
    }
}
int main(int argc, char **argv)
{
    int cnt;
    cin >> cnt;
    while (cnt--)
    {
        int level;
        Long A, B;
        cin >> level >> A >> B;
        auto tempA{findindex(level, A - 1)}, tempB{findindex(level, B - 1)};
#ifdef debug
        cout << "----------" << endl;
        cout << tempA.first << ',' << tempA.second << endl;
        cout << tempB.first << ',' << tempB.second << endl;
        cout << "----------" << endl;
#endif
        double x = tempA.first - tempB.first;
        double y = tempA.second - tempB.second;
        cout.flags(ios::fixed);
        cout.precision(0);
        cout << sqrt(x * x + y * y) * 5.0 << endl;
    }
    return EXIT_SUCCESS;
}


作者：Belous
链接：https://www.acwing.com/solution/content/1388/
 

#include <cstdio>
#include <cstring>
#include <cmath>

typedef long long LL;

struct Point
{
    LL x, y;
};

Point get(LL n, LL a)
{
    if (n == 0) return {0, 0};
    LL block = 1ll << n * 2 - 2, len = 1ll << n - 1;
    auto p = get(n - 1, a % block);
    LL x = p.x, y = p.y;
    int z = a / block;

    if (z == 0) return {y, x};
    else if (z == 1) return {x, y + len};
    else if (z == 2) return {x + len, y + len};
    return {len * 2 - 1 - y, len - 1 - x};
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        LL n, a, b;
        scanf("%lld%lld%lld", &n, &a, &b);
        auto pa = get(n, a - 1);
        auto pb = get(n, b - 1);
        double dx = pa.x - pb.x, dy = pa.y - pb.y;
        printf("%.0lf\n", sqrt(dx * dx + dy * dy) * 10);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/200835/
 

基本概念
普通(一维，二维)前缀和:

a[1],a[2],a[3].....a[n]
s[i] = a[i] + a[i-1]...a[2] + a[1]

a[3] + a[4]...a[14] + a[15] = s[15] - s[3-1]
s[l,r] = s[r] - s[l-1]
二维前缀和:

假设在一个二维平面上，每个点具有一定的权值，我们要计算点（2，2）到（8，4）的权值和。



首先我们要找到这么几块面积：



我们可以发现，我们所要求的黄色区域，就是黑色 - 绿色 - 粉色 + 青色。

好了，知识都听少的，看例题。

例1激光炸弹
一种新型的激光炸弹，可以摧毁一个边长为 R 的正方形内的所有的目标。

现在地图上有 N 个目标，用整数Xi,Yi表示目标在地图上的位置，每个目标都有一个价值Wi。

激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个边长为 RR 的正方形的边必须和x，y轴平行。

若目标位于爆破正方形的边上，该目标不会被摧毁。

求一颗炸弹最多能炸掉地图上总价值为多少的目标。

输入格式
第一行输入正整数 N 和 R ,分别代表地图上的目标数目和正方形的边长，数据用空格隔开。

接下来NN行，每行输入一组数据，每组数据包括三个整数Xi,Yi,Wi,分别代表目标的x坐标，y坐标和价值，数据用空格隔开。

输出格式
输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。

数据范围
0<N≤10000
0≤Xi,Yi≤5000

输入样例：
2 1
0 0 1
1 1 1
输出样例：
1
题解：
这很明显就是一道二维前缀和的问题了，找区域最值。

#include<bits/stdc++.h>
using namespace std;

const int maxn = 5010;
int g[maxn][maxn];

int main(void)
{
    int N,R;
    cin >> N >> R;

    int n = R, m = R;

    for(int i = 0,x,y,w;i < N;++i)
    {
        cin >> x >> y >> w;
        x++,y++;
        n = max(n,x);
        m = max(m,y);
        g[x][y] += w;
    }

    for(int i = 1; i <= n; i++)
        for(int j = 1;j <= m; j++)
            g[i][j] += g[i-1][j] + g[i][j-1] - g[i][j];

    int ans = 0;
    for(int i = R;i <= n;i++)
        for(int j = R;j <= m;j++)
            ans = max(ans,g[i][j]-g[i-R][j]-g[i][j-R]+g[i-R][j-R]);

    cout << ans ;

    return 0;
}

作者：Chicago
链接：https://www.acwing.com/solution/content/959/
 

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 5010;

int s[N][N];

int main()
{
    int n, R;
    scanf("%d%d", &n, &R);
    R = min(R, 5001);

    for (int i = 0; i < n; i ++ )
    {
        int x, y, w;
        scanf("%d%d%d", &x, &y, &w);
        x ++, y ++ ;
        s[x][y] += w;
    }

    for (int i = 1; i <= 5001; i ++ )
        for (int j = 1; j <= 5001; j ++ )
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];

    int res = 0;
    for (int i = R; i <= 5001; i ++ )
        for (int j = R; j <= 5001; j ++ )
            res = max(res, s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]);

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/203942/
 

AcWing 100. IncDec序列    原题链接    中等
作者：    小呆呆 ,  2019-10-04 23:52:17 ,  阅读 724

5


2
算法分析：
差分解决一段区域同时增加或减少的问题
给区间【L，R】上都加上一个常数c，则b[L] += c , b[R + 1] -=c

求出a的差分序列b，其中b1 = a1,b(i) = a(i) - a(i - 1) (2 <= i <= n)。令b(n + 1) = 0，题目对序列a的操作，相当于每次可以选出b1,b2…b(n + 1)中的任意两个数，一个加1，另外一个减一。目标是把b2,b3,…bn变为全0。最终得到的数列a就是由 n 个 b1 构成的

任选两个数的方法可分为四类
1、2 <= i , j <=n（优先）
2、i = 1, 2 <=j <=n
3、2 <= i <= n , j = n + 1
4、i = 1, j = n + 1（没有意义）

设b2,b3....bn中正数总和为p，负数总和的绝对值为q。首先以正负数匹配的方式尽量执行1类操作，可执行min(p,q)次。剩余|p - q|个为匹对，每个可以选与b1或b(n + 1)匹配，即执行2 或 3 类操作，共需|p - q|次

综上所诉，最少操作次数为min(p,q) + |p - q|。根据|p - q|次第2、3类操作的选择情况，能产生|p - q| + 1中不同的b1的值，即最终得到的序列a可能有|p - q| + 1 种

import java.util.Scanner;

public class Main {
    static int N = 100010;
    static int[] a = new int[N];
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        for(int i = 1; i <= n;i ++) a[i] = scan.nextInt();
        //构成差分序列
        for(int i = n;i >= 2;i --) a[i] -= a[i - 1];

        long p = 0;//b2到bn的正数总和
        long q = 0;//b2到bn的负数总和
        for(int i = 2;i <= n;i ++)
        {
            if(a[i] > 0) p += a[i];
            else q -= a[i];//注意这里a[i]是负数，所以需要q = q - q[i]变成整数
        }
        System.out.println(Math.min(p, q) + Math.abs(p - q));
        System.out.println(Math.abs(p - q) + 1);
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/5060/
 

#include <stdio.h>

const int N=100005;

int n;
int a[N];

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",a+i);
    for(int i=n;i;i--)
        a[i]-=a[i-1];
    long long p=0,q=0;
    for(int i=2;i<=n;i++)
        if(a[i]>0)p+=a[i];
        else    q-=a[i];
    printf("%lld\n%lld\n",p>q?p:q,(p>q?p-q:q-p)+1);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/362390/
 

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

typedef long long LL;

int n;
int a[N], b[N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i ++ ) b[i] = a[i] - a[i - 1];

    LL p = 0, q = 0;
    for (int i = 2; i <= n; i ++ )
        if (b[i] > 0) p += b[i];
        else q -= b[i];

    cout << max(p, q) << endl;
    cout << abs(p - q) + 1 << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/203971/
 

AcWing 102. 最佳牛围栏    原题链接    中等
作者：    Nicoppa ,  2019-03-14 14:22:08 ,  阅读 1580

25


10
博客地址 https://www.Halocat.Top
不懂吗？那就搞懂为止

农夫约翰的农场由 NN 块田地组成，每块地里都有一定数量的牛,其数量不会少于1头，也不会超过2000头。

约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。

围起区域内至少需要包含 FF 块地，其中 FF 会在输入中给出。

在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。

输入格式
第一行输入整数 NN 和 FF ，数据间用空格隔开。

接下来 NN 行，每行输出一个整数，第i+1i+1行输出的整数代表，第ii片区域内包含的牛的数目。

输出格式
输出一个整数，表示围起区域内每块地包含的牛的数量的平均值可能的最大值乘以1000得到的数值。

数据范围
1≤N≤1000001≤N≤100000
1≤F≤N1≤F≤N
输入样例：
10 6
6 
4
2
10
3
8
5
9
4
1
输出样例：
6500
题目题解
先分析这道题应该用什么算法，本题应该怎么入手

首先本题没有出现二分的特征词：“最大值最小” or “最小值最大” 并且给的数列不具备单调性，并且不适于排序，我们看到这种题可以先提出假设 比如，假设这道题用二分能解出

那么我们判断是否存在一个平均值大于等于mid，如果最优解是x，那么mid <= x的时候，必然可以找到一段，其平均值≥mid， 否则 一定找不到

对于二分，二分是二分性而不是单调性 只要满足可以找到一个值一半满足一半不满足即可 而不用满足单调性

那么这个题我们就可以使用二分来解决

知道了这道题的算法之后，我们就来分析这道题

首先我们二分针对的是平均数，那么根据我们就可以捏出以下主函数

int main() {
    scanf("%d %d", &n, &m);
    double l = 0, r = 0;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &cows[i]);
        r = std::max(r, (double)cows[i]);
    } //最小左区间 最大右区间

    while(r - l > 1e-5) { //开始二分 因为是实数所以这里还搞个精度
        double mid = (l + r) / 2; // 不是>>1 这里是实数
        if(check(mid)) l = mid; //将问题转变为判定问题
        else r = mid;
    } printf("%d\n", (int)(r * 1000)); //因为我们找的极大值 所以要右端点*1000 否则可能会出错
    return 0; 
}
二分最难的地方就在于check函数的写法，我们先来捋一遍思路，防止写代码的时候思路混乱

①：我们要找的是 有没有一段不小于F的区间，使这段区间的平均数尽可能的大，如果我们找到了一段连续的区间且区间长度不小于F且平均数大于我们二分的平均数 那么大于这个数且区间也满足的一定满足了 我们直接判断正确即可

②：因为我们要找一段区间的平均数，根据平均数的一个基本应用，显而易见，对于一段序列，每个数减去我们所算的平均数，如果大于0 那么他本身就大于平均数，如果小于0 那么它本身就小于平均数 此时我们就能算出哪些数大于0 哪些数小于0 ，之后我们再使用前缀和，就能判断一个区间内的平均值是否大于或小于我们二分的平均数了

③：据②我们还可以继续优化，因为我们不仅需要找F大小区间内，我们还要找＞F大小区间内的，我们如果用二次for太费时间了，我们这里可以使用双指针的做法，我们设i=0,j=Fi=0,j=F 每次使两个数++ 因为i,ji,j始终满足相距FF的距离，所以我们用一个变量minvminv来存储ii所遍历到的最小值，这样我们比较的距离一定是≥F≥F的，并且如果我们用jj位的前缀和数减去minvminv的话，就能得到我们的最优解，如果这个最优解＞= 0 那么就满足我们的指定条件（如果不懂这一步 请看②）。 到此，结束

我们便可以写出二分的checkcheck代码

bool check(double avg) {
    for (int i = 1; i <= n; i++) {
        sum[i] = sum[i - 1] + (cows[i] - avg); //计算前缀和
    }

    double minv = 0; //设置最小值
    for (int i = 0, j = m; j <= n; j++, i++) {
        minv = std::min(minv, sum[i]); //找最优极小值
        if(sum[j] - minv >= 0) return true; //进行判断
    } return false; //如果所有的都不满足，那么这个平均数就一定不满足
}
以下是全代码：

//#define fre yes

#include <cstdio>
#include <iostream>

const int N = 100005;
int cows[N]; double sum[N];

int n, m;

bool check(double avg) {
    for (int i = 1; i <= n; i++) {
        sum[i] = sum[i - 1] + cows[i] - avg;
    }

    double minv = 0;
    for (int i = 0, j = m; j <= n; j++, i++) {
        minv = std::min(minv, sum[i]);
        if(sum[j] - minv >= 0) return true;
    } return false;
}

int main() {
    scanf("%d %d", &n, &m);
    double l = 0, r = 0;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &cows[i]);
        r = std::max(r, (double)cows[i]);
    }

    while(r - l > 1e-5) {
        double mid = (l + r) / 2;
        if(check(mid)) l = mid;
        else r = mid;
    } printf("%d\n", (int)(r * 1000));
    return 0; 
}

作者：Nicoppa
链接：https://www.acwing.com/solution/content/1148/
 

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, F;
double a[N], s[N];

bool check(double avg)
{
    for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + a[i] - avg;

    double mins = 0;
    for (int k = F; k <= n; k ++ )
    {
        mins = min(mins, s[k - F]);
        if (s[k] >= mins) return true;
    }

    return false;
}

int main()
{
    scanf("%d%d", &n, &F);

    double l = 0, r = 0;
    for (int i = 1; i <= n; i ++ )
    {
        scanf("%lf", &a[i]);
        r = max(r, a[i]);
    }

    while (r - l > 1e-5)
    {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }

    printf("%d\n", (int)(r * 1000));

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/204001/
 


AcWing 113. 特殊排序    原题链接    简单
作者：    昂昂累世士 ,  2019-02-13 12:47:04 ,  阅读 1608

15


3
题目描述
有N个元素，编号1.2..N，每一对元素之间的大小关系是确定的，关系不具有传递性。也就是说，元素的大小关系是N个点与N*(N-1)/2条有向边构成的任意有向图。
然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过10000次提问来获取信息，每次提问只能了解某两个元素之间的关系。
现在请你把这N个元素排成一行，使得每个元素都小于右边与它相邻的元素。你可以通过我们预设的bool函数compare来获得两个元素之间的大小关系。例如，编号为a和b的两个元素，如果元素a小于元素b,则compare（a,b）返回true，否则返回false。将N个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。
数据范围
1≤N≤1000

输入样例

[[0, 1, 0], [0, 0, 0], [1, 1, 0]]

输出样例

[3, 1, 2]

注意：不存在两个元素大小相等的情况。

分析：
本题与一般排序有三个区别：
其一是交互式，你并不知道大小关系，只能通过调用compare接口询问；
其二是大小不具备传递性，比如a < b,b < c 并不能推出a < c；
其三是不能超过一万次询问，数据范围为1000，nlogn略小于一万，而CBA算法在最坏情况下的下界也就是nlogn。
对于其第二个性质仅仅导致答案不唯一，题目仅要求输出一种答案，所以可以忽视该条件。采用二分插入排序解决该问题，首先将第一个元素压入向量里，然后二分查找合适的位置r，将待插入元素插入到向量末尾，从后往前不断交换相邻的两个数直到待插入的元素到达指定位置。注意该二分算法的写法，循环退出时l比r大一，意味着r位置的必然小于待插入的元素，r+1及其之后的元素都大于待插入的元素。（比yxc大佬的代码更加简练了一点，因为我觉得mid=1+r+1>>2以致于代码最后还要多一次判断不容易理解，不如直接在循环里就判断好了，后面插入到末尾后只用不断前移，不用再进行判断了）。

C++ 代码
class Solution {
public:
    vector<int> specialSort(int N) {
        vector<int> res;
        res.push_back(1);
        for(int i = 2;i <= N;i++){
            int l = 0,r = res.size() - 1;
            while(l <= r){
                int mid = l + r >> 1;
                if(compare(res[mid],i)) l = mid + 1;
                else    r = mid - 1;
            }
            res.push_back(i);
            for(int j = res.size() - 2;j > r;j--)   swap(res[j],res[j + 1]);
        }
        return res;
    }
};

作者：昂昂累世士
链接：https://www.acwing.com/solution/content/1009/
 

// Forward declaration of compare API.
// bool compare(int a, int b);
// return bool means whether a is less than b.

class Solution {
public:
    vector<int> specialSort(int N) {
        vector<int> res(1, 1);
        for (int i = 2; i <= N; i ++ )
        {
            int l = 0, r = res.size() - 1;
            while (l < r)
            {
                int mid = l + r + 1 >> 1;
                if (compare(res[mid], i)) l = mid;
                else r = mid - 1;
            }

            res.push_back(i);
            for (int j = res.size() - 2; j > r; j -- ) swap(res[j], res[j + 1]);
            if (compare(i, res[r])) swap(res[r], res[r + 1]);
        }

        return res;
    }
};

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/204025/
 

https://www.bilibili.com/video/av70261237

#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int row[N], col[N], s[N], c[N];

LL work(int n, int a[])
{
    for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + a[i];

    if (s[n] % n) return -1;

    int avg = s[n] / n;

    c[1] = 0;
    for (int i = 2; i <= n; i ++ ) c[i] = s[i - 1] - (i - 1) * avg;

    sort(c + 1, c + n + 1);
    LL res = 0;
    for (int i = 1; i <= n; i ++ ) res += abs(c[i] - c[(n + 1) / 2]);

    return res;
}

int main()
{
    int n, m, cnt;
    scanf("%d%d%d", &n, &m, &cnt);

    while (cnt -- )
    {
        int x, y;
        scanf("%d%d", &x, &y);
        row[x] ++, col[y] ++ ;
    }

    LL r = work(n, row);
    LL c = work(m, col);

    if (r != -1 && c != -1) printf("both %lld\n", r + c);
    else if (r != -1) printf("row %lld\n", r);
    else if (c != -1) printf("column %lld\n", c);
    else printf("impossible\n");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/205163/
 

七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。

于是TYVJ今年举办了一次线下七夕祭。

Vani同学今年成功邀请到了cl同学陪他来共度七夕，于是他们决定去TYVJ七夕祭游玩。

TYVJ七夕祭和11区的夏祭的形式很像。

矩形的祭典会场由N排M列共计N×M个摊点组成。

虽然摊点种类繁多，不过cl只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。

Vani预先联系了七夕祭的负责人zhq，希望能够通过恰当地布置会场，使得各行中cl感兴趣的摊点数一样多，并且各列中cl感兴趣的摊点数也一样多。

不过zhq告诉Vani，摊点已经随意布置完毕了，如果想满足cl的要求，唯一的调整方式就是交换两个相邻的摊点。

两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。

由于zhq率领的TYVJ开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。

现在Vani想知道他的两个要求最多能满足多少个。

在此前提下，至少需要交换多少次摊点。

输入格式
第一行包含三个整数N和M和T，T表示cl对多少个摊点感兴趣。

接下来T行，每行两个整数x, y，表示cl对处在第x行第y列的摊点感兴趣。

输出格式
首先输出一个字符串。

如果能满足Vani的全部两个要求，输出both；

如果通过调整只能使得各行中cl感兴趣的摊点数一样多，输出row；

如果只能使各列中cl感兴趣的摊点数一样多，输出column；

如果均不能满足，输出impossible。

如果输出的字符串不是impossible， 接下来输出最小交换次数，与字符串之间用一个空格隔开。

数据范围
1≤N,M≤100000,0≤T≤min(N∗M,100000),1≤x≤N,1≤y≤M1≤N,M≤100000,0≤T≤min(N∗M,100000),1≤x≤N,1≤y≤M
样例
输入样例：
2 3 4
1 3
2 1
2 2
2 3
输出样例：
row 1
分治+贪心+前缀和+中位数+排序
这道题目有一个非常重要的性质就是，只会改变相邻的两个数的位置，因此我们交换两个数，只会改变一行的喜爱小摊或者一列的喜爱小摊，而不会同时改变行和列的喜爱小摊，既然这样的话，我们就可以将这道题目分成两个部分，一部分是求行的最少次数，一部分是求列的最少次数。
既然如此的话，这道题目就成为了环形的均分纸牌问题，均分纸牌这是一道经典的贪心问题，可以自行百度理解即可懒惰病发作ing 但是环形均分纸牌问题和普通均分纸牌问题又有不同之处，因此我们要截环为序列，所以说我们可以利用中位数把环形变成区间，具体思路可见《算法竞赛进阶指南》。
感谢@sandychn 大佬指出简短代码中一个小问题.
后更新简短代码
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define fir(i,a,b) for(ll i=a;i<=b;i++)
const int N=1e5+10;
ll n,m,t,a[N],b[N],f[N],x,y,rr,cc;
ll calc(ll a[],ll n)
{
    fir(i,1,n)
    {
        a[i]-=(a[0]/n);
        f[i]=f[i-1]+a[i];
    }
    sort(f+1,f+1+n);
    ll mid=(n+1)>>1,ans=0;//不是n|1,因为n若为奇数会出问题.不过这道题目也不会出现问题.因为中位数只要求是最中间,但是如果说我们要求出n+1的话,那么不能用n|1. 感谢@sandychn 大佬指出问题.
    fir(i,1,n)
        ans+=abs(f[mid]-f[i]);
    return ans;
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m>>t;
    for(int i=1;i<=t;i++)
    {
        cin>>x>>y;
        a[x]++;
        b[y]++;
    }
    fir(i,1,n)
        a[0]+=a[i];
    fir(i,1,m)
        b[0]+=b[i];
    ll as=a[0]%n,bs=b[0]%m;
    if (!as && !bs)
        cout<<"both "<<calc(a,n)+calc(b,m);
    else if(!as)
        cout<<"row "<<calc(a,n);
    else if(!bs)
        cout<<"column "<<calc(b,m);
    else
        cout<<"impossible";
    return 0;
}
lyd老师的精简C++ 代码
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
using namespace std;
const int u=100010; 
long long b[u],c[u],f[u];
long long n,m,t,i,j,x,y;

long long calc(long long a[u],int n)
{
    long long ans=0; int i;
    for(i=1;i<=n;i++)
    {
        a[i]-=a[0]/n;
        f[i]=f[i-1]+a[i];
    }
    sort(f+1,f+n+1);
    for(i=1;i<=n;i++) ans+=abs(f[i]-f[n+1>>1]);
    return ans;
}

int main()
{
    freopen("tanabata.in","r",stdin);
    freopen("tanabata.out","w",stdout); 
    cin>>n>>m>>t;
    for(i=1;i<=t;i++)
    {
        scanf("%d%d",&x,&y);
        b[x]++,c[y]++; 
    }
    for(i=1;i<=n;i++) b[0]+=b[i];
    for(i=1;i<=m;i++) c[0]+=c[i];
    if(b[0]%n==0&&c[0]%m==0)
        printf("both %lld\n",calc(b,n)+calc(c,m));
    else if(b[0]%n==0)
        printf("row %lld\n",calc(b,n));
    else if(c[0]%m==0)
        printf("column %lld\n",calc(c,m));
    else puts("impossible");
    return 0;
}
蒟蒻我的繁杂代码
#include <bits/stdc++.h>
using namespace std;
const int N=100100;
#define ll long long
ll n,m,t,i,j,k,s[N],a[N],x,y,ans1,ans2,r[N],c[N],rr,cc;
void init()
{
    ios::sync_with_stdio(false);
    cin>>n>>m>>t;
    for (i=1;i<=t;i++)
    {
        int x,y;
        cin>>x>>y;
        r[x]++;
        c[y]++;
        rr++;
        cc++;
    } 
}
bool work1()//横排
{
    if (t%n!=0)
        return 0;
    memset(s,0,sizeof(s));
    rr/=n;
    for (i=1;i<=n;i++)
    {
        r[i]-=rr;
        s[i]=s[i-1]+r[i];
    }
    sort(s+1,s+1+n);
    int k=(1+n)>>1;
    for (i=1;i<=n;i++)
        ans1+=abs(s[i]-s[k]);
    return 1;
}
bool work2()//竖排
{
    if (t%m!=0)
        return 0;
    memset(s,0,sizeof(s));
    cc/=m;
    for (i=1;i<=m;i++)
    {
        c[i]-=cc;
        s[i]=s[i-1]+c[i];
    }
    sort(s+1,s+1+m);
    int k=(1+m)>>1;
    for (i=1;i<=m;i++)
        ans2+=abs(s[i]-s[k]);
    return 1;
}
int main()
{
    init();
    bool ok1=work1(),ok2=work2();
    if (ok1 && ok2)
        cout<<"both";
    else
    if (ok1)
        cout<<"row";
    else if (ok2)
        cout<<"column";
    else 
        cout<<"impossible";
    if (ok1 || ok2)
        cout<<" "<<ans1+ans2;
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/837/
 

AcWing 106. 动态中位数    原题链接    困难
作者：    秦淮岸灯火阑珊 ,  2019-01-22 15:58:07 ,  阅读 1594

18


5
题目描述
依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。

输入格式
第一行输入一个整数P，代表后面数据集的个数，接下来若干行输入各个数据集。

每个数据集的第一行首先输入一个代表数据集的编号的整数。

然后输入一个整数M，代表数据集中包含数据的个数，M一定为奇数，数据之间用空格隔开。

数据集的剩余行由数据集的数据构成，每行包含10个数据，最后一行数据量可能少于10个，数据之间用空格隔开。

输出格式
对于每个数据集，第一行输出两个整数，分别代表数据集的编号以及输出中位数的个数（应为数据个数加一的二分之一），数据之间用空格隔开。

数据集的剩余行由输出的中位数构成，每行包含10个数据，最后一行数据量可能少于10个，数据之间用空格隔开。

输出中不应该存在空行。

数据范围
1≤P≤10001≤P≤1000
1≤M≤99991≤M≤9999
样例
输入样例：
3 
1 9 
1 2 3 4 5 6 7 8 9 
2 9 
9 8 7 6 5 4 3 2 1 
3 23 
23 41 13 22 -3 24 -31 -11 -8 -7 
3 5 103 211 -311 -45 -67 -73 -81 -99 
-33 24 56
输出样例：
1 5
1 2 3 4 5
2 5
9 8 7 6 5
3 12
23 23 22 22 13 3 5 5 3 -3 
-7 -3
对顶堆
这是一个很有用的算法作者第一次学到，具体思路大致是，开两个堆，一个是大根堆，一个是小根堆，然后小于中位数的都放在大根堆，大于中位数的都放在小根堆，如果说，一个堆的个数大于了当前序列的1212，那么就将多余的数移过去，直到两个堆数量相等。
C++ 代码

#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
using namespace std;
struct cmp1
{
    bool operator ()(int &a,int &b)
    {
        return a>b;//小根堆，不是大根堆
    }
};
priority_queue <int,vector<int>, cmp1> q1,kong1;
priority_queue <int> q2,kong2;
void init()
{
    int t,x,n,now;
    cin>>t;
    while(t--)
    {
        cin>>x>>n;
        cout<<x<<" "<<(n+1)/2<<endl;
        q1=kong1;
        q2=kong2;
        int cnt=0;
        for (int i=1;i<=n;i++)
        {
            cin>>now;
            if(q1.empty())
                q1.push(now);
            else
            {
                if(now>q1.top()) 
                    q1.push(now);
                else 
                    q2.push(now);
                while(q1.size()<q2.size())
                {
                    q1.push(q2.top());
                    q2.pop();
                }
                while(q1.size()>q2.size()+1)
                {
                    q2.push(q1.top());
                    q1.pop();
                }
            }
            if (i&1)
            {
                cnt++;
                cout<<q1.top()<<" ";
                if (!(cnt%10))
                    cout<<endl;
            }
        }
        puts("");
    }
}
int main()
{
    init();
    return 0;
}


作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/838/
 

快速选择   47   47行   105ms   105ms
#include <stdio.h>

typedef long long ll;

const int N=10005;

int test,n;
int a[N];
ll ans[N>>1],size;

template<typename T>
T quick_search(T *begin,T *end,int k)
{
    if(begin==end-1)return *begin;
    T pivot=*(begin+(end-begin>>1));
    T *i=begin-1,*j=end;
    while(i!=j)
    {
        while(i!=j&&*++i<pivot);
        while(i!=j&&*--j>pivot);
        if(i!=j)*i^=*j,*j^=*i,*i^=*j;
    }
    if(k<=j-begin)return quick_search(begin,j,k);
    else    return quick_search(j,end,k-(j-begin));
}

int main()
{
    int T;
    for(scanf("%d",&T);T--;putchar('\n'))
    {
        size=0;
        scanf("%d%d",&test,&n);
        printf("%d %d\n",test,n+1>>1);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",a+i);
            if(i&1)ans[size++]=quick_search(a+1,a+i+1,i+1>>1);
        }
        for(int i=0;i<size;i++)
        {
            if(i&&i%10==0)putchar('\n');
            printf("%d ",ans[i]);
        }
    }
    return 0;
}
对顶堆   148   148行   5ms   5ms
#include <stdio.h>

typedef long long ll;

const int N=10005;

int test,n;
ll heap1[N],size_heap1; // 大根堆
ll heap2[N],size_heap2; // 小根堆
ll ans[N],size_ans;

void down_heap1(int u)
{
    int t=u;
    if(u<<1<=size_heap1&&heap1[t]<heap1[u<<1])t=u<<1;
    if((u<<1|1)<=size_heap1&&heap1[t]<heap1[u<<1|1])t=u<<1|1;
    if(u!=t)
    {
        heap1[u]^=heap1[t];
        heap1[t]^=heap1[u];
        heap1[u]^=heap1[t];
        down_heap1(t);
    }
}

void up_heap1(int u)
{
    while(u>>1&&heap1[u]>heap1[u>>1])
    {
        heap1[u]^=heap1[u>>1];
        heap1[u>>1]^=heap1[u];
        heap1[u]^=heap1[u>>1];
        u>>=1;
    }
}

void insert_heap1(int x)
{
    heap1[++size_heap1]=x;
    up_heap1(size_heap1);
}

void erase_heap1(int u)
{
    if(u!=size_heap1)
    {
        heap1[u]^=heap1[size_heap1];
        heap1[size_heap1]^=heap1[u];
        heap1[u]^=heap1[size_heap1];
    }
    size_heap1--;
    down_heap1(u);
    up_heap1(u);
}

void down_heap2(int u)
{
    int t=u;
    if(u<<1<=size_heap2&&heap2[u<<1]<heap2[t])t=u<<1;
    if((u<<1|1)<=size_heap2&&heap2[u<<1|1]<heap2[t])t=u<<1|1;
    if(t!=u)
    {
        heap2[u]^=heap2[t];
        heap2[t]^=heap2[u];
        heap2[u]^=heap2[t];
        down_heap2(t);
    }
}

void up_heap2(int u)
{
    while(u>>1&&heap2[u>>1]>heap2[u])
    {
        heap2[u]^=heap2[u>>1];
        heap2[u>>1]^=heap2[u];
        heap2[u]^=heap2[u>>1];
        u>>=1;
    }
}

void insert_heap2(int x)
{
    heap2[++size_heap2]=x;
    up_heap2(size_heap2);
}

void erase_heap2(int u)
{
    if(u!=size_heap2)
    {
        heap2[u]^=heap2[size_heap2];
        heap2[size_heap2]^=heap2[u];
        heap2[u]^=heap2[size_heap2];
    }
    size_heap2--;
    down_heap2(u);
    up_heap2(u);
}

int main()
{
    int T;
    for(scanf("%d",&T);T--;putchar('\n'))
    {
        size_ans=0;
        size_heap1=0;
        size_heap2=0;
        scanf("%d %d",&test,&n);
        for(int i=1;i<=n;i++)
        {
            int x;
            scanf("%d",&x);
            if(i&1)
                if(x<=heap1[1])
                {
                    insert_heap1(x);
                    ans[size_ans++]=heap1[1];
                }
                else
                {
                    insert_heap2(x);
                    ans[size_ans++]=heap2[1];
                }
            else
            {
                if(size_heap1>size_heap2)insert_heap1(x);
                else    insert_heap2(x);
                if(size_heap1>size_heap2)
                {
                    insert_heap2(heap1[1]);
                    erase_heap1(1);
                }
                else if(size_heap1<size_heap2)
                {
                    insert_heap1(heap2[1]);
                    erase_heap2(1);
                }
            }
        }
        printf("%d %d\n",test,size_ans);
        for(int i=0;i<size_ans;i++)
        {
            if(i&&i%10==0)putchar('\n');
            printf("%d ",ans[i]);
        }
    }
    return 0;
}
线段树   135   135行   17ms   17ms
#include <stdio.h>

typedef long long ll;

const int N=10005;
const int M=40005;

int test,n;
struct point
{
    int l,r;
    ll sum;
}tr[M];
ll alls[N],size_alls;
ll ans[N],size_ans;
ll a[N];

template<typename T>
void sort(T *begin,T *end)
{
    if(begin==end-1)return;
    T pivot=*(begin+(end-begin>>1));
    T *i=begin-1,*j=end;
    while(i!=j)
    {
        while(i!=j&&*++i<pivot);
        while(i!=j&&*--j>pivot);
        if(i!=j)*i^=*j,*j^=*i,*i^=*j;
    }
    sort(begin,j),sort(j,end);
}

template<typename T>
int unique(T *begin,T *end)
{
    T *pivot1,*pivot2;
    pivot1=pivot2=begin;
    while(pivot1!=end)
    {
        while(pivot1!=end&&*pivot1==*pivot2)pivot1++;
        if(pivot1!=end)*++pivot2=*pivot1;
    }
    return pivot2-begin+1;
}

int find(int x)
{
    int l=1,r=size_alls;
    while(l<r)
    {
        int mid=l+r>>1;
        if(alls[mid]>=x)r=mid;
        else    l=mid+1;
    }
    return r;
}

void pushup(int u)
{
    tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;
}

void build(int u,int l,int r)
{
    tr[u].l=l,tr[u].r=r;
    tr[u].sum=0;
    if(l==r)return;
    int mid=l+r>>1;
    build(u<<1,l,mid);
    build(u<<1|1,mid+1,r);
}

void modify(int u,int x,int c)
{
    if(tr[u].l==tr[u].r)tr[u].sum+=c;
    else
    {
        int mid=tr[u].l+tr[u].r>>1;
        if(x<=mid)modify(u<<1,x,c);
        else    modify(u<<1|1,x,c);
        pushup(u);
    }
}

ll query(int u,int l,int r)
{
    if(tr[u].l>=l&&tr[u].r<=r)return tr[u].sum;
    ll sum=0,mid=tr[u].l+tr[u].r>>1;
    if(l<=mid)sum+=query(u<<1,l,r);
    if(mid<r)sum+=query(u<<1|1,l,r);
    return sum;
}

int get_kth(int k)
{
    int l=1,r=size_alls;
    while(l<r)
    {
        int mid=l+r>>1;
        if(query(1,1,mid)>=k)r=mid;
        else    l=mid+1;
    }
    return alls[r];
}

int main()
{
    int T;
    for(scanf("%d",&T);T--;putchar('\n'))
    {
        size_alls=0;
        size_ans=0;
        scanf("%d%d",&test,&n);
        for(int i=1;i<=n;i++)
        {
            scanf("%lld",a+i);
            alls[++size_alls]=a[i];
        }
        sort(alls+1,alls+size_alls+1);
        size_alls=unique(alls+1,alls+size_alls+1);
        build(1,1,n);
        for(int i=1;i<=n;i++)
        {
            modify(1,find(a[i]),1);
            if(i&1)ans[size_ans++]=get_kth(i+1>>1);
        }
        printf("%d %d\n",test,size_ans);
        for(int i=0;i<size_ans;i++)
        {
            if(i&&i%10==0)putchar('\n');
            printf("%d ",ans[i]);
        }
    }
    return 0;
}
线段树(lazytag)   153(lazytag)   153行   27ms   27ms
#include <stdio.h>

typedef long long ll;

const int N=10005;
const int M=40005;

int test,n;
struct point
{
    int l,r;
    ll sum;
    ll lazytag;
}tr[M];
ll alls[N],size_alls;
ll ans[N],size_ans;
ll a[N];

template<typename T>
void sort(T *begin,T *end)
{
    if(begin==end-1)return;
    T pivot=*(begin+(end-begin>>1));
    T *i=begin-1,*j=end;
    while(i!=j)
    {
        while(i!=j&&*++i<pivot);
        while(i!=j&&*--j>pivot);
        if(i!=j)*i^=*j,*j^=*i,*i^=*j;
    }
    sort(begin,j),sort(j,end);
}

template<typename T>
int unique(T *begin,T *end)
{
    T *pivot1,*pivot2;
    pivot1=pivot2=begin;
    while(pivot1!=end)
    {
        while(pivot1!=end&&*pivot1==*pivot2)pivot1++;
        if(pivot1!=end)*++pivot2=*pivot1;
    }
    return pivot2-begin+1;
}

int find(int x)
{
    int l=1,r=size_alls;
    while(l<r)
    {
        int mid=l+r>>1;
        if(alls[mid]>=x)r=mid;
        else    l=mid+1;
    }
    return r;
}

void pushup(int u)
{
    tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;
}

void pushdown(int u)
{
    if(tr[u].lazytag)
    {
        tr[u<<1].lazytag+=tr[u].lazytag;
        tr[u<<1|1].lazytag+=tr[u].lazytag;
        tr[u<<1].sum+=tr[u].lazytag*(tr[u<<1].r-tr[u<<1].l+1);
        tr[u<<1|1].sum+=tr[u].lazytag*(tr[u<<1|1].r-tr[u<<1|1].l+1);
        tr[u].lazytag=0;
    }
}

void build(int u,int l,int r)
{
    tr[u].l=l,tr[u].r=r;
    tr[u].sum=0;
    tr[u].lazytag=0;
    if(l==r)return;
    int mid=l+r>>1;
    build(u<<1,l,mid);
    build(u<<1|1,mid+1,r);
}

void modify(int u,int l,int r,ll c)
{
    if(tr[u].l>=l&&tr[u].r<=r)
    {
        tr[u].sum+=c*(tr[u].r-tr[u].l+1);
        tr[u].lazytag+=c;
        return;
    }
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    if(l<=mid)modify(u<<1,l,r,c);
    if(mid<r)modify(u<<1|1,l,r,c);
    pushup(u);
}

ll query(int u,int l,int r)
{
    if(tr[u].l>=l&&tr[u].r<=r)return tr[u].sum;
    pushdown(u);
    ll sum=0,mid=tr[u].l+tr[u].r>>1;
    if(l<=mid)sum+=query(u<<1,l,r);
    if(mid<r)sum+=query(u<<1|1,l,r);
    return sum;
}

int get_kth(int k)
{
    int l=1,r=size_alls;
    while(l<r)
    {
        int mid=l+r>>1;
        if(query(1,mid,mid)>=k)r=mid;
        else    l=mid+1;
    }
    return alls[r];
}

int main()
{
    int T;
    for(scanf("%d",&T);T--;putchar('\n'))
    {
        size_alls=0;
        size_ans=0;
        scanf("%d%d",&test,&n);
        for(int i=1;i<=n;i++)
        {
            scanf("%lld",a+i);
            alls[++size_alls]=a[i];
        }
        sort(alls+1,alls+size_alls+1);
        size_alls=unique(alls+1,alls+size_alls+1);
        build(1,1,n);
        for(int i=1;i<=n;i++)
        {
            modify(1,find(a[i]),n,1);
            if(i&1)ans[size_ans++]=get_kth(i+1>>1);
        }
        printf("%d %d\n",test,size_ans);
        for(int i=0;i<size_ans;i++)
        {
            if(i&&i%10==0)putchar('\n');
            printf("%d ",ans[i]);
        }
    }
    return 0;
}
树状数组   114   114行   9ms   9ms
#include <stdio.h>
#include <string.h>

typedef long long ll;

const int N=10005;

int test,n;
ll a[N];
ll tr[N];
ll alls[N],size_alls;
ll ans[N],size_ans;

template<typename T>
void sort(T *begin,T *end)
{
    if(begin==end-1)return;
    T pivot=*(begin+(end-begin>>1));
    T *i=begin-1,*j=end;
    while(i!=j)
    {
        while(i!=j&&*++i<pivot);
        while(i!=j&&*--j>pivot);
        if(i!=j)*i^=*j,*j^=*i,*i^=*j;
    }
    sort(begin,j),sort(j,end);
}

template<typename T>
int unique(T *begin,T *end)
{
    T *pivot1,*pivot2;
    pivot1=pivot2=begin;
    while(pivot1!=end)
    {
        while(pivot1!=end&&*pivot1==*pivot2)pivot1++;
        if(pivot1!=end)*++pivot2=*pivot1;
    }
    return pivot2-begin+1;
}

template<typename T>
int find(T x)
{
    int l=1,r=size_alls;
    while(l<r)
    {
        int mid=l+r>>1;
        if(alls[mid]>=x)r=mid;
        else    l=mid+1;
    }
    return r;
}

ll lowbit(ll x)
{
    return x&-x;
}

void modify(int x,ll c)
{
    for(int i=x;i<=n;i+=lowbit(i))
        tr[i]+=c;
}

ll query(int x)
{
    ll res=0;
    for(int i=x;i;i-=lowbit(i))
        res+=tr[i];
    return res;
}

int get_kth(ll k)
{
    int l=1,r=size_alls;
    while(l<r)
    {
        int mid=l+r>>1;
        if(query(mid)>=k)r=mid;
        else    l=mid+1;
    }
    return alls[r];
}

int main()
{
    int T;
    for(scanf("%d",&T);T--;putchar('\n'))
    {
        size_alls=size_ans=0;
        memset(tr,0,sizeof tr);
        scanf("%d%d",&test,&n);
        for(int i=1;i<=n;i++)
        {
            scanf("%lld",a+i);
            alls[++size_alls]=a[i];
        }
        sort(alls+1,alls+size_alls+1);
        size_alls=unique(alls+1,alls+size_alls+1);
        for(int i=1;i<=n;i++)
        {
            modify(find(a[i]),1);
            if(i&1)ans[size_ans++]=get_kth(i+1>>1);
        }
        printf("%d %d\n",test,size_ans);
        for(int i=0;i<size_ans;i++)
        {
            if(i&&i%10==0)putchar('\n');
            printf("%d ",ans[i]);
        }
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/362841/
 


AcWing 107. 超快速排序    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-01-22 17:05:41 ,  阅读 2234

12


2
题目描述
在这个问题中，您必须分析特定的排序算法----超快速排序。

该算法通过交换两个相邻的序列元素来处理n个不同整数的序列，直到序列按升序排序。

对于输入序列

9 1 0 5 4
超快速排序生成输出

0 1 4 5 9
。

您的任务是确定超快速排序需要执行多少交换操作才能对给定的输入序列进行排序。

输入格式
输入包括一些测试用例。

每个测试用例的第一行输入整数n，代表该用例中输入序列的长度。

接下来n行每行输入一个整数aiai,代表用例中输入序列的具体数据，第i行的数据代表序列中第i个数。

当输入用例中包含的输入序列长度为0时，输入终止，该序列无需处理。

输出格式
对于每个需要处理的输入序列，输出一个整数op，代表对给定输入序列进行排序所需的最小交换操作数，每个整数占一行。

数据范围
0≤N<5000000≤N<500000
0≤ai≤9999999990≤ai≤999999999
样例
输入样例：
5
9
1
0
5
4
3
1
2
3
0
输出样例：
6
0
归并排序求逆序对
首先发现题目就是在模拟冒泡排序，而交换的次数，就是冒泡排序的交换次数就是我们的逆序对个数，至于求逆序对最快的方法，就是归并排序。
还要注意这里一定要用Longlong，不然的话就会WA，因为最大值可能为n∗nn∗n 作者就是这个傻孩子
C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N=501000;
#define ll long long
ll n,m,i,j,k,a[N],b[N],cnt;
void merge(ll a[],ll l,ll r)
{
    if (r-l<1)
        return ;
    ll mid=(l+r)>>1;
    merge(a,l,mid);
    merge(a,mid+1,r);
    ll i=l,j=mid+1;
    for (ll k=l;k<=r;k++)
    {
        if (j>r || i<=mid && a[i]<=a[j])
            b[k]=a[i++];
        else
        {
            cnt+=mid-i+1;
            b[k]=a[j++];
        }
    }
    for (ll k=l;k<=r;k++)
        a[k]=b[k];
}
int main()
{
    ios::sync_with_stdio(false);
    while(cin>>n && n)
    {
        for (i=1;i<=n;i++)
            cin>>a[i];
        cnt=0;
        merge(a,1,n);
        cout<<cnt<<endl;
    }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/841/
 

#include <cstdio>

typedef long long LL;

const int N = 500010;

int n;
LL q[N], w[N];

LL merge_sort(int l, int r)
{
    if (l == r) return 0;

    int mid = l + r >> 1;
    LL res = merge_sort(l, mid) + merge_sort(mid + 1, r);
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) w[k ++ ] = q[i ++ ];
        else
        {
            res += mid - i + 1;
            w[k ++ ] = q[j ++ ];
        }
    while (i <= mid) w[k ++ ] = q[i ++ ];
    while (j <= r) w[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = w[j];

    return res;
}

int main()
{
    while (scanf("%d", &n), n)
    {
        for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

        printf("%lld\n", merge_sort(0, n - 1));
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/205204/
 

AcWing 1273. 天才的记忆（RMQ算法详解）    原题链接    简单
作者：    负壹 ,  2020-06-19 10:03:02 ,  阅读 219

5


2
算法1
(RMQ算法) O(nlogn)O(nlogn)
题中数据量比较大，查询也比较多，寻常的平方复杂度一定会超时，这里采用RMQ算法，实际上就是用动态规划预先处理数据，查询时时间复杂度是常数级。

首先定义f[i,j]为以第i个数为起点，长度为2^j的一段区间中的最大值，显然状态转移为

f[i,j] = max(f[i,j-1],f[i+2^(j-1),j-1])

这样的话可以在nlogn的时间下完成f数组的建立，下边是区间最大值的查询，对于区间[l,r]，存在一个k使得r-l+1>=2^k且r-l+1<2^(k+1),这样的话区间[l,r]的最大值就是max(f[l,k],f[r-2^k+1,k]),查询可以在常数级完成。

C++ 代码
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int N = 200010,M = 18;
int a[N];
int n,m;
int f[N][M];

int main(){
    cin>>n;
    for(int i = 1;i<=n;i++)cin>>a[i];

    for(int j = 0;j<M;j++){
        for(int i = 1;i+(1<<j)-1<=n;i++)
            if(!j)f[i][j] = a[i];
            else f[i][j] = max(f[i][j-1],f[i+(1<<j-1)][j-1]);
    }


    cin>>m;
    while(m--){
        int l,r;
        cin>>l>>r;
        int len = r-l+1;
        int k = log(len)/log(2);
        cout<< max(f[l][k],f[r-(1<<k)+1][k])<<endl;;
    }
    return 0;
}

作者：负壹
链接：https://www.acwing.com/solution/content/14969/
 


#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 200010, M = 18;

int n, m;
int w[N];
int f[N][M];

void init()
{
    for (int j = 0; j < M; j ++ )
        for (int i = 1; i + (1 << j) - 1 <= n; i ++ )
            if (!j) f[i][j] = w[i];
            else f[i][j] = max(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);
}

int query(int l, int r)
{
    int len = r - l + 1;
    int k = log(len) / log(2);

    return max(f[l][k], f[r - (1 << k) + 1][k]);
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);

    init();

    scanf("%d", &m);
    while (m -- )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", query(l, r));
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/205231/
 


AcWing 1292. 哥德巴赫猜想    原题链接    简单
作者：    小呆呆 ,  2020-04-15 17:09:33 ,  阅读 130

2


算法分析
暴力想法：

for(a = 3;;a ++)
    b = n - 3;
    if(a 和 b都是质数)
    {
        print;
        break;
    }
此方法的时间复杂度是O(nn‾√)O(nn),会gg

优化解法

1、先预处理出106106以内的所有质数，
2、如下伪代码
for(a = 所有质数)
    b = n - a
    if(!st[b])
    {
        print;
        break;
    }
由于从1到n中，约有nlnnnlnn个质数，运行的次数是106+T∗106ln106106+T∗106ln106
时间复杂度 106+T∗106ln106106+T∗106ln106
Java代码
import java.util.Scanner;

public class Main {
    static int N = 1000010;
    static int[] primes = new int[N];
    static int cnt = 0;
    static boolean[] st = new boolean[N];
    static void init()
    {
        for(int i = 2;i <= N - 1;i ++)
        {
            if(!st[i]) primes[cnt ++] = i;
            for(int j = 0;primes[j] * i <= N - 1;j ++)
            {
                st[primes[j] * i] = true;
                if(i % primes[j] == 0) break;
            }
        }
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        init();

        while(true)
        {
            int n = scan.nextInt();
            if(n == 0) break;
            for(int i = 1;;i ++)
            {
                int a = primes[i];
                int b = n - a;
                if(!st[b])
                {
                    System.out.println(n +" = " + a + " + " + b);
                    break;
                }
            }
        }
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/11581/
 


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>


using namespace std;

const int N = 1000010;

int primes[N], cnt;
bool st[N];

void init(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int main()
{
    init(N - 1);

    int n;
    while (cin >> n, n)
    {
        for (int i = 1; ; i ++ )
        {
            int a = primes[i];
            int b = n - a;
            if (!st[b])
            {
                printf("%d = %d + %d\n", n, a, b);
                break;
            }
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/172842/
 

AcWing 1293. 夏洛克和他的女朋友    原题链接    简单
作者：    TaoZex ,  2020-01-31 18:06:06 ,  阅读 209

3


让他给这些珠宝染色，使得一件珠宝的价格是另一件珠宝的价格的质因子时，两件珠宝的颜色不同。

即从一个质数向合数连一条边，最后会构成二分图即从一个质数向合数连一条边，最后会构成二分图
注：质数之间彼此互质没有连边，合数之间不满足题意也没有连边注：质数之间彼此互质没有连边，合数之间不满足题意也没有连边
当n<=2时只有质数，输出1，由二分图可知其他情况均为2当n<=2时只有质数，输出1，由二分图可知其他情况均为2
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
int primes[N],cnt;
bool st[N];

void init(int n){
    for(int i=2;i<=n;i++){
        if(!st[i]) primes[cnt++]=i;
        for(int j=0;primes[j]*i<=n;j++){
            st[primes[j]*i]=true;
            if(i%primes[j]==0) break;
        }
    }
}

int main(){
    int n;
    cin>>n;

    init(n+1);

    if(n<=2) puts("1");
    else puts("2");

    for(int i=2;i<=n+1;i++){    //他买了 n 件珠宝，第 i 件的价值是 i+1
        if(!st[i]) printf("1 ");    //!st为true代表素数
        else printf("2 ");
    }
    return 0;
}

作者：TaoZex
链接：https://www.acwing.com/solution/content/7602/
 


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int primes[N], cnt;
bool st[N];

void init(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[i * primes[j]] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int main()
{
    int n;
    cin >> n;

    init(n + 1);

    if (n <= 2) puts("1");
    else puts("2");

    for (int i = 2; i <= n + 1; i ++ )
        if (!st[i]) printf("1 ");
        else printf("2 ");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/172854/
 

AcWing 196. 质数距离    原题链接    中等
作者：    小呆呆 ,  2020-04-15 21:51:26 ,  阅读 340

7


算法分析
二次筛法
这里的区间范围给定的最大值是2^31 - 1,而用线性筛法求的是[1,n]中的所有质数，因此直接用线性筛法求肯定会直接gg，因此需要通过挖掘某些性质，才能有技巧性的完成，y总的视频讲得实在太好了，不得不为他点赞

性质
性质1：若一个数n是一个合数，必然存在2个因子dd,ndnd，假设dd <= ndnd，则dd <= n‾√n，因此必然存在一个小于等于 n‾√n的因子

性质2：若x∈∈[L,R],且x是合数，则一定存在P <= 231−1‾‾‾‾‾‾‾√231−1 (< 50000)，使得P能整除x，其中P < x.

步骤
1、找出1 ~ 231−1‾‾‾‾‾‾‾√231−1 (< 50000)中的所有质因子
2、对于1 ~ 50000 中每个质数P，将[L,R]中所有P的倍数筛掉(至少2倍)
找到大于等于L的最小的P的倍数P0P0，找下一个倍数时只需要+= P即可
引理(分数的上取整转换下取整)


细节
ly20 同学在y总的代码 问的3个很高质量的问题，也是很细节的地方，感谢ly20 同学

（1）每个质数是2~50000中的数，为啥 LL p = primes[i]; 这里的p的LL啊， int 不就够了吗？
（2）for (LL j = max(p * 2, (l + p - 1) / p * p); j <= r; j += p) 这里的 j 是小于等于 r 的，而 r 的取值范围是小于2 ^ 31，也是在int 范围内啊， 这里为啥用LL啊？
（3） 我知道这里是复用st数组，但是在用之前都初始化为0了啊，为什么init(50000); 放在while (cin >> l >> r) 的外面（也就是最前面）代码不行啊？
回答：

(1)LL p = primes[i]，这里p用LL是因为如果p也是用int类型，本身l也是用int类型，如果l取得足够大，下面的l + p - 1会有可能直接爆int变成负数
(2)这里的 j 是小于等于 r 的，而 r 的取值范围是小于2 ^ 31,这里确实是这样，可是这个循环跳出的条件是j <= r，也就是说如果r是最大的int，那么当j += p，要超过最大的int的时候需要比它还大才能跳出循环，因此直接爆int变成负数，然后j <= r依然成立，会一直死循环下去
(3)放在最前面也是可以的，y总的代码中判断从[1,50000]中谁是质数和在区间[L,R]中谁是质数直接复用st[]数组，就不用再开一个数组去存了，也可以把init()放在前面，用一个专门的数组去记录区间[L,R]中谁是质数
时间复杂度 O(n)O(n)
参考文献
算法提高课

Java 代码
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    static int N = 50010;
    static int M = 1000010;
    static int[] primes = new int[N];
    static int cnt = 0;
    static boolean[] st = new boolean[N];
    static boolean[] bool = new boolean[M];//存[L,R]的元素是否是质数
    static int[] primes2 = new int[M];
    static void init(int n)
    {
        for(int i = 2;i <= n;i ++)
        {
            if(!st[i]) primes[cnt ++] = i;
            for(int j = 0;primes[j] * i <= n;j ++)
            {
                st[primes[j] * i] = true;
                if(i % primes[j] == 0) break;
            }
        }
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        init(50000);
        while(scan.hasNext())
        {
            int l = scan.nextInt();
            int r = scan.nextInt();
            Arrays.fill(bool, false);
            Arrays.fill(primes2, 0);
            for(int i = 0;i < cnt;i ++)
            {
                long p = primes[i];
                for(long j = Math.max(2 * p, (l + p - 1) / p * p);j <= r;j += p)
                    bool[(int)(j - l)] = true;
            }
            int k = 0;
            for(int i = 0;i <= r - l;i ++)
            {
                if(!bool[i] && i + l >= 2)
                    primes2[k ++] = i + l;
            }
            if(k < 2) System.out.println("There are no adjacent primes.");
            else
            {
                int minp = 0,maxp = 0;//最小、大距离的位置
                for(int i = 0;i + 1 < k;i ++)
                {
                    int d = primes2[i + 1] - primes2[i];
                    if(d < primes2[minp + 1] - primes2[minp]) minp = i;
                    if(d > primes2[maxp + 1] - primes2[maxp]) maxp = i;
                }
                System.out.println(primes2[minp] + "," + primes2[minp + 1] + " are closest, "+ primes2[maxp] +"," + primes2[maxp + 1] + " are most distant.");
            }
        }
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/11586/
 

分析

对于每个合数 xx，一定存在一个 ≤sqrt(x)≤sqrt(x) 的质因子 pp，那么对于极限数据而言，(231−1)‾‾‾‾‾‾‾‾√(231−1)约 5×1045×104，因此 [l,r][l,r] 内任何一个合数，都存在一个 5×1045×104 以内的质因子。
因此我们可以线性筛出 5×1045×104 内的质数，再用埃氏筛思想筛去 [l,r][l,r] 内的所有合数。
维护 [l,r][l,r] 区间时，不可能开一个 [1,r][1,r] 的数组，我们做离散化处理，用 [0,r−l][0,r−l] 表示 [l,r][l,r]。
数学知识：大于等于 ll 的 jj 的最小倍数为 ⌈lj⌉×j=⌊l+j−1j⌋×j⌈lj⌉×j=⌊l+j−1j⌋×j。
注意点

我们用 [0,50000][0,50000] 内的质数 jj，筛去 [l,r][l,r] 区间大于 jj 的 jj 的倍数，因此如果区间内包含 11，是无法将 11 筛去的，因为最小的质数为 22，用 22 无法筛去 11，因此需要特判。
在筛倍数的时候，for循环每次+j，会爆int，因此开long long。
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 1000010;

int l, r;
int primes[N], cnt;
bool st[N];

void euler(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) primes[cnt++] = i;
        for (int j = 0; primes[j] <= n / i; j++) {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int main() {
    euler(50000);
    while (cin >> l >> r) {
        memset(st, false, sizeof st);
        for (int i = 0; i < cnt; i++) {
            LL j = primes[i];
            for (LL k = max(2 * j, (l + j - 1) / j * j); k <= r; k += j) {
                st[k - l] = true;
            }
        }
        vector<int> res;
        if (l == 1) st[0] = true;
        for (int i = 0; i <= r - l; i++) {
            if (!st[i]) res.push_back(i + l);
        }
        if (res.size() < 2) {
            puts("There are no adjacent primes.");
        } else {
            int minv = N, maxv = 0, minr, maxr;
            for (int i = 1; i < res.size(); i++) {
                int d = res[i] - res[i - 1];
                if (d > maxv) maxv = d, maxr = i;
                if (d < minv) minv = d, minr = i;
            }
            printf("%d,%d are closest, %d,%d are most distant.\n", 
                res[minr - 1], res[minr], res[maxr - 1], res[maxr]);
        }
    }
    return 0;
}

作者：番茄酱
链接：https://www.acwing.com/activity/content/code/content/173866/
 

AcWing 197. 阶乘分解    原题链接    中等
作者：    秦淮岸灯火阑珊 ,  2019-02-09 09:37:11 ,  阅读 1591

4


1
因为我们有一个质因子p已经出现过了,所以我们并需要乘以2.(乘以二,是因为我们是在统计质因子出现的次数)
这句话错误的,已经删除了.

原题链接
更好的阅读体验

题目描述
给定整数 N ，试把阶乘 N!N! 分解质因数，按照算术基本定理的形式输出分解结果中的 pipi 和 cici 即可。

输入格式
一个整数NN。

输出格式
N!N! 分解质因数后的结果，共若干行，每行一对pi,cipi,ci，表示含有picipici项。按照pi从小到大的顺序输出。

数据范围
1≤N≤1061≤N≤106
样例
输入样例：
5
输出样例：
2 3
3 1
5 1
样例解释
5!=120=23∗3∗55!=120=23∗3∗5
数学性质(质因数分解)
首先可以排出的方法,就是把1~N中每一个数字都质因数分解,这种方法复杂度太高了,淘汰.
正确的数学姿态是:我们发现N!中质数因子p的个数,就是1~N中每个数含有的质因数p个数.既然如此的话,那么我们发现,至少有一个质因子p的显然有[np][np]个,而至少有两个质因子p数的显然是有[np2][np2]
C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
long long p[N],vis[N],n,m;
long long zs(long long n)//素数筛
{
    for(long long i=2;i<=n;i++)
    {
        if (!vis[i])
            p[++p[0]]=i;
        for(long long j=2;j<=n/i;j++)
            vis[i*j]=1;
    }
}
long long power(long long a,long long b)//快速幂
{
    long long ans=1;
    while(b)
    {
        if (b&1)
            ans=ans*a;
        a*=a;
        b>>=1;
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    zs(n);
    for(long long i=2;i<=n;i++)
        if (!vis[i])
        {
            long long ans=0;
            cout<<i<<" ";
            for(long long k=1;power(i,k)<=n;k++)//统计p出现的次数
                ans=ans+n/power(i,k);
            cout<<ans<<endl;
        }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/982/
 


（文章链接 ）
#include<cstdio>
#include<iostream>
using namespace std;
const int MAXN=1e6;
int primes[MAXN],primeCnt=0;
bool notPrime[2*MAXN];
void initPrime(int x){
    for(int i=2;i<=x;i++){
        if(notPrime[i])continue;
        for(int j=2;j<=x/i;j++){
            notPrime[i*j]=1;
        }
    }
    for(int i=2;i<=x;i++)
        if(!notPrime[i])primes[++primeCnt]=i;
}
int ans[MAXN],ansValue[MAXN];
int main(){
    int n;
    scanf("%d",&n);
    initPrime(n);
    for(int i=1;i<=primeCnt;i++){
        int tmpN=n,nowPrime=primes[i],nowAns=0;
        while(tmpN){
            nowAns+=(tmpN/nowPrime);
            tmpN/=nowPrime;
        }
        printf("%d %d\n",nowPrime,nowAns);
    }
    return 0;
}

作者：Object_
链接：https://www.acwing.com/solution/content/4960/
 

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1000010;

int primes[N], cnt;
bool st[N];

void init(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[i * primes[j]] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int main()
{
    int n;
    cin >> n;
    init(n);

    for (int i = 0; i < cnt; i ++ )
    {
        int p = primes[i];
        int s = 0;
        for (int j = n; j; j /= p) s += j / p;
        printf("%d %d\n", p, s);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/172909/
 


AcWing 1289. 序列的第k个数    原题链接    简单
作者：    小呆呆 ,  2020-04-16 16:53:30 ,  阅读 125

4


算法分析
是否存在a,b,c，使得a，b，c既是一个等差数列，也是一个等比数列
证明：

若a,b,c是一个等差数列，因此a + c = 2b(1)
若a,b,c是一个等比数列，因此(2)a * c = b^2(2)
对(2)乘上4,得到4 * a * c = 4 * b^2(3)
对(1)两边加平方，得到(a + c)^2 = 4 * b^2(4)
联立(3)，(4)可得(a - c)^2 = 0，即a = c = b
因此当且仅当a == b == c时，它既是一个公差为0的等差数列也是一个公比为1的等比数列，因此它的第k项用等差数列和等比数列求出来的结果是一样的

两种情况
情况1：若a,b,c是一个等差数列，则第k项是a + (c - b) * (k - 1)
情况2：若a,b,c是一个等比数列，则第k项是a * (b / c)^(k - 1)，其中b / c一定是一个整数，用快速幂求解
时间复杂度 O(logn)O(logn)
参考文献
算法提高课

Java 代码
import java.util.Scanner;

public class Main {
    static int mod = 200907;
    static long qmi(int a,int k)
    {
        long res = 1 % mod;
        long t = a;
        while(k > 0)
        {
            if((k & 1) != 0) res = res * t % mod;
            k >>= 1;
            t = t * t % mod;
        }
        return res;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int T = scan.nextInt();
        while(T -- > 0)
        {
            int a = scan.nextInt();
            int b = scan.nextInt();
            int c = scan.nextInt(); 
            int k = scan.nextInt();
            if(a + c == 2 * b) System.out.println((a + (long)(c - b) * (k - 1)) % mod);
            else System.out.println(a * qmi(c / b,k - 1) % mod);
        }
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/11635/
 

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int mod = 200907;

int qmi(int a, int k)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % mod;
        a = (LL)a * a % mod;
        k >>= 1;
    }
    return res;
}

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int a, b, c, k;
        cin >> a >> b >> c >> k;
        if (a + c == b * 2) cout << (a + (b - a) * (LL)(k - 1)) % mod << endl;
        else cout << (LL)a * qmi(b / a, k - 1) % mod << endl;
    }

    return 0;


作者：yxc
链接：https://www.acwing.com/activity/content/code/content/172923/
 

AcWing 1290. 越狱    原题链接    简单
作者：    Dear_You ,  2020-01-14 10:54:23 ,  阅读 314

2


upd:2020.9.01

题目描述
监狱有连续编号为 1 到 n 的 n 个房间，每个房间关押一个犯人。

有 m 种宗教，每个犯人可能信仰其中一种。

如果相邻房间的犯人信仰的宗教相同，就可能发生越狱。

求有多少种状态可能发生越狱。

分析
正着不行那就反向思考,即有多少种不会发生越狱的情况,对于第一个人，有m种，之后呢因为不能和前面相

同，所以只有m-1种，总方案数减去不能越狱的方案数就是答案了

C++ 代码
#include<bits/stdc++.h>
#define ll long long
#define MOD 100003
using namespace std;
ll n,m;

inline ll quickpow(ll m,ll n){
    ll ans=1;
    for (;n;n>>=1){
        if(n&1) ans=(ans*m)%MOD;
        m=m*m%MOD;
    }
    return ans;
}

int main(){
    scanf("%lld%lld",&m,&n);
    ll zong=quickpow(m,n);
    ll x1=m*quickpow(m-1,n-1)%MOD;

    printf("%lld\n",(zong-x1+MOD)%MOD);
}

作者：Dear_You
链接：https://www.acwing.com/solution/content/7559/
 

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int mod = 100003;

int qmi(int a, LL k)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % mod;
        a = (LL)a * a % mod;
        k >>= 1;
    }
    return res;
}

int main()
{
    int m;
    LL n;
    cin >> m >> n;

    cout << (qmi(m, n) - (LL)m * qmi(m - 1, n - 1) % mod + mod) % mod << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/172934/
 

AcWing 1291. 轻拍牛头    原题链接    简单
作者：    mur ,  2020-02-17 14:52:02 ,  阅读 141

2


小优化
对y老师的代码的小优化，问题求其他的数中有多少个是它的约数。计算s数组时，故只需统计输入的数据。

C++ 代码
#include <iostream>
using namespace std;

const int N = 1000010;

int a[N], cnt[N], s[N];

int main()
{
    int n;
    cin >> n;

    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
        cnt[a[i]]++; //a[i]的个数
    }

    for (int i = 1; i < N; i++) //预处理约数为a[i]的数
    {
        for (int j = i; j < N; j += i) 
        {
            if (cnt[i]) s[j] += cnt[i]; //只统计输入的数据
        }
    }

    for (int i = 0; i < n; i++) cout << s[a[i]] - 1 << endl; //不包括自己
}

作者：mur
链接：https://www.acwing.com/solution/content/8674/
 

把 if (cnt[i]) 移到第二次循环外面会更快


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1000010;

int n;
int a[N], cnt[N], s[N];

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ )
    {
        scanf("%d", &a[i]);
        cnt[a[i]] ++ ;
    }

    for (int i = 1; i < N; i ++ )
        for (int j = i; j < N; j += i)
            s[j] += cnt[i];

    for (int i = 0; i < n; i ++ ) printf("%d\n", s[a[i]] - 1);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/174305/
 

AcWing 1294. 樱花    原题链接    中等
作者：    yingzhaoyang ,  2020-01-14 14:22:53 ,  阅读 237

9


题目描述
题意:求不定方程1x+1y=1n!1x+1y=1n!的正整数解的个数.
(xx,yy为未知数,nn为给定的数)

样例
输入样例: 1439 

输出样例: 102426508

线性筛素数(主要算法:数学推导)
下面是玄学数学推导时间:

因为
1x+1y=1n!
1x+1y=1n!

可以很轻松地看出 1x1x和1y1y是小于1n!1n!的,于是由小学知识可知xx和yy是大于n!n!的.

于是,我们令
y=n!+k(k∈N∗)
y=n!+k(k∈N∗)
于是,原式变为
1x+1n!+k=1n!
1x+1n!+k=1n!
两边通分,得
n!×(n!+k)+x×n!=x×(n!+k)
n!×(n!+k)+x×n!=x×(n!+k)
整理,得
x=(n!)2k+k
x=(n!)2k+k
分析至此,已经比较明晰了.

因为xx是正整数,则(n!)2k+k(n!)2k+k也必须为正整数.

又因为k∈N∗k∈N∗,故只需(n!)2k(n!)2k为正整数即可.

由于kk可以为任意正整数,故kk只需取(n!)2(n!)2的约数即可.

此时x=(n!)2k+kx=(n!)2k+k为正整数,y=n!+ky=n!+k也为正整数,故这样的kk是满足题意的.

所以本题的实质其实是:
求(n!)2的正约数个数和
求(n!)2的正约数个数和
玄学数学推导终于结束了…

接下来才是真正与算法有关的部分了.
我们知道,一个正整数可以被唯一分解为
N=pc11⋅pc22⋅pc33⋯pcmm
N=p1c1⋅p2c2⋅p3c3⋯pmcm
其中cici均为正整数,pipi均为质数,且满足p1<p2<p3<⋯<pmp1<p2<p3<⋯<pm
则NN的正约数个数为
(c1+1)⋅(c2+1)⋅(c3+1)⋅⋯⋅(cm+1)=∏i=1m(ci+1)
(c1+1)⋅(c2+1)⋅(c3+1)⋅⋯⋅(cm+1)=∏i=1m(ci+1)
所以我们只需找出所有的cici即可.

为了提高效率,我们采用线性筛素数的方法,先找出n!n!的质因子,再通过分解质因数的方法找出所有的cici即可.

注意我们这里只是找出了n!n!的所有的cici,而题目要求的是(n!)2(n!)2的约数个数,所以统计时一定要乘2!!!!

因为平方过后,n!n!的所有cici都变为了2ci2ci.(这个应该可以理解吧....)

还有一件事,记得取模(此事非常重要)!!!!

自此,你就完美的解决了这道题.

时间复杂度 O(nlogn)O(nlogn)
C++ 代码
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll MAX=1e6+1;
const ll mod=1e9+7;
ll n,ans=1;
ll c[MAX],prime[MAX];//c[i]为指数 
ll flag[MAX],s[MAX];
int tot;
inline void Linear()//线性筛素数 (查找1到n中每个数的最小质因子并记录位置)
{
    for(int i=2;i<=n;i++){
        if(!flag[i]){
            prime[++tot]=i;
            s[i]=tot;   
        }
        for(int j=1;j<=tot&&i*prime[j]<=n;j++){
            flag[i*prime[j]]=1;
            s[i*prime[j]]=j;// s[i] 表示 i 的最小质因子在prime数组中的位置 
            if(i%prime[j]==0)
                break;
        }
    }
}
inline void divide(int x)//将x分解质因数 
{
    while(x!=1){
        ++c[s[x]];//s[x]为x的最小质因子，c[s[x]]表示s[x]这个质因子的指数 
        x/=prime[s[x]];//分解 
    }
}
int main()
{
    scanf("%lld",&n);
    Linear();
    for(int i=1;i<=n;i++)
        divide(i);
    for(int i=1;i<=MAX;i++)
        if(c[i])
            ans=ans*(2*c[i]+1)%mod;//注意这里要乘二,因为最后统计的是n!的约数个数,而不是n!,所以所有的ci要变为2*ci
    printf("%lld\n",ans);
    return 0;
}

作者：yingzhaoyang
链接：https://www.acwing.com/solution/content/7562/
 
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e6 + 10, mod = 1e9 + 7;

int primes[N], cnt;
bool st[N];

void init(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int main()
{
    int n;
    cin >> n;

    init(n);

    int res = 1;
    for (int i = 0; i < cnt; i ++ )
    {
        int p = primes[i];
        int s = 0;
        for (int j = n; j; j /= p) s += j / p;
        res = (LL)res * (2 * s + 1) % mod;
    }

    cout << res << endl;


    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/174318/
 

AcWing 198. 反素数    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-09 11:39:40 ,  阅读 1385

7


1
原题链接

题目描述
对于任何正整数x，其约数的个数记作g(x)，例如g(1)=1、g(6)=4。

如果某个正整数x满足：对于任意的小于x的正整数 i，都有g(x)>g(i) ，则称x为反素数。

例如，整数1，2，4，6等都是反素数。

现在给定一个数N，请求出不超过N的最大的反素数。

输入格式
一个正整数N。

输出格式
一个整数，表示不超过N的最大反素数。

数据范围
1≤N≤2∗1091≤N≤2∗109
样例
输入样例：
1000
输出样例：
840
数学性质(质因数分解)
首先我们来三个性质
1~N中最大的反质数,就是1~N中约数个数最多的数中最小的一个.因为,如果不是最小的那一个,必然会出现g(x)=g(i)g(x)=g(i)
1~N中任何数的不同质因子都不会超过10个,因为2∗3∗5∗7∗11∗13∗17∗19∗23∗29∗31>2∗1092∗3∗5∗7∗11∗13∗17∗19∗23∗29∗31>2∗109,且所有质因数的指数总和不超过30,因为231>2∗109231>2∗109.
x的质因子是连续的若干个最小的质数,且质数的指数单调递减.如果说我们选择的质数不是连续的,也就是A1∗A3A1∗A3,那么我还不如选择A1∗A2A1∗A2,因为这样数还更小.至于指数问题,如果说c1<c2c1<c2,那么c1+1c1+1,c2−1c2−1会是的我们乘积更加小,而且约数个数不变.x=A1C1∗A2C2∗A3C3∗......∗AnCnx=A1C1∗A2C2∗A3C3∗......∗AnCn
根据上面一系列性质,我们得出了最简洁的思路,使用DFS,尝试确定前十个质数的指数,然后满足指数单调递减,总乘积不超过N,且同时记录约数的个数
C++ 代码
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define INF 2e9
ll zs[11]={0,2,3,5,7,11,13,17,19,23,29},c[11],ans=INF,cnt_ans=1,n;
void dfs(ll now, ll num, ll cnt)
{
    if (now==11) 
    {
        if (cnt>cnt_ans || (cnt==cnt_ans && ans>num))
        {
            cnt_ans=cnt;
            ans=num;
        }
        return;
    }
    ll num_cnt=num;
    for (int i=0;i<=c[now-1];i++)
    {
        if (num_cnt>n)
            return;
        c[now]=i;
        dfs(now+1,num_cnt,cnt*(i+1));
        num_cnt*=zs[now];
    }
}
int main() 
{
    cin>>n;
    c[0]=INF;
    dfs(1,1,1);
    cout<<ans<<endl;
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/985/
 

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

int primes[9] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
int maxd, number;
int n;

void dfs(int u, int last, int p, int s)
{
    if (s > maxd || s == maxd && p < number)
    {
        maxd = s;
        number = p;
    }

    if (u == 9) return;

    for (int i = 1; i <= last; i ++ )
    {
        if ((LL)p * primes[u] > n) break;
        p *= primes[u];
        dfs(u + 1, i, p, s * (i + 1));
    }
}

int main()
{
    cin >> n;

    dfs(0, 30, 1, 1);

    cout << number << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/174335/
 


AcWing 200. Hankson的趣味题    原题链接    中等
作者：    yxc ,  2019-07-28 17:47:13 ,  阅读 1109

14


3
算法
(数论) O(nb1‾‾√/log(b1))O(nb1/log(b1))
由于 [x,b0]=b1[x,b0]=b1，因此 xx 一定是 b1b1 的约数。
所以我们可以枚举 b1b1 的所有约数，然后依次判断是否满足 [x,b0]=b1[x,b0]=b1 以及 (x,a0)=a1(x,a0)=a1 即可。

如果直接用试除法求 b1b1 的所有约数，那么总计算量是 nb1‾‾√=2000∗2×109‾‾‾‾‾‾‾√≈108nb1=2000∗2×109≈108，会有一个测试数据超时。

我们可以先预处理出 1∼b1‾‾√1∼b1 内的所有质数，然后用这些质数去试除 b1b1。由质数定理：

1∼n1∼n 中的质数个数约为 nln(n)nln(n)。

因此我们可以在 bi‾‾√/log(bi)bi/log(bi) 的时间复杂度内将 b1b1 分解质因数。然后通过DFS枚举出 b1b1 的所有约数。

时间复杂度分析
一共 nn 组测试数据，每组测试数据分解 b1b1 的计算量是 nb1‾‾√/log(b1)≈107nb1/log(b1)≈107。

平均每个数的约数个数为 lognlogn 个，计算最小公倍数和最大公约数的时间复杂度也是 O(logn)O(logn)，因此判断 xx 是否合法的计算量是 nlog2n≈2×106nlog2n≈2×106。

C++ 代码
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL;
typedef pair<int, int> PII;

const int N = 45000, M = 50;

int primes[N], cnt;
bool st[N];

PII factor[M];
int cntf;

int divider[N], cntd;

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

void dfs(int u, int p)
{
    if (u > cntf)
    {
        divider[cntd ++ ] = p;
        return;
    }

    for (int i = 0; i <= factor[u].second; i ++ )
    {
        dfs(u + 1, p);
        p *= factor[u].first;
    }
}

int main()
{
    get_primes(N);

    int n;
    scanf("%d", &n);
    while (n -- )
    {
        int a0, a1, b0, b1;
        scanf("%d%d%d%d", &a0, &a1, &b0, &b1);

        int d = b1;
        cntf = 0;
        for (int i = 0; primes[i] <= d / primes[i]; i ++ )
        {
            int p = primes[i];
            if (d % p == 0)
            {
                int s = 0;
                while (d % p == 0) s ++, d /= p;
                factor[ ++ cntf] = {p, s};
            }
        }
        if (d > 1) factor[ ++ cntf] = {d, 1};

        cntd = 0;
        dfs(1, 1);

        int res = 0;
        for (int i = 0; i < cntd; i ++ )
        {
            int x = divider[i];
            if (gcd(x, a0) == a1 && (LL)x * b0 / gcd(x, b0) == b1)
            {

                res ++ ;
            }
        }

        printf("%d\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/solution/content/3101/
 

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 50010;

int primes[N], cnt;
bool st[N];
struct Factor
{
    int p, s;
}factor[10];
int fcnt;

int dividor[1601], dcnt;

void init(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

void dfs(int u, int p)
{
    if (u == fcnt)
    {
        dividor[dcnt ++ ] = p;
        return;
    }

    for (int i = 0; i <= factor[u].s; i ++ )
    {
        dfs(u + 1, p);
        p *= factor[u].p;
    }
}

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

int main()
{
    init(N - 1);

    int n;
    cin >> n;
    while (n -- )
    {
        int a, b, c, d;
        cin >> a >> b >> c >> d;

        fcnt = 0;
        int t = d;
        for (int i = 0; primes[i] <= t / primes[i]; i ++ )
        {
            int p = primes[i];
            if (t % p == 0)
            {
                int s = 0;
                while (t % p == 0) t /= p, s ++ ;
                factor[fcnt ++ ] = {p, s};
            }
        }

        if (t > 1) factor[fcnt ++ ] = {t, 1};

        dcnt = 0;
        dfs(0, 1);

        int res = 0;
        for (int i = 0; i < dcnt; i ++ )
        {
            int x = dividor[i];
            if (gcd(a, x) == b && (LL)c * x / gcd(c, x) == d) res ++ ;
        }

        cout << res << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/174349/
 

AcWing 201. 可见的点    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-22 17:27:35 ,  阅读 847

4


1
原题链接
更好的阅读体验

题目描述
在一个平面直角坐标系的第一象限内，如果一个点(x,y)(x,y)与原点(0,0)(0,0)的连线中没有通过其他任何点，则称该点在原点处是可见的。

例如，点(4,2)(4,2)就是不可见的，因为它与原点的连线会通过点(2,1)(2,1)。

部分可见点与原点的连线如下图所示：



编写一个程序，计算给定整数N的情况下，满足0≤x,y≤N0≤x,y≤N的可见点(x,y)(x,y)的数量（可见点不包括原点）。

输入格式
第一行包含整数C，表示共有C组测试数据。

每组测试数据占一行，包含一个整数N。

输出格式
每组测试数据的输出占据一行。

应包括：测试数据的编号（从1开始），该组测试数据对应的N以及可见点的数量。

同行数据之间用空格隔开。

数据范围
1≤N,C≤10001≤N,C≤1000
样例
输入样例：
4
2
4
5
231
输出样例：
1 2 5
2 4 13
3 5 21
4 231 32549
欧拉函数 O(NlogN)O(NlogN)
分析这道题目,我们发现除了(1,0),(0,1),(1,1)三个钉子,其他钉子被看到,只有满足了1≤x,y≤N,x≠y1≤x,y≤N,x≠y 而且gcd(x,y)=1gcd(x,y)=1
然后我们再次发现,能够看到的钉子,是沿着(0,0)(n,n)(0,0)(n,n)这条直线对称的,所以我们只要考虑其中一半就好了,然后最后乘以2即可.
然后满足上述性质的钉子,x的数量恰好就是φ(y)φ(y)
有了性质的数学题目是什么,就是直接套公式.ans=3+2∗∑Ni=2φ(i)ans=3+2∗∑i=2Nφ(i) 然后我们就只需要利用类似于素数筛选法一样的东西,筛选欧拉函数即可.
C++ 代码
//SDOI仪仗队,和这道题目极为类似,或者说一模一样,只不过不是多组数据.
#include<bits/stdc++.h>
using namespace std;
const int N=41000;
long long phi[N],n,ans;
void euler(long long n)
{
    for(long long i=2; i<=n; i++)
        phi[i]=i;
    for(long long i=2; i<=n; i++)
        if (phi[i]==i)
            for(long long j=i; j<=n; j+=i)
                phi[j]=phi[j]/i*(i-1);
}
int main()
{
    cin>>n;
    n--;
    euler(n);
    for(long long i=2; i<=n; i++)
        ans=ans+2*phi[i];
    if (n==0)
        cout<<0<<endl;
    else
        cout<<ans+3;
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1053/
 

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int primes[N], cnt;
bool st[N];
int phi[N];

void init(int n)
{
    phi[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[i * primes[j]] = true;
            if (i % primes[j] == 0)
            {
                phi[i * primes[j]] = phi[i] * primes[j];
                break;
            }
            phi[i * primes[j]] = phi[i] * (primes[j] - 1);
        }
    }
}

int main()
{
    init(N - 1);

    int n, m;
    cin >> m;
    for (int T = 1; T <= m; T ++ )
    {
        cin >> n;
        int res = 1;
        for (int i = 1; i <= n; i ++ ) res += phi[i] * 2;
        cout << T << ' ' << n << ' ' << res << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/174364/
 

AcWing 220. 最大公约数(通俗易懂&效率高)    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-08-01 22:55:27 ,  阅读 1007

13


5
更好的阅读体验

题目
题目描述
给定整数NN，求1≤x,y≤N1≤x,y≤N且gcd(x,y)gcd(x,y)为素数的数对(x,y)(x,y)有多少对。

gcd(x,y)gcd(x,y)即求x，yx，y的最大公约数。

输入格式
输入一个整数N

输出格式
输出一个整数，表示满足条件的数对数量。

数据范围
1≤N≤107
1≤N≤107
输入样例：
4
输出样例：
4
解题报告
题意理解
就是要找统计一类特殊数对.

要求两个数,他们的最大公约数为素数.

算法解析
这道题目思路比较清晰,除了算法基础课上的欧拉函数,完全没有高级数学知识,只有最大公约数,乘法这些数学知识,而且公式都非常简短,可以放心食用.违背了数学题目的常识

我们先来下定义.
a=x×dx为任意正整数b=y×dy为任意正整数d为素数
a=x×dx为任意正整数b=y×dy为任意正整数d为素数

那么什么时候才会出现
gcd(a,b)=d
gcd(a,b)=d

也就是题目要求统计的数对呢?

我们思索一下,什么是最大公约数,不就是两个数的最大公因子吗?

那么我们把定义放入进去.
a=x×db=y×dgcd(a,b)=gcd(x×d,y×d)=dgcd(a,b)=d×gcd(x,y)
a=x×db=y×dgcd(a,b)=gcd(x×d,y×d)=dgcd(a,b)=d×gcd(x,y)

此时我们应该很好看出来了,一个a,ba,b为合法数对的条件了.
gcd(x,y)=1x,y必须互素
gcd(x,y)=1x,y必须互素

否则的话,我们观察发现
gcd(a,b)=d×gcd(x,y)如果不满足gcd(x,y)=1的话d×gcd(x,y)≠d
gcd(a,b)=d×gcd(x,y)如果不满足gcd(x,y)=1的话d×gcd(x,y)≠d

一个素数乘以一个大于1的数字,请问还有可能是素数吗?

显然是不可能的.

所以我们就证明了这个性质.

既然如此的话,我们发现了性质,那么就要推导公式了.

对于一个素数dd而言.他在11~nn中显然有这些数.
d,d×2,d×3,…,d×k.d×k≤n
d,d×2,d×3,…,d×k.d×k≤n

我们发现gcd(a,b)=dgcd(a,b)=d的数对,只能从上面这个式子中选择.

因为最大公约数是dd,所以必须有共同因子dd.

那么我们再来简化数列,也就是上面式子,都抛去d.
a/=db/=d.
a/=db/=d.

那么a,ba,b就会从下面这个数列中选择
1,2,3,…k
1,2,3,…k

我们再来分析.

因为合法数对a,ba,b都除以dd这个最大公约数,所以此时.
gcd(a,b)=d==>gcd(a/d,b/d)=1
gcd(a,b)=d==>gcd(a/d,b/d)=1

总而言之,言而总之,我们要

在下面这个数列中,找到两个互质的数,那么一定是合法数对.
1,2,3,…k
1,2,3,…k

比如说我们选择
2,3
2,3

那么实际上对应的数字就是
2×d,3×d
2×d,3×d

因此当前的任务就是找到互质的两个数.

此时我们就需要用到这道题目唯一的难点数学知识.

欧拉函数:是小于n的正整数中与n互质的数的数目

那么我们对于一个数列而言,它的欧拉函数总和,就是两个互质数对个数.
ans=ϕ1+ϕ2+ϕ3+…+ϕk
ans=ϕ1+ϕ2+ϕ3+…+ϕk

不过本题目是无序数对,因此.
ans×2
ans×2

因此使用线性筛法,就可以O(n)O(n)求出每一个ϕiϕi
不过为了加速处理,我们还可以使用前缀和数组.
sum[i]表示ϕ1+ϕ2+ϕ3+..+ϕk的总和
sum[i]表示ϕ1+ϕ2+ϕ3+..+ϕk的总和
代码解析
#include <bits/stdc++.h>
const int N=1e7+10;
using namespace std;
int zs[N],cnt,phi[N],n;
long long sum[N],ans;
bool st[N];
void get_phi(int n)
{
    phi[1]=1;
    for (int i=2; i<=n; i++)
    {
        if (!st[i])
        {
            zs[cnt++]=i;
            phi[i]=i-1;
        }
        for (int j=0; zs[j]<=n/i; j++)
        {
            int t=zs[j]*i;
            st[t]=true;
            if (i%zs[j]==0)
            {
                phi[t]=phi[i]*zs[j];
                break;
            }
            phi[t]=phi[i]*(zs[j]-1);
        }
    }
}
int main()
{
    scanf("%d",&n);
    get_phi(n);
    for(int i=2;i<=n;i++)
        sum[i]=sum[i-1]+phi[i];
    for(int i=0;i<cnt;i++)
    {
        int now=n/zs[i];
        ans+=sum[now]*2+1;//因为phi[1]=1,我们的前缀和没有处理.
    }
    printf("%lld\n",ans);
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/3325/
 


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e7 + 10;

int primes[N], cnt;
bool st[N];
int phi[N];
LL s[N];

void init(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0)
            {
                phi[i * primes[j]] = phi[i] * primes[j];
                break;
            }
            phi[i * primes[j]] = phi[i] * (primes[j] - 1);
        }
    }

    for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + phi[i];
}

int main()
{
    int n;
    cin >> n;
    init(n);

    LL res = 0;
    for (int i = 0; i < cnt; i ++ )
    {
        int p = primes[i];
        res += s[n / p] * 2 + 1;
    }

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/174376/
 


AcWing 203. 同余方程    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-22 17:37:56 ,  阅读 815

9


3
原题链接
更好的阅读体验

题目描述
求关于x的同余方程ax≡1(modb)ax≡1(modb)的最小正整数解。

输入格式
输入只有一行，包含两个正整数a,b,用一个空格隔开。

输出格式
输出只有一行,包含一个正整数x，表示最小正整数解。

输入数据保证一定有解。

数据范围
2≤a,b≤2∗1092≤a,b≤2∗109
样例
输入样例：
3 10
输出样例：
7
拓展欧几里得算法+线性同余方程
线性同余方程,也就是给定a,b,m,求一个整数x满足a×x≡b(modm)a×x≡b(modm),然后因为a×x≡b(modm)a×x≡b(modm)等价于a×x−ba×x−b是m的倍数,不妨设y为一个负数,那么这个方程可以改写为a×x+m×y=ba×x+m×y=b
然后这道题目就是特殊的,a×x≡1(modb)a×x≡1(modb)
于是我们可以通过拓展欧几里得算法求出特解,然后(x%b+b)%b(x%b+b)%b来达到最小值的效果.
C++ 代码
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int ex_gcd(int a,int b,int &x,int &y)
{
    if (b==0)
    {
        x=1;
        y=0;
        return a;
    }
    int d=ex_gcd(b,a%b,x,y);
    int z=x;
    x=y;
    y=z-y*(a/b);
    return d;
}
signed main()
{
    int a,b,x=0,y=0;
    scanf("%lld%lld",&a,&b);
    ex_gcd(a,b,x,y);
    printf("%lld\n",(x%b+b)%b);
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1054/
 


AcWing 203. 同余方程
作者：    swust-zyh ,  2020-04-29 13:05:02 ,  阅读 63

3


1
1.0 % x = 0, 所以x一定不为0

2.x % b的正余数求法, (x % b + b) % b, 一般我们不需要负余数, 所以若x为负数时, 求余一般写成这样
取模正确写法 (x % y + y) % y

(因为c++会根据x的正负来选择返回正负余数)

3.


4.图解
exgcd的递归思想与通解表达式与基本应用


/*
1.由于输入数据保证同余方程一定有解, 而同余方程等价于ax + by = 1, 要想该方程有解x, y, 则a, b的最大公约数一定为1

2.x必然不可能等于0, 因为x = 0的话, ax % b = 0.不满足题意

3. x = x0 + k(b / d); -> 最小(d == 1) -> x0 + kb的min
   y = y0 + k(a / d);
*/

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

// 维护了d最大公约数, 同时也维护了方程ax + by = d的解x, y
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        /*
        因为此时a为最大公约数d, 所以要想方程ax + by = d成立, x需要等于1, y随便取值
        (但是就算ll可以过爆int的情况如果y取得太大爆longlong的话还是不行的, 所以这个地方的y应该尽量取小的好)
        */
        x = 1, y = 0; // 这里y建议都取成0
        return a;
    }

    /*
    这里x, y传参为什么要颠倒, 见图解我们会发现
    ax + by, a, b的系数其实是由a % b(x)和b(y)上的系数转化过来的。
    */
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x; // 见图解 x引用

    return d; // 维护了最大公约数
}

int main()
{
    int a, b;
    cin >> a >> b;

    int x, y;
    exgcd(a, b, x, y);

    /*
    x可能为正也可能为负
    **** 求x + kb (k∈Z)的最小正整数 = x % b的正余数
    */
    cout << (x % b + b) % b << endl; // 求正余数公式

    return 0;
}

作者：swust-zyh
链接：https://www.acwing.com/activity/content/code/content/298338/
 
#include <iostream>

using namespace std;

int n,m;
int x,y;

void exgcd(int a,int b,int &x,int &y)
{
    b?exgcd(b,a%b,y,x),y-=a/b*x:x=y=1;
}

int main()
{
    scanf("%d %d",&n,&m);
    exgcd(n,m,x,y);
    printf("%lld\n",(x%m+0ll+m)%m);
    return 0;
}

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }

    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;

    return d;
}

int main()
{
    int a, b;
    cin >> a >> b;

    int x, y;
    exgcd(a, b, x, y);

    cout << (x % b + b) % b << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/174843/
 


AcWing 222. 青蛙的约会(来自一个憨憨的纯模拟)    原题链接    困难
作者：    Accepting ,  2020-05-21 18:36:56 ,  阅读 163

3


鄙人不才，此中鄙陋甚多，望海涵！
题目描述
两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。

它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。

可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。

不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。

但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。

为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。

我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。

设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。

青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。

纬度线总长L米。

现在要你求出它们跳了几次以后才会碰面。

输入格式
输入只包括一行5个整数x，y，m，n，L，其中x≠y < 2000000000，0 < m、n < 2000000000，0 < L < 2100000000。

输出格式
输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行”Impossible”

输入样例
1 2 3 4 5
输出样例
4
算法 模拟
其实这个代码看起来长，但有50行代码都是重复的，虽然多，但也好写（CV）
真正需要处理的只有4种情况而已，始终要把模型转化为后追前的追及问题即可！
C++ 代码
#include<iostream>

using namespace std;

typedef long long ll;

int main()
{
    int x,y,m,n,l;
    cin>>x>>y>>m>>n>>l;
    int d=y-x;
    int v=n-m;
    int flag=0;
    if(d==0) cout<< 0 <<endl;
    else if(v==0 && d!=0) puts("Impossible");
    else if(d<0)
    {
        d=-d;
        if(v>0)
        {
            if(d%v==0) cout<< d/v <<endl;
            else
            {
                for(ll i=1;i<=10000000;i++)
                    if((ll)(d+i*l)%v==0)
                    {
                        cout<< (ll)(d+i*l)/v <<endl;
                        flag=1;
                        break;
                    }
                    if(!flag) 
                    {
                        puts("Impossible");
                        return 0;
                    }
            }
        }
        else
        {
            d=l-d;
            v=-v;
            if(d%v==0) cout<< d/v <<endl;
            else
            {
                for(ll i=1;i<=10000000;i++)
                    if((ll)(d+i*l)%v==0)
                    {
                        cout<< (ll)(d+i*l)/v <<endl;
                        flag=1;
                        break;
                    }
                    if(!flag) 
                    {
                        puts("Impossible");
                        return 0;
                    }
            }
        }
    }
    else
    {
        d=l-d;
        if(v>0)
        {
            if(d%v==0) cout<< d/v <<endl;
            else
            {
                for(ll i=1;i<=10000000;i++)
                    if((ll)(d+i*l)%v==0)
                    {
                        cout<< (ll)(d+i*l)/v <<endl;
                        flag=1;
                        break;
                    }
                    if(!flag) 
                    {
                        puts("Impossible");
                        return 0;
                    }
            }
        }
        else
        {
            d=l-d;
            v=-v;
            if(d%v==0) cout<< d/v <<endl;
            else
            {
                for(ll i=1;i<=10000000;i++)
                    if((ll)(d+i*l)%v==0)
                    {
                        cout<< (ll)(d+i*l)/v <<endl;
                        flag=1;
                        break;
                    }
                    if(!flag) 
                    {
                        puts("Impossible");
                        return 0;
                    }
            }
        }
    }
    return 0;
}

作者：Accepting
链接：https://www.acwing.com/solution/content/13478/
 


2


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

LL exgcd(LL a, LL b, LL &x, LL &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }

    LL d = exgcd(b, a % b, y, x);
    y -= a / b * x;

    return d;
}

int main()
{
    LL a, b, m, n, L;
    cin >> a >> b >> m >> n >> L;

    LL x, y;
    LL d = exgcd(m - n, L, x, y);
    if ((b - a) % d) puts("Impossible");
    else
    {
        x *= (b - a) / d;
        LL t = abs(L / d);
        cout << (x % t + t) % t << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/174861/
 

AcWing 202. 最幸运的数字    原题链接    简单
作者：    kirai ,  2019-06-03 18:34:45 ,  阅读 1020

10


2
考虑x个8的整数可以表示为10x−19×810x−19×8，于是这个问题相当于求解最小的x满足：
10x−19×8≡0 (mod L)
10x−19×8≡0 (mod L)

整理下就是：
8(10x−1)≡0 (mod 9L)
8(10x−1)≡0 (mod 9L)

为了满足条件，8的存在可以化简一下模数，直接放进去考虑，即：
10x−1≡0 (mod 9Lgcd(L,8))
10x−1≡0 (mod 9Lgcd(L,8))

也就是：
10x≡1 (mod 9Lgcd(L,8))
10x≡1 (mod 9Lgcd(L,8))

令p=9Lgcd(L,8)p=9Lgcd(L,8)，考虑xx与pp不一定互质，所以应用欧拉定理，得到一个可行解：令x=ϕ(p)x=ϕ(p)
10ϕ(p)≡1 (mod p)
10ϕ(p)≡1 (mod p)

由于ϕ(p)ϕ(p)不一定是满足条件的最小自然数，但是可以证明满足上式的xx一定是ϕ(p)ϕ(p)的因子，于是我们枚举ϕ(p)ϕ(p)的因子判断是否满足条件即可。

C++ 代码
#include<bits/stdc++.h>

using namespace std;
using LL = long long;

LL mul(LL x, LL n, LL mod) {
  LL ret = 1;
  while (n) {
    if (n & 1) ret = ret * x % mod;
    n >>= 1;
    x = x * x % mod;
  }
  return ret;
}

LL phi(LL x) {
  LL ret = x;
  for (LL i = 2; i * i <= x; i++) {
    if (x % i == 0) {
      ret = ret / i * (i - 1);
      while (x % i == 0) x /= i;
    }
  }
  if (x > 1) ret = ret / x * (x - 1);
  return ret;
}

signed main() {
  // freopen("in", "r", stdin);
  LL L;
  for (int _ = 1; cin >> L && L; _++) {
    LL mod = L / __gcd(8LL, L) * 9LL;
    LL p = phi(mod), ret = 1E18;
    for (LL x = 1; x * x <= p; x++) {
      if (p % x != 0) continue;
      if (mul(10, x, mod) == 1) ret = min(ret, x);
      if (mul(10, p / x, mod) == 1) ret = min(ret, p / x);
    }
    printf("Case %d: ", _);
    printf("%lld\n", ret == 1E18 ? 0 : ret);
  }
  return 0;
}

作者：kirai
链接：https://www.acwing.com/solution/content/2350/
 


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

LL qmul(LL a, LL k, LL b)
{
    LL res = 0;
    while (k)
    {
        if (k & 1) res = (res + a) % b;
        a = (a + a) % b;
        k >>= 1;
    }
    return res;
}

LL qmi(LL a, LL k, LL b)
{
    LL res = 1;
    while (k)
    {
        if (k & 1) res = qmul(res, a, b);
        a = qmul(a, a, b);
        k >>= 1;
    }
    return res;
}

LL get_euler(LL C)
{
    LL res = C;
    for (LL i = 2; i <= C / i; i ++ )
        if (C % i == 0)
        {
            while (C % i == 0) C /= i;
            res = res / i * (i - 1);
        }
    if (C > 1) res = res / C * (C - 1);
    return res;
}

int main()
{
    int T = 1;
    LL L;
    while (cin >> L, L)
    {
        int d = 1;
        while (L % (d * 2) == 0 && d * 2 <= 8) d *= 2;

        LL C = 9 * L / d;

        LL phi = get_euler(C);

        LL res = 1e18;
        if (C % 2 == 0 || C % 5 == 0) res = 0;
        else
        {
            for (LL d = 1; d * d <= phi; d ++ )
                if (phi % d == 0)
                {
                    if (qmi(10, d, C) == 1) res = min(res, d);
                    if (qmi(10, phi / d, C) == 1) res = min(res, phi / d);
                }
        }

        printf("Case %d: %lld\n", T ++, res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/174898/
 


AcWing 1298. 曹冲养猪（孙子定理求通解）    原题链接    中等
作者：    Accepting ,  2020-03-18 11:44:45 ,  阅读 224

1


题目描述
自从曹冲搞定了大象以后，曹操就开始琢磨让儿子干些事业，于是派他到中原养猪场养猪，可是曹冲很不高兴，于是在工作中马马虎虎，有一次曹操想知道母猪的数量，于是曹冲想狠狠耍曹操一把。

举个例子，假如有 16 头母猪，如果建了 3 个猪圈，剩下 1 头猪就没有地方安家了；如果建造了 5 个猪圈，但是仍然有 1 头猪没有地方去；如果建造了 7 个猪圈，还有 2 头没有地方去。

你作为曹总的私人秘书理所当然要将准确的猪数报给曹总，你该怎么办？

输入格式
第一行包含一个整数 n，表示建立猪圈的次数；

接下来 n 行，每行两个整数 ai,bi，表示建立了 ai 个猪圈，有 bi 头猪没有去处。

你可以假定 ai,aj 互质。

输出格式
输出仅包含一个正整数，即为曹冲至少养猪的数目。

数据范围
1≤n≤10,
1≤bi≤ai≤1100000
所有ai的乘积不超过 1018

输入样例
3
3 1
5 1
7 2
输出样例：
16
算法
中国剩余定理简单应用
C++ 代码
#include<iostream>

using namespace std;

const int N=15;

typedef long long LL;

LL M[N],m[N],a[N];

LL exgcd(LL a,LL b,LL &x,LL &y)
{
    if(b==0)
    {
        x=1,y=0;
        return a;
    }
    LL d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}


int main()
{
    int n;
    cin>>n;
    M[0]=1;
    for(int i=1;i<=n;i++)
    {
        cin>>m[i]>>a[i];
        M[0]*=m[i];
    }
    LL res=0;
    for(int i=1;i<=n;i++)
    {
        M[i]=M[0]/m[i];
        LL x=0,y=0;
        exgcd(M[i],m[i],x,y);
        x=(x%m[i]+m[i])%m[i];
        res=(res+a[i]*M[i]*x)%M[0];
    }
    cout<< res <<endl;
    return 0;
}

作者：Accepting
链接：https://www.acwing.com/solution/content/10105/
 


/*
1. 中国剩余定理
    x=a1(mod m1)  x=a2(mod m2)  x=a3(mod m3)....
    设 M=m1*m2*m3.... 两两互质
    令 Mi=M/mi ti是Mi关于M的逆元 Mi*ti=1(mod m)
    x=(a1*M1*t1)*(a2*M2*t3)...
2. 题意
     就是中国剩余定理模板题

*/
//代码
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=10;

int n;
int A[N],B[N];

void ex_gcd(ll a,ll b,ll &x,ll &y){
    if(!b)x=1,y=0;
    else{
    ex_gcd(b,a%b,y,x);
    y-=a/b*x;
    }
}
int main(){
    cin>>n;
    ll M=1;
    for(int i=0;i<n;i++){
        cin>>A[i]>>B[i];
        M*=A[i];
    }
    ll res=0;
    for(int i=0;i<n;i++){
        ll Mi=M/A[i];
        ll ti,x;
        ex_gcd(Mi,A[i],ti,x);
        res+=B[i]*Mi*ti;
    }
    cout<<(res%M+M)%M<<endl;
}

作者：wuog
链接：https://www.acwing.com/activity/content/code/content/187387/
 

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 10;

int n;
int A[N], B[N];

void exgcd(LL a, LL b, LL &x, LL &y)
{
    if (!b) x = 1, y = 0;
    else
    {
        exgcd(b, a % b, y, x);
        y -= a / b * x;
    }
}

int main()
{
    scanf("%d", &n);

    LL M = 1;
    for (int i = 0; i < n; i ++ )
    {
        scanf("%d%d", &A[i], &B[i]);
        M *= A[i];
    }

    LL res = 0;
    for (int i = 0; i < n; i ++ )
    {
        LL Mi = M / A[i];
        LL ti, x;
        exgcd(Mi, A[i], ti, x);
        res += B[i] * Mi * ti;
    }

    cout << (res % M + M) % M << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/174913/
 


AcWing 1303. 斐波那契前 n 项和    原题链接    中等
作者：    垫底抽风 ,  2020-06-22 12:58:05 ,  阅读 370

15


2
题目描述
大家都知道 Fibonacci 数列吧，f1=1,f2=1,f3=2,f4=3,⋯,fn=fn−1+fn−2f1=1,f2=1,f3=2,f4=3,⋯,fn=fn−1+fn−2。

现在问题很简单，输入 nn 和 mm，求 fnfn 的前 nn 项和 SnmodmSnmodm。

输入格式
共一行，包含两个整数 nn 和 mm。

输出格式
输出前 nn 项和 SnmodmSnmodm 的值。

数据范围
1≤n≤20000000001≤n≤2000000000（别数了，2×1092×109）
1≤m≤10000000101≤m≤1000000010（109+10109+10）

输入样例：
5 1000
输出样例：
12
看数据范围，基本可以肯定是矩阵快速幂了，那么怎么构造矩阵呢？

这里给出一个万能，但较为复杂的矩阵构造方式。

首先推一下公式

fn=fn−1+fn−2fn=fn−1+fn−2
Sn−Sn−1=fnSn−Sn−1=fn
=fn−1+fn−2=fn−1+fn−2
=Sn−1−Sn−3=Sn−1−Sn−3
所以 Sn−Sn−1=Sn−1−Sn−3Sn−Sn−1=Sn−1−Sn−3
Sn=2×Sn−1−Sn−3Sn=2×Sn−1−Sn−3
那么有递推式了，怎么构造矩阵呢？

结论：对于数列 {an}{an}，若ai=k1ai−1+k2ai−2+⋯+kia0ai=k1ai−1+k2ai−2+⋯+kia0，那么 ⎡⎣⎢⎢⎢⎢⎢⎢k110⋮0k201⋮0⋯⋯⋯⋮⋯ki−100⋮1ki00⋮0⎤⎦⎥⎥⎥⎥⎥⎥n⎡⎣⎢⎢⎢⎢⎢⎢ai−1ai−2⋮a1a0⎤⎦⎥⎥⎥⎥⎥⎥=⎡⎣⎢⎢⎢⎢⎢⎢an+i−1an+i−2⋮an+1an⎤⎦⎥⎥⎥⎥⎥⎥[k1k2⋯ki−1ki10⋯0001⋯00⋮⋮⋮⋮⋮00⋯10]n[ai−1ai−2⋮a1a0]=[an+i−1an+i−2⋮an+1an]
证明：

因为 ⎡⎣⎢⎢⎢⎢⎢⎢k110⋮0k201⋮0⋯⋯⋯⋮⋯ki−100⋮1ki00⋮0⎤⎦⎥⎥⎥⎥⎥⎥⎡⎣⎢⎢⎢⎢⎢⎢ai−1ai−2⋮a1a0⎤⎦⎥⎥⎥⎥⎥⎥=⎡⎣⎢⎢⎢⎢⎢⎢aiai−1⋮a2a1⎤⎦⎥⎥⎥⎥⎥⎥[k1k2⋯ki−1ki10⋯0001⋯00⋮⋮⋮⋮⋮00⋯10][ai−1ai−2⋮a1a0]=[aiai−1⋮a2a1]
所以此结论对于 n=1n=1 成立

假设此结论对于 n=Nn=N 成立，那么有
⎡⎣⎢⎢⎢⎢⎢⎢k110⋮0k201⋮0⋯⋯⋯⋮⋯ki−100⋮1ki00⋮0⎤⎦⎥⎥⎥⎥⎥⎥N⎡⎣⎢⎢⎢⎢⎢⎢ai−1ai−2⋮a1a0⎤⎦⎥⎥⎥⎥⎥⎥=⎡⎣⎢⎢⎢⎢⎢⎢aN+i−1aN+i−2⋮aN+1aN⎤⎦⎥⎥⎥⎥⎥⎥[k1k2⋯ki−1ki10⋯0001⋯00⋮⋮⋮⋮⋮00⋯10]N[ai−1ai−2⋮a1a0]=[aN+i−1aN+i−2⋮aN+1aN]
两边同时左乘矩阵 ⎡⎣⎢⎢⎢⎢⎢⎢k110⋮0k201⋮0⋯⋯⋯⋮⋯ki−100⋮1ki00⋮0⎤⎦⎥⎥⎥⎥⎥⎥[k1k2⋯ki−1ki10⋯0001⋯00⋮⋮⋮⋮⋮00⋯10]
得 ⎡⎣⎢⎢⎢⎢⎢⎢k110⋮0k201⋮0⋯⋯⋯⋮⋯ki−100⋮1ki00⋮0⎤⎦⎥⎥⎥⎥⎥⎥N+1⎡⎣⎢⎢⎢⎢⎢⎢ai−1ai−2⋮a1a0⎤⎦⎥⎥⎥⎥⎥⎥=⎡⎣⎢⎢⎢⎢⎢⎢k110⋮0k201⋮0⋯⋯⋯⋮⋯ki−100⋮1ki00⋮0⎤⎦⎥⎥⎥⎥⎥⎥⎡⎣⎢⎢⎢⎢⎢⎢aN+i−1aN+i−2⋮aN+1aN⎤⎦⎥⎥⎥⎥⎥⎥=⎡⎣⎢⎢⎢⎢⎢⎢k1×aN+i−1+k2×aN+i−2+⋯+ki×aNaN+i−1⋮aN+2aN+1⎤⎦⎥⎥⎥⎥⎥⎥=⎡⎣⎢⎢⎢⎢⎢⎢aN+iaN+i−1⋮aN+2aN+1⎤⎦⎥⎥⎥⎥⎥⎥[k1k2⋯ki−1ki10⋯0001⋯00⋮⋮⋮⋮⋮00⋯10]N+1[ai−1ai−2⋮a1a0]=[k1k2⋯ki−1ki10⋯0001⋯00⋮⋮⋮⋮⋮00⋯10][aN+i−1aN+i−2⋮aN+1aN]=[k1×aN+i−1+k2×aN+i−2+⋯+ki×aNaN+i−1⋮aN+2aN+1]=[aN+iaN+i−1⋮aN+2aN+1]
所以此结论对于 n=Nn=N 也成立。

所以此结论对于任意的 n∈N+n∈N+ 都成立，证毕

由上述结论，可以构造出矩阵 A=⎡⎣⎢⎢210001−100⎤⎦⎥⎥, S=⎡⎣⎢⎢S2S1S0⎤⎦⎥⎥=⎡⎣⎢⎢f0+f1+f2f0+f1f0⎤⎦⎥⎥=⎡⎣⎢⎢210⎤⎦⎥⎥A=[20−1100010], S=[S2S1S0]=[f0+f1+f2f0+f1f0]=[210]
找到矩阵之后，用矩阵快速幂求出 AnAn，然后再乘上矩阵 SS，即可求出 SnSn
时间复杂度 (logn)O(log⁡n)
注：该题矩阵快速幂的时间复杂度虽然是 (logn)O(log⁡n)，看似能跑的飞快，但实际上还有 2727 的常数，并不能跑的飞快，当然过这题毫无压力

C++C++ 代码
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdlib>

using namespace std;

typedef long long ll;

const int N = 3;

int n, m;
ll A[N][N] =    // 上述矩阵 A
{
    {2, 0, -1},
    {1, 0, 0},
    {0, 1, 0}
};
ll S[N] = {2, 1, 0}; // 上述矩阵 S（转置）

void multi(ll A[], ll B[][N]) // 计算向量 A 乘方阵 B，并将结果储存在 A 中
{
    ll ans[N] = {0};
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            ans[i] += A[j] * B[i][j] % m;
    for (int i = 0; i < N; i ++ )
        A[i] = ans[i] % m;
}

void multi(ll A[][N], ll B[][N]) // 计算方阵 A * B，并将结果储存在 A 中
{
    ll ans[N][N] = {0};
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            for (int k = 0; k < N; k ++ )
                ans[i][j] += A[i][k] * B[k][j] % m;
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            A[i][j] = ans[i][j] % m;
}

int main()
{
    scanf("%d%d", &n, &m);

    while (n)        // 矩阵快速幂
    {
        if (n & 1) multi(S, A);
        multi(A, A);
        n >>= 1;
    }

    printf("%lld", (S[2] % m + m) % m);

    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/solution/content/15121/
 


AcWing 1303. 斐波那契前 n 项和——一个更巧妙的解法    原题链接    中等
作者：    垫底抽风 ,  2020-08-01 20:27:05 ,  阅读 170

10


题目描述
这里的做法，和这个做法的时间复杂度是相同的，但常数更小

思路
观察原式 fn=fn−1+fn−2
观察原式 fn=fn−1+fn−2
移项可得 fn−2=fn−fn−1
移项可得 fn−2=fn−fn−1
也就是 fn=fn+2−fn+1
也就是 fn=fn+2−fn+1
将斐波那契的前n项都写成这种形式，得
将斐波那契的前n项都写成这种形式，得
⎧⎩⎨⎪⎪⎪⎪⎪⎪f1=f2=f3=f4=fn= f3−f2 f4−f3 f5−f4 f6−f5  ⋮ fn+2−fn+1
{f1= f3−f2f2= f4−f3f3= f5−f4f4= f6−f5  ⋮fn= fn+2−fn+1
累加所有等式，
累加所有等式，
左边正好是我们要求的答案
左边正好是我们要求的答案
而右边，从f1到fn+1，都互相抵消掉了，
而右边，从f1到fn+1，都互相抵消掉了，
得到
得到
f1+f2+⋯+fn=fn+2−f2=fn+2−1
f1+f2+⋯+fn=fn+2−f2=fn+2−1
也就是说，我们就只需要求出 fn+2−1 即可
也就是说，我们就只需要求出 fn+2−1 即可
这里给出三种求的算法
这里给出三种求的算法
算法1    矩阵快速幂
这里不再做过多赘述，关于矩阵快速幂的方法可以看下面的参考文献

时间复杂度 O(logn)O(log⁡n)
参考文献1    求斐波那契数列若干方法
参考文献2    如何通过递推式构造矩阵
C++ 代码
#include <iostream>

using namespace std;

typedef long long ll;

int n, m;
ll A[2][2] = {      // 用于快速幂的矩阵
    {1, 1},
    {1, 0}
};
ll res[2] = {1, 0}; // 用于存答案的矩阵（转置）

// 计算列矩阵 A 乘方阵 B 的乘积，并存储在 A 中
void _multi(ll A[], ll B[][2])
{
    ll ans[2] = {0};
    for (int i = 0; i < 2; i ++ )
        for (int j = 0; j < 2; j ++ )
            ans[i] += A[j] * B[i][j] % m;
    for (int i = 0; i < 2; i ++ )
        A[i] = ans[i] % m;
}

// 计算方阵 A 乘方阵 B 的乘积，并存储在 A 中
void multi(ll A[][2], ll B[][2])
{
    ll ans[2][2] = {0};
    for (int i = 0; i < 2; i ++ )
        for (int j = 0; j < 2; j ++ )
            for (int k = 0; k < 2; k ++ )
                ans[i][j] += A[i][k] * B[k][j] % m;
    for (int i = 0; i < 2; i ++ )
        for (int j = 0; j < 2; j ++ )
            A[i][j] = ans[i][j] % m;
}

int main()
{
    scanf("%d %d", &n, &m);
    n += 2; // 求 f[n + 2] 的结果

    while (n) // 矩阵快速幂板子
    {
        if (n & 1) _multi(res, A);
        multi(A, A);
        n >>= 1;
    }

    printf("%lld\n", res[1] - 1); // 最后 res[1] 即为 f[n + 2] 的结果

    return 0;
}
算法2    推式子 + 暴力
时间复杂度 O(n) O(O(能过))
空间复杂度 O(n) O(O(超级大))
这里先给出结论，再给出证明过程

结论  fn=fkfn−k+1+fk−1fn−k  (k≤n)  fn=fkfn−k+1+fk−1fn−k  (k≤n)
证明
∵fn=fn−1+fn−2=f2fn−2+1+f1fn−2∵fn=fn−1+fn−2=f2fn−2+1+f1fn−2
∴结论对于 k=1 成立∴结论对于 k=1 成立
假设结论对于 k=i 成立假设结论对于 k=i 成立
则有fn=fifn−i+1+fi−1fn−i则有fn=fifn−i+1+fi−1fn−i
⇒=fi(fn−i+fn−i−1)+fi−1fn−i⇒=fi(fn−i+fn−i−1)+fi−1fn−i
⇒=fifn−i+fifn−i−1+fi−1fn−i⇒=fifn−i+fifn−i−1+fi−1fn−i
⇒=(fi+fi−1)fn−i+fifn−i−1⇒=(fi+fi−1)fn−i+fifn−i−1
⇒=fi+1fn−i+fifn−i−1⇒=fi+1fn−i+fifn−i−1
所以结论对于 k=i+1 成立，证毕所以结论对于 k=i+1 成立，证毕
那么根据结论，当 n=2kn=2k 时，有
f2k=fkfk+1+fk−1fk=fk(fk+1+fk−1)=fk(2fk+1−fk)f2k=fkfk+1+fk−1fk=fk(fk+1+fk−1)=fk(2fk+1−fk)
当 n=2k+1n=2k+1 时，有
f2k+1=fkfk+fk+1fk+1=f2k+f2k+1f2k+1=fkfk+fk+1fk+1=fk2+fk+12
也就是说，我们可以通过递归求出 f⌊k2⌋f⌊k2⌋ 和 f⌊k2⌋+1f⌊k2⌋+1 来得到 fkfk
直接这么求，时间复杂度还是 O(n)O(n)，和递推相比，并没有任何优化

但是这个做法的优点，是可以快速将我们要求的 fnfn 的 nn 缩小到一个很小的范围内

利用这一点，我们可以预处理出 ff 的前 kk 项（具体 kk 的值根据题目而定）

如果递归到了 kk 以内，直接返回我们预处理好的值

C++ 代码
#include <iostream>

using namespace std;

typedef long long ll;
const int k = 1e7 + 5; // 这里取 k = 1e7 + 5

int n, m;
int f[k];

// 递归求出 f[x] 的值
ll calc(int x)
{
    if (x < k) return f[x]; // 如果 x 在我们预处理的 k 之内，则直接返回我们预处理出的值
    ll t1 = calc(x / 2 + 1), t2 = calc(x / 2); // 递归求出 f[x / 2 + 1] 和 f[x / 2]
    if (x & 1) return (t1 * t1 + t2 * t2) % m; // 按照上述等式，返回 x 是奇数时的结果
    return t2 * (t1 * 2 - t2 % m + m) % m; // 返回 x 是偶数时的结果，注意这里求的是 % m 的正余数，要在括号内先加上 m，以保证结果为正数
}

int main()
{
    scanf("%d %d", &n, &m);

    f[1] = f[2] = 1; // 递推求出 f[0 ~ k - 1] 的值
    for (int i = 3; i < k; i ++ )
        f[i] = (f[i - 1] + f[i - 2]) % m;

    printf("%lld\n", calc(n + 2) - 1); // 输出结果

    return 0;
}
算法3    快速倍增法
这里感谢@洛零巨佬给出该方法
时间复杂度 O(logn)O(log⁡n)
我们在做递归时，可以通过二元组的方式进行计算，并返回(fn,fn+1)(fn,fn+1)，将时间复杂度优化至 O(logn)O(log⁡n)
C ++ 代码
#include <cstdio>
#include <utility>

using namespace std;

typedef long long ll;
typedef pair<ll, ll> pll;

int n, m;

// 递归求出二元组 {f[x], f[x + 1]}
pll calc(int x)
{
    if (!x) return make_pair(0, 1);         // 如果 x 为 0，那么返回 (0, 1)
    pll u = calc(x >> 1);                   // 递归求出二元组 (f[x / 2], f[x / 2 + 1])
    ll t1 = u.first, t2 = u.second;         // 分别取出 f[x / 2] 和 f[x / 2 + 1]
    ll f2 = t1 * (2 * t2 - t1 % m + m) % m; // 求出 (f[x], f[x + 1]) 中，x 为奇数的元素的值
    ll f1 = (t1 * t1 + t2 * t2) % m;        // 求出 (f[x], f[x + 1]) 中，x 为偶数的元素的值
    if (!(x & 1)) return make_pair(f2, f1); // 如果 x 是偶数，则 f[x] = f2，直接返回 (f2, f1) 即可
    return make_pair(f1, (f1 + f2) % m);    // 否则说明 x 是奇数，则 f[x] = f1，需要求下 f[x + 1] 再返回
}

int main()
{
    scanf("%d %d", &n, &m);

    printf("%lld\n", calc(n + 2).first - 1); // 输出结果

    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/solution/content/16868/
 

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 3;

int n, m;

void mul(int c[], int a[], int b[][N])
{
    int temp[N] = {0};
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            temp[i] = (temp[i] + (LL)a[j] * b[j][i]) % m;

    memcpy(c, temp, sizeof temp);
}

void mul(int c[][N], int a[][N], int b[][N])
{
    int temp[N][N] = {0};
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            for (int k = 0; k < N; k ++ )
                temp[i][j] = (temp[i][j] + (LL)a[i][k] * b[k][j]) % m;

    memcpy(c, temp, sizeof temp);
}

int main()
{
    cin >> n >> m;

    int f1[N] = {1, 1, 1};
    int a[N][N] = {
        {0, 1, 0},
        {1, 1, 1},
        {0, 0, 1}
    };

    n -- ;
    while (n)
    {
        if (n & 1) mul(f1, f1, a);  // res = res * a
        mul(a, a, a);  // a = a * a
        n >>= 1;
    }

    cout << f1[2] << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/174930/
 

AcWing 1304. 佳佳的斐波那契    原题链接    中等
作者：    垫底抽风 ,  2020-06-22 17:44:20 ,  阅读 274

12


1
题目描述
佳佳对数学，尤其对数列十分感兴趣。

在研究完 Fibonacci 数列后，他创造出许多稀奇古怪的数列。

例如用 S(n)S(n) 表示 Fibonacci 前 nn 项和 modmmodm 的值，即 S(n)=(F1+F2+⋯+Fn)modmS(n)=(F1+F2+⋯+Fn)modm，其中 F1=F2=1,Fi=Fi−1+Fi−2F1=F2=1,Fi=Fi−1+Fi−2。

可这对佳佳来说还是小菜一碟。

终于，她找到了一个自己解决不了的问题。

用 T(n)=(F1+2F2+3F3+⋯+nFn)modmT(n)=(F1+2F2+3F3+⋯+nFn)modm 表示 Fibonacci 数列前 nn 项变形后的和 modmmodm 的值。

现在佳佳告诉你了一个 nn 和 mm，请求出 T(n)T(n) 的值。

输入格式
共一行，包含两个整数 nn 和 mm。

输出格式
共一行，输出 T(n)T(n) 的值。

数据范围
1≤n,m≤231−11≤n,m≤231−1
输入样例：
5 5
输出样例：
1
样例解释
T(5)=(1+2×1+3×2+4×3+5×5)mod5=1T(5)=(1+2×1+3×2+4×3+5×5)mod5=1
算法1
首先推公式

设
Sn=F1+F2+⋯+Fn,Sn=F1+F2+⋯+Fn,
Gn=S1+S2+⋯+SnGn=S1+S2+⋯+Sn
那么 T(n)=F1+2F2+3F3+⋯+nFn=[nF1−(n−1)F1]+[nF2−(n−2)F2]+⋯+[nFn−1−Fn−1]+[nFn]T(n)=F1+2F2+3F3+⋯+nFn=[nF1−(n−1)F1]+[nF2−(n−2)F2]+⋯+[nFn−1−Fn−1]+[nFn]
=(nF1+nF2+⋯+nFn)−[(n−1)F1+(n−2)F2+⋯+2Fn−2+Fn−1]=(nF1+nF2+⋯+nFn)−[(n−1)F1+(n−2)F2+⋯+2Fn−2+Fn−1]
=n(F1+F2+⋯+Fn)−[(F1+F2+⋯+Fn−1)+(F1+F2+⋯+Fn−2)+⋯+(F1+F2)+(F1)]=n(F1+F2+⋯+Fn)−[(F1+F2+⋯+Fn−1)+(F1+F2+⋯+Fn−2)+⋯+(F1+F2)+(F1)]
=nSn−[Sn−1+Sn−2+⋯+S2+S1]=nSn−[Sn−1+Sn−2+⋯+S2+S1]
=nSn−Gn−1=nSn−Gn−1
那么只要快速求出 SnSn 和 Gn−1Gn−1 就好了。
关于快速求 SnSn 的方法，可以参考 AcWing 1303. 斐波那契前 nn 项和。
那 GnGn 怎么求呢？

先推下公式，
由斐波那契前 nn 项和中所推公式 Sn=2Sn−1−Sn−3Sn=2Sn−1−Sn−3
可得 Gn−Gn−1=2(Gn−1−Gn−2)−(Gn−3−Gn−4)Gn−Gn−1=2(Gn−1−Gn−2)−(Gn−3−Gn−4)
整理得 Gn=3Gn−1−2Gn−2−Gn−3+Gn−4Gn=3Gn−1−2Gn−2−Gn−3+Gn−4
那么只要构造矩阵 A=⎡⎣⎢⎢⎢⎢3100−2010−10011000⎤⎦⎥⎥⎥⎥,G=⎡⎣⎢⎢⎢⎢G3G2G1G0⎤⎦⎥⎥⎥⎥=⎡⎣⎢⎢⎢⎢S0+S1+S2+S3S0+S1+S2S0+S1S0⎤⎦⎥⎥⎥⎥=⎡⎣⎢⎢⎢⎢3F1+2F2+F32F1+F2F10⎤⎦⎥⎥⎥⎥=⎡⎣⎢⎢⎢⎢7310⎤⎦⎥⎥⎥⎥A=[3−2−11100001000010],G=[G3G2G1G0]=[S0+S1+S2+S3S0+S1+S2S0+S1S0]=[3F1+2F2+F32F1+F2F10]=[7310]
然后用矩阵快速幂即可解决

时间复杂度 (logn)O(log⁡n)
常数巨大，但能过

C++C++ 代码
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

typedef long long ll;

int n, m;

void multi_3(ll A[][3], ll B[][3]) // 求出 3 × 3 的方阵 A 和 B 的乘积，并把结果储存在 A 中
{
    ll ans[3][3] = {0};
    for (int i = 0; i < 3; i ++ )
        for (int j = 0; j < 3; j ++ )
            for (int k = 0; k < 3; k ++ )
                ans[i][j] += A[i][k] * B[k][j] % m;
    for (int i = 0; i < 3; i ++ )
        for (int j = 0; j < 3; j ++ )
            A[i][j] = ans[i][j] % m;
}

void _multi_3(ll A[], ll B[][3])   // 求出 1 × 3 的矩阵 A 与 3 × 3 的方阵 B 的乘积，并把结果储存在 A 中
{
    ll ans[3] = {0};
    for (int i = 0; i < 3; i ++ )
        for (int j = 0; j < 3; j ++ )
            ans[i] += A[j] * B[i][j] % m;
    for (int i = 0; i < 3; i ++ )
        A[i] = ans[i] % m;
}

void multi_4(ll A[][4], ll B[][4]) // 求出 4 × 4 的矩阵 A 和 B 的乘积，并把结果储存在 A 中
{
    ll ans[4][4] = {0};
    for (int i = 0; i < 4; i ++ )
        for (int j = 0; j < 4; j ++ )
            for (int k = 0; k < 4; k ++ )
                ans[i][j] += A[i][k] * B[k][j] % m;
    for (int i = 0; i < 4; i ++ )
        for (int j = 0; j < 4; j ++ )
            A[i][j] = ans[i][j] % m;
}

void _multi_4(ll A[], ll B[][4])   // 求出 1 × 4 的矩阵 A 乘 4 × 4 的矩阵 B 的乘积，并把结果储存在 A 中
{
    ll ans[4] = {0};
    for (int i = 0; i < 4; i ++ )
        for (int j = 0; j < 4; j ++ )
            ans[i] += A[j] * B[i][j];
    for (int i = 0; i < 4; i ++ )
        A[i] = ans[i] % m;
}

ll get_S(int n)                    // 求出 S[n]
{
    ll S[3] = {2, 1, 0};
    ll A[3][3] =
    {
        {2, 0, -1},
        {1, 0, 0},
        {0, 1, 0}
    };
    while (n)
    {
        if (n & 1) _multi_3(S, A);
        multi_3(A, A);
        n >>= 1;
    }
    return S[2];
}

ll get_G(int n)                    // 求出 G[n]
{
    ll G[4] = {7, 3, 1, 0};
    ll A[4][4] =
    {
        {3, -2, -1, 1},
        {1, 0, 0, 0},
        {0, 1, 0, 0},
        {0, 0, 1, 0}
    };
    while (n)
    {
        if (n & 1) _multi_4(G, A);
        multi_4(A, A);
        n >>= 1;
    }
    return G[3];
}

int main()
{
    scanf("%d %d", &n, &m);
    ll S = get_S(n), G = get_G(n - 1);
    printf("%lld\n", ((n * S - G) % m + m) % m);
    return 0;
}
算法2
上面的代码虽然能过，但是代码长度的确非常长，不好写。

上机考试的时候不光要考虑代码的时间复杂度、空间复杂度，还要考虑代码复杂度——yxc

那么有没有什么写起来更简单的算法呢？

看上述算法，是将 SnSn 和 Gn−1Gn−1 分开来算，相当于是写了两遍矩阵快速幂，所以代码写起来就非常复杂。
我们在算的时候，其实可以用一个矩阵，直接将 SnSn 和 Gn−1Gn−1 存在一起，然后一起算出来。
这时候就要换一个构造矩阵的方法了。

我们先构造一个矩阵 Xn=[Fn−1FnSnGn−1]Xn=[Fn−1FnSnGn−1]
然后想一下，如何将 XnXn 转移到 Xn+1Xn+1 呢？
不妨设 Xn×A=Xn+1Xn×A=Xn+1
其中 A=⎡⎣⎢⎢⎢⎢a11a21a31a41a12a22a32a42a13a23a33a43a14a24a34a44⎤⎦⎥⎥⎥⎥A=[a11a12a13a14a21a22a23a24a31a32a33a34a41a42a43a44]
所以有 [Fn−1FnSnGn−1]⎡⎣⎢⎢⎢⎢a11a21a31a41a12a22a32a42a13a23a33a43a14a24a34a44⎤⎦⎥⎥⎥⎥=[FnFn+1Sn+1Gn]=[FnFn+Fn−1Sn+Fn+Fn−1Gn−1+Sn][Fn−1FnSnGn−1][a11a12a13a14a21a22a23a24a31a32a33a34a41a42a43a44]=[FnFn+1Sn+1Gn]=[FnFn+Fn−1Sn+Fn+Fn−1Gn−1+Sn]
所以 [a11Fn−1+a21Fn+a31Sn+a41Gn−1a12Fn−1+a22Fn+a32Sn+a42Gn−1a13Fn−1+a23Fn+a33Sn+a43Gn−1a14Fn−1+a24Fn+a34Sn+a44Gn−1]=[FnFn+Fn−1Sn+Fn+Fn−1Gn−1+Sn][a11Fn−1+a21Fn+a31Sn+a41Gn−1a12Fn−1+a22Fn+a32Sn+a42Gn−1a13Fn−1+a23Fn+a33Sn+a43Gn−1a14Fn−1+a24Fn+a34Sn+a44Gn−1]=[FnFn+Fn−1Sn+Fn+Fn−1Gn−1+Sn]
太乱了，整理下
⎧⎩⎨⎪⎪⎪⎪a11Fn−1+a21Fn+a31Sn+a41Gn−1a12Fn−1+a22Fn+a32Sn+a42Gn−1a13Fn−1+a23Fn+a33Sn+a43Gn−1a14Fn−1+a24Fn+a34Sn+a44Gn−1=Fn=Fn+Fn−1=Sn+Fn+Fn−1=Gn−1+Sn{a11Fn−1+a21Fn+a31Sn+a41Gn−1=Fna12Fn−1+a22Fn+a32Sn+a42Gn−1=Fn+Fn−1a13Fn−1+a23Fn+a33Sn+a43Gn−1=Sn+Fn+Fn−1a14Fn−1+a24Fn+a34Sn+a44Gn−1=Gn−1+Sn
可以推出
⎧⎩⎨⎪⎪⎪⎪a21=a12=a13=a34= 1 a22=1 a23=a33=1 a44=1{a21= 1a12= a22=1a13= a23=a33=1a34= a44=1
（非唯一解）

所以 A=⎡⎣⎢⎢⎢⎢0100110011100011⎤⎦⎥⎥⎥⎥A=[0110111000110001]
因为 Xn−1A=XnXn−1A=Xn
所以 Xn=X1An−1Xn=X1An−1
根据定义，X1=[F0F1S1G0]=[0110]X1=[F0F1S1G0]=[0110]
所以我们只需要用矩阵快速幂求出 An−1An−1，再左乘矩阵 [0110][0110] 即可。

时间复杂度 (logn)O(log⁡n)
C++ 代码
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

typedef long long ll;

int n, m;
ll A[4][4] = {                   // 上述矩阵 A
    {0, 1, 1, 0},
    {1, 1, 1, 0},
    {0, 0, 1, 1},
    {0, 0, 0, 1}
};
ll X[4] = {0, 1, 1, 0};          // 上述矩阵 X

void multi(ll A[][4], ll B[][4]) // 求出 4 × 4 的方阵 A 与 B 的乘积，并储存在 A 中
{
    ll ans[4][4] = {0};
    for (int i = 0; i < 4; i ++ )
        for (int j = 0; j < 4; j ++ )
            for (int k = 0; k < 4; k ++ )
                ans[i][j] += A[i][k] * B[k][j] % m;
    for (int i = 0; i < 4; i ++ )
        for (int j = 0; j < 4; j ++ )
            A[i][j] = ans[i][j] % m;
}

void _multi(ll A[], ll B[][4])   // 求出 1 × 4 的矩阵 A 与 4 × 4 的矩阵 B 的乘积，并储存在 A 中
{
    ll ans[4] = {0};
    for (int i = 0; i < 4; i ++ )
        for (int j = 0; j < 4; j ++ )
            ans[i] += A[j] * B[j][i] % m;
    for (int i = 0; i < 4; i ++ )
        A[i] = ans[i] % m;
}

void get(int n)                  // 求出 X[n]
{
    while (n)
    {
        if (n & 1) _multi(X, A);
        multi(A, A);
        n >>= 1;
    }
}

int main()
{
    scanf("%d %d", &n, &m);

    get(n - 1);                  // 求出 X[n - 1]

    printf("%lld\n", ((n * X[2] - X[3]) % m + m) % m);

    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/solution/content/15132/
 


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 4;

int n, m;

void mul(int c[][N], int a[][N], int b[][N])  // c = a * b
{
    static int t[N][N];
    memset(t, 0, sizeof t);

    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            for (int k = 0; k < N; k ++ )
                t[i][j] = (t[i][j] + (LL)a[i][k] * b[k][j]) % m;

    memcpy(c, t, sizeof t);
}

int main()
{
    cin >> n >> m;

    // {fn, fn+1, sn, pn}
    // pn = n * sn - tn
    int f1[N][N] = {1, 1, 1, 0};
    int a[N][N] = {
        {0, 1, 0, 0},
        {1, 1, 1, 0},
        {0, 0, 1, 1},
        {0, 0, 0, 1},
    };

    int k = n - 1;

    // 快速幂
    while (k)
    {
        if (k & 1) mul(f1, f1, a);  // f1 = f1 * a
        mul(a, a, a);  // a = a * a
        k >>= 1;
    }

    cout << (((LL)n * f1[0][2] - f1[0][3]) % m + m) % m << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/188826/
 


AcWing 1305. GT考试    原题链接    中等
作者：    Anoxia_3 ,  2020-08-01 10:30:02 ,  阅读 69

2


f[i][j]f[i][j]:表示长度是i，且不包含不吉利串，末尾部分与不吉利数字相同的长度是j的所有字符串集合。

状态转移方程：f[i+1][k]=a[0][k]∗f[i][0]+a[1][k]∗f[i][1]+…+a[m−1][k]∗f[i][m−1]f[i+1][k]=a[0][k]∗f[i][0]+a[1][k]∗f[i][1]+…+a[m−1][k]∗f[i][m−1]
发现f[i]与f[i+1]f[i]与f[i+1]的关系是线性的，所以可以用向量来计算，F[i+1]=F[i]∗AF[i+1]=F[i]∗A。

A向量中a[i][j]a[i][j]表示在总长度相邻的两个串中，将末尾部分与不吉利数字重复部分的长度从i变成ji变成j的方案数，这是一个定值，可以预处理。

通过kmp可以优化求A向量的过程。

在代码中因为ff数组是不断累乘的，所以在做完快速幂之后ff数组就是在乘完AnAn后的结果。


#include <iostream>
#include <cstring>

using namespace std;

const int N = 25;

int n , m , mod;
char str[N];
int ne[N] , a[N][N];

void mul(int c[][N] , int a[][N] , int b[][N])
{
    static int t[N][N];
    memset(t , 0 , sizeof t);//如果写了static，就不能通过static int t[N][N] = 0的方式初始化，因为只会调用一次 

    for(int i = 0 ; i < m ; i++)
        for(int j = 0 ; j < m ; j++)
            for(int k = 0 ; k < m ; k++)
                t[i][j] = (t[i][j] + a[i][k] * b[k][j]) % mod;

    memcpy(c , t , sizeof t);
}

int qmi(int k)
{
    int f[N][N] = {1};//为了简化代码f数组开二维，其实只用到了f[0]

    while(k)
    {
        if(k & 1) mul(f , f , a);
        k >>= 1;
        mul(a , a, a);
    }

    int res = 0;
    for(int i = 0 ; i < m ; i++) res = (res + f[0][i]) % mod;
    return res;
}

int main()
{
    cin >> n >> m >> mod;
    cin >> str + 1;

    //kmp
    for(int i = 2 , j = 0 ; i < m ; i++)
    {
        while(j && str[j + 1] != str[i]) j = ne[j];
        if(str[j + 1] == str[i]) j++;
        ne[i] = j;
    }

    for(int j = 0 ; j < m ; j++)//当前长度是j
        for(int c = '0' ; c <= '9' ; c++)//枚举后一位添加的数字
        {
            int k = j;
            while(k && str[k + 1] != c) k = ne[k];
            if(str[k + 1] == c) k++;
            if(k < m) a[j][k]++;//添加完后一位后，与不吉利串的匹配长度是k，方案数++
        }

    cout << qmi(n) << endl;
    return 0;
}

作者：Anoxia_3
链接：https://www.acwing.com/solution/content/17413/
 

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 25;

int n, m, mod;
char str[N];
int ne[N];
int a[N][N];

void mul(int c[][N], int a[][N], int b[][N])  // c = a * b
{
    static int t[N][N];
    memset(t, 0, sizeof t);

    for (int i = 0; i < m; i ++ )
        for (int j = 0; j < m; j ++ )
            for (int k = 0; k < m; k ++ )
                t[i][j] = (t[i][j] + a[i][k] * b[k][j]) % mod;

    memcpy(c, t, sizeof t);
}

int qmi(int k)
{
    int f0[N][N] = {1};
    while (k)
    {
        if (k & 1) mul(f0, f0, a);  // f0 = f0 * a
        mul(a, a, a);  // a = a * a
        k >>= 1;
    }

    int res = 0;
    for (int i = 0; i < m; i ++ ) res = (res + f0[0][i]) % mod;
    return res;
}

int main()
{
    cin >> n >> m >> mod;
    cin >> str + 1;

    // kmp
    for (int i = 2, j = 0; i <= m; i ++ )
    {
        while (j && str[j + 1] != str[i]) j = ne[j];
        if (str[j + 1] == str[i]) j ++ ;
        ne[i] = j;
    }

    // 初始化A[i][j]
    for (int j = 0; j < m; j ++ )
        for (int c = '0'; c <= '9'; c ++ )
        {
            int k = j;
            while (k && str[k + 1] != c) k = ne[k];
            if (str[k + 1] == c) k ++ ;
            if (k < m) a[j][k] ++ ;
        }


    // F[n] = F[0] * A^n
    cout << qmi(n) << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/188887/
 


AcWing 1307. 牡牛和牝牛    原题链接    简单
作者：    王雨阳 ,  2020-03-23 20:08:40 ,  阅读 199

6


Description:
约翰要带 N 只牛去参加集会里的展示活动，这些牛可以是牡牛，也可以是牝牛。

牛们要站成一排，但是牡牛是好斗的，为了避免牡牛闹出乱子，约翰决定任意两只牡牛之间至少要有 K 只牝牛。

请计算一共有多少种排队的方法，所有牡牛可以看成是相同的，所有牝牛也一样，答案对 5000011 取模。

Solution:
设 f[i]f[i] 表示 i 头牛站成一排有多少种排队的方法。

显然，对于1≤i≤k+1,f[i]=i+11≤i≤k+1,f[i]=i+1
因为这些情况最多有一只牡牛。

假设有i头牛排队，我们考虑最后一头牛，是牡牛或者不是牡牛。

如果不是牡牛， 那么前i-1头牛任意排队就可以了， 方案为f[i - 1]。
如果是牡牛，那么第i - k 到 i - 1都不能是牡牛，方案数为f[i - k - 1]

所以 ,f[i] = f[i - 1] + f[i - k - 1]

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int mod = 5000011, N = 1e5 +100;
int n, k, f[N];

int main()
{
    scanf("%d%d", &n, &k);
    for(int i = 1; i <= k + 1; i ++)  
        f[i] = i + 1;
    for(int i = k + 2; i <= n; i ++)
        f[i] = (f[i - 1] + f[i - k - 1]) % mod;
    printf("%d\n", f[n]);
    return 0;
}

作者：王雨阳
链接：https://www.acwing.com/solution/content/10366/
 


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, mod = 5000011;

int n, k;
int f[N], s[N];

int main()
{
    cin >> n >> k;

    f[0] = s[0] = 1;
    for (int i = 1; i <= n; i ++ )
    {
        f[i] = s[max(i - k - 1, 0)];
        s[i] = (s[i - 1] + f[i]) % mod;
    }

    cout << s[n] << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/188918/
 


AcWing 1308. 方程的解    原题链接    中等
作者：    Anoxia_3 ,  2020-08-02 21:39:03 ,  阅读 82

1


利用隔板法，把g(x)这个数看成g(x)个小球把g(x)这个数看成g(x)个小球，左边k个变量看成kk个变量看成k个盒子，要求每个盒子中都要有小球，

将g(x)个球排成一排，因为有k个盒子，所以需要把小球分成k部分，即要k−1将g(x)个球排成一排，因为有k个盒子，所以需要把小球分成k部分，即要k−1个隔板将小球分割，

因为每个盒子中都要有小球，所以一共有n-1个位置可以放置隔板，因此结果是 C n−1k−1C n−1k−1
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 150;

int f[1000][100][N];//f[i][j]表示求Cij
int k , x;

int qmi(int a,  int b, int mod)
{
    int res = 1;
    while(b)
    {
        if(b & 1) res = (LL) res * a % mod;
        b >>= 1;
        a = (LL) a * a % mod;
    }

    return res;
}

void add(int c[] , int a[] , int b[])
{
    for(int i = 0 , t = 0 ; i < N ; i++)
    {
        t += a[i] + b[i];
        c[i] = t % 10;
        t /= 10;
    }
}

int main()
{

    cin >> k >> x;

    int n = qmi(x % 1000 , x , 1000);

    //C(n-1 , k-1)，因为题目中没有说取模，所以要用到高精度
    for(int i = 0 ; i < n ; i++)
        for(int j = 0 ; j <= i && j < k ; j++)//C右上角<=C右下角，C右上角 <= k-1
            if(!j) f[i][j][0] = 1;
            else add(f[i][j] , f[i - 1][j] , f[i - 1][j - 1]);

    int *g = f[n - 1][k - 1];
    int k = N - 1;
    while(!g[k]) k--;
    while(k >= 0) cout << g[k--];

    return 0;
}

作者：Anoxia_3
链接：https://www.acwing.com/solution/content/17593/
 


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 150;

int k, x;
int f[1000][100][N];

int qmi(int a, int b, int p)
{
    int res = 1;
    while (b)
    {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

void add(int c[], int a[], int b[])
{
    for (int i = 0, t = 0; i < N; i ++ )
    {
        t += a[i] + b[i];
        c[i] = t % 10;
        t /= 10;
    }
}

int main()
{
    cin >> k >> x;

    int n = qmi(x % 1000, x, 1000);

    // C(n - 1, k - 1)
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j <= i && j < k; j ++ )
            if (!j) f[i][j][0] = 1;
            else add(f[i][j], f[i - 1][j], f[i - 1][j - 1]);  // f[i][j] = f[i - 1][j] + f[i - 1][j - 1];

    int *g = f[n - 1][k - 1];
    int i = N - 1;
    while (!g[i]) i -- ;
    while (i >= 0) cout << g[i -- ];

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/188959/
 

AcWing 1309. 车的放置    原题链接    中等
作者：    Anoxia_3 ,  2020-08-03 10:35:48 ,  阅读 64

1


乘法原理、加法原理
将原来的图分成上下两块，分别在上半部分放ii个，下半部分放k−ik−i个，方案之间是加法原理，因为两两之间没有关系。

①先考虑上半部分：

          若在上半部分放ii个，则要从bb行中选出i行用来放置，是一个组合问题，即Ci bCi b；再考虑列，因为
车的前后顺序不同，方案也不同，所以是个排列问题，即Ai aAi a。

②再考虑下半部分：

          因为已经放了ii个，所以下半部分只能放k−ik−i个，同样先考虑行，要从dd行中选出k−ik−i行，即Ck−i dCk−i d；再考虑列，同样是排列问题，即即Ak−i a+c−iAk−i a+c−i
内部是乘法原理，因为后面的结果会受到前面的影响。

#include <iostream>

using namespace std;

typedef long long LL;

const int N = 2010 , mod = 100003;//因为式子中出现a+c，所以N要开两倍

int f[N] , inf[N];

int qmi(int a ,  int b)
{
    int res = 1;
    while(b)
    {
        if(b & 1) res = (LL) res * a % mod;
        b >>= 1;
        a = (LL) a * a % mod;
    }
    return res;
}

int C(int a , int b)
{
    if(a < b) return 0;
    return (LL)f[a] * inf[b] % mod  * inf[a-b] % mod;
}

int A(int a , int b)
{
    if(a < b) return 0;
    return (LL)f[a] * inf[a - b] % mod;
}

int main()
{
    int a , b , c , d , k;
    cin >> a >> b >> c >> d >> k;

    f[0] = inf[0] = 1;
    for(int i = 1 ; i < N ; i++)    
    {
        f[i] = (LL)f[i - 1] * i % mod;
        inf[i] = (LL)inf[i - 1] * qmi(i , mod - 2) % mod;
    }

    int res = 0;
    for(int i = 0 ; i <= b ; i++)
        res = (res + (LL) C(b , i) * A(a , i) % mod * C(d , k - i) % mod * A(a + c - i , k - i) % mod) % mod;

    cout << (res % mod + mod) % mod << endl;
    return 0; 
}

作者：Anoxia_3
链接：https://www.acwing.com/solution/content/17627/
 


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 2010, mod = 100003;

int fact[N], infact[N];

int qmi(int a, int k)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % mod;
        a = (LL)a * a % mod;
        k >>= 1;
    }
    return res;
}

int C(int a, int b)
{
    if (a < b) return 0;
    return (LL)fact[a] * infact[a - b] % mod * infact[b] % mod;
}

int P(int a, int b)
{
    if (a < b) return 0;
    return (LL)fact[a] * infact[a - b] % mod;
}

int main()
{
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; i ++ )
    {
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2) % mod;
    }

    int a, b, c, d, k;
    cin >> a >> b >> c >> d >> k;

    int res = 0;
    for (int i = 0; i <= k; i ++ )
    {
        res = (res + (LL)C(b, i) * P(a, i) % mod * C(d, k - i) % mod * P(a + c - i, k - i)) % mod;
    }

    cout << res << endl;

    return 0;


作者：yxc
链接：https://www.acwing.com/activity/content/code/content/192187/
 

AcWing 1310. 数三角形    原题链接    中等
作者：    番茄酱 ,  2020-02-19 17:39:16 ,  阅读 269

8


首先n++, m++;转化为格点数，我们需要从 n×mn×m 个格点中选出 33 个合法格点构成三角形，那么显然我们只需要将 C3nmCnm3 减去不合法的情况（即三点共线的情况）。

我们将三点共线的斜率分为三种情况分别统计：

斜率不存在（即竖直）：mC3nmCn3
斜率为 00（即水平）：nC3mnCm3
斜率存在且不为 00，斜率为正，与斜率为负是对称的，那么只考虑前者即可。
首先n--, m--; 还原为长度。
我们在 n×mn×m 的矩形中，枚举底为 ii，高为 jj 的直角三角形，共有 (n−i+1)(m−j+1)(n−i+1)(m−j+1) 种（当然，我们只考虑斜边斜率大于 00 的情况）
这样的直角三角形，其斜边上的两个端点一定在格点上，我们只需要考察斜边上除了端点，还存在的格点的数量，结论：有 gcd(i,j)−1gcd(i,j)−1 个。那么这个三角形的斜边对三点共线的贡献即为：(gcd(i,j)−1)(gcd(i,j)−1) 种。
总结：共 2(n−i+1)(m−j+1)(gcd(i,j)−1)2(n−i+1)(m−j+1)(gcd(i,j)−1) 种
最后，利用容斥原理，从总数减去不合法的即可。

#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

LL n, m;

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

LL C(LL a, LL b) {
    return a * (a - 1) * (a - 2) / 6;
}

int main() {
    cin >> n >> m;
    n++, m++; // 转化为格点数
    LL res = C(n * m, 3) - n * C(m, 3) - m * C(n, 3);
    n--, m--; // 还原成长度
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++)
            res -= 2 * (n - i + 1) * (m - j + 1) * (gcd(i, j) - 1);
    }
    cout << res << endl;
    return 0;
}

作者：番茄酱
链接：https://www.acwing.com/solution/content/8781/
 


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

LL C(int n)
{
    return (LL)n * (n - 1) * (n - 2) / 6;
}

int main()
{
    int n, m;
    cin >> n >> m;

    n ++, m ++ ;

    LL res = C(n * m) - (LL)n * C(m) - (LL)m * C(n);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            res -= 2ll * (gcd(i, j) - 1) * (n - i) * (m - j);

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/192215/
 


AcWing 1312. 序列统计    原题链接    中等
作者：    番茄酱 ,  2020-02-21 13:22:09 ,  阅读 390

5


1
解法
约定：题目中的 N,L,RN,L,R 用 n,l,rn,l,r 表示。

首先，数据之间只存在相对关系，那么可以将 [l,r][l,r] 区间映射到 [0,r−l][0,r−l]，设序列长度为 kk，题意即求：

满足 0≤a1≤a2≤⋯≤ak≤r−l, 其中 ai∈[0,r−l] 的序列个数
满足 0≤a1≤a2≤⋯≤ak≤r−l, 其中 ai∈[0,r−l] 的序列个数
令 x1=a1,x2=a2−a1,⋯,xk=ak−ak−1x1=a1,x2=a2−a1,⋯,xk=ak−ak−1，则有：

0≤x1+x2+⋯+xk≤r−l, 其中 xi≥0 
0≤x1+x2+⋯+xk≤r−l, 其中 xi≥0 
那么我们只要求上述满足条件的 {xk}{xk} 数列的个数，问题即：用不超过 r−lr−l 个小球放入 kk 个盒子，盒子允许为空的方案数。

但是我们更倾向于解决盒子不空的情况，那么可以这么转化：先给每一个盒子放入一个小球，那么就变成了盒子不空的情况，此时我们需要令小球的总数 +k+k，即用不超过 r−l+kr−l+k 个小球放入 kk 个盒子，且盒子不空的方案数。

我们考虑「隔板法」来解决这个排列组合问题。需要注意的是，这里的条件是不等式，对于等式而言，我们用 k−1k−1 个隔板将所有小球分为 kk 部分即可；对于不等式，我们考虑用 kk 个隔板，将所有小球分为 k+1k+1 部分，其中最后一部分被舍弃（即不选用），当然最后一部分的个数在本题可以为零。如下示意图：

⚪···⚪|⚪···⚪|···|⚪···⚪|⚪···⚪

⚪···⚪|⚪···⚪|···|⚪···⚪|这里没有球

如果用 yiyi 表示每个盒子的小球个数，那么第一部分为 y1y1，第二部分为 y2y2，倒数第二部分为 ykyk，最后一部分为舍弃的部分（可以为零，如第二个图）。

这样我们就可以运行排列组合的知识，共 nn 个球，有 n−1n−1 个缝隙，还需要加上最右边的一个“缝隙”，共 nn 个缝隙，插入 kk 个隔板。答案为：∑nk=1Ckr−l+k∑k=1nCr−l+kk
计算
数据范围 109109，显然不能枚举长度 kk 来累加答案，需要进行数学推导，下面的过程用到了两个组合数公式：

Cmn=Cn−mn, Cmn=Cmn−1+Cm−1n−1
Cnm=Cnn−m, Cnm=Cn−1m+Cn−1m−1
令 r−l=mr−l=m，则：

原式=======∑k=1nCkm+kC1m+1+C2m+2+⋯+Cnm+nCmm+1+Cmm+2+⋯+Cmm+n(Cm+1m+1+Cmm+1)+⋯+Cmm+n−Cm+1m+1(Cm+1m+2+Cmm+2)+⋯+Cmm+n−1⋯Cm+1m+n+1−1
原式=∑k=1nCm+kk=Cm+11+Cm+22+⋯+Cm+nn=Cm+1m+Cm+2m+⋯+Cm+nm=(Cm+1m+1+Cm+1m)+⋯+Cm+nm−Cm+1m+1=(Cm+2m+1+Cm+2m)+⋯+Cm+nm−1=⋯=Cm+n+1m+1−1
然后用 LucasLucas 定理求解组合数即可。

代码
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int mod = 1e6 + 3;

int n, l, r;

int ksm(int a, int k) {
    int res = 1;
    while (k) {
        if (k & 1) res = (LL)res * a % mod;
        a = (LL)a * a % mod;
        k >>= 1;
    }
    return res;
}

int C(int a, int b) {
    int res = 1, inv = 1;
    for (int i = 1, j = a; i <= b; i++, j--) {
        res = (LL)res * j % mod;
        inv = (LL)inv * i % mod;
    }
    res = (LL)res * ksm(inv, mod - 2) % mod;
    return res;
}

int lucas(LL a, LL b) {
    if (a < mod && b < mod) return C(a, b);
    return (LL)C(a % mod, b % mod) * lucas(a / mod, b / mod) % mod;
}

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        scanf("%d%d%d", &n, &l, &r);
        int res = lucas(r - l + n + 1, r - l + 1) - 1;
        cout << (res % mod + mod) % mod << endl;
    }
    return 0;
}

作者：番茄酱
链接：https://www.acwing.com/solution/content/8867/
 

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int p = 1000003;

int qmi(int a, int k)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int C(int a, int b)
{
    if (a < b) return 0;

    int down = 1, up = 1;
    for (int i = a, j = 1; j <= b; i --, j ++ )
    {
        up = (LL)up * i % p;
        down = (LL)down * j % p;
    }

    return (LL)up * qmi(down, p - 2) % p;
}

int Lucas(int a, int b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)Lucas(a / p, b / p) * C(a % p, b % p) % p;
}

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        int n, l, r;
        cin >> n >> l >> r;
        cout << (Lucas(r - l + n + 1, r - l + 1) + p - 1) % p << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/192257/
 


AcWing 1315. 网格    原题链接    中等
作者：    Anoxia_3 ,  2020-08-03 20:38:43 ,  阅读 75

1


1
卡特兰数的应用
依据卡塔兰数的推导，找出(n,m)(n,m)关于y=x+1y=x+1的对称点(m−1,n+1)(m−1,n+1)，每一条非法路径都对应一条(0,0)(0,0)到(m−1,n+1)(m−1,n+1)的路径，因此合法路径=总路径数-非法路径，即Cnn+m−Cm−1n+mCn+mn−Cn+mm−1
#include <iostream>

using namespace std;

const int N = 10010;

int primes[N] , cnt;
bool st[N];
int a[N] , b[N];

void init(int n)
{
    for(int i = 2 ; i <= n ; i++)
    {
        if(!st[i]) primes[cnt++] = i;

        for(int j = 0 ; primes[j] <= n / i ; j++)
        {
            st[primes[j] * i] = true;

            if(i % primes[j] == 0) break;
        }
    }
}

int get(int n , int p)//n!中p的次数
{
    int res = 0;
    for(int i = n ; i ; i /= p) res += i / p;
    return res;
}

void mul(int a[] , int &len , int b)//a = a * b 高精度*低精度
{
    int t = 0;
    for(int i = 0  ; i < len ; i++)
    {
        t += a[i] * b;
        a[i] = t % 10;
        t /= 10;
    }

    while(t)
    {
        a[len++] = t % 10;
        t /= 10;
    }

}

int C(int a , int b , int c[])//把$C_{a}^{b}$存到c数组中
{
    int len = 1;
    c[0] = 1;

    for(int i = 0 ; i < cnt ; i++)
    {
        int p = primes[i];
        int s = get(a , p) - get(b , p) - get(a - b , p);
        while(s--) mul(c , len , p);
    }

    return len;
}

void sub(int a[] , int al , int b[] , int bl)
{
    for(int i = 0 , t = 0; i < al ; i++)
    {
        a[i] -= t + b[i];
        if(a[i] < 0) t = 1 , a[i] += 10;
        else t = 0;//t代表前一位是否要减一
    }
}

int main()
{
    init(N - 1);

    int n , m;
    cin >> n >> m;
    int al = C(n + m , m , a);
    int bl = C(n + m , m - 1 , b);

    sub(a , al , b , bl);

    int i = al - 1;
    while(!a[i] && i) i--;
    while(i >= 0) cout << a[i--];
    return 0;
}

作者：Anoxia_3
链接：https://www.acwing.com/solution/content/17680/
 

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int primes[N], cnt;
bool st[N];
int a[N], b[N];

void init(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int get(int n, int p)
{
    int s = 0;
    while (n) s += n / p, n /= p;
    return s;
}

void mul(int r[], int &len, int x)
{
    int t = 0;
    for (int i = 0; i < len; i ++ )
    {
        t += r[i] * x;
        r[i] = t % 10;
        t /= 10;
    }
    while (t)
    {
        r[len ++ ] = t % 10;
        t /= 10;
    }
}

void sub(int a[], int al, int b[], int bl)
{
    for (int i = 0, t = 0; i < al; i ++ )
    {
        a[i] -= t + b[i];
        if (a[i] < 0) a[i] += 10, t = 1;
        else t = 0;
    }
}

int C(int x, int y, int r[N])
{
    int len = 1;
    r[0] = 1;

    for (int i = 0; i < cnt; i ++ )
    {
        int p = primes[i];
        int s = get(x, p) - get(y, p) - get(x - y, p);
        while (s -- ) mul(r, len, p);
    }

    return len;
}

int main()
{
    init(N - 1);

    int n, m;
    cin >> n >> m;
    int al = C(n + m, m, a);
    int bl = C(n + m, n + 1, b);

    sub(a, al, b, bl);

    int k = al - 1;
    while (!a[k] && k > 0) k -- ;
    while (k >= 0) printf("%d", a[k -- ]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/192302/
 


AcWing 1316. 有趣的数列    原题链接    中等
作者：    Anoxia_3 ,  2020-08-03 21:35:32 ,  阅读 99

1


看到样例中n=3，答案=5，就有可能是卡特兰数。

做法：依次将1~2n内的每个数归入奇数项和偶数项，显然1要排在奇数项的第一位(整个序列的第一位)。

本题结论：奇数项数>=偶数项数

证明：
      如果奇数项数 < 偶数项数，那么当将一个数归入奇数项时，因为是顺次枚举每个数，那么这个数将比上一个选出归入偶数项的数要大，即如果把这个数放入奇数项，肯定会比之后所有的偶数项都要大，显然会比相邻的偶数项要大，不满足条件，假设不成立。

#include <iostream>

using namespace std;

const int N = 2000010;

typedef long long LL;

int n , mod;
int primes[N] , cnt;
bool st[N];

int qmi(int a, int b)
{
    int res = 1;
    while(b)
    {
        if(b & 1) res = (LL) res * a % mod;
        b >>= 1;
        a = (LL) a * a % mod;
    }
    return res;
}

void init(int n)
{
    for(int i = 2 ; i <= n ; i++)
    {
        if(!st[i]) primes[cnt++] = i;

        for(int j = 0 ; primes[j] <= n / i ; j++)
        {
            st[primes[j] * i] = true;

            if(i % primes[j] == 0) break;
        }
    }
}

int get(int x , int p)
{
    int s = 0;
    while(x) s += x / p , x /= p;
    return s;
}

int C(int a , int b)
{
    int res = 1;
    for(int i = 0 ; i < cnt ; i++)
    {
        int p = primes[i];
        int s = get(a , p) - get(b , p) - get(a - b , p);
        res = (LL) res * qmi(p , s) % mod;
    }
    return res;
}

int main()
{

    cin >> n >> mod;

    init(2 * n);//因为式子中会用到2*n

    cout << (C(2 * n , n) - C(2 * n , n - 1) + mod) % mod << endl;
    return 0;
}

作者：Anoxia_3
链接：https://www.acwing.com/solution/content/17682/
 

看到 2n，不禁想起卡特兰数（什么鬼，其实是看了算法标签。

自己想的一个映射方式。
对于一个 2n 的 01 卡特兰序列。

从左往右考虑每一位，设当前是第 i 位，那么要填的就是第 i 个数字
如果是 0，则将 i 填到奇数下标（ 1、3、5、7、9 ）中第一个空位中。
如果是 1，则将 i 填到偶数下标（2、4、6、8）的第一个空位中
因为卡特兰保证在任何情况下 0 个个数 >= 1 的个数。
所以再填一个偶数的时候，他前面的奇数已经填完了，所以肯定比他的值小。

然后逆映射也是类似的，所以显然就是卡特兰数。。

#include <cstdio>
#include <iostream>
using namespace std;
const int N = 2000005;
typedef long long LL;
int n, P, ans = 1, cnt[N];
bool st[N];
int power(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = (LL)res * a % P;
        a = (LL)a * a % P;
        b >>= 1;
    }
    return res;
}
int get(int a, int b) {
    int res = 0;
    while (a) res += a / b, a /= b;
    return res;
}
int main() {
    scanf("%d%d", &n, &P);
    // C(2n, n)
    int x = n + 1;
    for (int i = 2; i * i <= x; i++) {
        while (x % i == 0) cnt[i]++, x /= i;
    }
    if (x > 1) cnt[x] ++;
    for (int i = 2; i <= 2 * n; i++) {
        if (st[i]) continue;
        for (int j = i * 2; j <= 2 * n; j += i) st[j] = true;
        int k = get(2 * n, i) - 2 * get(n, i) - cnt[i];
        ans = (LL)ans * power(i, k) % P;
    }
    printf("%d\n", ans);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/192386/
 

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 2000010;

int n, p;
int primes[N], cnt;
bool st[N];

void init(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if  (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[i * primes[j]] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int qmi(int a, int k)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int get(int n, int p)
{
    int s = 0;
    while (n)
    {
        s += n / p;
        n /= p;
    }
    return s;
}

int C(int a, int b)
{
    int res = 1;
    for (int i = 0; i < cnt; i ++ )
    {
        int prime = primes[i];
        int s = get(a, prime) - get(b, prime) - get(a - b, prime);

        res = (LL)res * qmi(prime, s) % p;
    }

    return res;
}

int main()
{
    scanf("%d%d", &n, &p);
    init(n * 2);

    cout << (C(n * 2, n) - C(n * 2, n - 1) + p) % p << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/193215/
 

#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

typedef long long ll;

const int N=148935;
const int M=2000005;

ll n,p;
ll ans=1;
int a[M];
int primes[N],cnt;
bool st[M];

inline void init(int n)
{
    for(int i=2;i<=n;i++)
    {
        if(!st[i])primes[cnt++]=i;
        for(int j=0;primes[j]<=n/i;j++)
        {
            st[primes[j]*i]=true;
            if(i%primes[j]==0)break;
        }
    }
}

inline void get_primes(int n,int t)
{
    for(int i=0;primes[i]<=n;i++)
        for(int j=n/primes[i];j;j/=primes[i])
            a[primes[i]]+=j*t;
}

int main()
{
    scanf("%lld %lld",&n,&p);
    init(M-1);
    get_primes(n<<1,1);
    get_primes(n,-2);
    int j=n+1;
    for(int i=0;primes[i]<=j/primes[i];i++)
        while(j%primes[i]==0)
            j/=primes[i],a[primes[i]]--;
    if(j>1)a[j]--;
    for(int i=0;i<cnt;i++)
        while(a[primes[i]]--)
            ans=ans*primes[i]%p;
    printf("%lld\n",ans);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/358991/
 


AcWing 207. 球形空间产生器    原题链接    困难
作者：    秦淮岸灯火阑珊 ,  2019-03-03 16:14:11 ,  阅读 775

7


1
原题连接
更好的阅读体验

题目描述
有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。

现在，你被困在了这个nn维球体中，你只知道球面上n+1n+1个点的坐标，你需要以最快的速度确定这个nn维球体的球心坐标，以便于摧毁这个球形空间产生器。

输入格式
第一行是一个整数nn。

接下来的n+1n+1行，每行有nn个实数，表示球面上一点的n维坐标。

每一个实数精确到小数点后66位，且其绝对值都不超过2000020000。

输出格式
有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。

每个实数精确到小数点后3位。

数据保证有解。

数据范围
1≤n≤101≤n≤10
样例
输入样例：
2
0.0 0.0
-1.0 1.0
1.0 0.0
输出样例：
0.500 1.500
高斯消元
超级讨厌这种数学题目,欺负蒟蒻我latex写不好,注意以下latex一些是数学公式生成器生成的.
对于一个球体而言,所有点到球心的距离相等,所以只需要求出一个点(x1,x2,…,xn)(x1,x2,…,xn)使得满足∑nj=0(ai,j−xj)2=C∑j=0n(ai,j−xj)2=C
记住C是常数,i∈[1,n+1]i∈[1,n+1] 那么这个方程组是由n+1n+1个nn元二次方程,然后我们同时消去C.∑nj=1(a2i,j−a2i+1,j−2xj(ai,j−ai+1,j,))(i=1,2,3,…,n)∑j=1n(ai,j2−ai+1,j2−2xj(ai,j−ai+1,j,))(i=1,2,3,…,n)
我们再把变量放左边,常数放右边.
∑nj=12(ai,j−ai+1,j)xj=∑nj=1(a2i,j−a2i+1,j)(i=1,2,3,…,n)∑j=1n2(ai,j−ai+1,j)xj=∑j=1n(ai,j2−ai+1,j2)(i=1,2,3,…,n)
然后我们就可以开始愉快地高斯消元了.
C++ 代码
#include <bits/stdc++.h>
using namespace std;
int n,i,j;
double a[21][21],b[21],c[21][21];
inline int work()
{
    for(i=1;i<=n;i++)
    {
        for(j=i;j<=n;j++)
            if (fabs(c[j][i])>1e-8)
            {
                for (int k=1;k<=n;k++)
                    swap(c[i][k],c[j][k]);
                swap(b[i],b[j]);
            }
        for(int j=1;j<=n;j++)
        {
            if (i==j)
                continue;
            double rate=c[j][i]/c[i][i];
            for(int k=i;k<=n;k++)
                c[j][k]-=c[i][k]*rate;
            b[j]-=b[i]*rate;
        }
    }
}
inline void init()
{
    cin>>n;
    for(i=1;i<=n+1;i++)
        for(j=1;j<=n;j++)
            cin>>a[i][j];
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        {
            c[i][j]=2*(a[i][j]-a[i+1][j]);
            b[i]+=a[i][j]*a[i][j]-a[i+1][j]*a[i+1][j];
        }
}
inline void out()
{
    for(int i=1;i<=n;i++)
        printf("%.3lf ",b[i]/c[i][i]);
}
int main()
{
    init();
    work();
    out();
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1086/
 


#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

const int N=12;

int n;
double sum[N];
double w[N][N];
double b[N][N];
double x[N];

inline void print(double a[][N])
{
    for(int i=0;i<n;i++,puts(""))
        for(int j=0;j<=n;j++)
            printf("%.2lf ",b[i][j]);
    putchar('\n');
}

int main()
{
    scanf("%d",&n);
    for(int i=0;i<=n;i++)
        for(int j=0;j<n;j++)
        {
            scanf("%lf",&w[i][j]);
            sum[i]+=w[i][j]*w[i][j];
        }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
            b[i][j]=2.0*(w[i+1][j]-w[0][j]);
        b[i][n]=sum[i+1]-sum[0];
    }
    for(int i=0;i<n;i++)
        for(int j=i+1;j<n;j++)
            for(int k=n;k>=i;k--)
                b[j][k]-=b[i][k]*b[j][i]/b[i][i];
    for(int i=n-1;i>0;i--)
        for(int j=i-1;j>=0;j--)
            b[j][n]-=b[j][i]/b[i][i]*b[i][n];
    for(int i=0;i<n;i++)
        x[i]=b[i][n]/b[i][i];
    for(int i=0;i<n;i++)
        printf("%.3lf ",x[i]);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/359096/
 

遇事不决先打卡

#include <cstdio>
#include <iostream>
using namespace std;
const int N = 11;
const double eps = 1e-5;
int n;
double a[N][N], x[N][N];
int main() {
    scanf("%d", &n);
    for (int i = 0; i <= n; i++)
        for (int j = 0; j < n; j++) scanf("%lf", &x[i][j]);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            a[i][j] = 2 * (x[i][j] - x[i + 1][j]);
            a[i][n] += x[i][j] * x[i][j] - x[i + 1][j] * x[i + 1][j];
        }
    }
    for (int r = 0, c = 0; c < n; c++) {
        for (int i = n; i >= c; i--) a[r][i] /= a[r][c];
        for (int i = r + 1; i < n; i++)
            for (int j = n; j >= r; j--) a[i][j] -= a[r][j] * a[i][c];
        r++;
    }

    for (int i = n - 2; ~i; i--)
        for (int j = n - 1; j > i; j--) a[i][n] -= a[i][j] * a[j][n];

    for (int i = 0; i < n; i++) printf("%.3lf ", a[i][n]);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/192936/
 

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 15;

int n;
double a[N][N], b[N][N];

void gauss()
{
    // 转化成上三角矩阵
    for (int r = 1, c = 1; c <= n; c ++, r ++ )
    {
        // 找主元
        int t = r;
        for (int i = r + 1; i <= n; i ++ )
            if (fabs(b[i][c]) > fabs(b[t][c]))
                t = i;

        // 交换
        for (int i = c; i <= n + 1; i ++ ) swap(b[t][i], b[r][i]);
        // 归一化
        for (int i = n + 1; i >= c; i -- ) b[r][i] /= b[r][c];
        // 消
        for (int i = r + 1; i <= n; i ++ )
            for (int j = n + 1; j >= c; j -- )
                b[i][j] -= b[i][c] * b[r][j];
    }

    // 转化成对角矩阵
    for (int i = n; i > 1; i -- )
        for (int j = i - 1; j; j -- )
        {
            b[j][n + 1] -= b[i][n + 1] * b[j][i];
            b[j][i] = 0;
        }
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n + 1; i ++ )
        for (int j = 1; j <= n; j ++ )
            scanf("%lf", &a[i][j]);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
        {
            b[i][j] += 2 * (a[i][j] - a[0][j]);
            b[i][n + 1] += a[i][j] * a[i][j] - a[0][j] * a[0][j];
        }

    gauss();

    for (int i = 1; i <= n; i ++ ) printf("%.3lf ", b[i][n + 1]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/193255/
 

AcWing 208. 开关问题    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-03-03 16:35:32 ,  阅读 805

7


2
原题连接
更好的阅读体验

题目描述
有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。

你的目标是经过若干次开关操作后使得最后NN个开关达到一个特定的状态。

对于任意一个开关，最多只能进行一次开关操作。

你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序）

输入格式
输入第一行有一个数KK，表示以下有KK组测试数据。

每组测试数据的格式如下：

第一行 一个数NN（0<N<29）（0<N<29）。

第二行 NN个0或者1的数，表示开始时NN个开关状态。

第三行 NN个0或者1的数，表示操作结束后NN个开关的状态。

接下来 每行两个数IJIJ，表示如果操作第 II 个开关，第JJ个开关的状态也会变化。

每组数据以 0 0 结束。

输出格式
如果有可行方法，输出总数，否则输出“Oh,it’s impossible~!!” 。

样例
输入样例：
2
3
0 0 0
1 1 1
1 2
1 3
2 1
2 3
3 1
3 2
0 0
3
0 0 0
1 0 1
1 2
2 1
0 0
输出样例：
4
Oh,it's impossible~!!
高斯消元+异或空间
设xixi表示第ii个开关的操作情况,那么xi=1xi=1为按了这个开关,否则xi=0xi=0表示这个开关并没有按下去,那么我们接着统计ai,jai,j表示第i个开关和第j个开关的联系情况,ai,j=1ai,j=1表示按下j会影响i的状态,否则就是不会影响,即ai,j=0ai,j=0,特殊地一个点就是,ai,i=1ai,i=1,因为我们本身肯定会影响本身.
我们用int整数,来存储一个n+1位的二进制数
C++ 代码
#include <bits/stdc++.h>
using namespace std;
int a[110],n,t,ans,x,y;
signed main()
{
    ios::sync_with_stdio(false);
    cin>>t;
    while(t--)
    {
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        for(int i=1;i<=n;i++)
        {
            cin>>x;
            a[i]^=x;
            a[i]|=1<<i;
        }
        while(cin>>x>>y && (x && y))
            a[y]|=1<<x;
        ans=1;
        for(int i=1;i<=n;i++)
        {
            for(int j=i+1;j<=n;j++)
                if (a[j]>a[i])
                    swap(a[i],a[j]);
            if (a[i]==0)
            {
                ans=1<<(n-i+1);
                break;
            }
            if (a[i]==1)
            {
                ans=0;
                break;
            }
            for(int k=n;k;k--)
                if (a[i]>>k & 1)
                {
                    for(int j=1;j<=n;j++)
                        if (i!=j && (a[j]>>k & 1))
                            a[j]^=a[i];
                    break;
                }
        }
        if (ans==0)
            cout<<"Oh,it's impossible~!!"<<endl;
        else
            cout<<ans<<endl;
    }
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1087/
 

#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

const int N=35;

int T,n;
int a[N][N];

inline int Gauss()
{
    int r,c;
    for(r=c=1;c<=n;c++)
    {
        int t=r;
        for(int i=r+1;i<=n;i++)
            if(a[i][c])t=i;
        if(!a[t][c])continue;
        for(int i=c;i<=n+1;i++)
            swap(a[t][i],a[r][i]);
        for(int i=r+1;i<=n;i++)
            for(int j=n+1;j>=c;j--)
                a[i][j]^=a[i][c]&a[r][j];
        r++;
    }
    int res=1;
    if(r<n+1)
    {
        for(int i=r;i<=n;i++)
        {
            if(a[i][n+1])return -1;
            res<<=1;
        }
    }
    return res;
}

int main()
{
    for(scanf("%d",&T);T--;)
    {
        memset(a,0,sizeof a);
        scanf("%d",&n);
        for(int i=1;i<=n;i++)scanf("%d",&a[i][n+1]);
        for(int i=1;i<=n;i++)
        {
            int t;
            scanf("%d",&t);
            a[i][n+1]^=t;
            a[i][i]=1;
        }
        for(int u,v;scanf("%d%d",&u,&v),u||v;a[v][u]=1);
        int t=Gauss();
        if(~t)printf("%d\n",t);
        else puts("Oh,it's impossible~!!");
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/359271/
 

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 35;

int n;
int a[N][N];

int gauss()
{
    int r, c;
    for (r = 1, c = 1; c <= n; c ++ )
    {
        // 找主元
        int t = r;
        for (int i = r + 1; i <= n; i ++ )
            if (a[i][c])
                t = i;

        if (!a[t][c]) continue;
        // 交换
        for (int i = c; i <= n + 1; i ++ ) swap(a[t][i], a[r][i]);
        // 消
        for (int i = r + 1; i <= n; i ++ )
            for (int j = n + 1; j >= c; j -- )
                a[i][j] ^= a[i][c] & a[r][j];
        r ++ ;
    }

    int res = 1;
    if (r < n + 1)
    {
        for (int i = r; i <= n; i ++ )
        {
            if (a[i][n + 1]) return -1;  // 出现了 0 == !0，无解
            res *= 2;
        }
    }

    return res;
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        memset(a, 0, sizeof a);
        scanf("%d", &n);
        for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i][n + 1]);
        for (int i = 1; i <= n; i ++ )
        {
            int t;
            scanf("%d", &t);
            a[i][n + 1] ^= t;
            a[i][i] = 1;
        }

        int x, y;
        while (scanf("%d%d", &x, &y), x || y) a[y][x] = 1;

        int t = gauss();
        if (t == -1) puts("Oh,it's impossible~!!");
        else printf("%d\n", t);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/193292/
 

    AcWing 214. Devu和鲜花    原题链接    中等
作者：    叁秋. ,  2020-05-25 21:40:29 ,  阅读 222

5


1
经典容斥
题意就不说了.

解法
理想情况
理想每一组中可以取无限朵花，那么我们就需要达到x1+x2+x3+……+xn=Mx1+x2+x3+……+xn=M。
此时xi>=0xi>=0，那么令yi=xi+1yi=xi+1，则y1+y2+y3+……+yn=M+Ny1+y2+y3+……+yn=M+N。
因为yi>=1yi>=1，所以可以用隔板法,在M+N−1M+N−1个空隙中插入N−1N−1个板,答案为CN−1M+N−1CM+N−1N−1。

实际
在实际中有x1<=A1,x2<=A2,x3<=A3……xn<=Anx1<=A1,x2<=A2,x3<=A3……xn<=An等条件，此时就需要同时满足这N个条件。
那么正难则反，考虑求补集，也就是至少不满足其中一个条件的方案。就可以用总方案减去这些方案就可以得出答案。
设不满足ii的方案为sisi，
那么答案就是CN−1M+N−1−|s1⋃s2⋃s3……⋃sn|CM+N−1N−1−|s1⋃s2⋃s3……⋃sn|。
将其展开就是：
CN−1M+N−1−|s1|−|s2|−……|s3|+|s1⋂s2|+……−|s1⋂s2⋂s3|−……CM+N−1N−1−|s1|−|s2|−……|s3|+|s1⋂s2|+……−|s1⋂s2⋂s3|−……。
就是一个容斥原理的展开。
考虑sisi怎么求。以s1s1举例，假如要求s1s1，就代表我们必须从第一组里取出至少A1+1A1+1朵花，那么此时还剩M−(A1+1)M−(A1+1)朵花。剩下的就是隔板，
那么此时方案就是CN−1M+N−1−(A1+1)CM+N−1−(A1+1)N−1。
那么|s1⋂s2||s1⋂s2|同上，方案就是CN−1M+N−1−(A1+1)−(A2+1)CM+N−1−(A1+1)−(A2+1)N−1。
整理一下，就得到 res=CN−1M+N−1−∑i=1CN−1M+N−1−(Ai+1)+∑i<jCN−1M+N−1−(Ai+1)−(Aj+1)−……res=CM+N−1N−1−∑i=1CM+N−1−(Ai+1)N−1+∑i<jCM+N−1−(Ai+1)−(Aj+1)N−1−……。
总所周知，容斥复杂度O(2n)O(2n)，那么可以从0枚举到2n−10枚举到2n−1。
然后把每一个条件看成一个二进制位,如果是11或00就代表遵守或不遵守这个条件，奇数个就减，偶数个就加。
那么怎么去算组合数，可以发现虽然MM非常大，但是我们的NN很小，所以只需按着定义去算，大概是NN的复杂度。所以总的复杂度就是O(2N∗N)O(2N∗N)。

参考代码
/*
    容斥+组合数计算.
*/
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
typedef long long ll;
const int N=25;
ll n,m;
int res;
ll a[N];
int down=1;
int ksm(int a,int b) {
    int res=1;
    while(b) {
        if(b&1) res=1ll*res*a%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return res;
}
int C(ll a,ll b) {
    if(a<b) return 0;
    int up=1;
    for(ll i=a; i>a-b; --i) up=i%mod*up%mod;
    return 1ll*up*down%mod;
}
int main() {
    scanf("%lld%lld",&n,&m);
    for(int i=0; i<n; ++i) scanf("%lld",&a[i]);
    for(int i=1; i<=n-1; ++i) down=1ll*i*down%mod;
    down=ksm(down,mod-2);
    for(int i=0; i<(1<<n); ++i) {
        ll d=m+n-1,up=n-1;
        int sign=1;
        for(int j=0; j<n; ++j) {
            if((i>>j)&1) {
                sign*=-1;
                d-=a[j]+1;
            }
        }
        res=(res+C(d,up)*sign)%mod;
    }
    printf("%d\n",(res+mod)%mod);
    return 0;
}

作者：叁秋.
链接：https://www.acwing.com/solution/content/13666/
 


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 20, mod = 1e9 + 7;

LL A[N];
int down = 1;

int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int C(LL a, LL b)
{
    if (a < b) return 0;
    int up = 1;
    for (LL i = a; i > a - b; i -- ) up = i % mod * up % mod;

    return (LL)up * down % mod; // 费马小定理
}

int main()
{
    LL n, m;
    cin >> n >> m;
    for (int i = 0; i < n; i ++ ) cin >> A[i];

    for (int j = 1; j <= n - 1; j ++ ) down = (LL)j * down % mod;
    down = qmi(down, mod - 2, mod);

    int res = 0;
    for (int i = 0; i < 1 << n; i ++ )
    {
        LL a = m + n - 1, b = n - 1;
        int sign = 1;
        for (int j = 0; j < n; j ++ )
            if (i >> j & 1)
            {
                sign *= -1;
                a -= A[j] + 1;
            }
        res = (res + C(a, b) * sign) % mod;
    }

    cout << (res + mod) % mod << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/196359/
 

AcWing 215. 破译密码    原题链接    困难
作者：    Anoxia_3 ,  2020-08-07 09:18:07 ,  阅读 92

3


1
莫比乌斯函数：


题意：给定a,b,d，若1≤x≤a，1≤y≤b1≤x≤a，1≤y≤b，求有多少对x和y,使得(x,y)=d(x,y)=d。

转化=>令x′=x/d，y′=y/dx′=x/d，y′=y/d，则1≤x′≤a/d，1≤y′≤b/d1≤x′≤a/d，1≤y′≤b/d，求有多少对x'和y'互质,。

如何求总共有多少对合法的呢？这里用到补集的思想：合法对数= 总对数-不合法对数。

不合法对：x'和y'的最大公因数大于1。
令a′=a/d，b′=b/da′=a/d，b′=b/d，利用容斥原理求得不合法对数：

a′b′−a′/2∗b‘2−a′/3∗b′/3−…(有一个质公因子)a′b′−a′/2∗b‘2−a′/3∗b′/3−…(有一个质公因子)
            +a′/6∗b′/6+…                      (有两个不同质公因子)+a′/6∗b′/6+…                      (有两个不同质公因子)
            −a′/30∗b′/30−…                  (有三个不同质公因子)−a′/30∗b′/30−…                  (有三个不同质公因子)
=>∑min(a,b)i=1a′/i∗b′/i∗mobius[i]∑i=1min(a,b)a′/i∗b′/i∗mobius[i]
发现如果要这样做i就要枚举1−N1−N，因此每次的时间复杂度是O(n)O(n)的,有N=50000N=50000，会TLETLE，所以还要优化。

如何优化？
发现，这个式子中虽然i要枚举NN次，但是实际上因为整除的原因aiai的值很少，只有2a‾√2a个！
因为a1a1、a2a2、a3a3、…是单调递减的，所以整个序列的值可以分成2a‾√2a段相同的值。

说明：1、为什么是2a‾√2a段 2、怎么分

1、
将原来的n项分为两部分：
     1、a1−aa√     1、a1−aa 有a‾√a项
     2、aa√+1−aa     2、aa+1−aa 有a‾√a个取值

2、
设g(x)表示使axax的取值不变的最大的x值，就有axax=ag(x)ag(x)，且axax>ag(x)+1ag(x)+1，其中g(x)=aaxg(x)=aax
证：axax=ag(x)ag(x)

只有这一条式子无法保证时间复杂度，因为虽然知道从xx跳到g(x)g(x)，分式的值不变，但是不知道g(x)g(x)是不是xx所能达到的最大值，因此需要证下式!

证：axax>ag(x)+1ag(x)+1

由这条式子可以得知，g(x)g(x)可以使分式的值不变，但是g(x)+1g(x)+1却小于，说明g(x)g(x)是xx所能达到的最大值！
综上：将原来的序列分成2a‾√2a段，而且每次都会跳一段，所以总共会跳2a‾√2a次，时间复杂度就是O(a‾√)O(a)!

#include <iostream>

using namespace std;

typedef long long LL;

const int N = 50010;

int primes[N] , cnt;
bool st[N];
int mobius[N] , sum[N];

void init(int n)
{
    mobius[1] = 1;
    for(int i = 2 ; i <= n ; i++)
    {
        if(!st[i]) 
        {
            primes[cnt++] = i;
            mobius[i] = -1;
        }

        for(int j = 0 ; primes[j] <= n / i ; j++)
        {
            int t = primes[j] * i;
            st[t] = true;
            if(i % primes[j] == 0)
            {
                mobius[t] = 0;//t中至少包含2个primes[j]
                break;
            }
            mobius[t] = mobius[i] * -1;//primes[j]只出现一次，所以t的mobius值取决于i
        }
    }

    for(int i = 1 ; i <= n ; i++) sum[i] = sum[i - 1] + mobius[i];
}

int main()
{
    init(N - 1);

    int T;
    cin >> T;
    while(T--)
    {
        int a , b , d;
        cin >> a >> b >> d;
        a /= d , b /= d;
        int n = min(a , b);
        LL res = 0;
        for(int l = 1 , r ; l <= n ; l = r + 1)
        {
            r = min(n , min(a / (a / l) , b / (b / l)));
            //x最远跳到的位置g(x) = t / (t / x)，因为要使a/l和b/l的值都不变，所以要取跳的位置的min
            res += (sum[r] - sum[l - 1]) * (LL)(a / l) * (b / l);
            //在x∈[l,r]上，a/x和b/x的值是不变的，所以只要求出l~r上mobius的和*分式的值即可
        }
        cout << res << endl;
    }
    return 0;
}

作者：Anoxia_3
链接：https://www.acwing.com/solution/content/17858/
 

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 50010;

int primes[N], cnt;
bool st[N];
int mobius[N], sum[N];

// 线性筛法，求莫比乌斯函数
void init(int n)
{
    mobius[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            mobius[i] = -1;
        }
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                mobius[t] = 0;
                break;
            }
            mobius[t] = mobius[i] * -1;
        }
    }

    for (int i = 1; i <= n; i ++ ) sum[i] = sum[i - 1] + mobius[i];
}

int main()
{
    init(N - 1);

    int T;
    scanf("%d", &T);
    while (T -- )
    {
        int a, b, d;
        scanf("%d%d%d", &a, &b, &d);
        a /= d, b /= d;
        int n = min(a, b);
        LL res = 0;
        for (int l = 1, r; l <= n; l = r + 1)
        {
            r = min(n, min(a / (a / l), b / (b / l)));
            res += (sum[r] - sum[l - 1]) * (LL)(a / l) * (b / l);
        }

        printf("%lld\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/196411/
 

AcWing 217. 绿豆蛙的归宿    原题链接    简单
作者：    zhangxu ,  2019-09-08 22:29:09 ,  阅读 427

4


感觉 书上写的 如果状态转移复杂了 不好对付
有等可能的挺在原地 或者是 掉到之前某个点 计算就必须 单独分开 而不能 直接 每次for ++ 了
按照 直接理解重写了分 同事 2019 南昌网络赛 D 题 也是 差不多的思路

#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 5;
int n, m;
int head[maxn], cnt;
int to[maxn], nxt[maxn];
int from[maxn], pre[maxn], come[maxn], val[maxn], tot;
int out[maxn], deg[maxn];
double dis[maxn];

void cometo(int a, int b, int c) {
    come[++ tot] = b, val[tot] = c;
    pre[tot] = from[a],  from[a] = tot;
}

void ade(int a, int b) {
    to[++ cnt] = b;
    nxt[cnt] = head[a], head[a] = cnt;
}

double redis(int u) {
    if(u == n) return 0;
    double res = 0;
    for(int i = from[u]; i; i = pre[i]) {
        res += (dis[come[i]] + 1.0 * val[i]) / deg[u];
    }
    return res;
}

void topsort() {
    queue<int> que;
    que.push(n);
    while(!que.empty()) {
        int x = que.front(); que.pop();
        dis[x] = redis(x);
        for(int i = head[x]; i; i = nxt[i]) {
            out[to[i]] --;
            if(out[to[i]] == 0) que.push(to[i]);
        }
    }
}

int main() {
    scanf("%d %d", &n, &m);
    for(int i = 1, a, b, c; i <= m; ++ i) {
        scanf("%d %d %d", &a, &b, &c);
        cometo(a, b, c), ade(b, a);
        deg[a] ++, out[a] ++;
    }
    topsort();
    printf("%.2lf\n", dis[1]);
    return 0;
}

作者：zhangxu
链接：https://www.acwing.com/solution/content/4448/
 


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 200010;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int dout[N];
double f[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

double dp(int u)
{
    if (f[u] >= 0) return f[u];
    f[u] = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        f[u] += (w[i] + dp(j)) / dout[u];
    }
    return f[u];
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);

    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
        dout[a] ++ ;
    }

    memset(f, -1, sizeof f);

    printf("%.2lf\n", dp(1));

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/196433/
 

#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

const int N=100005;
const int M=200005;

int n,m;
int e[M],w[M],ne[M],idx;
int h[N],din[N],dout[N];
int q[N],hh,tt;
double f[N],g[N];

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0,a;i<m;i++)
    {
        scanf("%d%d%d",e+idx,&a,w+ ++idx);
        ne[idx]=h[a],h[a]=idx;
        din[e[idx]]++,dout[e[idx]]++;
    }
    q[0]=n,g[n]=1;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
        {
            f[e[i]]+=(f[t]+w[i])/dout[e[i]];
            if(!--din[e[i]])q[++tt]=e[i];
        }
    }
    printf("%.2lf\n",f[1]);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/359911/
 

AcWing 218. 扑克牌    原题链接    中等
作者：    mesopotamian ,  2019-11-15 17:55:39 ,  阅读 441

7


4
期望dp的状态转移方程


C++ 代码
#include<bits/stdc++.h>
using namespace std;
#define eps 1e-8
double F[15][15][15][15][5][5],E;
bool vis[15][15][15][15][5][5];
int A,B,C,D;
double dfs(int a,int b,int c,int d,int e,int f)
{
    if(F[a][b][c][d][e][f]>1e-8) return F[a][b][c][d][e][f];
    if(a+(e==1)+(f==1)>=A&&b+(e==2)+(f==2)>=B&&
       c+(e==3)+(f==3)>=C&&d+(e==4)+(f==4)>=D) return 0;
    double sum=1.0,Min1=1e9,Min2=1e9;
    int cnt = a+b+c+d+(e!=0)+(f!=0);
    if(a<13) sum+=dfs(a+1,b,c,d,e,f)*(13-a)/(54-cnt);
    if(b<13) sum+=dfs(a,b+1,c,d,e,f)*(13-b)/(54-cnt);
    if(c<13) sum+=dfs(a,b,c+1,d,e,f)*(13-c)/(54-cnt);
    if(d<13) sum+=dfs(a,b,c,d+1,e,f)*(13-d)/(54-cnt);
    if(e==0)for(int i=1;i<5;++i)Min1=min(Min1,dfs(a,b,c,d,i,f)/(54-cnt));
    if(f==0)for(int i=1;i<5;++i)Min2=min(Min2,dfs(a,b,c,d,e,i)/(54-cnt));
    if(e==0)sum+=Min1;
    if(f==0)sum+=Min2;
    return F[a][b][c][d][e][f]=sum;
}
int main(int argc, char const *argv[])
{
    scanf("%d%d%d%d",&A,&B,&C,&D);
    if(max(A-13,0)+max(B-13,0)+max(C-13,0)+max(D-13,0)>2)
    return puts("-1.000"),0;
    double ans = dfs(0,0,0,0,0,0);
    printf("%.3f",ans);
    return 0;
}

作者：mesopotamian
链接：https://www.acwing.com/solution/content/5890/
 


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 14;
const double INF = 1e20;

int A, B, C, D;
double f[N][N][N][N][5][5];

double dp(int a, int b, int c, int d, int x, int y)
{
    double &v = f[a][b][c][d][x][y];
    if (v >= 0) return v;
    int as = a + (x == 0) + (y == 0);
    int bs = b + (x == 1) + (y == 1);
    int cs = c + (x == 2) + (y == 2);
    int ds = d + (x == 3) + (y == 3);
    if (as >= A && bs >= B && cs >= C && ds >= D) return v = 0;

    int sum = a + b + c + d + (x != 4) + (y != 4);
    sum = 54 - sum;
    if (sum <= 0) return v = INF;

    v = 1;
    if (a < 13) v += (13.0 - a) / sum * dp(a + 1, b, c, d, x, y);
    if (b < 13) v += (13.0 - b) / sum * dp(a, b + 1, c, d, x, y);
    if (c < 13) v += (13.0 - c) / sum * dp(a, b, c + 1, d, x, y);
    if (d < 13) v += (13.0 - d) / sum * dp(a, b, c, d + 1, x, y);
    if (x == 4)
    {
        double t = INF;
        for (int i = 0; i < 4; i ++ ) t = min(t, 1.0 / sum * dp(a, b, c, d, i, y));
        v += t;
    }
    if (y == 4)
    {
        double t = INF;
        for (int i = 0; i < 4; i ++ ) t = min(t, 1.0 / sum * dp(a, b, c, d, x, i));
        v += t;
    }

    return v;
}

int main()
{
    cin >> A >> B >> C >> D;
    memset(f, -1, sizeof f);

    double t = dp(0, 0, 0, 0, 4, 4);
    if (t > INF / 2) t = -1;

    printf("%.3lf\n", t);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/196477/
 


    AcWing 1319. 移棋子游戏    原题链接    中等
作者：    垫底抽风 ,  2020-06-26 14:27:54 ,  阅读 182

12


题目描述
给定一个有 NN 个节点的有向无环图，图中某些节点上有棋子，两名玩家交替移动棋子。

玩家每一步可将任意一颗棋子沿一条有向边移动到另一个点，无法移动者输掉游戏。

对于给定的图和棋子初始位置，双方都会采取最优的行动，询问先手必胜还是先手必败。

输入格式
第一行，三个整数 N,M,KN,M,K，NN 表示图中节点总数，MM 表示图中边的条数，KK 表示棋子的个数。

接下来 M 行，每行两个整数 X,YX,Y 表示有一条边从点 XX 出发指向点 YY。

接下来一行，KK 个空格间隔的整数，表示初始时，棋子所在的节点编号。

节点编号从 11 到 NN。

输出格式
若先手胜，输出 win，否则输出 lose。

数据范围
1≤N≤2000,1≤N≤2000,
1≤M≤6000,1≤M≤6000,
1≤K≤N1≤K≤N
输入样例：
6 8 4
2 1
2 4
1 4
1 5
4 5
1 3
3 5
3 6
1 2 4 6
输出样例：
win
这题咋没人写题解嘞 qwqqwq
SG 函数
首先定义 mexmex 函数，这是施加于一个集合的函数，返回最小的不属于这个集合的非负整数
例：mex({1,2})=0,mex({0,1})=2,mex({0,1,2,4})=3mex({1,2})=0,mex({0,1})=2,mex({0,1,2,4})=3
在一张有向无环图中，对于每个点 uu，设其所有能到的点的 SGSG 函数值集合为集合 AA，那么 uu 的 SGSG 函数值为 mex(A)mex(A)，记做 SG(u)=mex(A)SG(u)=mex(A)
例图：

例图解释：

SG(5)=mex({∅})=0SG(5)=mex({∅})=0
SG(3)=mex({SG(5)})=mex({0})=1SG(3)=mex({SG(5)})=mex({0})=1
SG(4)=mex({SG(5),SG(3)})=mex({0,1})=2SG(4)=mex({SG(5),SG(3)})=mex({0,1})=2
SG(2)=mex({SG(3)}=mex({1})=0SG(2)=mex({SG(3)}=mex({1})=0
SG(1)=mex({SG(2),SG(4)})=mex({0,2})=1SG(1)=mex({SG(2),SG(4)})=mex({0,2})=1
那么 SGSG 函数的定义说完了，这题和 SGSG 函数又有什么关系呢？
下面先说本题做法，再证明该方法正确性。

做法：求出每个棋子所在的点的 SGSG 函数值，将所有值异或起来。若异或值为 00，则输出win，否则输出lose

证明：
首先，由于这是一张有向无环图，所以游戏最后一定会结束，也就是说每个棋子最后都会移动到一个点上，且该点没有任何能到达的点。
那么根据定义，结束状态的所有点的 SGSG 函数值异或起来为 00，做法对于结束状态可行。
所以接下来，只要证明出

任何一种每个棋子所在点的 SGSG 函数值异或起来非 00 的情况，一定能通过一次移动棋子，到达一个 每个棋子所在点的 SGSG 函数值异或起来为 00 的情况
任何一种每个棋子所在点的 SGSG 函数值异或起来为 00 的情况，一定不能通过一次移动棋子，到达一个每个棋子所在点的 SGSG 函数值异或起来为 00 的情况
那么做法就是对的

证明 1：
设每个棋子所在点的 SGSG 函数值分别为 a1,a2,⋯,ana1,a2,⋯,an
设 x=a1 XOR a2 XOR ⋯ XOR anx=a1 XOR a2 XOR ⋯ XOR an，设 xx 的最高位为第 kk 位，那么在 a1,a2,⋯,ana1,a2,⋯,an 中，一定有一个值的第 kk 位为 11
设该值为 aiai，那么由于 xx 的第 kk 位和 aiai 的第 kk 位都是 11，且第 kk 位是 xx 的最高位，所以 ai XOR xai XOR x 一定小于 aiai
又因为 aiai 是其中一个棋子所在点的 SGSG 函数值，那么根据 SGSG 函数值的定义，该点能到达的所有点中，一定存在一个点的 SGSG 函数值为 ai XOR xai XOR x
那么我们就可以将该点上的棋子，移到一个 SGSG 函数值为 ai XOR xai XOR x 的点上去
移完之后，原来每个棋子所在点的 SGSG 函数异或值就变为了 a1 XOR a2 XOR ⋯ XOR ai−1 XOR (ai XOR x) XOR ai+1 ⋯ XOR ana1 XOR a2 XOR ⋯ XOR ai−1 XOR (ai XOR x) XOR ai+1 ⋯ XOR an
=(a1 XOR a2 XOR ⋯ XOR an) XOR x=x XOR x=0=(a1 XOR a2 XOR ⋯ XOR an) XOR x=x XOR x=0
1 证毕

证明 2：
反证法，设将点 uu 上的棋子移动到点 vv 上后，每个棋子所在点的 SGSG 函数值仍然为 00
那就说明 SG(u)=SG(v)SG(u)=SG(v)，不符合 SGSG 函数的定义，不成立
2 证毕

所以做法是正确的。

那么如何求出每个点的 SGSG 函数值呢？
记忆化搜索就好啦~
每层记忆化搜索中，如果该点的 SGSG 函数值已经被计算出，那就直接返回该值。否则用一个 setset 记录每个点能到的所有点的 SGSG 函数值集合，然后从 00 开始遍历，找到第一个 setset 里面没有的数，将该值记录在该点上并返回。

时间复杂度
貌似是 O(n+mlogm)O(n+mlog⁡m)
C++C++ 代码
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <set>

using namespace std;

const int N = 2005;
const int M = 6005;

int n, m, k;
int h[N], e[M], ne[M], idx;          // 邻接表存图
int sg[N];                           // 存所有被计算过的点的 SG 函数值
int res;

inline void add(int u, int v)        // 加边函数。从点 u 向点 v 连一条有向边
{
    e[ ++ idx] = v;
    ne[idx] = h[u];
    h[u] = idx;
}

int SG(int u)
{
    if (~sg[u]) return sg[u];        // 如果当前 sg[u] 不是 -1，那么说明该点的 SG 函数值已经被计算过了，直接返回
    set<int> S;                      // 否则要建一个集合 S，存该点能到的所有点的 SG 函数值
    for (int i = h[u]; i; i = ne[i]) // 遍历点 u 能到达的所有点
        S.insert(SG(e[i]));          // 计算该点的 SG 函数值，并放入集合 S
    for (int i = 0; ; i ++ )         // 从 0 开始枚举所有非负整数
        if (!S.count(i))             // 如果该值没有在 S 中出现过
        {
            sg[u] = i;               // 那么将该值记录在 sg[u] 中并返回
            return i;
        }
}

int main()
{
    scanf("%d %d %d", &n, &m, &k);   // 读入题目中 N, M, K
    for (int i = 0; i < m; i ++ )    // 读入 M 条边并建图
    {
        int u, v;
        scanf("%d %d", &u, &v);
        add(u, v);
    }
    memset(sg, -1, sizeof sg);       // 先将 sg 数组中的所有值初始化成 -1，表示没有记录过
    while (k -- )                    // 读入 K 个棋子所在的点
    {
        int u;
        scanf("%d", &u);
        res ^= SG(u);
    }
    if (res) puts("win");            // 如果 res 不为 0，那么输出 win
    else    puts("lose");            // 否则输出 lose
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/solution/content/15279/
 


#include <cstdio>
#include <cstring>
#include <set>

using namespace std;

const int N = 2010, M = 6010;

int n, m, k;
int h[N], e[M], ne[M], idx;
int f[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int sg(int u)
{
    if (f[u] != -1) return f[u];

    set<int> S;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        S.insert(sg(j));
    }

    for (int i = 0; ; i ++ )
        if (S.count(i) == 0)
        {
            f[u] = i;
            break;
        }

    return f[u];
}

int main()
{
    scanf("%d%d%d", &n, &m, &k);
    memset(h, -1, sizeof h);

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }

    memset(f, -1, sizeof f);

    int res = 0;
    for (int i = 0; i < k; i ++ )
    {
        int u;
        scanf("%d", &u);
        res ^= sg(u);
    }

    if (res) puts("win");
    else puts("lose");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/197415/
 


AcWing 1321. 取石子    原题链接    困难
作者：    Serman轩 ,  2020-05-08 17:18:16 ,  阅读 203

2


1
题目描述
Alice 和 Bob 两个好朋友又开始玩取石子了。

游戏开始时，有 N 堆石子排成一排，然后他们轮流操作（Alice 先手），每次操作时从下面的规则中任选一个：

从某堆石子中取走一个；
合并任意两堆石子。
不能操作的人输。

Alice 想知道，她是否能有必胜策略。

输入格式
第一行输入 T，表示数据组数。

对于每组测试数据，第一行读入 N；

接下来 N 个正整数 a1,a2,⋯,aN ，表示每堆石子的数量。

输出格式
对于每组测试数据，输出一行。

输出 YES 表示 Alice 有必胜策略，输出 NO 表示 Alice 没有必胜策略。

数据范围
1≤T≤100,
1≤N≤50,
1≤ai≤1000

算法1
(数学) O(1)O(1)
这道题先是课上听了记忆化搜索，然后一直觉得搜索时是有问题的，有一类情况没有考虑到。就是B类 REMOVE石头的时候，其中一个为2. 此时应该A+1, B-3的。但是代码里只要考虑B-1，A不变的非2情况。一直想为什么不用加这个可能也是对的，分析了3个小时在没分析出来，希望有大佬日后看到可以给我解答。

不过发现了下述性质

首先把所有石子堆分为2类。一类是只有1个石头的堆。一类是>1个石头的堆。
我们维护有1个石头的堆的堆数，ONES。维护>1个石头的堆 SUM数 为 石子总数+堆数-1， OTHERS。

假设第二类的OTHERS <=2 （即要么全是第一类，要么第二类就一个2个石头的堆）。我们可以枚举发现，有3个1 是先手必输的， 6个1 是必输的。 3 * k 个1 都是必输的（可数学归纳）

if (others <= 2) {
    System.out.println(ones % 3 == 0 ? "NO": "YES");
} 
我们还可以证明如果没有第一类。 OTHERS为奇数则先手必胜。（算法提高课已证）

下面就是考虑既有第一类 又有第二类，且第二类OTHERS > 2的情况。

先说结论

else {
    System.out.println((ones % 2 == 1 || others % 2 == 1) ? "YES" : "NO");
}
可以证明第一类石子的堆数为偶数并且第二类SUM数为偶数则先手必败。
最小情况， OTHERS = 4 ，ONES = 0; （根据算法提高课的证明，OTHERS += 2 依然为偶数，则还是必败）
如果ONES += 2；
先手有几种选择。

（移除第一类石堆）ONES - -. 那么后手可以通过再一次ONES– 使得 ONES 回到之前已证的必败态。

（第一类石堆和第二类石堆合并）ONES - -, OTHERS++。 那么后手可以通过再一次该操作回到ONES = 0, OTHERS=偶数+2的已证必败态。

（2个第一类合并）ONES-=2, OTHERS += 3. 那么后手可以对第二类做基本操作（合并或者移除非2的石堆，因为OTHERS >=4必然可以找到这个操作）使得OTHERS–。 回到双偶数的必败态。

（第二类的基本操作） OTHERS- -。那么后手就要分情况讨论。
4.1 OTHERS == 3, 那么后手就合并2个第一类，得到ONES = 0, OTHER=6的情况，回到已证必败态。
4.2 OTHERS != 3 ， 那么后手就用第二类基本操作，使得OTHERS–， 回到之前 OTHERS >= 4, ONES = 2 的更小的双偶必败态。

递推得证。

同理如果先手看到的局面是这2个数里至少有一个是奇数的，他只要给通过一种方式给后手构造出一种双偶数的局面，他就可以保持自己必胜。
1. ONES 为奇， OTHERS 为奇，使用ONES MERGE 进OTHERS， ONES–, OTHERS++. 变成双偶数
2. ONES 为奇， OTHERS 为偶，使用REMOVE ONES STONE， ONES–。 变成双偶数
3. ONES 为偶， OTHERS为奇，使用OTHERS基本操作，OTHERS–。 变成双偶数。

由上述可以得知一旦拿到双偶数，则任何操作都是必败。可以证明在有第一类 又有第二类，且第二类OTHERS > 2的情况，先手2个数有一个为奇数 则必胜。

时间复杂度 O(1)
JAVA 代码
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int ones = 0, others = -1;
            for (int i = 0; i < n; i++) {
                int x = sc.nextInt();
                if (x == 1) ones++;
                else others += x + 1;
            }
            if (others <= 2) {
                System.out.println(ones % 3 == 0 ? "NO": "YES");
            } else {
                System.out.println((ones % 2 == 1 || others % 2 == 1) ? "YES" : "NO");
            }
        }
    }
}

作者：Serman轩
链接：https://www.acwing.com/solution/content/12916/
 



# 定义一组大小大于1的堆的状态为这些堆的数量加上这些堆的石子总数减去1的结果
# dp(a, b)表示大小只有1的堆有a个，其余堆分成一组的的状态是b的情况下是否是必赢局
from functools import lru_cache
@lru_cache(typed=False, maxsize=128000000)
def dp(a, b) -> bool:
    if a == 0:
        '''
        在剩下的a=0情况里面，所有堆的石子个数都是大于等于2的
        把这些石碓看成一个整体来讨论，整体的状态值定义为这些堆的数量加上这些堆的石子总数减去1的结果
        如果b是一个奇数:
            如果只剩一堆了
                如果b=1, 那是必赢局不用往下转移状态了
                如果b!=1, 那b >= 3, 最后这一堆的大小一定大于等于3，可以拿掉这一堆里面的一个石子，变换到b是偶数状态
            如果剩下不止一堆
                随便找两堆合并起来，变换到b是偶数的状态

            综上，b为奇数状态不论什么情况都至少能找到一种转换路径转到b为偶数的状态

        如果b是一个偶数：
            如果只剩一堆了：
                只能取石子，b是一个偶数，且是正数，那b >= 2，可推出这一堆石子个数大于等于2，取掉一个石子，一定变到b是奇数状态
            如果剩下不止一堆
                如果当前操作是合并石子，那下一个状态必然是b是奇数状态
                如果当前操作是拿石子，拿的那一堆如果石子数大于2，那拿掉之后还是进入b是奇数状态
                                   如果拿掉那一堆石子数刚好是2，那新产生了一个大小是1的堆，这种状态交给下一个人，下一个人
                                   一定可以把这个1合并到另外一堆去，状态又回到了所有堆个数大于等于2，且b为偶数的状态，所以
                                   这么操作，会交一个不败局给下一个人

            综上，b为偶数情况下，不管怎么操作，都会把一个不败局重新交回给上一个人

        根据博弈理论，持有b为奇数状态的人必胜，否则必败
        '''
        return (b & 1) != 0

    if b == 1:
        return dp(a+1, 0)

    else:

        '''
        对于有大小是1的堆的情况，分情况进行状态转移
        '''

        # 两个大小是1的堆合并
        if a >= 2 and not dp(a-2, b + 3 if b != 0 else 2):
            return True

        # 一个大小是1的和一个大小不是1的堆合并
        if b != 0 and not dp(a-1, b + 1):
            return True

        # 两个大小不是1的堆合并
        if b != 0 and not dp(a, b - 1):
            return True

        # 大小是1的堆拿掉一个石子
        if a >= 1 and not dp(a-1, b):
            return True

        # 大小不是1的堆拿掉一个石子(跟上面一个分支的处理重复)
        # 但是这有个疑问，从大小不是1的堆里面拿掉一个石子，有可能让a+1的，这种状态转移漏掉了居然答案是对的，暂时没想通什么原理
        # 是数据弱还是怎么的，这个地方逻辑不严密，DP状态两维没法描述这种状况，应该还要多一维描述堆大小是2的堆的个数
        #if b != 0 and not dp(a, b-1):
        #    return True

        # 前面几种情况都赢不了，那只能输掉了
        return False

T = int(input())
for _ in range(T):
    n = int(input())
    arr = list(map(int, input().split()))
    a, b = 0, -1 # a是只有一个石子的堆的个数，b是超过一个石子的所有堆的堆数加上这些堆石子总数减去1

    for val in arr:
        if val == 1:
            a += 1
        else:
            b += 1 + val

    print('YES' if dp(a, b) else 'NO')

作者：皓首不倦
链接：https://www.acwing.com/solution/content/20942/
 


#include <stdio.h>
#include <string.h>

const int N=55;
const int M=50050;

int f[N][M];

bool dp(int a,int b)
{
    if(~f[a][b])return f[a][b];
    if(!a)return f[a][b]=b&1;
    if(b==1)return dp(a+1,0);
    if(a&&!dp(a-1,b))return f[a][b]=true;
    if(b&&!dp(a,b-1))return f[a][b]=true;
    if(a>1&&!dp(a-2,b+(b?3:2)))return f[a][b]=true;
    if(a&&b&&!dp(a-1,b+1))return f[a][b]=true;
    return f[a][b]=false;
}

int main()
{
    memset(f,-1,sizeof f);
    int T;
    for(scanf("%d",&T);T--;)
    {
        int n,x,a=0,b=0;
        for(scanf("%d",&n);n--;)
        {
            scanf("%d",&x);
            if(x==1)a++;
            else b+=x+1;
        }
        if(b)b--;
        puts(dp(a,b)?"YES":"NO");
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/361713/
 



#include <cstdio>
#include <cstring>

using namespace std;

const int N = 55, M = 50050;

int f[N][M];

int dp(int a, int b)
{
    int &v = f[a][b];
    if (v != -1) return v;
    if (!a) return v = b % 2;
    if (b == 1) return dp(a + 1, 0);

    if (a && !dp(a - 1, b)) return v = 1;
    if (b && !dp(a, b - 1)) return v = 1;
    if (a >= 2 && !dp(a - 2, b + (b ? 3 : 2))) return v = 1;
    if (a && b && !dp(a - 1, b + 1)) return v = 1;

    return v = 0;
}

int main()
{
    memset(f, -1, sizeof f);

    int T;
    scanf("%d", &T);
    while (T -- )
    {
        int n;
        scanf("%d", &n);
        int a = 0, b = 0;
        for (int i = 0; i < n; i ++ )
        {
            int x;
            scanf("%d", &x);
            if (x == 1) a ++ ;
            else b += b ? x + 1 : x;
        }

        if (dp(a, b)) puts("YES");
        else puts("NO");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/197462/
 


#include <cstdio>

using namespace std;

const int N = 1010;

int n;
int a[N];
int l[N][N], r[N][N];

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d", &n);
        for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);

        for (int len = 1; len <= n; len ++ )
            for (int i = 1; i + len - 1 <= n; i ++ )
            {
                int j = i + len - 1;
                if (len == 1) l[i][j] = r[i][j] = a[i];
                else
                {
                    int L = l[i][j - 1], R = r[i][j - 1], X = a[j];
                    if (R == X) l[i][j] = 0;
                    else if (X < L && X < R || X > L && X > R) l[i][j] = X;
                    else if (L > R) l[i][j] = X - 1;
                    else l[i][j] = X + 1;

                    L = l[i + 1][j], R = r[i + 1][j], X = a[i];
                    if (L == X) r[i][j] = 0;
                    else if (X < L && X < R || X > L && X > R) r[i][j] = X;
                    else if (R > L) r[i][j] = X - 1;
                    else r[i][j] = X + 1;
                }
            }

        if (n == 1) puts("1");
        else printf("%d\n", l[2][n] != a[1]);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/197506/
 


#include <stdio.h>

const int N=1005;

int n,a[N];
int l[N][N];
int r[N][N];

int main()
{
    int T;
    for(scanf("%d",&T);T--;putchar('\n'))
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)scanf("%d",a+i);
        for(int len=0;len<n;len++)
            for(int i=1;i+len<=n;i++)
            {
                int j=i+len;
                if(!len)l[i][j]=r[i][j]=a[i];
                else
                {
                    int L=l[i][j-1],R=r[i][j-1],X=a[j];
                    if(R==X)l[i][j]=0;
                    else if(L<X&&R<X||L>X&&R>X)l[i][j]=X;
                    else if(L>R)l[i][j]=X-1;
                    else    l[i][j]=X+1;
                    L=l[i+1][j],R=r[i+1][j],X=a[i];
                    if(L==X)r[i][j]=0;
                    else if(L<X&&R<X||L>X&&R>X)r[i][j]=X;
                    else if(R>L)r[i][j]=X-1;
                    else    r[i][j]=X+1;
                }
            }
        putchar((n==1||l[2][n]!=a[1])?49:48);
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/361934/
 


    #include <stdio.h>

const int N=1005;

int n,a[N];
int l[N][N];
int r[N][N];

int main()
{
    int T;
    for(scanf("%d",&T);T--;putchar('\n'))
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)scanf("%d",a+i);
        for(int len=0;len<n;len++)
            for(int i=1;i+len<=n;i++)
            {
                int j=i+len;
                if(!len)l[i][j]=r[i][j]=a[i];
                else
                {
                    int L=l[i][j-1],R=r[i][j-1],X=a[j];
                    if(R==X)l[i][j]=0;
                    else if(L<X&&R<X||L>X&&R>X)l[i][j]=X;
                    else if(L>R)l[i][j]=X-1;
                    else    l[i][j]=X+1;
                    L=l[i+1][j],R=r[i+1][j],X=a[i];
                    if(L==X)r[i][j]=0;
                    else if(L<X&&R<X||L>X&&R>X)r[i][j]=X;
                    else if(R>L)r[i][j]=X-1;
                    else    r[i][j]=X+1;
                }
            }
        putchar((n==1||l[2][n]!=a[1])?49:48);
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/361936/
 

#include <cstdio>
#include <iostream>
using namespace std;
const int N = 1005;
int n, a[N], L[N][N], R[N][N];
int main() {
    int T; scanf("%d", &T);
    while(T--) {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) scanf("%d", a + i), L[i][i] = R[i][i] = a[i];
        for (int len = 2; len < n; len++) {
            for (int i = 1, j; (j = i + len - 1) <= n; i++) {
                int l = L[i][j - 1], r = R[i][j - 1], x = a[j];
                if (r == x) L[i][j] = 0;
                else if((x < r && x < l) || (x > r && x > l)) L[i][j] = x;
                else if(l < r) L[i][j] = x + 1;
                else L[i][j] = x - 1; 
                l = L[i + 1][j], r = R[i + 1][j], x = a[i];
                if (l == x) R[i][j] = 0;
                else if((x < r && x < l) || (x > r || x > l)) R[i][j] = x;
                else if(l < r) R[i][j] = x - 1;
                else R[i][j] = x + 1; 
            }
        }
        puts(a[1] == L[2][n] ? "0" : "1");
    }
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/197917/
 
AcWing 1250. 格子游戏    原题链接    简单
作者：    小呆呆 ,  2020-04-04 00:42:13 ,  阅读 251

5


1
算法分析
并查集(典型并查集判断是否存在环的问题)

1、将每个坐标看成一个点值，为了方便计算，第一个位置即(1,1)看成是0，(1,2)看成是1，依次类推，假设当前点是(x,y),则该点的映射值是a = (x * n + y)，
若向下画，则b = [(x + 1) * n + y],若向右画，则b = [x * n + y - 1]

2、枚举所有操作，通过并查集操作判断a和b是否在同一个集合，

若在同一个集合则标记此操作可以让格子形成环
若不在同一个集合，则需要将两个集合进行合并
时间复杂度
并查集操作接近O(1)O(1)
参考文献
算法提高课

Java 代码
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {

    static int N = 201 * 201 + 10;
    static int n,m;
    static int[] p = new int[N];
    static int get(int x,int y)
    {
        return x * n + y;
    }
    static int find(int x)
    {
        if(x != p[x]) p[x] = find(p[x]);
        return p[x];
    }
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] s1 = br.readLine().split(" ");
        n = Integer.parseInt(s1[0]);
        m = Integer.parseInt(s1[1]);
        for(int i = 0;i < n * n;i ++) p[i] = i;
        int res = 0;
        for(int i = 1;i <= m;i ++)
        {
            String[] s2= br.readLine().split(" ");
            int x = Integer.parseInt(s2[0]) - 1;
            int y = Integer.parseInt(s2[1]) - 1;
            String d = s2[2];
            int a = get(x,y);
            int b ;
            if(d.equals("D")) b = get(x + 1,y);
            else b = get(x,y + 1);

            int pa = find(a);
            int pb = find(b);
            if(pa == pb)
            {
                res = i;
                break;
            }
            p[pa] = pb;
        }
        if(res == 0) System.out.println("draw");
        else System.out.println(res);
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/10961/
 

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 40010;

int n, m;
int p[N];

int get(int x, int y)
{
    return x * n + y;
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> m;

    for (int i = 0; i < n * n; i ++ ) p[i] = i;

    int res = 0;
    for (int i = 1; i <= m; i ++ )
    {
        int x, y;
        char d;
        cin >> x >> y >> d;
        x --, y -- ;
        int a = get(x, y);
        int b;
        if (d == 'D') b = get(x + 1, y);
        else b = get(x, y + 1);

        int pa = find(a), pb = find(b);
        if (pa == pb)
        {
            res = i;
            break;
        }
        p[pa] = pb;
    }

    if (!res) puts("draw");
    else cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/161716/
 


include <algorithm>

using namespace std;

const int N=40005;

int n,m;
int p[N];

inline int read()
{
    int x=0;
    char ch;
    bool fx=false;
    do ch=getchar();while(~ch&&ch!='-'&&(ch<48||ch>57));
    if(ch=='-')fx=true,ch=getchar();
    for(;ch>47&&ch<58;ch=getchar())
        x=(x<<1)+(x<<3)+(ch^48);
    return fx?-x:x;
}

int find(int x)
{
    if(p[x]!=x)p[x]=find(p[x]);
    return p[x];
}

inline int get(int x,int y)
{
    return x*n+y;
}

int main()
{
    n=read(),m=read();
    for(int i=1;i/n<=n;i++)
        p[i]=i;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        char c;
        x=read(),y=read();
        c=getchar();
        int a=find(get(x,y));
        int b=find(get(x+(c=='D'),y+(c=='R')));
        if(a==b)
        {
            printf("%d\n",i);
            return 0;
        }
        p[a]=b;
    }
    puts("draw");
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/329429/
 



AcWing 1252. 搭配购买    原题链接    简单
作者：    辰风 ,  2020-03-02 11:53:42 ,  阅读 179

3


思路


代码
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int p[10010];
int w[10010];
int v[10010];
int f[10010];
int n,m,sum;
int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main(){
    cin >> n >> m >> sum;

    for (int i = 1; i <= n; i ++ ) p[i] = i;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    while(m--){
        int a,b;
        cin >> a >> b;
        int pa=find(a);int pb=find(b);
        if(pa!=pb){
            w[pb]+=w[pa];
            v[pb]+=v[pa];
            p[pa]=p[pb];//注意这里一定要最后合并集合
        }
    }
    for (int i = 1; i <= n; i ++ )
        if (p[i] == i)
            for (int j = sum; j >= v[i]; j -- )
                f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[sum];
}

作者：辰风
链接：https://www.acwing.com/solution/content/9410/
 

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010;

int n, m, vol;
int v[N], w[N];
int p[N];
int f[N];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> m >> vol;

    for (int i = 1; i <= n; i ++ ) p[i] = i;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    while (m -- )
    {
        int a, b;
        cin >> a >> b;
        int pa = find(a), pb = find(b);
        if (pa != pb)
        {
            v[pb] += v[pa];
            w[pb] += w[pa];
            p[pa] = pb;
        }
    }

    // 01背包
    for (int i = 1; i <= n; i ++ )
        if (p[i] == i)
            for (int j = vol; j >= v[i]; j -- )
                f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[vol] << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/161730/
 

AcWing 237. 程序自动分析    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-12 20:08:18 ,  阅读 1927

6


3
原题链接
更好的阅读体验

题目描述
在实现程序自动分析的过程中,常常需要判定一些约束条件是否能被同时满足。

考虑一个约束满足问题的简化版本：假设x1,x2,x3,…x1,x2,x3,…代表程序中出现的变量，给定n个形如xi=xjxi=xj或xi≠xjxi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。

例如，一个问题中的约束条件为：x1=x2，x2=x3，x3=x4，x1≠x4x1=x2，x2=x3，x3=x4，x1≠x4，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。

现在给出一些约束满足问题，请分别对它们进行判定。

输入格式
输入文件的第1行包含1个正整数tt，表示需要判定的问题个数，注意这些问题之间是相互独立的。

对于每个问题，包含若干行：

第1行包含1个正整数nn，表示该问题中需要被满足的约束条件个数。

接下来nn行，每行包括3个整数i,j,ei,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1e=1，则该约束条件为xi=xjxi=xj；若e=0e=0，则该约束条件为xi≠xjxi≠xj。

输出格式
输出文件包括tt行。

输出文件的第k行输出一个字符串“YES”或者“NO”（不包含引号，字母全部大写），“YES”表示输入中的第k个问题判定为可以被满足，“NO”表示不可被满足。

数据范围
1≤n≤10000001≤n≤1000000
1≤i,j≤10000000001≤i,j≤1000000000
样例
输入样例：
2
2
1 2 1
1 2 0
2
1 2 1
2 1 1
输出样例：
NO
YES
并查集
什么题目要用到并查集?那就是具有非常明显的传递关系的题目,或者说并查集擅长动态维护许多具有传递性的关系,能在无向图中维护节点之间的连通性.
这道题目明显就有两个关系变量相等的约束条件和不相等的约束条件.所以说,我们就将相等的约束条件,转化为将两个变量合并到一个集合中.
那么当相等约束条件全部执行完后,记住是全部执行完毕后,我们再去看不相等约束条件,如果说发现不相等的两个变量在同一个集合,那么就是不满足问题输出NO.如果都满足了,那么就是YES!
C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N=1000000*2+10;
int a[N][3],n,m,i,j,cnt,t,fa[N],ms[N];
unordered_map<int,int> c;//建立关系表
int get(int x)
{
    return fa[x]==x?x:fa[x]=get(fa[x]);//路径压缩,防止链式结构
}
void merge(int x,int y)
{
    fa[get(x)]=get(y);
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>t;
    while(t--)
    {
        cin>>n;
        n*=3;
        for(int i=1;i<=n;i++)
        {
            int x;
            cin>>x;
            if (i%3)//变量i和变量j
            {
                if (c[x]==0)
                    c[x]=(++cnt);//没有出现过
                a[i/3+1][i%3]=c[x];//i/3+1是第几对关系.i%3则是判断是变量i还是变量j
                fa[c[x]]=c[x];
            }
            else//约束条件e
                ms[i/3]=x;
        }
        int ok=0;
        for(int i=1;i<=n/3;i++)
            if (ms[i])//相等约束条件
                merge(a[i][1],a[i][2]);
        for(int i=1;i<=n/3;i++)
            if (!ms[i])
            {
                if (get(a[i][1])==get(a[i][2]))//不相等的两个变量,发现居然相等了,那么不符合问题
                {
                    ok=true;
                    cout<<"NO";
                    break;
                }
            }
        if (!ok)
            cout<<"YES";
        cout<<endl;
    }
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1004/
 


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 2000010;

int n, m;
int p[N];
unordered_map<int, int> S;

struct Query
{
    int x, y, e;
}query[N];

int get(int x)
{
    if (S.count(x) == 0) S[x] = ++ n;
    return S[x];
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        n = 0;
        S.clear();
        scanf("%d", &m);
        for (int i = 0; i < m; i ++ )
        {
            int x, y, e;
            scanf("%d%d%d", &x, &y, &e);
            query[i] = {get(x), get(y), e};
        }

        for (int i = 1; i <= n; i ++ ) p[i] = i;

        // 合并所有相等约束条件
        for (int i = 0; i < m; i ++ )
            if (query[i].e == 1)
            {
                int pa = find(query[i].x), pb = find(query[i].y);
                p[pa] = pb;
            }

        // 检查所有不等条件
        bool has_conflict = false;
        for (int i = 0; i < m; i ++ )
            if (query[i].e == 0)
            {
                int pa = find(query[i].x), pb = find(query[i].y);
                if (pa == pb)
                {
                    has_conflict = true;
                    break;
                }
            }

        if (has_conflict) puts("NO");
        else puts("YES");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/161741/
 

AcWing 239. 奇偶游戏    原题链接    中等
作者：    秦淮岸灯火阑珊 ,  2019-02-12 20:34:54 ,  阅读 1313

14


1
原题链接
更好的阅读体验

题目描述
小A和小B在玩一个游戏。

首先，小A写了一个由0和1组成的序列S，长度为N。

然后，小B向小A提出了M个问题。

在每个问题中，小B指定两个数 l 和 r，小A回答 S[l~r] 中有奇数个1还是偶数个1。

机智的小B发现小A有可能在撒谎。

例如，小A曾经回答过 S[1~3] 中有奇数个1， S[4~6] 中有偶数个1，现在又回答 S[1~6] 中有偶数个1，显然这是自相矛盾的。

请你帮助小B检查这M个答案，并指出在至少多少个回答之后可以确定小A一定在撒谎。

即求出一个最小的k，使得01序列S满足第1~k个回答，但不满足第1~k+1个回答。

输入格式
第一行包含一个整数N，表示01序列长度。

第二行包含一个整数M，表示问题数量。

接下来M行，每行包含一组问答：两个整数l和r，以及回答“even”或“odd”，用以描述S[l~r] 中有奇数个1还是偶数个1。

输出格式
输出一个整数k，表示01序列满足第1~k个回答，但不满足第1~k+1个回答，如果01序列满足所有回答，则输出问题总数量。

数据范围
N≤109,M≤10000N≤109,M≤10000
样例
输入样例：
10
5
1 2 even
3 4 odd
5 6 even
1 6 even
7 10 odd
输出样例：
3
前缀和+异或性质+并查集+离散化
我们可以用sum数组表示序列S的前缀和,那么会得到以下性质.
s[l~r]有偶数个1,等价于sum[l-1]与sum[r]奇偶性相同 (1+0=1 0+0=0,1是奇数,0是偶数)
s[l~r]有奇数个1,等价于sum[l-1]与sum[r]奇偶性不同 (1+1=0 0+1=0,1是奇数,0是偶数)
以下是传递关系细目表
如果说x1x1和x2x2奇偶性质相同,x2x2与x3x3奇偶性质相同,那么x1x1和x3x3也相同
如果说x1x1和x2x2奇偶性质相同,x2x2与x3x3奇偶性质不同,那么x1x1和x3x3也不同
如果说x1x1和x2x2奇偶性质不同,x2x2与x3x3奇偶性质不同,那么x1x1和x3x3就相同
上面看清楚地啊,别看错了,尤其是相同和不同
离散化:这道题目N超大,但是M却少,所以记得离散化.(最讨厌离散化了)
异或:我们可以通过异或来满足上面的传递关系,具体可以看代码.我懒了,主要是太久没有写题解了,今天晚上要写至少八篇,好累哎.QwQ
不懂得记得call下博主啊!不要将问题留在心里!!!
C++ 代码
#include<bits/stdc++.h>
using namespace std;
const int N=10010<<1;
struct node
{
    int l,r,ans;
} q[N];
int a[N],fa[N],d[N],n,m,t_n;
int get(int x)
{
    if (x==fa[x])
        return x;
    int root=get(fa[x]);
    d[x]^=d[fa[x]];//异或
    return fa[x]=root;
}
inline int read_init()//离散化
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        char str[5];
        scanf("%d%d%s",&q[i].l,&q[i].r,str);
        q[i].ans=(str[0]=='e'?0:1);
        a[++t_n]=q[i].l-1;
        a[++t_n]=q[i].r;
    }
    sort(a+1,a+1+t_n);
    n=unique(a+1,a+1+t_n)-a-1;//去重
}
inline int work()
{
    read_init();
    for(int i=1;i<=n;i++)
        fa[i]=i;
    for(int i=1;i<=m;i++)
    {
        int x=lower_bound(a+1,a+1+n,q[i].l-1)-a;//离散化后要找数
        int y=lower_bound(a+1,a+1+n,q[i].r)-a;
        int p=get(x),q2=get(y);
        if (p==q2)
        {
            if ((d[x]^d[y])!=q[i].ans)//变量要相等,但是却不相等了.
            {
                cout<<i-1<<endl;
                return 0;
            }
        } 
        else
        {
            fa[p]=q2;//合并merge.两方代码就懒得写函数了,见谅
            d[p]^=d[x]^d[y]^q[i].ans;//统统异或
        }
    }
    cout<<m;//数据过于优秀,一个问题都没有
}
int main()
{
    work();
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1006/
 


带边权写法
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 20010;

int n, m;
int p[N], d[N];
unordered_map<int, int> S;

int get(int x)
{
    if (S.count(x) == 0) S[x] = ++ n;
    return S[x];
}

int find(int x)
{
    if (p[x] != x)
    {
        int root = find(p[x]);
        d[x] += d[p[x]];
        p[x] = root;
    }
    return p[x];
}

int main()
{
    cin >> n >> m;
    n = 0;

    for (int i = 0; i < N; i ++ ) p[i] = i;

    int res = m;
    for (int i = 1; i <= m; i ++ )
    {
        int a, b;
        string type;
        cin >> a >> b >> type;
        a = get(a - 1), b = get(b);

        int t = 0;
        if (type == "odd") t = 1;

        int pa = find(a), pb = find(b);
        if (pa == pb)
        {
            if (((d[a] + d[b]) % 2 + 2) % 2 != t)
            {
                res = i - 1;
                break;
            }
        }
        else
        {
            p[pa] = pb;
            d[pa] = d[a] ^ d[b] ^ t;
        }
    }

    cout << res << endl;

    return 0;
}
扩展域写法
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 40010, Base = N / 2;

int n, m;
int p[N];
unordered_map<int, int> S;

int get(int x)
{
    if (S.count(x) == 0) S[x] = ++ n;
    return S[x];
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> m;
    n = 0;

    for (int i = 0; i < N; i ++ ) p[i] = i;

    int res = m;
    for (int i = 1; i <= m; i ++ )
    {
        int a, b;
        string type;
        cin >> a >> b >> type;
        a = get(a - 1), b = get(b);

        if (type == "even")
        {
            if (find(a + Base) == find(b))
            {
                res = i - 1;
                break;
            }
            p[find(a)] = find(b);
            p[find(a + Base)] = find(b + Base);
        }
        else
        {
            if (find(a) == find(b))
            {
                res = i - 1;
                break;
            }

            p[find(a + Base)] = find(b);
            p[find(a)] = find(b + Base);
        }
    }

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/161795/
 

AcWing 238. 银河英雄传说    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-12 20:21:01 ,  阅读 1156

8


1
原题链接
更好的阅读体验

题目描述
有一个划分为N列的星际战场，各列依次编号为1,2,…,N。

有N艘战舰，也依次编号为1,2,…,N,其中第i号战舰处于第i列。

有T条指令，每条指令格式为以下两种之一：

1、M i j，表示让第i号战舰所在列的全部战舰保持原有顺序，接在第j号战舰所在列的尾部。

2、C i j，表示询问第i号战舰与第j号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。

现在需要你编写一个程序，处理一系列的指令。

输入格式
第一行包含整数T，表示共有T条指令。

接下来T行，每行一个指令，指令有两种形式：M i j或C i j。

其中M和C为大写字母表示指令类型，i和j为整数，表示指令涉及的战舰编号。

输出格式
你的程序应当依次对输入的每一条指令进行分析和处理：

如果是M i j形式，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息；

如果是C i j形式，你的程序要输出一行，仅包含一个整数，表示在同一列上，第i号战舰与第j号战舰之间布置的战舰数目，如果第i号战舰与第j号战舰当前不在同一列上，则输出-1。

数据范围
N≤30000,T≤500000N≤30000,T≤500000
样例
输入样例：
4
M 2 3
C 1 2
M 2 4
C 4 2
输出样例：
-1
1
并查集(边带权)
什么题目要用到并查集?那就是具有非常明显的传递关系的题目,或者说并查集擅长动态维护许多具有传递性的关系,能在无向图中维护节点之间的连通性.
这道题目要注意的就是,我们要边带权,也就是我们不能只处理集合的关系,而是要多一个附带的数组,这个数组就来记录这道题目中最特殊的间隔了多少战舰.听上去很高大上的边带权,实际上就是格外多了一个数组跟随着merge和find一起走而已.也就多了两三行代码,精简容易得很,直接上代码.
C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N=31000+10;
int fa[N],n,t,i,j,d[N],size[N];//size就是记录个数
int get(int x)
{
    if (x==fa[x])
        return x;
    int root=get(fa[x]);
    d[x]+=d[fa[x]];//往下推进
    return fa[x]=root;
}
void merge(int x,int y)
{
    x=get(x),y=get(y);
    fa[x]=y,d[x]=size[y];
    size[y]+=size[x];//顺带记录
}
int main()
{
    scanf("%d\n",&t);
    for(i=1;i<=30000;i++)
        fa[i]=i,size[i]=1;
    while(t--)
    {
        char ch=getchar();
        scanf("%d %d\n",&i,&j);
        if (ch=='M')
            merge(i,j);
        else
        {
            if (get(i)==get(j))
                cout<<abs(d[i]-d[j])-1;
            else
                cout<<"-1";
            cout<<endl;
        }
    }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1005/
 



#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 30010;

int m;
int p[N], size[N], d[N];

int find(int x)
{
    if (p[x] != x)
    {
        int root = find(p[x]);
        d[x] += d[p[x]];
        p[x] = root;
    }
    return p[x];
}

int main()
{
    scanf("%d", &m);

    for (int i = 1; i < N; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    while (m -- )
    {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        if (op[0] == 'M')
        {
            int pa = find(a), pb = find(b);
            d[pa] = size[pb];
            size[pb] += size[pa];
            p[pa] = pb;
        }
        else
        {
            int pa = find(a), pb = find(b);
            if (pa != pb) puts("-1");
            else printf("%d\n", max(0, abs(d[a] - d[b]) - 1));
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/161763/
 

#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <climits>
#include <utility>
#include <sstream>
#include <cctype>
#include <cstdio>
#include <bitset>
#include <vector>

using namespace std;

const int N=30005;

int m;
int p[N],d[N];
int sz[N];

inline int read()
{
    int x=0;
    char ch;
    bool fx=false;
    do ch=getchar();while(~ch&&ch!='-'&&(ch<48||ch>57));
    if(ch=='-')fx=true,ch=getchar();
    for(;ch>47&&ch<58;ch=getchar())
        x=(x<<1)+(x<<3)+(ch^48);
    return fx?-x:x;
}

int find(int x)
{
    if(p[x]!=x)
    {
        int root=find(p[x]);
        d[x]+=d[p[x]];
        p[x]=root;
    }
    return p[x];
}

int main()
{
    for(int i=1;i<N;i++)
    {
        p[i]=i;
        sz[i]=1;
    }
    for(int T=read();T--;)
    {
        char op;
        int a,b;
        op=getchar();
        a=read(),b=read();
        if(op=='M')
        {
            a=find(a);
            b=find(b);
            d[a]+=sz[b];
            sz[b]+=sz[a];
            p[a]=b;
        }
        else printf("%d\n",find(a)==find(b)?abs(d[a]-d[b])-1:-1);
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/329695/
 

AcWing 241. 楼兰图腾    原题链接    简单
作者：    qiaoxinwei ,  2020-05-28 23:11:28 ,  阅读 303

14


2
树状数组
引入问题
给出一个长度为nn的数组，完成以下两种操作：
1. 将第ii个数加上kk
2. 输出区间[i,j][i,j]内每个数的和

朴素算法
单点修改：O(1)O(1)
区间查询：O(n)O(n)
使用树状数组
单点修改：O(logn)O(logn)
区间查询：O(logn)O(logn)
前置知识
lowbit()lowbit()运算：非负整数xx在二进制表示下最低位1及其后面的0构成的数值。

举例说明：
lowbit(12)=lowbit([1100]2)=[100]2=4lowbit(12)=lowbit([1100]2)=[100]2=4
函数实现：

int lowbit(int x)
{
    return x & -x;
}
树状数组思想
树状数组的本质思想是使用树结构维护”前缀和”，从而把时间复杂度降为O(logn)O(logn)。

对于一个序列，对其建立如下树形结构：


每个结点t[x]保存以x为根的子树中叶结点值的和
每个结点覆盖的长度为lowbit(x)
t[x]结点的父结点为t[x + lowbit(x)]
树的深度为log2n+1log2n+1
树状数组操作
add(x, k)表示将序列中第x个数加上k。

以add(3, 5)为例：
在整棵树上维护这个值，需要一层一层向上找到父结点，并将这些结点上的t[x]值都加上k，这样保证计算区间和时的结果正确。时间复杂度为O(logn)O(logn)。
void add(int x, int k)
{
    for(int i = x; i <= n; i += lowbit(i))
        t[i] += k;
}
ask(x)表示将查询序列前x个数的和

以ask(7)为例：
查询这个点的前缀和，需要从这个点向左上找到上一个结点，将加上其结点的值。向左上找到上一个结点，只需要将下标 x -= lowbit(x)，例如 7 - lowbit(7) = 6。
int ask(int x)
{
    int sum = 0;
    for(int i = x; i; i -= lowbit(i))
        sum += t[i];
    return sum;
}
以上关于树状数组的介绍来自于B站 。
本题题解
算法1
(暴力枚举) O(n2)O(n2)
一种朴素做法就是遍历所有点i， 分别统计i位置左边比a[i]小的数的个数m、右边比a[i]小的数的个数n，运用乘法原理：
1. 第一步从左边m个数中任选一个，有m种选法
2. 第二步从右边n个数中任选一个，有n种选法
那么在i位置组成图腾∧的方案数一共是 m * n。
累加每个点的方案数，即为所有组成图腾∧的方案总数。

时间复杂度O(n2)O(n2)。

C++ 代码
#include <iostream>
#include <cstdio>

using namespace std;

const int N = 2000010;

typedef long long LL;

int a[N];
//ll[i]表示i的左边比第i个数小的数的个数
//rl[i]表示i的右边比第i个数小的数的个数
//lg[i]表示i的左边比第i个数大的数的个数
//rg[i]表示i的右边比第i个数大的数的个数
int ll[N], rl[N], lg[N], rg[N];

int main()
{
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);

    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j < i; j++)
        {
            //a[]保存的是1 ~ n的一个排列，不可能相等
            if(a[j] < a[i]) ll[i] ++;
            else lg[i] ++;
        }
    }

    for(int i = 1; i <= n; i++)
    {
        for(int j = n; j > i; j--)
        {
            if(a[j] < a[i]) rl[i] ++;
            else rg[i] ++;
        }
    }

    LL resV = 0, resA = 0;
    for(int i = 1; i <= n; i++)
    {
        resV += (LL)lg[i] * rg[i];
        resA += (LL)ll[i] * rl[i];
    }

    printf("%lld %lld\n", resV, resA);

    return 0;
}
算法2
(树状数组) O(nlogn)O(nlogn)
从左向右依次遍历每个数a[i]，使用树状数组统计在i位置之前所有比a[i]大的数的个数、以及比a[i]小的数的个数。
统计完成后，将a[i]加入到树状数组。

从右向左依次遍历每个数a[i]，使用树状数组统计在i位置之后所有比a[i]大的数的个数、以及比a[i]小的数的个数。
统计完成后，将a[i]加入到树状数组。

时间复杂度 O(nlogn)O(nlogn)
C++ 代码
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 2000010;

typedef long long LL;

int n;
//t[i]表示树状数组i结点覆盖的范围和
int a[N], t[N];
//Lower[i]表示左边比第i个位置小的数的个数
//Greater[i]表示左边比第i个位置大的数的个数
int Lower[N], Greater[N];

//返回非负整数x在二进制表示下最低位1及其后面的0构成的数值
int lowbit(int x)
{
    return x & -x;
}

//将序列中第x个数加上k。
void add(int x, int k)
{
    for(int i = x; i <= n; i += lowbit(i)) t[i] += k;
}
//查询序列前x个数的和
int ask(int x)
{
    int sum = 0;
    for(int i = x; i; i -= lowbit(i)) sum += t[i];
    return sum;
}

int main()
{

    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);

    //从左向右，依次统计每个位置左边比第i个数y小的数的个数、以及大的数的个数
    for(int i = 1; i <= n; i++)
    {
        int y = a[i]; //第i个数

        //在前面已加入树状数组的所有数中统计在区间[1, y - 1]的数字的出现次数
        Lower[i] = ask(y - 1); 

        //在前面已加入树状数组的所有数中统计在区间[y + 1, n]的数字的出现次数
        Greater[i] = ask(n) - ask(y);

        //将y加入树状数组，即数字y出现1次
        add(y, 1);
    }

    //清空树状数组，从右往左统计每个位置右边比第i个数y小的数的个数、以及大的数的个数
    memset(t, 0, sizeof t);

    LL resA = 0, resV = 0;
    //从右往左统计
    for(int i = n; i >= 1; i--)
    {
        int y = a[i];
        resA += (LL)Lower[i] * ask(y - 1);
        resV += (LL)Greater[i] * (ask(n) - ask(y));

        //将y加入树状数组，即数字y出现1次
        add(y, 1);
    }

    printf("%lld %lld\n", resV, resA);

    return 0;
}

作者：qiaoxinwei
链接：https://www.acwing.com/solution/content/13818/

题解LeetCode 59-II. 【python】队列的最大值
lh359149153的头像lh359149153
44分钟前
题目描述
请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

样例
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]

算法1
(辅助队列) O(n2)
思路
1.o(1)求max:维护一个辅助队列：当新插入值value>队内已有（-1），先把对内弹出（用不上）–> 维护成了非单增的
注：维护队列时，用while循环

时间复杂度
参考文献
python 代码
from collections import deque
class MaxQueue:

    def __init__(self):
        self.q1=deque()
        self.q2=deque()


    #从辅助栈获取
    def max_value(self) -> int:
        if self.q2:
            return self.q2[0]
        else:
            return -1

    #压入；存储；维护单调队列
    def push_back(self, value: int) -> None:
        self.q1.append(value)
        while self.q2 and value>self.q2[-1]:
            self.q2.pop()
        self.q2.append(value)

    #从主栈弹出队头值
    def pop_front(self) -> int:
        if not self.q1:
            return -1
        #队头值
        res=self.q1.popleft()
        if res==self.q2[0]:
            self.q2.popleft()
        return res 



#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 200010;

int n;
int a[N];
int tr[N];
int Greater[N], lower[N];

int lowbit(int x)
{
    return x & -x;
}

void add(int x, int c)
{
    for (int i = x; i <= n; i += lowbit(i)) tr[i] += c;
}

int sum(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

int main()
{
    scanf("%d", &n);

    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);

    for (int i = 1; i <= n; i ++ )
    {
        int y = a[i];
        Greater[i] = sum(n) - sum(y);
        lower[i] = sum(y - 1);
        add(y, 1);
    }

    memset(tr, 0, sizeof tr);
    LL res1 = 0, res2 = 0;
    for (int i = n; i; i -- )
    {
        int y = a[i];
        res1 += Greater[i] * (LL)(sum(n) - sum(y));
        res2 += lower[i] * (LL)(sum(y - 1));
        add(y, 1);
    }

    printf("%lld %lld\n", res1, res2);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/164715/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 242. 一个简单的整数问题    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-13 20:05:25 ,  阅读 977

6


4
原题链接
更好的阅读体验

题目描述
给定长度为N的数列A，然后输入M行操作指令。

第一类指令形如“C l r d”，表示把数列中第l~r个数都加d。

第二类指令形如“Q X”，表示询问数列中第x个数的值。

对于每个询问，输出一个整数表示答案。

输入格式
第一行包含两个整数N和M。

第二行包含N个整数A[i]。

接下来M行表示M条指令，每条指令的格式如题目描述所示。

输出格式
对于每个询问，输出一个整数表示答案。

每个答案占一行。

数据范围
1≤N,M≤1051≤N,M≤105,
|d|≤10000|d|≤10000,
|A[i]|≤1000000000|A[i]|≤1000000000
样例
输入样例：
10 5
1 2 3 4 5 6 7 8 9 10
Q 4
Q 1
Q 2
C 1 6 3
Q 2
输出样例：
4
1
2
5
树状数组(区间修改,单点查询)
树状数组只支持单点查询,但是这里我们要资瓷区间操作,那么就得来一点特殊操作.
首先我们可以开一个数组B,然后对于每条C操作,我们直接利用前缀和的思想.
把b[l]+=d;
把b[r+1]-=d;
然后我们就成功达成成就,把维护序列的具体值,转化为维护指令的累计影响,每次操作的影响,在l处开始,然后在r+1处消除.然后就让单点修改可以维护区间修改.
C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
#define lowbit(x) x&(-x)
int a[N],c[N],b[N],i,j,n,m;
inline int ask(int x)
{
    int ans=a[x];
    for(;x;x-=lowbit(x))
        ans+=c[x];
    return ans;
}
inline void add(int x,int y)
{
    for(;x<=n;x+=lowbit(x))
        c[x]+=y;
}
int main()
{
    scanf("%d%d\n",&n,&m);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i]);
    getchar();
    for(i=1;i<=m;i++)
    {
        char ch=getchar();
        if (ch=='C')
        {
            int l,r,d;
            scanf("%d%d%d\n",&l,&r,&d);
            add(l,d);
            add(r+1,-d);//前缀和思想
        }
        if (ch=='Q')
        {
            int x;
            scanf(" %d\n",&x);
            printf("%d\n",ask(x));
        }
    }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1010/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int n, m;
int a[N];
LL tr[N];

int lowbit(int x)
{
    return x & -x;
}

void add(int x, int c)
{
    for (int i = x; i <= n; i += lowbit(i)) tr[i] += c;
}

LL sum(int x)
{
    LL res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);

    for (int i = 1; i <= n; i ++ ) add(i, a[i] - a[i - 1]);

    while (m -- )
    {
        char op[2];
        int l, r, d;
        scanf("%s%d", op, &l);
        if (*op == 'C')
        {
            scanf("%d%d", &r, &d);
            add(l, d), add(r + 1, -d);
        }
        else
        {
            printf("%lld\n", sum(l));
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/164726/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 243. 一个简单的整数问题2    原题链接    困难
作者：    秦淮岸灯火阑珊 ,  2019-02-13 20:39:27 ,  阅读 1444

5


2
题目描述
给定一个长度为N的数列A，以及M条指令，每条指令可能是以下两种之一：

1、“C l r d”，表示把 A[l],A[l+1],…,A[r] 都加上 d。

2、“Q l r”，表示询问 数列中第 l~r 个数的和。

对于每个询问，输出一个整数表示答案。

输入格式
第一行两个整数N,M。

第二行N个整数A[i]。

接下来M行表示M条指令，每条指令的格式如题目描述所示。

输出格式
对于每个询问，输出一个整数表示答案。

每个答案占一行。

数据范围
1≤N,M≤1051≤N,M≤105,
|d|≤10000|d|≤10000,
|A[i]|≤1000000000|A[i]|≤1000000000
样例
输入样例：
10 5
1 2 3 4 5 6 7 8 9 10
Q 4 4
Q 1 10
Q 2 4
C 3 6 3
Q 2 4
输出样例：
4
55
9
15
树状数组(区间修改+区间查询)
首先我们可以开一个数组B,然后对于每条C操作,我们直接利用前缀和的思想.
把b[l]+=d;
把b[r+1]-=d;
然后我们就成功达成成就,把维护序列的具体值,转化为维护指令的累计影响,每次操作的影响,在l处开始,然后在r+1处消除.然后就让单点修改可以维护区间修改.
现在b数组的前缀和就是∑xi=1b[i]∑i=1xb[i] 就是经过指令后a[x]增加的值,那么序列a的前缀和a[1~x]增加的值就是:
∑i=1x∑j=1ib[j]
∑i=1x∑j=1ib[j]
然后上式就可以转换为
∑i=1x∑j=1ib[j]=∑i=1x(x−i+1)×b[i]=(x+1)∑i=1xb[i]−∑i=1xi×b[i]
∑i=1x∑j=1ib[j]=∑i=1x(x−i+1)×b[i]=(x+1)∑i=1xb[i]−∑i=1xi×b[i]
然后通过上面这个式子,我们就把原来的数组,经过差分操作去维护两个树状数组，一个维护didi，一个维护di×idi×i这样的话,我们在区间修改的过程中,就可以在两个树状数组中去查询得到前缀和，然后同理,区间修改操作就是差分数组的修改,每次只需要修改两个点,完美的将区间再次转换为单调修改。
C++ 代码
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define lowbit(x) x&(-x)
const int N=2e5;
ll c1[N],c2[N],n,m,a[N];
ll add(ll x,ll y)
{
    for(ll i=x;i<=n;i+=lowbit(i))
    {
        c1[i]+=y;
        c2[i]+=x*y;
    }
}
ll ask(ll x)
{
    ll ans=0;
    for(ll i=x;i;i-=lowbit(i))
        ans+=(x+1)*c1[i]-c2[i];
    return ans;
}
int main()
{
    scanf("%lld%lld\n",&n,&m);
    for(ll i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        add(i,a[i]-a[i-1]);
    }
    getchar();
    while(m--)
    {
        char ch=getchar();
        if (ch=='Q')
        {
            ll x,y;
            scanf("%lld%lld\n",&x,&y);
            cout<<ask(y)-ask(x-1)<<endl;
        }
        if (ch=='C')
        {
            ll x,y,d;
            scanf("%lld%lld%lld\n",&x,&y,&d);
            add(x,d);
            add(y+1,-d);
        }
    }
    return 0;
}
感谢lcf大佬的博客
感谢lyd大佬的蓝书

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1011/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int n, m;
int a[N];
LL tr1[N];  // 维护b[i]的前缀和
LL tr2[N];  // 维护b[i] * i的前缀和

int lowbit(int x)
{
    return x & -x;
}

void add(LL tr[], int x, LL c)
{
    for (int i = x; i <= n; i += lowbit(i)) tr[i] += c;
}

LL sum(LL tr[], int x)
{
    LL res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

LL prefix_sum(int x)
{
    return sum(tr1, x) * (x + 1) - sum(tr2, x);
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i ++ )
    {
        int b = a[i] - a[i - 1];
        add(tr1, i, b);
        add(tr2, i, (LL)b * i);
    }

    while (m -- )
    {
        char op[2];
        int l, r, d;
        scanf("%s%d%d", op, &l, &r);
        if (*op == 'Q')
        {
            printf("%lld\n", prefix_sum(r) - prefix_sum(l - 1));
        }
        else
        {
            scanf("%d", &d);
            // a[l] += d
            add(tr1, l, d), add(tr2, l, l * d);
            // a[r + 1] -= d
            add(tr1, r + 1, -d), add(tr2, r + 1, (r + 1) * -d);
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/164758/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 244. 谜一样的牛    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-13 20:57:20 ,  阅读 1198

9


3
原题链接
更好的阅读体验

题目描述
有n头奶牛，已知它们的身高为 1~n 且各不相同，但不知道每头奶牛的具体身高。

现在这nn头奶牛站成一列，已知第i头牛前面有AiAi头牛比它低，求每头奶牛的身高。

输入格式
第1行：输入整数nn。

第2..n行：每行输入一个整数AiAi,第i行表示第i头牛前面有AiAi头牛比它低。
（注意：因为第1头牛前面没有牛，所以并没有将它列出）

输出格式
输出包含nn行，每行输出一个整数表示牛的身高。

第ii行输出第ii头牛的身高。

数据范围
1≤n≤1051≤n≤105
样例
输入样例：
5
1
2
1
0
输出样例：
2
4
5
3
1
树状数组+二分
我们发现,如果说第KK头牛的前面有AkAk头牛比它矮,那么它的身高HkHk就是数值1 n1 n中第Ak+1Ak+1小的没有在Hk+1,Hk+2,…,HnHk+1,Hk+2,…,Hn中出现过的数
所以说,我们需要建立一个长度为n的1序列b,刚开始都是1,然后n到1倒序扫描每一个AiAi,对于每个AiAi执行查询和修改操作.
也就是说这道题目的题意就是让我们,动态维护一个01序列,支持查询第k个1所在的位置,以及修改序列中的一个数值
C++ 代码
#include <bits/stdc++.h>
using namespace std;
#define lowbit(x) x&(-x)
const int N=2e5;
int c[N],a[N],n,m,i,j,ans[N];
inline int ask(int x)
{
    int ans=0;
    for(;x;x-=lowbit(x))
        ans+=c[x];
    return ans;
}
inline int add(int x,int y)
{
    for(;x<=n;x+=lowbit(x))
        c[x]+=y;
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    add(1,1);
    for(i=2;i<=n;i++)
    {
        cin>>a[i];
        add(i,1);
    }
    for(i=n;i>=1;i--)
    {
        int l=1,r=n;
        while(l<r)//二分找点
        {
            int mid=l+r>>1;
            if (ask(mid)<a[i]+1)//查询第A_{i}+1个1在什么位置,这个位置号就是奶牛的高度
                l=mid+1;
            else
                r=mid;
        }
        ans[i]=r;
        add(r,-1);//我们已经选择了
    }
    for(i=1;i<=n;i++)//倒序扫描,正序输出
        cout<<ans[i]<<endl;
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1012/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int h[N];
int ans[N];
int tr[N];

int lowbit(int x)
{
    return x & -x;
}

void add(int x, int c)
{
    for (int i = x; i <= n; i += lowbit(i)) tr[i] += c;
}

int sum(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

int main()
{
    scanf("%d", &n);
    for (int i = 2; i <= n; i ++ ) scanf("%d", &h[i]);

    for (int i = 1; i <= n; i ++ ) tr[i] = lowbit(i);

    for (int i = n; i; i -- )
    {
        int k = h[i] + 1;
        int l = 1, r = n;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (sum(mid) >= k) r = mid;
            else l = mid + 1;
        }
        ans[i] = r;
        add(r, -1);
    }

    for (int i = 1; i <= n; i ++ ) printf("%d\n", ans[i]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/164773/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1275. 最大数    原题链接    中等
作者：    辰风 ,  2020-03-03 11:17:39 ,  阅读 300

2


思路


代码
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;
const int N=200010;
struct point{
    int l,r;
    int v;
}tr[N*4];
int m,p;
int query(int u,int l,int r){
    int v=0;
    if(tr[u].l>=l&&tr[u].r<=r)return tr[u].v;//如果当前的树已经被包含再查询区间内了，直接放回v
    int mid=tr[u].l+tr[u].r>>1;
    if(l<=mid)v=max(v,query(u<<1,l,r));//否则分别考虑再左节点和右节点是否有查询区间
    if(r>mid)v=max(v,query(u<<1|1,l,r));
    return v;
}
void build(int u,int l,int r){//建树
    tr[u]={l,r};
    if(l==r)return;
    int mid=l+r >> 1;
    build(u<<1,l,mid);
    build(u<<1|1,mid+1,r);
}
void modify(int u,int x,int v){
    if (tr[u].l == x && tr[u].r == x) tr[u].v = v;//如果已经找到了要添加的位置，就直接赋值
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        tr[u].v = max(tr[u << 1].v, tr[u << 1 | 1].v);//更新父节点
    }

}
int main(){
    cin >> m >> p;
    int n=0;//n表示当前树的长度
    int last=0;//last记录一下上一次查询的结果
    build(1,1,m);
    while(m--){
        char c;
        int x;
        cin >> c >> x;
        if(c=='Q'){
            last=query(1,n-x+1,n);
            cout << last  << "\n";
        }else{
            modify(1,n+1,(last + x) % p);
            n++;
        }
    }
}

作者：辰风
链接：https://www.acwing.com/solution/content/9453/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 200010;

int m, p;
struct Node
{
    int l, r;
    int v;  // 区间[l, r]中的最大值
}tr[N * 4];

void pushup(int u)  // 由子节点的信息，来计算父节点的信息
{
    tr[u].v = max(tr[u << 1].v, tr[u << 1 | 1].v);
}

void build(int u, int l, int r)
{
    tr[u] = {l, r};
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

int query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u].v;   // 树中节点，已经被完全包含在[l, r]中了

    int mid = tr[u].l + tr[u].r >> 1;
    int v = 0;
    if (l <= mid) v = query(u << 1, l, r);
    if (r > mid) v = max(v, query(u << 1 | 1, l, r));

    return v;
}

void modify(int u, int x, int v)
{
    if (tr[u].l == x && tr[u].r == x) tr[u].v = v;
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);
    }
}


int main()
{
    int n = 0, last = 0;
    scanf("%d%d", &m, &p);
    build(1, 1, m);

    int x;
    char op[2];
    while (m -- )
    {
        scanf("%s%d", op, &x);
        if (*op == 'Q')
        {
            last = query(1, n - x + 1, n);
            printf("%d\n", last);
        }
        else
        {
            modify(1, n + 1, (last + x) % p);
            n ++ ;
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/167554/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 245. 你能回答这些问题吗    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-14 21:29:09 ,  阅读 2225

18


4
原题链接
更好的阅读体验

感谢@upc1808040230指出代码一个锅。。。
已经修复完毕了。。。

题目描述
给定长度为N的数列A，以及M条指令，每条指令可能是以下两种之一：

1、“1 x y”，查询区间 [x,y] 中的最大连续子段和，即maxx≤l≤r≤y∑ri=lA[i]maxx≤l≤r≤y∑i=lrA[i]
2、“2 x y”，把 A[x] 改成 y。

对于每个查询指令，输出一个整数表示答案。

输入格式
第一行两个整数N,M。

第二行N个整数A[i]。

接下来M行每行3个整数k,x,y，k=1表示查询（此时如果x>y，请交换x,y），k=2表示修改。

输出格式
对于每个查询指令输出一个整数表示答案。

每个答案占一行。

数据范围
N≤500000,M≤100000N≤500000,M≤100000
样例
输入样例：
5 3
1 2 -3 4 5
1 2 3
2 2 -1
1 3 2
输出样例：
2
-1
线段树
区间最大连续字段和是一道非常经典的问题,这道题目中我们唯一与线段树模板不同的地方,也就是这里.
最大连续子段和,根据区间可见性,我们知道这里面必然会增加两个变量lmaxlmax和rmaxrmax分别管理前缀最大子段和和后缀最大子段和.然后根据区间可见性,显然[l,r][l,r]区间的最大子段和就是左区间的最大子段和,右区间最大子段和,以及左右两区间结合在一起中间的最大子段和.
C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N=500000<<2;
struct line_tree
{
    int lmax,rmax,sum,dat,l,r;
} t[N];
int n,m,a[N>>2];
int build(int p,int l,int r)
{
    t[p].l=l;
    t[p].r=r;
    if(t[p].l==t[p].r)
    {
        t[p].dat=t[p].sum=t[p].lmax=t[p].rmax=a[l];
        return 0;
    }
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build(p*2+1,mid+1,r);
    t[p].sum=t[p<<1].sum+t[p*2+1].sum;
    t[p].lmax=max(t[p<<1].lmax,t[p<<1].sum+t[p*2+1].lmax);//本身,以及左边前缀和加上右边前缀最大子段和
    t[p].rmax=max(t[p*2+1].rmax,t[p*2+1].sum+t[p<<1].rmax);//本身,以及右边前缀和加上左边后缀最大子段和.
    t[p].dat=max(max(t[p<<1].dat,t[p*2+1].dat),t[p<<1].rmax+t[p*2+1].lmax);
}
int change(int p,int x,int v)
{
    if (t[p].l==t[p].r)
    {
        t[p].dat=v;
        t[p].sum=v;
        t[p].lmax=v;
        t[p].rmax=v;
        return 0;
    }
    int mid=(t[p].l+t[p].r)>>1;
    if (x<=mid)
        change(p<<1,x,v);
    else
        change(p*2+1,x,v);
    t[p].sum=t[p<<1].sum+t[p*2+1].sum;
    t[p].lmax=max(t[p<<1].lmax,t[p<<1].sum+t[p*2+1].lmax);
    t[p].rmax=max(t[p*2+1].rmax,t[p*2+1].sum+t[p<<1].rmax);
    t[p].dat=max(max(t[p<<1].dat,t[p*2+1].dat),t[p<<1].rmax+t[p*2+1].lmax);
}
line_tree ask(int p,int l,int r)
{
    if (l<=t[p].l && r>=t[p].r)
        return t[p];
    int mid=(t[p].l+t[p].r)>>1,val=-(1<<30);
    line_tree a,b,c;
    a.dat=a.sum=a.lmax=a.rmax=val;
    b.dat=b.sum=b.lmax=b.rmax=val;
    c.sum=0;
    if (l<=mid)
    {
        a=ask(p<<1,l,r);
        c.sum+=a.sum;
    }
    if (r>mid)
    {
        b=ask(p*2+1,l,r);
        c.sum+=b.sum;
    }
    c.dat=max(max(a.dat,b.dat),a.rmax+b.lmax);
    c.lmax=max(a.lmax,b.lmax+a.sum);
    if (l>mid)
        c.lmax=max(c.lmax,b.lmax);
    c.rmax=max(b.rmax,b.sum+a.rmax);
    if (r<=mid)
        c.rmax=max(c.rmax,a.rmax);
    return c;
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    build(1,1,n);
    while(m--)
    {
        int k,x,y;
        cin>>k>>x>>y;
        if (k==1)
        {
            if (x>y)
                swap(x,y);
            cout<<ask(1,x,y).dat<<endl;
        }
        if (k==2)
            change(1,x,y);
    }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1016/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 500010;

int n, m;
int w[N];
struct Node
{
    int l, r;
    int sum, lmax, rmax, tmax;
}tr[N * 4];

void pushup(Node &u, Node &l, Node &r)
{
    u.sum = l.sum + r.sum;
    u.lmax = max(l.lmax, l.sum + r.lmax);
    u.rmax = max(r.rmax, r.sum + l.rmax);
    u.tmax = max(max(l.tmax, r.tmax), l.rmax + r.lmax);
}

void pushup(int u)
{
    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
    if (l == r) tr[u] = {l, r, w[r], w[r], w[r], w[r]};
    else
    {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void modify(int u, int x, int v)
{
    if (tr[u].l == x && tr[u].r == x) tr[u] = {x, x, v, v, v, v};
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);
    }
}

Node query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (r <= mid) return query(u << 1, l, r);
        else if (l > mid) return query(u << 1 | 1, l, r);
        else
        {
            auto left = query(u << 1, l, r);
            auto right = query(u << 1 | 1, l, r);
            Node res;
            pushup(res, left, right);
            return res;
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    build(1, 1, n);

    int k, x, y;
    while (m -- )
    {
        scanf("%d%d%d", &k, &x, &y);
        if (k == 1)
        {
            if (x > y) swap(x, y);
            printf("%d\n", query(1, x, y).tmax);
        }
        else modify(1, x, y);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/167568/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 246. 区间最大公约数    原题链接    困难
作者：    这个显卡不太冷 ,  2019-02-21 03:36:34 ,  阅读 1512

19


12
一级标题提醒：此题细节很多
1. gcd(a,b)=gcd(a,b−a)gcd(a,b)=gcd(a,b−a)
在lyd的书里提到的这个性质叫更相减损术，可以推广到多个数的情况。
更相减损术其实是欧几里得算法的一个特例。即gcd(a−nb,b)=gcd(a,b)gcd(a−nb,b)=gcd(a,b)。
(a,b,c)=((a,b),(b,c))=((a,b−a),(b,c−b))=(a,b−a,b,c−b)(a,b,c)=((a,b),(b,c))=((a,b−a),(b,c−b))=(a,b−a,b,c−b)
由于(b−a,b)=(a,b−a)(b−a,b)=(a,b−a)所以(a,b,c)=(a,b−a,c−b)(a,b,c)=(a,b−a,c−b)
有了这个式子说名可以通过维护序列的差分来达到求gcd同样的效果。
比如求(a,b,c)(a,b,c)只需要知道现在aa的值，然后知道(b−a,c−b)(b−a,c−b)的gcd，再求一个公约数就行了。

差分就可以把区间加减变成单点加减。可以用没有lazy的线段树来做。

再维护一个差分，做成树状数组或者线段树，用来维护每个数的值。

2. gcd(a,b)=gcd(a,−b)gcd(a,b)=gcd(a,−b)
在数值加减的过程中可能会产生负数，而约定gcd是没有负数的，所以需要用这个式子来搞定负数。
具体来说，就是在每次查询或者更新的时候，如果遇到了负数，就把它取反。
注意只能对结果取反而不能直接把线段树的负数叶子节点取反。因为直接把叶子取反会对今后的加减操作造成影响。
虽然gcd(a,b)=gcd(a,−b)gcd(a,b)=gcd(a,−b)但是(a+1,b)(a+1,b)和(−a+1,b)(−a+1,b)不一定相等。

差分操作
差分操作是a[x]+d,a[y+1]-d;这个时候就可能出现y+1越界的情况。需要及时特判掉。

大概就这么多吧。主要是一些小的细节需要注意。比如数据爆int，范围不给全，蒟蒻两行泪

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 5e5 + 23;
struct Node{
    int l, r;
    ll v, d;
}tr[maxn * 4];
ll a[maxn], b[maxn];
void pushup(Node &u, Node &l, Node &r)
{
    u.v = l.v + r.v;
    u.d = __gcd(l.d, r.d);
}
void pushup(int u)
{
    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
    //printf("%d[%d,%d]=%d\n",u,tr[u].l,tr[u].r,tr[u].d);
}
void build(int u, int l, int r)
{
    if(l == r) tr[u] = {l, r, b[l], b[l]};
    else 
    {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid); build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}
ll query(int u, int l, int r)
{
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].d;
    else 
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if(r <= mid) return query(u << 1, l, r);
        else if(l > mid) return query(u << 1 | 1, l, r);
        else return __gcd(query(u << 1, l, r), query(u << 1 | 1, l, r));
    }
}
ll query2(int u, int l, int r)
{
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].v;
    else 
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if(r <= mid) return query2(u << 1, l, r);
        else if(l > mid) return query2(u << 1 | 1, l, r);
        else return query2(u << 1, l, r) + query2(u << 1 | 1, l, r);
    }
}
void modify(int u, int p, ll v)
{
    if(tr[u].l == tr[u].r && tr[u].l == p) tr[u].d += v, tr[u].v += v;
    else 
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if(p <= mid) modify(u << 1, p, v);
        else modify(u << 1 | 1, p, v);
        pushup(u);
    }
}
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) scanf("%lld", &a[i]), b[i] = a[i] - a[i - 1];
    build(1, 1, n);
    char op[4];
    ll op1 = 0, op2 = 0, op3 = 0;
    while(m--)
    {
        scanf("%s%lld%lld", op, &op1, &op2);
        if(*op == 'C') 
        {
            scanf("%lld", &op3);
            modify(1, op1, op3);
            if(op2 + 1 <= n) modify(1, op2 + 1, -op3);
        }
        else 
        {
            ll t = query2(1, 1, op1); //cout << t << endl;
            printf("%lld\n", abs( __gcd(t, query(1, op1 + 1, op2))));
        }
    }
}

/*
1 2 2 2 2 / 1 3 5 7 9
2 2 2 2 2 / 2 4 6 8 10
2 2 8 -4 2 / 2 4 12 8 10
*/

作者：这个显卡不太冷
链接：https://www.acwing.com/solution/content/1047/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 500010;

int n, m;
LL w[N];
struct Node
{
    int l, r;
    LL sum, d;
}tr[N * 4];

LL gcd(LL a, LL b)
{
    return b ? gcd(b, a % b) : a;
}

void pushup(Node &u, Node &l, Node &r)
{
    u.sum = l.sum + r.sum;
    u.d = gcd(l.d, r.d);
}

void pushup(int u)
{
    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
    if (l == r)
    {
        LL b = w[r] - w[r - 1];
        tr[u] = {l, r, b, b};
    }
    else
    {
        tr[u].l = l, tr[u].r = r;
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void modify(int u, int x, LL v)
{
    if (tr[u].l == x && tr[u].r == x)
    {
        LL b = tr[u].sum + v;
        tr[u] = {x, x, b, b};
    }
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);
    }
}

Node query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (r <= mid) return query(u << 1, l, r);
        else if (l > mid) return query(u << 1 | 1, l, r);
        else
        {
            auto left = query(u << 1, l, r);
            auto right = query(u << 1 | 1, l, r);
            Node res;
            pushup(res, left, right);
            return res;
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%lld", &w[i]);
    build(1, 1, n);

    int l, r;
    LL d;
    char op[2];
    while (m -- )
    {
        scanf("%s%d%d", op, &l, &r);
        if (*op == 'Q')
        {
            auto left = query(1, 1, l);
            Node right({0, 0, 0, 0});
            if (l + 1 <= r) right = query(1, l + 1, r);
            printf("%lld\n", abs(gcd(left.sum, right.d)));
        }
        else
        {
            scanf("%lld", &d);
            modify(1, l, d);
            if (r + 1 <= n) modify(1, r + 1, -d);
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/167582/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 243. 一个简单的整数问题2    原题链接    困难
作者：    Anoxia_3 ,  2020-07-21 13:40:45 ,  阅读 124

3


拓拓展
作用：1、改一个区间的值；2、查某一区间内值的和

思路：设a数组是原数组，b数组是a数组的差分数组，
tr1数组是b数组的树状数组，tr2数组是i*b~i~数组树状数组
要查询某一区间内值的和当然要用前缀和！



（上式中加粗体是额外加入的值，非加粗的是原数）
为了便于计算，我们填补了每个数后面的差分，于是易得：
a~1~+a~2~+…+a~x~=(x+1) * (b~1~+b~2~+b~3~+…+b~x~) - (b~1~+2b~2~+3b~3~+…+xb~x~)
利用树状数组，可以很容易求得等号右边的两大项。

#include <iostream>

using namespace std;

typedef long long LL;

const int N = 100010;

int n , m;
int a[N];
LL tr1[N] , tr2[N];

int lowbit(int x)
{
    return x & -x;
}

void add(LL tr[] , int x , LL c)
{
    for(int i = x ; i <= n ; i += lowbit(i))    tr[i] += c;
}

LL sum(LL tr[] , int x)
{
    LL res = 0;
    for(int i = x ; i ; i -= lowbit(i))   res += tr[i];
    return res;
}

LL prefix_sum(int x)
{
    return sum(tr1 , x) * (x + 1) - sum(tr2 , x);
}

int main()
{
    scanf("%d%d" , &n , &m);

    for(int i = 1; i <= n ; i++)    scanf("%d", &a[i]);

    for(int i = 1 ; i <= n ; i++)
    {
        int b = a[i] - a[i - 1];
        add(tr1 , i , b);
        add(tr2 , i , (LL)b * i);
    }

    while(m--)
    {
        int l , r , d;
        char op[2];

        scanf("%s%d%d" , op , &l , &r);

        if(*op == 'Q')
            cout << prefix_sum(r) - prefix_sum(l - 1) << endl;
        else
        {   
            scanf("%d" , &d);
            add(tr1 , l , d) , add(tr1 , r + 1 , -d);
            add(tr2 , l , l * d) , add(tr2 , r + 1 , (r + 1) * (- d));
        }
    }
        return 0;
}

作者：Anoxia_3
链接：https://www.acwing.com/solution/content/16803/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


c++代码
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <queue>
#include <vector>
#include <stack>
#include <map>
#include <set>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <bitset>
#include <assert.h>

using namespace std;
typedef long long llong;
typedef set<int>::iterator ssii;

#define Cmp(a, b) memcmp(a, b, sizeof(b))
#define Cpy(a, b) memcpy(a, b, sizeof(a))
#define Set(a, v) memset(a, v, sizeof(a))
#define debug(x) cout << #x << ": " << x << endl
#define _forS(i, l, r) for(set<int>::iterator i = (l); i != (r); i++)
#define _rep(i, l, r) for(int i = (l); i <= (r); i++)
#define _for(i, l, r) for(int i = (l); i < (r); i++)
#define _forDown(i, l, r) for(int i = (l); i >= r; i--)
#define debug_(ch, i) printf(#ch"[%d]: %d\n", i, ch[i])
#define debug_m(mp, p) printf(#mp"[%d]: %d\n", p->first, p->second)
#define debugS(str) cout << "dbg: " << str << endl;
#define debugArr(arr, x, y) _for(i, 0, x) { _for(j, 0, y) printf("%c", arr[i][j]); printf("\n"); }
#define _forPlus(i, l, d, r) for(int i = (l); i + d < (r); i++)
#define lowbit(i) (i & (-i))

const int maxn = 100000 + 10;
int n, m;
int A[maxn];
llong sum[maxn];

void init() {
    Set(A, 0);
    Set(sum, 0);
}

class Fwick {
public:
    llong C[2][maxn];
    int n;

    void clear() {
        memset(C, 0, sizeof(C));
    }

    void resize(int n) {
        this->n = n;
    }

    llong ask(int k, int x) {
        llong ret = 0;
        while (x) {
            ret += C[k][x];
            x -= lowbit(x);
        }
        return ret;
    }

    void add(int k, int x, int d) {
        while (x <= n) {
            C[k][x] += d;
            x += lowbit(x);
        }
    }
};

Fwick fwick;

int main() {
    //freopen("input.txt", "r", stdin);
    init();

    scanf("%d%d", &n, &m);
    _rep(i, 1, n) {
        scanf("%d", &A[i]);
        sum[i] = sum[i - 1] + A[i];
    }

    fwick.clear();
    fwick.resize(n);

    _for(i, 0, m) {
        char op[2];
        scanf("%s", op);

        if(op[0] == 'C') {
            //
            int l, r, d;
            scanf("%d%d%d", &l, &r, &d);

            fwick.add(0, l, d);
            fwick.add(0, r + 1, -d);

            fwick.add(1, l, l * d);
            fwick.add(1, r + 1, -(r + 1) * d);
        }
        else {
            //
            int l, r;
            scanf("%d%d", &l, &r);
            llong ans = sum[r] + (r + 1) * fwick.ask(0, r) - fwick.ask(1, r);
            ans -= (sum[l - 1] + l * fwick.ask(0, l - 1) - fwick.ask(1, l - 1));
            printf("%lld\n", ans);
        }
    }
}

作者：心里没有一点AC数
链接：https://www.acwing.com/solution/content/4652/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 247. 亚特兰蒂斯    原题链接    困难
作者：    秦淮岸灯火阑珊 ,  2019-02-15 20:33:08 ,  阅读 1636

9


2
原题链接
更好的阅读体验

题目描述
有几个古希腊书籍中包含了对传说中的亚特兰蒂斯岛的描述。

其中一些甚至包括岛屿部分地图。

但不幸的是，这些地图描述了亚特兰蒂斯的不同区域。

您的朋友Bill必须知道地图的总面积。

你自告奋勇写了一个计算这个总面积的程序。

输入格式
输入包含多组测试用例。

对于每组测试用例，第一行包含整数n，表示总的地图数量。

接下来n行，描绘了每张地图，每行包含四个数字x1,y1,x2,y2x1,y1,x2,y2（不一定是整数）,(x1,y1)(x1,y1)和(x2,y2)(x2,y2)分别是地图的左上角位置和右下角位置。

当输入用例n=0n=0时，表示输入终止，该用例无需处理。

输出格式
每组测试用例输出两行。

第一行输出”Test case #k”，其中k是测试用例的编号，从1开始。

第二行输出“Total explored area：a”，其中a是总地图面积（即此测试用例中所有矩形的面积并，注意如果一片区域被多个地图包含，则在计算总面积时只计算一次），精确到小数点后两位数。

在每个测试用例后输出一个空行。

数据范围
1≤n≤1001≤n≤100
0≤x1<x2≤1000000≤x1<x2≤100000
0≤y1<y2≤1000000≤y1<y2≤100000
样例
输入样例：
2
10 10 20 20
15 15 25 25.5
0
输出样例：
Test case #1
Total explored area: 180.00 
线段树+扫描线+二分查找+离散化
这道题目是真的有毒还是我太菜了,各种算法大杂烩,最后还是看了五篇优秀的blog东凑西凑才理解的.为什么我要自告奋勇写这道题目,可见出题人的内心有多么友好啊......
离散化:首先坐标太大了,我们需要离散化.
二分:既然离散化了,自然就要二分找坐标了.
扫描线:题目告诉我们,需要将二维转化成为一维,所以我们需要扫描线这种变态级别神器来解答这道题目.具体来说,我们就是要取出N个矩阵的左右边界,然后从下往上或者从左往右的方向,不断地扫描,然后我们就会求出每一条扫描线在矩阵上覆盖的长度L,然后这一段面积就是L*宽度.
我觉得自己讲得不好,主要是思路也有些混乱,所以给出几位网上大佬的题解,希望能让各位不浪费点击我这条博客的流量,虽然图片很多.手动滑稽
以下为riba大佬的优秀讲解,个人觉得很好的一篇blog

现在假设我们有一根线，从下往上开始扫描
如图所示，我们可以把整个矩形分成如图各个颜色不同的小矩形，那么这个小矩形的高就是我们扫过的距离，那么剩下了一个变量，那就是矩形的长一直在变化。






我们的线段树就是为了维护矩形的长，我们给每一个矩形的上下边进行标记，下面的边标记为1，上面的边标记为-1，每遇到一个矩形时，我们知道了标记为1的边，我们就加进来这一条矩形的长，等到扫描到-1时，证明这一条边需要删除，就删去，利用1和-1可以轻松的到这种状态。
还要注意这里的线段树指的并不是线段的一个端点，而指的是一个区间，所以我们要计算的时候r+1和r-1
再提一下离散化，离散化就是把一段很大的区间映射到一个小区间内，这样会节省大量空间，要进行离散化，我们先对端点进行排序，然后去重，然后二分找值就可以了

以下为另外一位大佬的blog
这道题我一直在纠结，怎么求当前有扫描线上有的线段总长？怎么lazy下放？我一直想的是每个点维护的都是它维护的这个区间内的总的cnt等等。
后来我发现换个思路，一切都很简单！
我的每个节点t[x].l~t[x].r维护的其实是线段t[x].l~(t[x].r+1)，也就是若干条线段，因为点分成左右孩子的时候会有问题（比如[3,3]维护的到底是什么？）。
我们要把每个节点看成是一条线段。
对于每个节点维护两个值：
cnt：这个点所代表的线段被覆盖了多少次。
len：以这个点为根的子树中被覆盖的区间一共有多长。
当一条线段进来的时候，在代表它的那若干个节点上cnt++，其它节点cnt不用加。
然后len维护的就是这个区间内那些cnt>0的节点所覆盖的区间总长。
其实线段树上每个节点都可以有它的实际意义

C++ 代码
//这道题目码风有些诡异,虽然我已经尽量变成我这种通俗易懂的码风了.
#include <bits/stdc++.h>
using namespace std;
const int N=1100;
double dis[N];
struct node
{
    double x1,x2,h;
    int f;
    void init(double l2,double r2,double h2,int key)
    {
        x1=l2;
        x2=r2;
        h=h2;
        f=key;
    }
} line[N];
struct line_tree
{
    int l,r,f;
    double len;
} t[N<<2];
int cmp(node a,node b)
{
    return a.h<b.h;
}
void build(int p,int l,int r)
{
    t[p].l=l;
    t[p].r=r;
    t[p].f=0;
    t[p].len=0;
    if (l==r)
        return ;
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build((p<<1)+1,mid+1,r);
}
void get_len(int p)
{
    if (t[p].f>=1)
        t[p].len=dis[t[p].r+1]-dis[t[p].l];//这里记得+1
    else    
        t[p].len=t[p<<1].len+t[(p<<1)|1].len;
}
void change(int p,int l,int r,int v)
{
    if (t[p].l==l && r==t[p].r)
    {
        t[p].f+=v;
        get_len(p);
        return ;
    }
    int mid=(t[p].l+t[p].r)>>1;
    if (r<=mid)
        change(p<<1,l,r,v);
    else if (l>mid)
        change((p<<1)+1,l,r,v);
    else
    {
        change(p<<1,l,mid,v);
        change((p<<1)+1,mid+1,r,v);
    }
    get_len(p);
}
int find(double p,int l,int r)//诡异版二分
{
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if (dis[mid]==p)
            return mid;
        if (dis[mid]<p)
            l=mid+1;
        else
            r=mid-1;
    }
}
int main()
{
    int ts=0,n;
    while(scanf("%d",&n)!=EOF)
    {
        if (n==0)
            break;
        printf("Test case #%d\n",(++ts));
        int num=0;
        for(int i=0;i<n;i++)
        {
            double x1,x2,y1,y2;
            scanf("%lf%lf%lf%lf",&x1,&y1,&x2,&y2);
            line[num].init(x1,x2,y1,1);
            dis[num++]=x1;
            line[num].init(x1,x2,y2,-1);
            dis[num++]=x2;
        }
        sort(line,line+num,cmp);
        sort(dis,dis+num);
        int dis_num=unique(dis,dis+num)-dis;
        build(1,0,dis_num-1);
        double ans=0;
        for(int i=0;i<num-1;i++)
        {
            int line_l=find(line[i].x1,0,dis_num);
            int line_r=find(line[i].x2,0,dis_num)-1;
            change(1,line_l,line_r,line[i].f);
            ans=ans+t[1].len*(line[i+1].h-line[i].h);
        }
        printf("Total explored area: %.2lf\n\n",ans);
    }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1027/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 100010;

int n;
struct Segment
{
    double x, y1, y2;
    int k;
    bool operator< (const Segment &t)const
    {
        return x < t.x;
    }
}seg[N * 2];
struct Node
{
    int l, r;
    int cnt;
    double len;
}tr[N * 8];

vector<double> ys;

int find(double y)
{
    return lower_bound(ys.begin(), ys.end(), y) - ys.begin();
}

void pushup(int u)
{
    if (tr[u].cnt) tr[u].len = ys[tr[u].r + 1] - ys[tr[u].l];
    else if (tr[u].l != tr[u].r)
    {
        tr[u].len = tr[u << 1].len + tr[u << 1 | 1].len;
    }
    else tr[u].len = 0;
}

void build(int u, int l, int r)
{
    tr[u] = {l, r, 0, 0};
    if (l != r)
    {
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    }
}

void modify(int u, int l, int r, int k)
{
    if (tr[u].l >= l && tr[u].r <= r)
    {
        tr[u].cnt += k;
        pushup(u);
    }
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, k);
        if (r > mid) modify(u << 1 | 1, l, r, k);
        pushup(u);
    }
}

int main()
{
    int T = 1;
    while (scanf("%d", &n), n)
    {
        ys.clear();
        for (int i = 0, j = 0; i < n; i ++ )
        {
            double x1, y1, x2, y2;
            scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
            seg[j ++ ] = {x1, y1, y2, 1};
            seg[j ++ ] = {x2, y1, y2, -1};
            ys.push_back(y1), ys.push_back(y2);
        }

        sort(ys.begin(), ys.end());
        ys.erase(unique(ys.begin(), ys.end()), ys.end());

        build(1, 0, ys.size() - 2);

        sort(seg, seg + n * 2);

        double res = 0;
        for (int i = 0; i < n * 2; i ++ )
        {
            if (i > 0) res += tr[1].len * (seg[i].x - seg[i - 1].x);
            modify(1, find(seg[i].y1), find(seg[i].y2) - 1, seg[i].k);
        }

        printf("Test case #%d\n", T ++ );
        printf("Total explored area: %.2lf\n\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/167934/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1277. 维护序列    原题链接    困难
作者：    QWQjuruo ,  2019-12-15 14:27:09 ,  阅读 357

3


题目描述
老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

有长为 N 的数列，不妨设为 a1,a2,…,aN。

有如下三种操作形式：

把数列中的一段数全部乘一个值；
把数列中的一段数全部加一个值；
询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 P 的值。

样例
INPUT
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7
OUTPUT
2
35
8
算法1
(模拟) O(区间长度)O(区间长度)
不用说了吧，直接模拟乘法、加法、查询，复杂度惊人QWQ。

C++ 代码
咕咕咕
算法2
(线段树) O(log区间长度)O(log区间长度)
前置芝士：线段树
想必想切这道题的大佬都珂以爆切线段树模板了吧QWQ

这道题关键点在于线段树中的lazytaglazytag，注意该题需要让乘法优先级更高，因为如果先加会出现一些分数，分数带来的严重问题就是精度的缺失。所以这道题需要先乘后加。

下面是实现方法：
加法lazytaglazytag：与正常的线段树一样。
乘法lazytaglazytag：将原先的加法lazytaglazytag乘上需要乘的数，在将乘法lazytaglazytag乘上需要乘的数。下发lazytaglazytag时记得先下发乘法标记。

之后就是一些细节，比如说乘法lazytaglazytag初始值为0，标记的值需要模P等。

参考文献
关于线段树的介绍以及一些线段树的运用题。

C++ 代码
#include <bits/stdc++.h>
#define LL long long
using namespace std;

LL tag[400001], a[400001], num[400001], multag[400001];
LL P;

LL lc(LL p){
    return p << 1;
}

LL rc(LL p){
    return p << 1 | 1;
}

void pushup(LL p){
    num[p] = num[lc(p)] + num[rc(p)];
    num[p] %= P;
}

void build(LL p, LL l, LL r){
    multag[p] = 1;
    if (l == r){
        num[p] = a[l];
        num[p] %= P;
        return;
    }
    LL mid = (l + r) >> 1;
    build(lc(p), l, mid);
    build(rc(p), mid + 1, r);
    pushup(p);
}

void mulupd(LL p, LL l, LL r, LL x){
    multag[p] *= x;
    tag[p] *= x;
    num[p] *= x;
    num[p] %= P;
    multag[p] %= P;
    tag[p] %= P;
}

void upd(LL p, LL l, LL r, LL x){
    tag[p] += x;
    num[p] += (r - l + 1) * x;
    num[p] %= P;
    tag[p] %= P;
}

void pushdown(LL p, LL l, LL r){
    LL mid = (l + r) >> 1;
    mulupd(lc(p), l, mid, multag[p]);
    mulupd(rc(p), mid + 1, r, multag[p]);
    upd(lc(p), l, mid, tag[p]);
    upd(rc(p), mid + 1, r, tag[p]);
    multag[p] = 1;
    tag[p] = 0;
}

void change(LL L, LL R, LL l, LL r, LL p, LL x){
    if (L <= l && r <= R){
        tag[p] += x;
        num[p] += (r - l + 1) * x;
        num[p] %= P;
        tag[p] %= P;
        return;
    }
    pushdown(p, l, r);
    LL mid = (l + r) >> 1;
    if (L <= mid) change(L, R, l, mid, lc(p), x);
    if (R >= mid + 1) change(L, R, mid + 1, r, rc(p), x);
    pushup(p);
}

void mulchange(LL L, LL R, LL l, LL r, LL p, LL x){
    if (L <= l && r <= R){
        tag[p] *= x;
        multag[p] *= x;
        num[p] *= x;
        num[p] %= P;
        multag[p] %= P;
        tag[p] %= P;
        return;
    }
    pushdown(p, l, r);
    LL mid = (l + r) >> 1;
    if (L <= mid) mulchange(L, R, l, mid, lc(p), x);
    if (R >= mid + 1) mulchange(L, R, mid + 1, r, rc(p), x);
    pushup(p);
}

LL Q(LL L, LL R, LL l, LL r, LL p){
    if (L <= l && r <= R){
        return num[p] % P;
    }
    LL ans = 0;
    pushdown(p, l, r);
    LL mid = (l + r) >> 1;
    if (L <= mid) ans += Q(L, R, l, mid, lc(p));
    ans %= P;
    if (R >= mid + 1) ans += Q(L, R, mid + 1, r, rc(p));
    ans %= P;
    return ans;
}

int main(){
    LL n, m;
    cin >> n >> P;
    for (LL i = 1; i <= n; i++){
        scanf("%lld", &a[i]);
    }
    cin >> m; 
    build(1, 1, n);
    for (LL i = 1; i <= m; i++){
        LL type;
        scanf("%lld", &type);
        if (type == 1){
            LL l, r, x;
            scanf("%lld%lld%lld", &l, &r, &x);
            mulchange(l, r, 1, n, 1, x);
        }
        else if (type == 2){
            LL l, r, x;
            scanf("%lld%lld%lld", &l, &r, &x);
            change(l, r, 1, n, 1, x);
        }
        else{
            LL l, r;
            scanf("%lld%lld", &l, &r);
            printf("%lld\n", Q(l, r, 1, n, 1) % P);
        }
    }
    return 0;
} 

作者：QWQjuruo
链接：https://www.acwing.com/solution/content/7040/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int n, p, m;
int w[N];
struct Node
{
    int l, r;
    int sum, add, mul;
}tr[N * 4];

void pushup(int u)
{
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p;
}

void eval(Node &t, int add, int mul)
{
    t.sum = ((LL)t.sum * mul + (LL)(t.r - t.l + 1) * add) % p;
    t.mul = (LL)t.mul * mul % p;
    t.add = ((LL)t.add * mul + add) % p;
}

void pushdown(int u)
{
    eval(tr[u << 1], tr[u].add, tr[u].mul);
    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul);
    tr[u].add = 0, tr[u].mul = 1;
}

void build(int u, int l, int r)
{
    if (l == r) tr[u] = {l, r, w[r], 0, 1};
    else
    {
        tr[u] = {l, r, 0, 0, 1};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void modify(int u, int l, int r, int add, int mul)
{
    if (tr[u].l >= l && tr[u].r <= r) eval(tr[u], add, mul);
    else
    {
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, add, mul);
        if (r > mid) modify(u << 1 | 1, l, r, add, mul);
        pushup(u);
    }
}

int query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u].sum;

    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    int sum = 0;
    if (l <= mid) sum = query(u << 1, l, r);
    if (r > mid) sum = (sum + query(u << 1 | 1, l, r)) % p;
    return sum;
}

int main()
{
    scanf("%d%d", &n, &p);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    build(1, 1, n);

    scanf("%d", &m);
    while (m -- )
    {
        int t, l, r, d;
        scanf("%d%d%d", &t, &l, &r);
        if (t == 1)
        {
            scanf("%d", &d);
            modify(1, l, r, 0, d);
        }
        else if (t == 2)
        {
            scanf("%d", &d);
            modify(1, l, r, d, 1);
        }
        else printf("%d\n", query(1, l, r));
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/167944/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 256. 最大异或和    原题链接    中等
作者：    福如东海 ,  2020-01-01 02:49:54 ,  阅读 719

12


1
题目描述
给定一个非负整数序列 a，初始长度为 N。

有 M 个操作，有以下两种操作类型：

1、”A x”：添加操作，表示在序列末尾添加一个数 x，序列的长度 N 增大1。
2、”Q l r x”：询问操作，你需要找到一个位置 p，满足l≤p≤r，使得：a[p] xor a[p+1] xor … xor a[N] xor x 最大，输出这个最大值。

输入格式
第一行包含两个整数 N，M，含义如问题描述所示。

第二行包含 N 个非负整数，表示初始的序列 A。

接下来 M 行，每行描述一个操作，格式如题面所述。

输出格式
每个询问操作输出一个整数，表示询问的答案。

每个答案占一行。

数据范围
N,M≤3∗105,0≤a[i]≤107。

样例
输入样例：
5 5
2 6 4 3 6
A 1 
Q 3 5 4 
A 4 
Q 5 7 0 
Q 3 6 6 
输出样例：
4
5
6
算法1
(持久化01trie) O(nlogn)O(nlogn)
问题分析：
令s[i] = a[1] ^ a[2] ^ … a[i-1] ^ a[i]
则a[p] xor a[p+1] xor … xor a[N] xor x 相当于 s[N] ^ x ^ s[p-1]
S[N] ^ x 每次可以看成一个固定值 v提前算出来, 则相当于 求 l-1 <= p-1 <= r-1 使得 v 与 s[p-1]异或最大

做法：
s[p-1]的二进制最高位开始到最低位的每一个数字尽量与v的二进制对应位相反就可以保证异或出来最大。
s的每个版本可以看成是持久化的trie记录下来。
对持久化trie的每个节点额外维护一个信息version，表示其所属的持久化版本，显然一个节点的version等于其子节点中最大的版本号（因为子节点要么是连向之前的版本，要么创建了该节点后再创建子节点）。 如果一个节点的version 小于l-1，说明这个节点是s[l-1]插入之前就已经创建出来的节点，不应该考虑在内。

性质：
对持久化树的某一个版本的根节点开始往下访问，所能访问到的节点的版本不会超过该根节点的版本,所以该题只需要从r-1版本开始访问即可

注意点：
查询时，节点不空才能转移

时间复杂度
参考文献
C++ 代码
#include <iostream>
using namespace std;
const int N = 6e5 + 5;

int n, m, s[N], idx;

int trie[24 * N][2], version[24 * N];
int root[N];

void insert(int i, int p, int q, int k) {
    if (k < 0) {
        version[q] = i;
        return;
    }
    int c = s[i] >> k & 1; //最右侧为第0位，取出第k位
    if (p) trie[q][c ^ 1] = trie[p][c ^ 1];
    trie[q][c] = ++idx;
    insert(i, trie[p][c], trie[q][c], k - 1);
    version[q] = max(version[trie[q][c]], version[trie[q][c ^ 1]]);
}


int query(int root, int k, int pivot, int limit) {
    int q = root;
    for (int i = k; i >= 0; i--) {
        int c = pivot >> i & 1;
        int b = trie[q][c ^ 1];
        if  (b && version[b] >= limit) q = trie[q][c ^ 1];//节点不空，版本 >= limit才能转移
        else  q = trie[q][c];
    }
    return s[version[q]] ^ pivot;
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        int a;
        cin >> a;
        s[i] = s[i-1] ^ a;
        root[i] = ++idx; //每次为新版本的trie新建根节点
        insert(i, root[i-1], root[i], 23);
    }
    while (m--){
        char op; 
        int l, r, x;
        cin >> op;
        if (op == 'Q') {
            cin >> l >> r >> x;
            printf("%d\n", query(root[r-1], 23, s[n] ^ x, l-1));
        } else {
            cin >> x;
            root[++n] = ++idx;
            s[n] = s[n-1] ^ x;
            insert(n, root[n-1], root[n], 23);
        }
    }
    return 0;
}

作者：福如东海
链接：https://www.acwing.com/solution/content/7314/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 600010, M = N * 25;

int n, m;
int s[N];
int tr[M][2], max_id[M];
int root[N], idx;

void insert(int i, int k, int p, int q)
{
    if (k < 0)
    {
        max_id[q] = i;
        return;
    }
    int v = s[i] >> k & 1;
    if (p) tr[q][v ^ 1] = tr[p][v ^ 1];
    tr[q][v] = ++ idx;
    insert(i, k - 1, tr[p][v], tr[q][v]);
    max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]);
}

int query(int root, int C, int L)
{
    int p = root;
    for (int i = 23; i >= 0; i -- )
    {
        int v = C >> i & 1;
        if (max_id[tr[p][v ^ 1]] >= L) p = tr[p][v ^ 1];
        else p = tr[p][v];
    }

    return C ^ s[max_id[p]];
}

int main()
{
    scanf("%d%d", &n, &m);

    max_id[0] = -1;
    root[0] = ++ idx;
    insert(0, 23, 0, root[0]);

    for (int i = 1; i <= n; i ++ )
    {
        int x;
        scanf("%d", &x);
        s[i] = s[i - 1] ^ x;
        root[i] = ++ idx;
        insert(i, 23, root[i - 1], root[i]);
    }

    char op[2];
    int l, r, x;
    while (m -- )
    {
        scanf("%s", op);
        if (*op == 'A')
        {
            scanf("%d", &x);
            n ++ ;
            s[n] = s[n - 1] ^ x;
            root[n] = ++ idx;
            insert(n, 23, root[n - 1], root[n]);
        }
        else
        {
            scanf("%d%d%d", &l, &r, &x);
            printf("%d\n", query(root[r - 1], s[n] ^ x, l - 1));
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/168518/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <iostream>
using namespace std;
const int N = 600005, L = 24;
int n, m, s[N], trie[N * L][2];
int w[N * L], rt[N], tot; 
void insert(int i, int k, int p, int q) {
    if(k < 0) {
        w[q] = i;
        return;
    }
    int c = s[i] >> k & 1;
    if(p) trie[q][c ^ 1] = trie[p][c ^ 1];
    trie[q][c] = ++tot;
    insert(i, k - 1, trie[p][c], trie[q][c]);
    w[q] = max(w[trie[q][0]], w[trie[q][1]]);
}
int ask(int p, int val, int k, int limit) {
    if(k < 0) return val ^ s[w[p]];
    int c = val >> k & 1;
    return ask( trie[p][ w[trie[p][c ^ 1]] >= limit ? c ^ 1 : c ] , val, k - 1, limit);
}
int main() {
    scanf("%d%d", &n, &m);
    w[0] = -1; 
    insert(0, L - 1, 0, rt[0] = ++tot);
    for (int i = 1, x; i <= n; i++) {
        scanf("%d", &x); s[i] = s[i - 1] ^ x;
        insert(i, L - 1, rt[i - 1], rt[i] = ++tot);
    }
    for (int i = 1; i <= m; i++) {
        char op[2]; scanf("%s", op);
        if(op[0] == 'A') {
            int x; scanf("%d", &x);
            rt[++n] = ++tot;
            s[n] = s[n - 1] ^ x;
            insert(n, L - 1, rt[n - 1], rt[n]);
        } else {
            int l, r, x; scanf("%d%d%d", &l, &r, &x);
            printf("%d\n", ask(rt[r - 1], x ^ s[n], L - 1, l - 1));
        }
    }
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/168504/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 255. 第K个数 可持久化线段树（主席树）算法    原题链接    简单
作者：    墨染空 ,  2019-08-29 16:53:20 ,  阅读 885

9


1
指路学习笔记：可持久化线段树（主席树）：静态 + 动态

先考虑如何求总序列第kk小
我们可以建立一颗权值线段树，每个点存储的信息为该值域区间存在的数的个数。



因为线段树的性质，所以每个点的左子树的值域区间 <=<= 右子树的值域区间。

所以我们先看左子树区间有多少个数，记为cntleftcntleft。

如果ki<=cntleftki<=cntleft，说明第kiki小的数一定在左子树的值域内，所以问题便转换为了“在左子树的值域内找第kiki小的数”。
否则，说明第kiki小的数一定在左子树的值域内，考虑到左子树已经有cntleftcntleft个最小的数，问题便转换为了“在右子树的值域内找第ki−cntleftki−cntleft小的数”
问题转换到任意区间
我们要用[li,ri][li,ri] 区间的数建立权值线段树。

我们发现可以用前缀和来维护：

只要用预处理大法分别以[1,li][1,li]和[1,ri][1,ri]的数建立权值线段树，每个点的值对位相减即可。

关键性质
发现以[1,x][1,x]和[1,x+1][1,x+1]区间内的数所建立的权值线段树的差异仅在一条链上：（A[x+1]A[x+1]的次数+1+1）。

也就是不超过log2nlog2n个点。我们可以考虑动态开点：

与上一个权值线段树没有差异的地方直接指引过去
有差异，单独新增一个点
这样即可预处理出[1,x](1<=x<=n)[1,x](1<=x<=n)所有的权值线段树了。

时间复杂度O(nlog2n)O(nlog2n)，空间复杂度O(2n+nlog2n)O(2n+nlog2n)。

注意：由于值域很大，我们需要离散化一下。

参考代码：
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100005;
//d 为离散化数组
int n, m, len, a[N], d[N];

//T[i] 为 [1, i] 区间的权值线段树的根节点
int T[N], tot = 0;

//线段树的每个点
struct SegTree{
    int l, r, v;
}t[N * 20];

//建树
int build(int l, int r){
    int p = ++tot, mid = (l + r) >> 1;
    if(l < r) {
        t[p].l = build(l, mid);
        t[p].r = build(mid + 1, r);
    }
    t[p].v = 0; return p;
}

//增加一个数 pre 为上一个的根节点。
int update(int pre, int l, int r, int v){
    int p = ++tot, mid = (l + r) >> 1;
    t[p].l = t[pre].l, t[p].r = t[pre].r, t[p].v = t[pre].v + 1;
    if(l < r){
        //应该更新哪一个值域区间
        if(v <= mid) t[p].l = update(t[pre].l, l, mid, v);
        else t[p].r = update(t[pre].r, mid + 1, r, v); 
    }
    return p;
}

//查询
int query(int x, int y, int l, int r, int k){
    //找到了
    if(l == r) return l;
    //对位相减
    int sum = t[t[y].l].v - t[t[x].l].v, mid = (l + r) >> 1;
    if(k <= sum) return query(t[x].l, t[y].l, l, mid, k);
    else return query(t[x].r, t[y].r, mid + 1, r, k - sum);
}

int main(){
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d", a + i), d[i] = a[i];
    //离散化
    sort(d + 1, d + 1 + n);
    len = unique(d + 1, d + 1 + n) - (d + 1);
    for(int i = 1; i <= n; i++) 
        a[i] = lower_bound(d + 1, d + 1 + len, a[i]) - d;


    T[0] = build(1, len);
    for(int i = 1; i <= n; i++)
        T[i] = update(T[i - 1], 1, len, a[i]);

    //回答
    while(m--){
        int l, r, k; scanf("%d%d%d", &l, &r, &k);
        int ans = query(T[l - 1], T[r], 1, len, k);
        printf("%d\n", d[ans]);
    }
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/solution/content/4224/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 100010, M = 10010;

int n, m;
int a[N];
vector<int> nums;

struct Node
{
    int l, r;
    int cnt;
}tr[N * 4 + N * 17];

int root[N], idx;

int find(int x)
{
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
}

int build(int l, int r)
{
    int p = ++ idx;
    if (l == r) return p;
    int mid = l + r >> 1;
    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);
    return p;
}

int insert(int p, int l, int r, int x)
{
    int q = ++ idx;
    tr[q] = tr[p];
    if (l == r)
    {
        tr[q].cnt ++ ;
        return q;
    }
    int mid = l + r >> 1;
    if (x <= mid) tr[q].l = insert(tr[p].l, l, mid, x);
    else tr[q].r = insert(tr[p].r, mid + 1, r, x);
    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;
    return q;
}

int query(int q, int p, int l, int r, int k)
{
    if (l == r) return r;
    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int mid = l + r >> 1;
    if (k <= cnt) return query(tr[q].l, tr[p].l, l, mid, k);
    else return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt);
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ )
    {
        scanf("%d", &a[i]);
        nums.push_back(a[i]);
    }

    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());

    root[0] = build(0, nums.size() - 1);

    for (int i = 1; i <= n; i ++ )
        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]));

    while (m -- )
    {
        int l, r, k;
        scanf("%d%d%d", &l, &r, &k);
        printf("%d\n", nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)]);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/168534/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



AcWing 253. 普通平衡树    原题链接    中等
作者：    秦淮岸灯火阑珊 ,  2019-02-23 06:57:47 ,  阅读 791

6


4
题目描述
您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：

插入数值x。
删除数值x(若有多个相同的数，应只删除一个)。
查询数值x的排名(若有多个相同的数，应输出最小的排名)。
查询排名为x的数值。
求数值x的前驱(前驱定义为小于x的最大的数)。
求数值x的后继(后继定义为大于x的最小的数)。
输入格式
第一行为n，表示操作的个数。
接下来n行每行有两个数opt和x，opt表示操作的序号(1<=opt<=6)。

输出格式
对于操作3,4,5,6每行输出一个数，表示对应答案。

数据范围
n≤100000n≤100000,所有数均在−107−107到107107内。

样例
输入样例：
8
1 10
1 20
1 30
3 20
4 2
2 10
5 25
6 -1
输出样例：
2
20
20
20
Splay树
Splay树
Vector+STL二分精简代码

#include <bits/stdc++.h>
using namespace std;
vector<int> a;
int n,opt,x;
int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    while(n--)
    {
        cin>>opt>>x;
        if (opt==1)
            a.insert(upper_bound(a.begin(),a.end(),x),x);
        if (opt==2)
            a.erase(lower_bound(a.begin(),a.end(),x));
        if (opt==3)
            cout<<lower_bound(a.begin(),a.end(),x)-a.begin()+1<<endl;
        if (opt==4)
            cout<<a[x-1]<<endl;
        if (opt==5)
            cout<<*--lower_bound(a.begin(),a.end(),x)<<endl;
        if (opt==6)
            cout<<*upper_bound(a.begin(),a.end(),x)<<endl;
    }
}
以下为Splay代码
C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N=201000;
struct splay_tree
{
    int ff,cnt,ch[2],val,size;
} t[N];
int root,tot;
void update(int x)
{
    t[x].size=t[t[x].ch[0]].size+t[t[x].ch[1]].size+t[x].cnt;
}
void rotate(int x)
{
    int y=t[x].ff;
    int z=t[y].ff;
    int k=(t[y].ch[1]==x);
    t[z].ch[(t[z].ch[1]==y)]=x;
    t[x].ff=z;
    t[y].ch[k]=t[x].ch[k^1];
    t[t[x].ch[k^1]].ff=y;
    t[x].ch[k^1]=y;
    t[y].ff=x;
    update(y);update(x);
}
void splay(int x,int s)
{
    while(t[x].ff!=s)
    {
        int y=t[x].ff,z=t[y].ff;
        if (z!=s)
            (t[z].ch[0]==y)^(t[y].ch[0]==x)?rotate(x):rotate(y);
        rotate(x);
    }
    if (s==0)
        root=x;
}
void find(int x)
{
    int u=root;
    if (!u)
        return ;
    while(t[u].ch[x>t[u].val] && x!=t[u].val)
        u=t[u].ch[x>t[u].val];
    splay(u,0);
}
void insert(int x)
{
    int u=root,ff=0;
    while(u && t[u].val!=x)
    {
        ff=u;
        u=t[u].ch[x>t[u].val];
    }
    if (u)
        t[u].cnt++;
    else
    {
        u=++tot;
        if (ff)
            t[ff].ch[x>t[ff].val]=u;
        t[u].ch[0]=t[u].ch[1]=0;
        t[tot].ff=ff;
        t[tot].val=x;
        t[tot].cnt=1;
        t[tot].size=1;
    }
    splay(u,0);
}
int Next(int x,int f)
{
    find(x);
    int u=root;
    if (t[u].val>x && f)
        return u;
    if (t[u].val<x && !f)
        return u;
    u=t[u].ch[f];
    while(t[u].ch[f^1])
        u=t[u].ch[f^1];
    return u;
}
void Delete(int x)
{
    int last=Next(x,0);
    int Net=Next(x,1);
    splay(last,0);
    splay(Net,last);
    int del=t[Net].ch[0];
    if (t[del].cnt>1)
    {
        t[del].cnt--;
        splay(del,0);
    }
    else
        t[Net].ch[0]=0;
}
int kth(int x)
{
    int u=root;
    while(t[u].size<x)
        return 0;
    while(1)
    {
        int y=t[u].ch[0];
        if (x>t[y].size+t[u].cnt)
        {
            x-=t[y].size+t[u].cnt;
            u=t[u].ch[1];
        }
        else if (t[y].size>=x)
            u=y;
        else
            return t[u].val;
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    insert(1e9);
    insert(-1e9);
    while(n--)
    {
        int opt,x;
        scanf("%d%d",&opt,&x);
        if (opt==1)
            insert(x);
        if (opt==2)
            Delete(x);
        if (opt==3)
        {
            find(x);
            printf("%d\n",t[t[root].ch[0]].size);
        }
        if (opt==4)
            printf("%d\n",kth(x+1));
        if (opt==5)
            printf("%d\n",t[Next(x,0)].val);
        if (opt==6)
            printf("%d\n",t[Next(x,1)].val);
    }
    return 0;
}
/*
插入数值x。
删除数值x(若有多个相同的数，应只删除一个)。
查询数值x的排名(若有多个相同的数，应输出最小的排名)。
查询排名为x的数值。
求数值x的前驱(前驱定义为小于x的最大的数)。
求数值x的后继(后继定义为大于x的最小的数)。
*/

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1055/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, INF = 1e8;

int n;
struct Node
{
    int l, r;
    int key, val;
    int cnt, size;
}tr[N];

int root, idx;

void pushup(int p)
{
    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;
}

int get_node(int key)
{
    tr[ ++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1;
    return idx;
}

void zig(int &p)    // 右旋
{
    int q = tr[p].l;
    tr[p].l = tr[q].r, tr[q].r = p, p = q;
    pushup(tr[p].r), pushup(p);
}

void zag(int &p)    // 左旋
{
    int q = tr[p].r;
    tr[p].r = tr[q].l, tr[q].l = p, p = q;
    pushup(tr[p].l), pushup(p);
}

void build()
{
    get_node(-INF), get_node(INF);
    root = 1, tr[1].r = 2;
    pushup(root);

    if (tr[1].val < tr[2].val) zag(root);
}


void insert(int &p, int key)
{
    if (!p) p = get_node(key);
    else if (tr[p].key == key) tr[p].cnt ++ ;
    else if (tr[p].key > key)
    {
        insert(tr[p].l, key);
        if (tr[tr[p].l].val > tr[p].val) zig(p);
    }
    else
    {
        insert(tr[p].r, key);
        if (tr[tr[p].r].val > tr[p].val) zag(p);
    }
    pushup(p);
}

void remove(int &p, int key)
{
    if (!p) return;
    if (tr[p].key == key)
    {
        if (tr[p].cnt > 1) tr[p].cnt -- ;
        else if (tr[p].l || tr[p].r)
        {
            if (!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val)
            {
                zig(p);
                remove(tr[p].r, key);
            }
            else
            {
                zag(p);
                remove(tr[p].l, key);
            }
        }
        else p = 0;
    }
    else if (tr[p].key > key) remove(tr[p].l, key);
    else remove(tr[p].r, key);

    pushup(p);
}

int get_rank_by_key(int p, int key)    // 通过数值找排名
{
    if (!p) return 0;   // 本题中不会发生此情况
    if (tr[p].key == key) return tr[tr[p].l].size + 1;
    if (tr[p].key > key) return get_rank_by_key(tr[p].l, key);
    return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key);
}

int get_key_by_rank(int p, int rank)   // 通过排名找数值
{
    if (!p) return INF;     // 本题中不会发生此情况
    if (tr[tr[p].l].size >= rank) return get_key_by_rank(tr[p].l, rank);
    if (tr[tr[p].l].size + tr[p].cnt >= rank) return tr[p].key;
    return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);
}

int get_prev(int p, int key)   // 找到严格小于key的最大数
{
    if (!p) return -INF;
    if (tr[p].key >= key) return get_prev(tr[p].l, key);
    return max(tr[p].key, get_prev(tr[p].r, key));
}

int get_next(int p, int key)    // 找到严格大于key的最小数
{
    if (!p) return INF;
    if (tr[p].key <= key) return get_next(tr[p].r, key);
    return min(tr[p].key, get_next(tr[p].l, key));
}

int main()
{
    build();

    scanf("%d", &n);
    while (n -- )
    {
        int opt, x;
        scanf("%d%d", &opt, &x);
        if (opt == 1) insert(root, x);
        else if (opt == 2) remove(root, x);
        else if (opt == 3) printf("%d\n", get_rank_by_key(root, x) - 1);
        else if (opt == 4) printf("%d\n", get_key_by_rank(root, x + 1));
        else if (opt == 5) printf("%d\n", get_prev(root, x));
        else printf("%d\n", get_next(root, x));
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/168876/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


树 状 数 组

#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
const int N = 100005;
int opt[N], val[N], d[N], tot = 0, c[N], L;
void inline add(int x, int k) {
    for (; x <= tot; x += x & -x) c[x] += k;
}
int inline ask(int x) {
    int res = 0;
    for (; x; x -= x & -x) res += c[x];
    return res;
}
int inline kth(int x) {
    int s = 0;
    for (int i = L; ~i; i--)
        if((s | (1 << i)) < tot && c[s | (1 << i)] < x) s |= (1 << i), x -= c[s];
    return s + 1;
}
int main() {
    int T; scanf("%d", &T);
    for (int i = 1; i <= T; i++) {
        scanf("%d%d", opt + i, val + i);
        d[++tot] = val[i];
    }
    sort(d + 1, d + 1 + tot);
    tot = unique(d + 1, d + 1 + tot) - d - 1;
    L = log2(tot);
    for (int i = 1; i <= T; i++) {
        int x = lower_bound(d + 1, d + 1 + tot, val[i]) - d, op = opt[i];
        if(op == 1) add(x, 1);
        else if(op == 2) add(x, -1);
        else if(op == 3) printf("%d\n", ask(x - 1) + 1);
        else if(op == 4) printf("%d\n", d[kth(val[i])]);
        else if(op == 5) printf("%d\n", d[kth(ask(x - 1))]);
        else if(op == 6) printf("%d\n", d[kth(ask(x) + 1)]);
    }
    return 0;
}
Treap

#include <cstdio>
#include <iostream>
using namespace std;
const int N = 100010, INF = 1e8;

int n;
struct Node{
    int l, r, key, val, cnt, sz;
} t[N];

int rt, idx;

int getNode(int key) {
    t[++idx].key = key;
    t[idx].val = rand();
    t[idx].cnt = t[idx].sz = 1; 
    return idx;
}

void pushup(int p) {
    t[p].sz = t[t[p].l].sz + t[t[p].r].sz + t[p].cnt;
}

//初始化
void build() {
    getNode(-INF), getNode(INF);
    rt = 1, t[1].r = 2;
    pushup(rt);
}


//右旋
void zig(int &p) {
    int q = t[p].l;
    t[p].l = t[q].r, t[q].r = p;
    p = q;
    pushup(t[p].r); pushup(p);
}


// 左旋
void zag(int &p) {
    int q = t[p].r;
    t[p].r = t[q].l, t[q].l = p;
    p = q;
    pushup(t[p].l); pushup(p);
}

// 插入一个值 = key 的数
void insert(int &p, int key) {
    if(!p) p = getNode(key);
    else if(t[p].key == key) t[p].cnt++;
    else if(key < t[p].key) {
        insert(t[p].l, key);
        if(t[t[p].l].val > t[p].val) zig(p);
    } else {
        insert(t[p].r, key);
        if(t[t[p].r].val > t[p].val) zag(p);
    }
    pushup(p);
}

// 删除值为key
void del(int &p, int key) {
    if(!p) return;
    if(t[p].key == key) {
        if(t[p].cnt > 1) t[p].cnt--;
        else if(t[p].l || t[p].r) {
            if(!t[p].r || t[t[p].l].val > t[t[p].r].val) 
                zig(p), del(t[p].r, key);
            else zag(p), del(t[p].l, key);
        } else p = 0;
    } else if(key < t[p].key) del(t[p].l, key);
    else del(t[p].r, key); 
    pushup(p);
}


// 找值对应的排名
int getRank(int p, int key) {
    if (!p) return 0;
    if(t[p].key == key) return t[t[p].l].sz + 1;
    else if (key < t[p].key) return getRank(t[p].l, key);
    else return t[t[p].l].sz + t[p].cnt + getRank(t[p].r, key);
 }


// 通过排名找数值
int kth(int p, int rank) {
    if (!p) return INF;
    if(rank <= t[t[p].l].sz) return kth(t[p].l, rank);
    else if(rank <= t[t[p].l].sz + t[p].cnt) return t[p].key;
    else return kth(t[p].r, rank - t[t[p].l].sz - t[p].cnt);
}

// 找到 < key 的最大数
int pre(int p, int key) {
    if(!p) return -INF;
    if(key <= t[p].key) return pre(t[p].l, key);
    return max(t[p].key, pre(t[p].r, key));
}

// 找到 > key 的最小数
int nxt(int p, int key) {
    if(!p) return INF;
    if(key >= t[p].key) return nxt(t[p].r, key);
    return min(t[p].key, nxt(t[p].l, key));
}

int main() {
    build();
    scanf("%d", &n);
    while(n--) {
        int opt, x; scanf("%d%d", &opt, &x);
        if(opt == 1) insert(rt, x);
        else if(opt == 2) del(rt, x);
        else if(opt == 3) printf("%d\n", getRank(rt, x) - 1);
        else if(opt == 4) printf("%d\n", kth(rt, x + 1));
        else if(opt == 5) printf("%d\n", pre(rt, x));
        else if(opt == 6) printf("%d\n", nxt(rt, x));
    }
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/168849/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

聚聚，在哪看替罪羊树和fhq树？
滑稽_ωﾉ   2个月前     回复
b站~搜平衡树应该可以搜到


cWing 253. 普通平衡树
作者：    滑稽_ωﾉ ,  2020-02-10 16:27:39 ,  阅读 48

2


Treap
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdlib>

using namespace std;

const int N = 100010, INF = 0x3f3f3f3f;

struct Node{
    int l, r;
    int key, val;
    int cnt, size;
}tr[N];

int root, idx;

void pushup(int p)
{
    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;
}

int get_node(int key)
{
    tr[ ++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1;
    return idx;
}

void build()
{
    root = get_node(-INF);
    tr[root].r = get_node(INF);
    pushup(root);
}

void zig(int &p)        //  右旋
{
    int q = tr[p].l;
    tr[p].l = tr[q].r,  tr[q].r = p,  p = q;
    pushup(tr[p].r),  pushup(p);
}

void zag(int &p)        //  左旋
{
    int q = tr[p].r;
    tr[p].r = tr[q].l,  tr[q].l = p,  p = q;
    pushup(tr[p].l),  pushup(p);
}

void insert(int &p, int key)
{
    if(!p)  p = get_node(key);
    else if(key == tr[p].key)  tr[p].cnt ++;
    else if(key < tr[p].key)
    {
        insert(tr[p].l, key);
        if(tr[tr[p].l].val > tr[p].val)  zig(p);
    }else{
        insert(tr[p].r, key);
        if(tr[tr[p].r].val > tr[p].val)  zag(p);
    }
    pushup(p);
}

void dele(int &p, int key)
{
    if(!p)  return;
    if(key == tr[p].key)
    {
        if(tr[p].cnt > 1)  tr[p].cnt --;
        else if(tr[p].l || tr[p].r)
        {
            if(!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val)
            {
                zig(p);
                dele(tr[p].r, key);
            }else{
                zag(p);
                dele(tr[p].l, key);
            }
        }else
            p = 0;
    }else if(key < tr[p].key)  dele(tr[p].l, key);
    else  dele(tr[p].r, key);
    pushup(p);
}

int get_rank(int &p, int key)
{
    if(!p)  return -1;      //  要找的值不存在
    if(key == tr[p].key)  return tr[tr[p].l].size + 1;
    if(key < tr[p].key)  return get_rank(tr[p].l, key);
    else  return tr[tr[p].l].size + tr[p].cnt + get_rank(tr[p].r, key);
}

int get_key(int &p, int rank)
{
    if(!p)  return INF;     //  要找的排名不存在
    if(rank <= tr[tr[p].l].size)  return get_key(tr[p].l, rank);
    if(rank <= tr[tr[p].l].size + tr[p].cnt)  return tr[p].key;
    return  get_key(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);
}

int get_prev(int p, int key)       //  返回严格小于key的最大数
{
    if(!p)  return -INF;
    if(key <= tr[p].key)  return get_prev(tr[p].l, key);
    return max(tr[p].key, get_prev(tr[p].r, key));
}

int get_next(int &p, int key)       //  返回严格大于key的最小数
{
    if(!p)  return INF;
    if(key >= tr[p].key)  return get_next(tr[p].r, key);
    return min(tr[p].key, get_next(tr[p].l, key));
}

int main()
{
    build();

    int n;
    scanf("%d", &n);
    while(n --)
    {
        int t, x;
        scanf("%d%d", &t, &x);
        if(t == 1)  insert(root, x);
        else if(t == 2)  dele(root, x);
        else if(t == 3)  printf("%d\n", get_rank(root, x) - 1);
        else if(t == 4)  printf("%d\n", get_key(root, x + 1));
        else if(t == 5)  printf("%d\n", get_prev(root, x));
        else  printf("%d\n", get_next(root, x));
    }
    return 0;
}
fhq-Treap
#include<cstdio>
#include<cstdlib>

using namespace std;

const int N = 100010;

struct Node{
    int l, r;
    int val, key;
    int size;
}tr[N];

int root, idx;

int get_node(int val)
{
    int u = ++ idx;
    tr[u].val = val;
    tr[u].key = rand();
    tr[u].size = 1;
    return u;
}

void update(int u)
{
    tr[u].size = tr[tr[u].l].size + tr[tr[u].r].size + 1;
}

//  对于以u为根的子树按val值分裂，x和y返回分裂的两棵子树的根
void split(int u, int val, int &x, int &y)
{
    if(!u)  x = y = 0;
    else
    {
        if(tr[u].val <= val)
        {
            x = u;
            split(tr[u].r, val, tr[u].r, y);
        }
        else
        {
            y = u;
            split(tr[u].l, val, x, tr[u].l);
        }
        update(u);
    }
}

int merge(int x, int y)
{
    if(!x or !y)  return x + y;     //  如果一个不存在，返回另一个
    if(tr[x].key < tr[y].key)
    {
        tr[x].r = merge(tr[x].r, y);
        update(x);
        return x;
    }
    else
    {
        tr[y].l = merge(x, tr[y].l);
        update(y);
        return y;
    }
}

int x, y, z;
void insert(int val)
{
    split(root, val, x, y);
    root = merge(merge(x, get_node(val)), y);
}

void dele(int val)
{
    split(root, val, x, y);
    split(x, val - 1, x, z);        //  以z为根的子树的所有值都等于val
    z = merge(tr[z].l, tr[z].r);
    root = merge(merge(x, z), y);
}

int get_rank(int val)
{
    split(root, val - 1, x, y);
    int res = tr[x].size + 1;
    root = merge(x, y);
    return res;
}

int get_val(int rank)
{
    int u = root;
    while(u)
    {
        if(tr[tr[u].l].size + 1 == rank)  break;
        else if(tr[tr[u].l].size >= rank)  u = tr[u].l;
        else
        {
            rank -= tr[tr[u].l].size + 1;
            u = tr[u].r;
        }
    }
    return tr[u].val;
}

int get_prev(int val)
{
    split(root, val - 1, x, y);
    int u = x;
    while(tr[u].r)  u = tr[u].r;
    root = merge(x, y);
    return tr[u].val;
}

int get_next(int val)
{
    split(root, val, x, y);
    int u = y;
    while(tr[u].l)  u = tr[u].l;
    root = merge(x, y);
    return tr[u].val;
}

int main()
{
    int m;
    scanf("%d", &m);
    while(m --)
    {
        int op, x;
        scanf("%d%d", &op, &x);
        if(op == 1)  insert(x);
        else if(op == 2)  dele(x);
        else if(op == 3)  printf("%d\n", get_rank(x));
        else if(op == 4)  printf("%d\n", get_val(x));
        else if(op == 5)  printf("%d\n", get_prev(x));
        else  printf("%d\n", get_next(x));
    }
    return 0;
}
替罪羊树
#include<cstdio>
#include<vector>

using namespace std;

const int N = 100010;
const double alpha = 0.75;

struct Node{
    int l, r;
    int val;
    int size, fact;
    bool exist;
}tr[N];

int root, idx;

bool imbalance(int u)           //  不平衡
{
    if(max(tr[tr[u].l].size, tr[tr[u].r].size) > tr[u].size * alpha
        or tr[u].size - tr[u].fact > tr[u].size * 0.3)
            return true;
    return false;
}

vector<int> v;
void dfs(int u)                 //  中序遍历
{
    if(!u)  return;
    dfs(tr[u].l);
    if(tr[u].exist)  v.push_back(u);
    dfs(tr[u].r);
}

void lift(int &u, int l, int r) //  把vector重构成二叉树
{
    if(l == r)
    {
        u = v[l];
        tr[u].l = tr[u].r = 0;
        tr[u].size = tr[u].fact = 1;
        return;
    }
    int mid = l + r >> 1;
    while(l < mid and tr[v[mid - 1]].val == tr[v[mid]].val)  mid --;
    u = v[mid];
    if(l < mid)  lift(tr[u].l, l, mid - 1);
    else  tr[u].l = 0;
    lift(tr[u].r, mid + 1, r);

    tr[u].size = tr[u].fact = r - l + 1;
}

void rebuild(int &u)            //  重构
{
    v.clear();
    dfs(u);
    if(!v.size())
    {
        u = 0;
        return;
    }
    lift(u, 0, v.size() - 1);
}

void update(int u, int end)     
{
    if(!u)  return;
    if(tr[end].val < tr[u].val)  update(tr[u].l, end);
    else  update(tr[u].r, end);
    tr[u].size = tr[tr[u].l].size + tr[tr[u].r].size + 1;
}

void check(int &u, int end)
{
    if(u == end)  return;
    if(imbalance(u))
    {
        rebuild(u);
        update(root, u);
        return;
    }
    if(tr[end].val < tr[u].val)  check(tr[u].l, end);
    else  check(tr[u].r, end);
}

int get_node(int val)
{
    int u = ++ idx;
    tr[u].val = val;
    tr[u].size = tr[u].fact = 1;
    tr[u].exist = true;
    return u;
}

void insert(int &u, int val)
{
    if(!u)
    {
        u = get_node(val);
        check(root, u);
        return;
    }
    tr[u].size ++;
    tr[u].fact ++;
    if(val < tr[u].val)  insert(tr[u].l, val);
    else  insert(tr[u].r, val);
}

void del(int u, int val)
{
    if(tr[u].exist and tr[u].val == val)
    {
        tr[u].exist = false;
        tr[u].fact --;
        check(root, u);
        return;
    }
    tr[u].fact --;
    if(val < tr[u].val)  del(tr[u].l, val);
    else  del(tr[u].r, val);
}

int get_rank(int val)
{
    int u = root, rank = 1;
    while(u)
    {
        if(val <= tr[u].val)  u = tr[u].l;
        else
        {
            rank += tr[u].exist + tr[tr[u].l].fact;
            u = tr[u].r;
        }
    }
    return rank;
}

int get_val(int rank)
{
    int u = root;
    while(u)
    {
        if(tr[u].exist and tr[tr[u].l].fact + tr[u].exist == rank)  break;
        if(tr[tr[u].l].fact >= rank)  u = tr[u].l;
        else
        {
            rank -= tr[tr[u].l].fact + tr[u].exist;
            u = tr[u].r;
        }
    }
    return tr[u].val;
}

int get_prev(int val)
{
    return get_val(get_rank(val) - 1);
}

int get_next(int val)
{
    return get_val(get_rank(val + 1));
}

int main()
{
    int t;
    scanf("%d", &t);
    while(t --)
    {
        int op, x;
        scanf("%d%d", &op, &x);
        if(op == 1)  insert(root, x);
        else if(op == 2) del(root, x);
        else if(op == 3) printf("%d\n", get_rank(x));
        else if(op == 4) printf("%d\n", get_val(x));
        else if(op == 5) printf("%d\n", get_prev(x));
        else  printf("%d\n", get_next(x));
    }
    return 0;
}

作者：滑稽_ωﾉ
链接：https://www.acwing.com/activity/content/code/content/198217/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 265. 营业额统计    原题链接    简单
作者：    雪为谁落 ,  2020-02-13 17:27:45 ,  阅读 200

2


1
题目描述
对于第i个营业额a[i],找出abs(a[i]-a[j]){j=1~i-1}的最小值,用ans累加起来并输出.

样例
输入样例
6
5
1
2
5
4
6

输出样例
12
算法
(set) O(nlogn)O(nlogn)
浏览一下众大佬的题解，其实本蒟蒻的思路与”玩玩就好”神犇的题解思落相差无几，但是觉得大佬的操作有一点冗长（恕我直言）
所以打算在其基础上进行优化与补充
看到题目，便想到了set，set不光存储方便，而且支持lower_bound，感觉比较好用。
读入当前营业额时，利用set当中自带的lower_bound进行扫描，复杂度为O(logn)。
然后分两种情况:
1.如果i==1,则ans直接加上x
2.否则ans加上min(x-x的前驱,x-x的后继)–>这里的前驱与后继都是针对于数值大小来说得
注意事项
1.set中lower_bound返回的是指针
2.为了防止lower_bound返回指针是set.end()–>即寻找不到,应当预处理一下,在set当中预先加入无穷大与负无穷大这样可以方便判断

时间复杂度
O(nlogn)
参考文献
C++ 代码
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<set>
using namespace std;
inline int read()
{
    int s=0,w=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-')
            w=-w;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        s=s*10+c-'0';
        c=getchar();
    }
    return s*w;
}
const int N=40000+5;
int n,ans;
set<int> s;
int main()
{
    n=read();
    s.insert(1e9);
    s.insert(-(1e9));
    ans=0;
    for(int i=1;i<=n;i++)
    {
        int x=read();
        set<int>:: iterator it=s.lower_bound(x);
        if(i!=1)
            ans+=min(abs(x-*(--it)),abs(x-*it));
        else
            ans+=abs(x);
        s.insert(x);
    }
    printf("%d\n",ans);
    return 0;
}

作者：雪为谁落
链接：https://www.acwing.com/solution/content/8520/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 33010, INF = 1e7;

int n;
struct Node
{
    int l, r;
    int key, val;
}tr[N];

int root, idx;

int get_node(int key)
{
    tr[ ++ idx].key = key;
    tr[idx].val = rand();
    return idx;
}

void build()
{
    get_node(-INF), get_node(INF);
    root = 1, tr[1].r = 2;
}

void zig(int &p)
{
    int q = tr[p].l;
    tr[p].l = tr[q].r, tr[q].r = p, p = q;
}

void zag(int &p)
{
    int q = tr[p].r;
    tr[p].r = tr[q].l, tr[q].l = p, p = q;
}

void insert(int &p, int key)
{
    if (!p) p = get_node(key);
    else if (tr[p].key == key) return;
    else if (tr[p].key > key)
    {
        insert(tr[p].l, key);
        if (tr[tr[p].l].val > tr[p].val) zig(p);
    }
    else
    {
        insert(tr[p].r, key);
        if (tr[tr[p].r].val > tr[p].val) zag(p);
    }
}

int get_prev(int p, int key)    // 找到小于等于key的最大数
{
    if (!p) return -INF;
    if (tr[p].key > key) return get_prev(tr[p].l, key);
    return max(tr[p].key, get_prev(tr[p].r, key));
}

int get_next(int p, int key)    // 找到大于等于key的最小数
{
    if (!p) return INF;
    if (tr[p].key < key) return get_next(tr[p].r, key);
    return min(tr[p].key, get_next(tr[p].l, key));
}

int main()
{
    build();
    scanf("%d", &n);

    LL res = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int x;
        scanf("%d", &x);
        if (i == 1) res += x;
        else res += min(x - get_prev(root, x), get_next(root, x) - x);

        insert(root, x);
    }

    printf("%lld\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/168882/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

原来AC自动机就是KMP+TRIE啊！！！tqltql


AcWing 1282. 搜索关键词    原题链接    中等
作者：    AJ小公主 ,  2020-06-17 21:01:51 ,  阅读 230

5


1
我个人的理解 若有不当还请斧正
Tire(后缀数组) -> AC自动机 -> Tire图
以上是一个拓扑图的形式 先理解tire树再来搞懂 AC自动机
tire就不说了，直接来AC自动机。
AC自动机：
基础 Tire + KMP
用途：可以直接求一组模板串中有多少个模板串在主串中出现过。

怎么求？
先回忆一下KMP的匹配过程，就是预先处理出一个next数组来存储如果当前的模板串的字符与主串的字符不匹配时，
我们通过利用前面已经匹配的信息得到模板串可以往后直接移动最大多少位重新匹配而没有冗余。
我们预处理next数组的时候用到的是上一个字符的next

for(int i = 2; i <= n; i ++)
{
    int j = ne[i - 1]; // 每次用到上一个字符的next
    while(j && p[i] != p[j] + 1)j = ne[j];
    if(p[i] == p[j + 1])j ++;
    next[i] = j;
}
利用这种思想我们带入到tire 中假如我们已经构建了一个tire树，需要把树上的每一个节点的next都算出来
一维的时候我们next 根据前一个字符的next 计算 那么二维的话每个节点的next就需要父节点维的时候我们next 根据前一个字符的next 计算 那么二维的话每个节点的next就需要父节点next进行计算，意会一下。

先枚举当前节点可能存在的所以儿子（如果是都是小写字母的话就是26个 如果为01串就是2个 看情况而定）
1） 儿子不存在 直接pass
2) 儿子存在
假如我们前i层的next 已经算好了，第i + 1 层存在一个字符为’x’的节点，那么它的next数组等于它父节点的next
数组对应的那个节点的儿子为’x’的指针，如果这个指针不存在就继续往前找，知道找到或者到根节点啊结束。
while(j && !tr[j][i]) j = ne[j]; // j代表的是这个节点的next的指针 tr[j][i] 代表j指向的这个地址的儿子为i的字符是否存在

整个过程一层层来求用bfs 最终把所以节点的next全部存下来 over.

下一把如何计算当前节点是否出过
依次枚举主串 与j指针的儿子进行比较如果这个儿子存在那么吧j指向这个儿子
反正j就回溯到next指针的位置。

以上就是AC自动机的建立过程
tire图就是对AC自动机的一个小优化

for(int i = 0; i < 26; i ++)
{
    int p = tr[t][i];
    int j = ne[t];
    if(p)
    {
        while(j && !tr[j][i]) j = ne[j];
    }
    if(tr[j][i])j = tr[j][i];
}
这个while循环里面存在一个问题就是如果next指针指到的位置的儿子不存在这个字符那么就一直往回找直到找到为止
我们想一个办法可不可以直接让这个指针直到它要指的位置 当然可以了


如上图假如它的儿子不存在那么我们就将它指向它父节点的儿子指针 ，假如他父节点的儿子指针也不存在那么就他父节点的儿子指针就会指向它的父节点的儿子指针
假如已经到了第i层那么前面的已经更新好了，如果他的儿子不存在直接把它指向它的父节点指向的地方的儿子的位置即可。假如存在儿子那么直接指向它父节点的儿子等于这个节点的位置即可，因为前面已经更新好了。
有点绕 第一次的接触的同学多多思考一下画个图就明白了，我也是花了一下午才明白的。
大家要有耐心呀`。

for(int i = 0; i < 26; i ++)
{
    int &p = tr[t][i];
    int j = ne[t];
    if(!p)p = tr[j][i];
    else
    {
        ne[p] = tr[j][i];
    }
}
 [AC自动机超级详细](https://www.cnblogs.com/hyfhaha/p/10802604.html) 

作者：AJ小公主
链接：https://www.acwing.com/solution/content/14882/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010, S = 55, M = 1000010;

int n;
int tr[N * S][26], cnt[N * S], idx;
char str[M];
int q[N * S], ne[N * S];

void insert()
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int t = str[i] - 'a';
        if (!tr[p][t]) tr[p][t] = ++ idx;
        p = tr[p][t];
    }
    cnt[p] ++ ;
}

void build()
{
    int hh = 0, tt = -1;
    for (int i = 0; i < 26; i ++ )
        if (tr[0][i])
            q[ ++ tt] = tr[0][i];

    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = 0; i < 26; i ++ )
        {
            int p = tr[t][i];
            if (!p) tr[t][i] = tr[ne[t]][i];
            else
            {
                ne[p] = tr[ne[t]][i];
                q[ ++ tt] = p;
            }
        }
    }
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        memset(tr, 0, sizeof tr);
        memset(cnt, 0, sizeof cnt);
        memset(ne, 0, sizeof ne);
        idx = 0;

        scanf("%d", &n);
        for (int i = 0; i < n; i ++ )
        {
            scanf("%s", str);
            insert();
        }

        build();

        scanf("%s", str);

        int res = 0;
        for (int i = 0, j = 0; str[i]; i ++ )
        {
            int t = str[i] - 'a';
            j = tr[j][t];

            int p = j;
            while (p)
            {
                res += cnt[p];
                cnt[p] = 0;
                p = ne[p];
            }
        }

        printf("%d\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/169821/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

y总你这个方法会被形如aaaaaaaaaaaaa的字符串卡成o(n∗n)o(n∗n)

yxc   2个月前     回复
最坏情况下计算量是 50m50m，大于 5×1075×107 左右。


jcsxky   1个月前     回复
入门经典里面加了一个last数组，好像就是做这个优化的


yxc   1个月前    回复了 jcsxky 的评论     回复
我之前考虑的时候没想到比较好的优化方式，有链接或者图片吗？


jcsxky   1个月前    回复了 yxc 的评论     回复
我是看的刘汝佳那本算法竞赛入门经典3.3.3节的内容


yxc   5天前    回复了 jcsxky 的评论     回复
优化之后的时间复杂度可以降到多少呀

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/169821/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1285. 单词    原题链接    中等
作者：    FfFJ ,  2020-05-04 16:14:31 ,  阅读 219

4


2
题目描述
某人读论文，一篇论文是由许多单词组成的。

但他发现一个单词会在论文中出现很多次，现在他想知道每个单词分别在论文中出现多少次。

输入格式
第一行一个整数 NN，表示有多少个单词。

接下来 NN 行每行一个单词，单词中只包含小写字母。

输出格式
输出 NN 个整数，每个整数占一行，第 ii 行的数字表示第 ii 个单词在文章中出现了多少次。

数据范围
1≤N≤2001≤N≤200,
所有单词长度的总和不超过 106106。

样例
输入样例：
3
a
aa
aaa
输出样例：
6
3
1
算法
(AC自动机)
对于Trie图，其实最难理解的是它的Fail指针，也就是当前单词的后缀可以匹配的最长前缀，当然这里写的是ne数组，意思是一样的。
类似于下面的这张图示：

考虑完这个问题之后，我们用题目中的例子画一张图理解一下：

为什么可以这样呢，其实就是做了一个巧妙的转化，我们发现，要找所有单词中某个单词出现的次数，其实就是看在所有的前缀的后缀中某个单词出现的次数，这不就是ne数组的定义吗，问题也就解决了！

时间复杂度
时间复杂度是线性的，和所有单词的总长度有关，也就是O(nn)。

参考文献
算法提高课

java 代码
import java.io.*;

class Main{
    static int N = 210, M = 1000010;
    static int[][] tr = new int[M][26];
    static int[] f = new int[M];
    static int[] ne = new int[M];
    static int[] q = new int[M];
    static int[] id = new int[N];
    static int idx;

    static void insert(String str, int j){
        char[] arr = str.toCharArray();

        int p = 0;
        for(int i=0; i<arr.length; i++) {
            int u = arr[i] - 'a';
            if(tr[p][u] == 0) tr[p][u] = ++ idx;
            p = tr[p][u];
            f[p] ++;
        }

        id[j] = p;
    }

    static void build() {
        int hh = 0; int tt = -1;
        for(int i=0; i<26; i++) {
            if(tr[0][i] != 0) {
                q[++ tt] = tr[0][i];
            }
        }

        while(hh <= tt) {
            int t = q[hh ++]; // 这里的t相当于i-1

            for(int i=0; i<26; i++){
                int c = tr[t][i];
                if(c == 0) tr[t][i] = tr[ne[t]][i];
                else{
                    ne[c] = tr[ne[t]][i];
                    q[++ tt] = c;
                }
            }
        }
    }

    public static void main(String[] args) throws IOException{
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(in.readLine());

        for(int i=0; i<n; i++) {
            String cur = in.readLine();
            insert(cur, i);
        }

        build();

        for(int i=idx-1; i>=0; i--) f[ne[q[i]]] += f[q[i]];

        for(int i=0; i<n; i++) System.out.println(f[id[i]]);
    }
}

作者：FfFJ
链接：https://www.acwing.com/solution/content/7760/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1000010;

int n;
int tr[N][26], f[N], idx;
int q[N], ne[N];
char str[N];
int id[210];

void insert(int x)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int t = str[i] - 'a';
        if (!tr[p][t]) tr[p][t] = ++ idx;
        p = tr[p][t];
        f[p] ++ ;
    }
    id[x] = p;
}

void build()
{
    int hh = 0, tt = -1;
    for (int i = 0; i < 26; i ++ )
        if (tr[0][i])
            q[ ++ tt] = tr[0][i];

    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = 0; i < 26; i ++ )
        {
            int &p = tr[t][i];
            if (!p) p = tr[ne[t]][i];
            else
            {
                ne[p] = tr[ne[t]][i];
                q[ ++ tt] = p;
            }
        }
    }
}

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ )
    {
        scanf("%s", str);
        insert(i);
    }

    build();

    for (int i = idx - 1; i >= 0; i -- ) f[ne[q[i]]] += f[q[i]];

    for (int i = 0; i < n; i ++ ) printf("%d\n", f[id[i]]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/169866/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

第三章 图论完成情况：0/58
包括单源最短路的建图方式、单源最短路的综合应用、单源最短路的扩展应用、Floyd算法、最小生成树、最小生成树的扩展应用、负环、差分约束、最近公共祖先、强连通分量、双连通分量、二分图、欧拉回路和欧拉路径、拓扑排序等内容



AcWing 1129. 热浪    原题链接    简单
作者：    qym2008 ,  2020-02-17 18:00:46 ,  阅读 368

4


裸dijkstra+heap

C++ 代码
#include<bits/stdc++.h>
using namespace std;
const int N=6210*2;
int n,m,s,t,dist[N],h[N],e[N],w[N],ne[N],idx;
bool st[N];
typedef pair<int,int> PII;
void add(int a,int b,int c)
{
    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}
int dijkstra()
{
    memset(dist,0x3f,sizeof dist);
    dist[s]=0;
    priority_queue<PII,vector<PII>,greater<PII> > heap;
    heap.push({0,s});
    while(!heap.empty())
    {
        PII t=heap.top();
        heap.pop();
        int ver=t.second,distance=t.first;
        if(st[ver]) continue;
        st[ver]=true;
        for(int i=h[ver];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>distance+w[i])
            {
                dist[j]=distance+w[i];
                heap.push({dist[j],j});
            }
        }
    }
    return dist[t];
}
int main()
{
    cin>>n>>m>>s>>t;
    memset(h,-1,sizeof h);
    while(m--)
    {
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);add(b,a,c);
    }
    cout<<dijkstra();
    return 0;
}

作者：qym2008
链接：https://www.acwing.com/solution/content/8682/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2510, M = 6200 * 2 + 10;

int n, m, S, T;
int h[N], e[M], w[M], ne[M], idx;
int dist[N], q[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[S] = 0;

    int hh = 0, tt = 1;
    q[0] = S, st[S] = true;

    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }
}

int main()
{
    cin >> n >> m >> S >> T;

    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c), add(b, a, c);
    }

    spfa();

    cout << dist[T] << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/140736/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


可以直接用模拟队列(普通队列) 不写成循环队列的形式吗？


yxc   11个月前     回复
不推荐，因为无法确定队列长度。


小丸子a   5个月前    回复了 yxc 的评论     回复
https://www.acwing.com/activity/content/code/content/48498/
y总,基础课的spfa就是用普通队列的,两道题解法不是一样的吗.

以及,循环队列初始是hh=0,tt=-1还是hh=0,tt=0. 就是跟普通队列有差别好像


yxc   4个月前    回复了 小丸子a 的评论     回复
queue就是循环队列，不是普通队列。循环队列指的是数组可以循环利用，普通队列是指数组一直往后用，前面用过的位置不会再被用了。


greg666   11个月前     回复
这章里为什么用循环队列了。直接用queue不是更简便？


yxc   11个月前     回复
在本题中二者均可，区别不大。如果题目卡常的话，不推荐使用queue，常数略大。


orzorz   6个月前    回复了 yxc 的评论     回复
那这里的循环队列只开N会不会出现后面新加进来的把前面还没出队列的给覆盖了


yxc   6个月前    回复了 orzorz 的评论     回复
不会的，队列中没有重复节点，所以最多只会存n个点。

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/140736/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



AcWing 1128. 信使——记录一下四种模板    原题链接    简单
作者：    马丁 ,  2020-03-06 22:10:14 ,  阅读 287

5


2
本着练习的角度，使用dijkstra spfa floyd 算法完成本题，巩固一下模板…大佬勿喷....
spfa和dijikstra
只需要将mian的sfpa换成dijkstra即可切换

#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#define x first
#define y second

using namespace std;
typedef pair<int,int> PII;
const int N = 210 * 2;
int e[N],ne[N],w[N],h[N],dist[N],idx;
bool st[N];
void add(int a,int b,int c)
{
    e[++idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx;
}
int n,m;

int dijkstra()
{
    priority_queue<PII,vector<PII>,greater<PII>> heap;
    memset(dist,0x3f,sizeof dist);
    heap.push({0,1});

    while(heap.size())
    {
        auto t = heap.top();
        heap.pop();
        int ver = t.y,distance = t.x;
        //cout << ver << endl;
        if(st[ver])  continue;
        st[ver] = true;

        for(int i = h[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if(dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j],j});
            }
        }
    }
    int res = -0x3f3f3f3f;
    for(int i = 1; i <= n; i ++)
    {
        if(dist[i]==0x3f3f3f3f) return -1;
        res = max(res,dist[i]);

    }
    return res;

}

int spfa()
{
    queue<int> q;
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0;
    q.push(1);

    while(q.size())
    {
        int t = q.front();
        q.pop();
        st[t] = false;
        for(int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if(dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if(!st[j])
                {
                    st[j] = true;
                    q.push(j);
                }
            }
        }
    }
    int res = -0x3f3f3f3f;
    for(int i = 1; i <= n; i ++)
    {
        if(dist[i] == 0x3f3f3f3f) return -1;
        res = max(res,dist[i]);

    }
    return res;


}


int main()
{

    cin >> n >> m;
    memset(h,-1,sizeof h);
    for(int i = 1;i <= m; i ++)
    {
        int a,b,c;
        cin >> a >> b >> c;
        add(a,b,c);
        add(b,a,c);
    }
    int step = spfa();
    cout << step << endl;


    return 0;
}
朴素版dijkstra
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 110;
int g[N][N];
int dist[N];
int n,m;
bool st[N];
int dijkstra()
{
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0;

    for(int i = 1; i < n; i ++)
    {
        int t = 0;
        for(int j = 1; j <= n; j ++)    //找出未被标记中最小的点
        {
            if(!st[j] && (t == 0 || dist[t] > dist[j]))
                t = j;
        }
        st[t] = true;                   //标记已使用
        //cout << t << " "; //printf调试法
        for(int k = 1; k <= n; k ++)    //用最小的点，更新其他点
            dist[k] = min(dist[k],dist[t] + g[t][k]);
    }
    int res = -1;
    for(int i = 1; i <= n; i ++)
    {
        if(dist[i] == 0x3f3f3f3f) return -1;
        res = max(res,dist[i]);
    }
    return res;
}
int main()
{
    cin >> n >> m;
    memset(g,0x3f3f3f3f,sizeof g);
    for(int i = 1; i <= m; i ++)
    {
        int a,b,c;
        cin >> a >> b >> c;
        if(a == b) continue;
        g[a][b] = min(g[a][b],c);
        g[b][a] = min(g[b][a],c);
    }
    cout <<  dijkstra() << endl;

    return 0;
}
Floyd
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, INF = 0x3f3f3f3f;

int n, m;
int d[N][N];

int main()
{
    cin >> n >> m;

    memset(d, 0x3f, sizeof d);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(d[a][b], c);
    }

    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);

    int res = 0;
    for (int i = 1; i <= n; i ++ )
        if (d[1][i] == INF)
        {
            res = -1;
            break;
        }
        else res = max(res, d[1][i]);

    cout << res << endl;

    return 0;
}

作者：马丁
链接：https://www.acwing.com/solution/content/5091/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, INF = 0x3f3f3f3f;

int n, m;
int d[N][N];

int main()
{
    cin >> n >> m;

    memset(d, 0x3f, sizeof d);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(d[a][b], c);
    }

    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);

    int res = 0;
    for (int i = 2; i <= n; i ++ )
        if (d[1][i] == INF)
        {
            res = -1;
            break;
        }
        else res = max(res, d[1][i]);

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/140746/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



AcWing 1127. 香甜的黄油    原题链接    简单
作者：    1e9+7 ,  2020-04-08 12:44:20 ,  阅读 365

4


1
题目描述
农夫John发现了做出全威斯康辛州最甜的黄油的方法：糖。

把糖放在一片牧场上，他知道 N 只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。

当然，他将付出额外的费用在奶牛上。

农夫John很狡猾，就像以前的巴甫洛夫，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。

他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。

农夫John知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。

给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。

数据保证至少存在一个牧场和所有牛所在的牧场连通。
输入格式

第一行: 三个数：奶牛数 N，牧场数 P，牧场间道路数 C。

第二行到第 N+1 行: 1 到 N 头奶牛所在的牧场号。

第 N+2 行到第 N+C+1 行：每行有三个数：相连的牧场A、B，两牧场间距 D，当然，连接是双向的。
输出格式

共一行，输出奶牛必须行走的最小的距离和。
数据范围

1≤N≤500
,
2≤P≤800,
1≤C≤1450,
1≤D≤255

样例
输入样例：

3 4 5
2
3
4
1 2 1
1 3 5
2 3 7
2 4 3
3 4 5

输出样例：

8

题目分析
题意是这样的，P个顶点C条正权边，每个点有若干个奶牛
在1-n号点里面找一个点，使得所有点里面的奶牛到这个点的距离和最小

先看数据点800，边1500，每个点求一次
多源最短路，先想Floyd算一算会超
然后就是迪杰斯特拉（我不喜欢SPFA太玄学了）
算了一下问题不大 800x1500xlog1500大概1e7

时间复杂度O(PClogC)
C++ 代码
#include<bits/stdc++.h>
using namespace std;
const int N=3000,M=5000,C=1000;
int head[N],Next[M],ver[M],edge[M],d[N],v[N],total;
int n,m,c,x,y,z,num[C];
void add(int x,int y,int z)
{
    ver[++total]=y;
    edge[total]=z;
    Next[total]=head[x];
    head[x]=total;
}
int dijkstra(int s)
{
    memset(d,0x3f,sizeof(d));
    memset(v,0,sizeof(v));
    d[s]=0;
    priority_queue<pair<int ,int>>q;
    q.push({0,s});
    while(q.size())
    {
        x=q.top().second;
        q.pop();
        if(v[x])continue;
        v[x]=1;
        for(int i=head[x];i;i=Next[i])
        {
            y=ver[i],z=edge[i];
            if(d[y]>d[x]+z)
            {
                d[y]=d[x]+z;
                q.push({-d[y],y});
            }

        }
    }
    int res=0;
    for(int i=1;i<=n;i++)
        res+=num[i]*d[i];
    return res;
}
int main()
{
    cin>>c>>n>>m;
    while(c--)
    {
        cin>>x;
        num[x]++;
    }
    int ans=1<<29;
    while(m--)
    {
        cin>>x>>y>>z;
        add(x,y,z);
        add(y,x,z);
    }
    for(int i=1;i<=n;i++)
        ans=min(ans,dijkstra(i));
    cout<<ans<<endl;
}

作者：1e9+7
链接：https://www.acwing.com/solution/content/11172/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 810, M = 3000, INF = 0x3f3f3f3f;

int n, p, m;
int id[N];
int h[N], e[M], w[M], ne[M], idx;
int dist[N], q[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int spfa(int start)
{
    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;

    int hh = 0, tt = 1;
    q[0] = start, st[start] = true;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int j = id[i];
        if (dist[j] == INF) return INF;
        res += dist[j];
    }

    return res;
}

int main()
{
    cin >> n >> p >> m;
    for (int i = 0; i < n; i ++ ) cin >> id[i];

    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c), add(b, a, c);
    }

    int res = INF;
    for (int i = 1; i <= p; i ++ ) res = min(res, spfa(i));

    cout << res << endl;

  

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/140759/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Dijkstra Spfa
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>

using namespace std;

typedef pair<int, int> PII;

const int N = 810, M = 3000, null = 0x3f3f3f3f;

int h[N], e[M], w[M], ne[M], idx;
void add(int a, int b, int c)
{
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx ++;
}

int d[N], cows[N], n, p, m;
bool st[N];

int dijkstra(int start)         //以start为起点，返回到达所有牛的距离之和
{
    memset(st, 0, sizeof st);
    memset(d, 0x3f, sizeof d);
    d[start] = 0;

    priority_queue<PII, vector<PII>, greater<PII> > heap;
    heap.push((PII){0, start});

    while(!heap.empty())
    {
        PII t = heap.top();
        heap.pop();

        int u = t.second;

        if(st[u])  continue;
        st[u] = true;

        for(int i = h[u]; ~i; i = ne[i])
        {
            int j = e[i], dist = t.first + w[i];
            if(dist < d[j])
            {
                d[j] = dist;
                heap.push((PII){d[j], j});
            }
        }
    }

    int res = 0;
    for(int i = 1; i <= n; i ++)
    {
        if(d[cows[i]] == null)  return null;
        res += d[cows[i]];
    }
    return res;
}

int spfa(int start)
{
    memset(st, 0, sizeof st);
    memset(d, 0x3f, sizeof d);
    d[start] = 0;

    queue<int> q;
    q.push(start);
    st[start] = true;

    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        st[u] = false;

        for(int i = h[u]; ~i; i = ne[i])
        {
            int j = e[i], dist = d[u] + w[i];
            if(dist < d[j])
            {
                d[j] = dist;
                if(!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    int res = 0;
    for(int i = 1; i <= n; i ++)
    {
        if(d[cows[i]] == null)  return null;
        res += d[cows[i]];
    }
    return res;
}

int main()
{
    memset(h, -1, sizeof h);

    scanf("%d%d%d", &n, &p, &m);
    for(int i = 1; i <= n; i ++)  scanf("%d", &cows[i]);

    while(m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
        add(b, a, c);
    }

    int res = 2e9;
    for(int i = 1; i <= p; i ++)  res = min(res, dijkstra(i));

    printf("%d", res);
    return 0;
}

作者：滑稽_ωﾉ
链接：https://www.acwing.com/activity/content/code/content/142364/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


题目描述
农夫John发现了做出全威斯康辛州最甜的黄油的方法：糖。

把糖放在一片牧场上，他知道 N 只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。

当然，他将付出额外的费用在奶牛上。

农夫John很狡猾，就像以前的巴甫洛夫，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。

他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。

农夫John知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。

给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。

数据保证至少存在一个牧场和所有牛所在的牧场连通。

输入样例

3 4 5
2
3
4
1 2 1
1 3 5
2 3 7
2 4 3
3 4 5
输出样例
8
参考
根据y总的思路写了一份堆优化版本的dijkstra，从测试时间上来看，spfa用的时间比堆优化版的dijkstra的时间要短的多。

//dijkstra
#include<bits/stdc++.h>
using namespace std;
int n,p,m;
const int N=810,M=3000,INF=0x3f3f3f3f;
typedef pair<int,int> PII;
int h[N],ne[M],e[M],w[M],idx;
int id[N],dist[N],st[N];
void add(int a,int b,int c)
{
    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}
int dijkstra(int start)
{
    memset(dist,0x3f,sizeof dist);//距离更新
    memset(st,0,sizeof st); //状态更新
    priority_queue<PII,vector<PII>,greater<PII> > heap;
    heap.push({0,start});
    dist[start]=0;
    while(heap.size())
    {
        PII p=heap.top();
        heap.pop();
        int ver=p.second;
        if(st[ver]) continue;
        st[ver]=1;
        for(int i=h[ver];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[ver]+w[i])
            {
                dist[j]=dist[ver]+w[i];
                heap.push({dist[j],j});
            }
        }
    }
    int res=0;
    for(int i=1;i<=n;i++)
    {
        int j=id[i];
        if(dist[j]==INF) return INF;
        res+=dist[j];
    }
    return res;
}
int main()
{
    cin>>n>>p>>m;
    memset(h,-1,sizeof h);
    for(int i=1;i<=n;i++) cin>>id[i];
    for(int i=1;i<=m;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
        add(b,a,c);
    }
    int res=INF;
    for(int i=1;i<=p;i++)
        res=min(res,dijkstra(i));
    cout<<res<<endl;
    return 0;
}

作者：季科
链接：https://www.acwing.com/solution/content/6599/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1126. 最小花费    原题链接    简单
作者：    mlxg ,  2020-01-30 15:22:29 ,  阅读 418

8


3
单源求最值
加法最小值
1.无负权边：dijkstra 理由：算法的前提是st数组里的都是已经确定是最短路的，若存在负权边会破坏这个前提。

2.有负权边：spfa

加法最大值
自我感觉spfa能求，还未验证过

乘法最小值
1.>=1：dijkstra 理由：算法的前提是st数组里的都是已经确定最小值的，若存在<1的话会破坏这个前提。

2.>0：spfa

乘法最大值
1.0-1：dijkstra

2.>0:spfa

#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N = 2010;
double dist[N];
bool st[N];
double g[N][N];
int n,m,S,T;
void dijkstra()
{
    //memset(dist,0x3f,sizeof dist);
    dist[S]=1;
    //st[S]=true;
    for(int i=0;i<n;++i){
        int t=-1;
        for(int j=1;j<=n;++j){
            if((!st[j])&&(t==-1||dist[t]<dist[j]))
            t=j;
        }
        st[t]=true;
        for(int j=1;j<=n;++j){
            dist[j]=max(dist[j],dist[t]*g[t][j]);
        }
    }
}
int main()
{
    scanf("%d%d", &n, &m);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        double z = (100.0 - c) / 100;
        g[a][b] = g[b][a] = max(g[a][b], z);
    }

    cin >> S >> T;

    dijkstra();

    printf("%.8lf\n", 100 / dist[T]);
}

作者：mlxg
链接：https://www.acwing.com/solution/content/8010/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2010;

int n, m, S, T;
double g[N][N];
double dist[N];
bool st[N];

void dijkstra()
{
    dist[S] = 1;
    for (int i = 1; i <= n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] < dist[j]))
                t = j;
        st[t] = true;

        for (int j = 1; j <= n; j ++ )
            dist[j] = max(dist[j], dist[t] * g[t][j]);
    }
}

int main()
{
    scanf("%d%d", &n, &m);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        double z = (100.0 - c) / 100;
        g[a][b] = g[b][a] = max(g[a][b], z);
    }

    cin >> S >> T;

    dijkstra();

    printf("%.8lf\n", 100 / dist[T]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/140777/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 920. 最优乘车--优化    原题链接    中等
作者：    李乾 ,  2020-07-16 22:28:23 ,  阅读 134

5


1
这里讨论的是最优乘车的2种优化！
标答请移步至 此

优化1:DFS深搜

人们通常认为，DFS是指数级别的时间复杂度，所以DFS就一定会爆！
不一定!
思路：
dfs传入参数pos和bus,表示公交车的编号与这辆公交车的站数
如果到了终点则返回
决策1：如果没有到最后一站则继续坐这辆公交车；决策2：判断这一站是否为换乘站，如果是则换乘其他公交车
取决策1，决策2的最小值，返回函数
时间复杂度：O(不确定)O(不确定)， 各位同学在评论区打出自己认为的答案吧！
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstring>
#include <utility>
using namespace std ;
typedef pair<int,int> PII ;
const int N=510 ;
int m,n ;
bool st[N][N] ;
int stops[N][N] ;
vector<PII> transfer[N] ;
int dfs(int pos,int bus)                         //1
{
    st[pos][bus]=true ;
    if(stops[pos][bus]==n) return 0 ;            //2
    int res=2e9 ;
    if(stops[pos+1][bus]) res=dfs(pos+1,bus) ;   //3-1
    for(auto t:transfer[stops[pos][bus]])        //3-2
    {
        int fir=t.first ;
        int sec=t.second ;
        if(st[fir][sec]) continue ;
        res=min(res,dfs(fir,sec)+1) ;
    }
    return res ;                                 //4
}
int main()
{
    scanf("%d%d",&m,&n) ;
    string str ;
    getline(cin,str) ;
    PII res ;
    for(int i=1;i<=m;i++)
    {
        int cnt=1 ;
        string str ;
        getline(cin,str) ;
        for(auto ch:str)
        {
            if(ch==' ') 
            {
                transfer[stops[cnt][i]].push_back({cnt,i}) ;
                if(stops[cnt][i]==1) res={cnt,i} ;
                cnt++ ;
            }
            else stops[cnt][i]=stops[cnt][i]*10+ch-'0' ;
        }
    }
    int ans=dfs(res.first,res.second) ;
    if(ans==2e9) puts("NO") ;
    else printf("%d",ans) ;
    return 0 ;
}
优化2：建图方式

标答中，每一条公交线路都要建n(n−1)/2n(n−1)/2条边
为了提升效率，我们需要减少边数
方法
利用yxc的”虚拟源点”思想，可以给每条公交线路一个专用的虚拟源点。
把每条公交线路分成相等的2块，前一块所有点与虚拟源点连边，后一块所有点与虚拟源点连边。
利用分治思想，前后2块内部各自再创建虚拟源点。
时间复杂度 O(mnlogn)O(mnlogn)
代码如下：
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstring>
using namespace std ;
const int N=1010 ;
int m,n ;
int h[N],e[N*2],ne[N*2],w[N*2],idx ;
int dis[N] ;
int stop[N] ;
int add_cnt ;
void add(int a,int b,int c)
{
    e[idx]=b ;
    w[idx]=c ;
    ne[idx]=h[a] ;
    h[a]=idx++ ;
}
void Add(int stop[],int start,int end)
{
    add_cnt++ ;
    if(start>=end) return ;
    for(int i=start;i<=(start+end>>1);i++) add(stop[i],add_cnt,0) ;
    for(int i=(start+end>>1)+1;i<=end;i++) add(add_cnt,stop[i],1) ;
    Add(stop,start,start+end>>1) ;
    Add(stop,(start+end>>1)+1,end) ;
}
void bfs()  //和SPFA一个样子
{
    queue<int> q ;
    q.push(1) ;
    memset(dis,0x3f,sizeof dis) ;
    dis[1]=0 ;
    while(q.size())
    {
        int t=q.front() ;
        q.pop() ;
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i] ;
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i] ;
                q.push(j) ;
            }
        }
    }
}
int main()
{
    scanf("%d%d",&m,&n) ;
    add_cnt=n ;
    string str ;
    getline(cin,str) ;
    memset(h,-1,sizeof h) ;
    while(m--)
    {
        int cnt=0 ;
        string str ;
        getline(cin,str) ;
        memset(stop,0,sizeof stop) ;
        for(auto ch:str)
        {
            if(ch==' ') cnt++ ;
            else stop[cnt]=stop[cnt]*10+ch-'0' ;
        }
        Add(stop,0,cnt) ;
    }
    bfs() ;
    if(dis[n]>1e9) puts("NO") ;
    else printf("%d",dis[n]-1) ;
    return 0 ;
}
20ms优化至18ms!

作者：李乾
链接：https://www.acwing.com/solution/content/15594/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>
#include <sstream>

using namespace std;

const int N = 510;

int m, n;
bool g[N][N];
int dist[N];
int stop[N];
int q[N];

void bfs()
{
    int hh = 0, tt = 0;
    memset(dist, 0x3f, sizeof dist);
    q[0] = 1;
    dist[1] = 0;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = 1; i <= n; i ++ )
            if (g[t][i] && dist[i] > dist[t] + 1)
            {
                dist[i] = dist[t] + 1;
                q[ ++ tt] = i;
            }
    }
}

int main()
{
    cin >> m >> n;

    string line;
    getline(cin, line);
    while (m -- )
    {
        getline(cin, line);
        stringstream ssin(line);
        int cnt = 0, p;
        while (ssin >> p) stop[cnt ++ ] = p;
        for (int j = 0; j < cnt; j ++ )
            for (int k = j + 1; k < cnt; k ++ )
                g[stop[j]][stop[k]] = true;
    }

    bfs();

    if (dist[n] == 0x3f3f3f3f) puts("NO");
    else cout << max(dist[n] - 1, 0) << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/140786/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

y总

初始化dist的时候，是0x3f

 memset(dist, 0x3f, sizeof dist);
最后判断无解的时候，为什么是0x3f3f3f3f（已经测试，如果是dist[n] = 0x3f，有一测试点不过）

if (dist[n] == 0x3f3f3f3f) puts("NO");

yxc   8个月前     回复
memset以字节为单位赋值。所以初始成0x3f，会将一个int变量的四个字节全部变成0x3f，那么最终int的值就是0x3f3f3f3f


AcWing 903. 昂贵的聘礼    原题链接    中等
作者：    叁秋. ,  2019-11-11 16:28:18 ,  阅读 539

4


2
Dij
建立一个虚拟节点以建图.
那么虚拟节点到这些点的值就是初始购买值.
可替代物品直接建图即可,每次取min保证最小花费.
等级浮动只有100,直接从1号点的等级-m枚举,因为要保证能和1号点交换.

参考代码
#include<bits/stdc++.h>
#define re register
using namespace std;
typedef long long ll;
const double eps=1e-7;
const int INF=1e9;
const int N=105;
int n,m;
int x,y;
int cnt;
int tot;
int a,c;
int dis[N];
bool vis[N];
int level[N];
int Map[N][N];
inline int dij(int down,int up) {
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    dis[0]=0;
    for(int i=1; i<=n+1; ++i) {
        int now=-1;
        for(int j=0; j<=n; ++j) {
            if(!vis[j]&&(now==-1||dis[now]>dis[j])) now=j;
        }
        vis[now]=1;
        for(int j=1; j<=n; ++j) {
            if(level[j]>=down&&level[j]<=up)
                dis[j]=min(dis[j],dis[now]+Map[now][j]);
        }
    }
    return dis[1];
}
int main() {
    memset(Map,0x3f,sizeof Map);
    scanf("%d%d",&m,&n);
    for(int i=1; i<=n; ++i) {
        scanf("%d%d%d",&a,&level[i],&cnt);
        Map[0][i]=min(Map[0][i],a);
        while(cnt--) {
            scanf("%d%d",&x,&y);
            Map[x][i]=min(Map[x][i],y);
        }
    }
    int res=INF;
    for(int i=level[1]-m; i<=level[1]; ++i) res=min(res,dij(i,i+m));
    printf("%d",res);
}

作者：叁秋.
链接：https://www.acwing.com/solution/content/6152/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 903. 昂贵的聘礼 简洁题解    原题链接    中等
作者：    xxh ,  2020-02-06 16:28:14 ,  阅读 446

4


题解 ： https://xiaoxiaoh.blog.csdn.net/article/details/104198067

一、内容
 某天超市搞活动，小明想买一个自己一直想买的电脑，平时需要7000，小明觉得太贵了。但活动当天，超市里的商品可以通过买其他商品获得优惠券。例如买一个键盘然后买电脑只需要5000，如果买一个鼠标买电脑只需要4000。同理，买其他商品也有这样的优惠活动。但商场出于某种目的，给每一件商品都标了等级，如果买了低于某个等级的商品，就不能够再买某些高级商品。
为了方便，商店将每一件商品从1开始编号，电脑的编号为1.每一件商品都有对应的价格p,等级l,以及所对应的优惠商品Ki和优惠价格Ri。如果两件商品等级差超过D，就不能同时购买。小明想用最少的钱买到电脑。
Input

第一行是两个整数D，t（1 <= t <= 100），分别代表等级的差距限制和商品的数量。接下来按照编号从1到t给出商品的描述。每个商品的描述开头是v、e、m（m < t），表示该物品的价格、商品的等级和对应优惠商品总数。接下来m行每行包括两个整数K和R，分别表示优惠商品的编号和对应商品优惠后价格。
Output

输出最少需要的钱。
Sample Input

2 4
7000 2 2
2 5000
3 4000
500 1 0
1000 2 1
4  100
30 2 0
Sample Output

4130
二、思路
建立一个超级源点0，从0建立一条边到每个物品，权值为物品的价值。代表花费多少钱就可以购买这个物品。
若某个物品拥有替代品，代表从替代品建立一条边到这个物品，价值为替代的价值。 代表我有了这个替代品，那么还需要花费多少就能买这个物品。

最后就是等级制度。我们可以枚举每个等级区间，每次求最短路是只能更新在这个区间里面的物品。枚举所有情况求一个最小值就可以了。 特别注意的是区间必须包含1点。 那么范围就是【L[1] - m, L[1]】
三、代码
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 105, M = 1e4 + 5, INF = 0x3f3f3f3f;
struct E {
    int v, w, next;
} e[M];
int k, n, x, u, v, w, maxL = INF, len = 1, L[N], h[N], d[N];//L[i]代表i的等级
bool vis[N];
void add(int u, int v, int w) {
    e[len].v = v;
    e[len].w = w;
    e[len].next = h[u];
    h[u] = len++;
}
void spfa(int l, int r) {
    memset(d, 0x3f, sizeof(d));
    d[0] = 0;
    queue<int> q;
    q.push(0);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int j = h[u]; j; j = e[j].next) {
            int v = e[j].v;
            int w = e[j].w + d[u];
            if (l <= L[v] && L[v] <= r && d[v] > w) {
                d[v] = w;
                if (!vis[v]) vis[v] = true, q.push(v);
            }
        }
    } 
}
int main() {
    scanf("%d%d", &k, &n);
    for (int u = 1; u <= n; u++) {
        scanf("%d%d%d", &w, &L[u], &x);
        maxL = max(maxL, L[u]);
        add(0, u, w);//0号点花费w的价值就可以买
        while (x--) {
            scanf("%d%d", &v, &w);
            add(v, u, w); //v-->u 有了v花费w就可以买u 
        } 
    }
    //枚举下等级范围 求出最小的ans
    int ans = INF;
    for (int i = L[1] - k; i <= L[1]; i++) { //等级范围 肯定是要包含1点的 不然你连1都无法购买 
        //可以和[i, i + k]区间的人交易
        spfa(i, i + k);
        ans = min(d[1], ans); 
    } 
    printf("%d", ans);
    return 0;
}

作者：xxh
链接：https://www.acwing.com/solution/content/8233/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, INF = 0x3f3f3f3f;

int n, m;
int w[N][N], level[N];
int dist[N];
bool st[N];

int dijkstra(int down, int up)
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);

    dist[0] = 0;
    for (int i = 1; i <= n + 1; i ++ )
    {
        int t = -1;
        for (int j = 0; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                 t = j;

        st[t] = true;
        for (int j = 1; j <= n; j ++ )
            if (level[j] >= down && level[j] <= up)
                dist[j] = min(dist[j], dist[t] + w[t][j]);
    }

    return dist[1];
}

int main()
{
    cin >> m >> n;

    memset(w, 0x3f, sizeof w);
    for (int i = 1; i <= n; i ++ ) w[i][i] = 0;

    for (int i = 1; i <= n; i ++ )
    {
        int price, cnt;
        cin >> price >> level[i] >> cnt;
        w[0][i] = min(price, w[0][i]);
        while (cnt -- )
        {
            int id, cost;
            cin >> id >> cost;
            w[id][i] = min(w[id][i], cost);
        }
    }

    int res = INF;
    for (int i = level[1] - m; i <= level[1]; i ++ ) res = min(res, dijkstra(i, i + m));

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/140807/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1135. 新年好    原题链接    简单
作者：    Vicolor ,  2019-11-12 21:46:07 ,  阅读 490

4


2
题目描述
固定五个点的情况下求单源最短路

样例
6 6
2 3 4 5 6
1 2 8
2 3 3
3 4 4
4 5 5
5 6 2
1 6 7

21
分析
相当于单源里面套了一个小的最短路

C++ 代码
#include<bits/stdc++.h>
using namespace std;

const int N=5e4+5,M=5e5+5; 
struct mn{
    int to,d,nex;
}s[M<<1];
int n,m,net[N],h[N],t;
int q[7],dis[7][N];
queue<int> w;

void add(int a,int b,int c){//建图 
    s[++t].to=b;
    s[t].d=c;
    s[t].nex=net[a];
    net[a]=t;
}

void init(){//初始化，其实可以删去 
    while(w.size())
        w.pop();
    memset(h,0,sizeof(h));
}
void spfa(int x){//spfa 
    init();
    w.push(q[x]),h[q[x]]=1;
    dis[x][q[x]]=0;
    while(w.size()){
        int c=w.front();
        w.pop();
        for(int i=net[c];i;i=s[i].nex){
            int v=s[i].to;
            if(dis[x][c]+s[i].d<dis[x][v]){
                dis[x][v]=dis[x][c]+s[i].d;
                if(!h[v])
                    w.push(v);
                h[v]=1;
            }
        }
        h[c]=0;
    }
}
int main()
{
    memset(dis,0x3f,sizeof(dis));
    scanf("%d %d",&n,&m);
    for(int i=1;i<=5;++i)
        scanf("%d",&q[i]);
    q[0]=1;
    int a,b,c;
    for(int i=1;i<=m;++i){
        scanf("%d %d %d",&a,&b,&c);
        add(a,b,c);
        add(b,a,c);
    }
    for(int i=0;i<6;++i){
        init();
        spfa(i);
    }   
    int ans=0x3f3f3f3f;
    for(int i=1;i<=5;i++)//非常沙雕的直接杠的写法，dfs，bfs，Floyd都能代替 
        for(int j=1;j<=5;j++)
            for(int l=1;l<=5;l++)
                for(int k=1;k<=5;k++)
                    for(int p=1;p<=5;p++)
                        if((1<<i) + (1<<j) + (1<<l) + (1<<k) + (1<<p)==62)
                            ans=min(ans,dis[0][q[i]]+dis[i][q[j]]+dis[j][q[l]]+dis[l][q[k]]+dis[k][q[p]]);
    cout<<ans;
    return 0;
}

作者：Vicolor
链接：https://www.acwing.com/solution/content/6199/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

typedef pair<int, int> PII;

const int N = 50010, M = 200010, INF = 0x3f3f3f3f;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int q[N], dist[6][N];
int source[6];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dijkstra(int start, int dist[])
{
    memset(dist, 0x3f, N * 4);
    dist[start] = 0;
    memset(st, 0, sizeof st);

    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, start});

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second;
        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[ver] + w[i])
            {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j], j});
            }
        }
    }
}

int dfs(int u, int start, int distance)
{
    if (u > 5) return distance;

    int res = INF;
    for (int i = 1; i <= 5; i ++ )
        if (!st[i])
        {
            int next = source[i];
            st[i] = true;
            res = min(res, dfs(u + 1, i, distance + dist[start][next]));
            st[i] = false;
        }

    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    source[0] = 1;
    for (int i = 1; i <= 5; i ++ ) scanf("%d", &source[i]);

    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }

    for (int i = 0; i < 6; i ++ ) dijkstra(source[i], dist[i]);

    memset(st, 0, sizeof st);
    printf("%d\n", dfs(1, 0, 0));

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/141215/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 340. 通信线路    原题链接    中等
作者：    銘权 ,  2019-07-11 14:29:30 ,  阅读 1604

19


2
题目描述
N 个点，P 条边，求 1 到 N 的最小花费，如果经过的边数小于 K ，花费为 0 ，否则花费为 K+1 大的边权值

样例
5 7 1
1 2 5
3 1 4
2 4 8
3 2 3
5 2 9
3 4 7
4 5 6
如图：
```

分层图最短路
什么是分层图：
当同一个点可以有不同的操作时，我们将一个点分开，对应不同的操作，再重新与其他点相连
我们对每个点都进行如此操作后，原本只有一层的图就被我们分层了
我们把样例分层，如图：
```

红边是普通边，其他颜色的边是进行免费操作的边
分层图的作用

经过分层后，我们得到了新图
我们可以发现，原本题目中选 k 条边免费的操作被我们等价了：
在从一个点到另一个点时，如果选择免费，就进入下一层，相当于进行一次免费操作

因为可以免费 k 次，所以我们要建 k+1 层图
在 k+1 层图上我们已经不能再往下了，即免费操作已用完
那么，如何建边呢？
代码实现：

    for(int i=1,x,y,z;i<=p;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);    //本层建边
        for(int j=1,z1=0;j<=k;j++)
        {
            add(x+(j-1)*n,y+j*n,z1);    //第j层和第j+1层间的建边
            add(y+(j-1)*n,x+j*n,z1);
            add(x+j*n,y+j*n,z);
            add(y+j*n,x+j*n,z);    //第j+1层建边
        }
    }
关于本题
那么，本题已经很明显可以用分层图做

但是
由于最终花费是权值最大的边
所以，在更新最短路的操作中，需要略微变动
以前我们是这么更新的：

if ( dis[y] > dis[x] + z ) dis[y] = dis[x] + z;
现在我们要这么更新：

z=max(edge,dis[x]); //edge是当前边权值
if ( dis[y] > z ) dis[y] = z;
AC代码
#include<bits/stdc++.h>
using namespace std;

const int N=1000000+10,M=10000000+10;

int n,p,k;
int tot=0;
priority_queue< pair<int ,int> > q;
struct node
{
    int ver,nex,edge;
}po[M];
int head[N],dis[N];
bool v[N];

void add(int x,int y,int z)
{
    po[++tot].ver=y,po[tot].edge=z;
    po[tot].nex=head[x],head[x]=tot;
}

void dijkstra()
{
    memset(dis,0x3f,sizeof(dis));
    dis[1]=0;
    q.push(make_pair(0,1));
    while(q.size())
    {
        int x=q.top().second;
        q.pop();
        if(v[x]) continue;
        v[x]=true;
        for(int i=head[x];i;i=po[i].nex)
        {
            int y=po[i].ver,z=max(po[i].edge,dis[x]);
            if(dis[y]>z)
            {
                dis[y]=z;
                q.push(make_pair(-dis[y],y));
            }
        }
    }
}

int main()
{
    scanf("%d%d%d",&n,&p,&k);
    for(int i=1,x,y,z;i<=p;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);
        for(int j=1,z1=0;j<=k;j++)
        {
            add(x+(j-1)*n,y+j*n,z1);
            add(y+(j-1)*n,x+j*n,z1);
            add(x+j*n,y+j*n,z);
            add(y+j*n,x+j*n,z);
        }
    }
    for(int i=1,z=0;i<=k;i++)
        add(i*n,(i+1)*n,z);
    //如果读者认真观察代码的话一定会问为什么要有如此操作
    //那么读者仔细思考，若无此操作，如果有一组数据 1 到 N 经过的边小于 k ，会发生什么呢？

    dijkstra();

    if(dis[(k+1)*n]==1061109567) puts("-1");
    else printf("%d",dis[(k+1)*n]);
    //感谢 Schelski 指出的错误：忘记判路径是否存在了。。。
    return 0;
}

作者：銘权
链接：https://www.acwing.com/solution/content/2757/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


题目描述
在郊区有 N 座通信基站，P 条双向电缆，第 i 条电缆连接基站AiAi和BiBi。

特别地，1 号基站是通信公司的总站，N 号基站位于一座农场中。

现在，农场主希望对通信线路进行升级，其中升级第 i 条电缆需要花费LiLi。

电话公司正在举行优惠活动。

农产主可以指定一条从 1 号基站到 N 号基站的路径，并指定路径上不超过 K 条电缆，由电话公司免费提供升级服务。

农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。

求至少用多少钱可以完成升级。

输入格式
第1行：三个整数N，P，K。

第2..P+1行：第 i+1 行包含三个整数Ai,Bi,LiAi,Bi,Li。

输出格式
包含一个整数表示最少花费。

数据范围
0≤K<N≤10000≤K<N≤1000,
1≤P≤100001≤P≤10000,
1≤Li≤10000001≤Li≤1000000
输入样例：
5 7 1
1 2 5
3 1 4
2 4 8
3 2 3
5 2 9
3 4 7
4 5 6
输出样例：
4
解题报告
题意理解
就是让你从起点11,到终点NN,找一条代价最少的路径,每一条路径的代价是这条路径上的最大权值,且你可以指定一条路径上KK条边权值为零.

思路解析
首先我们一眼就可以确定这道题目是的最短路算法.毕竟题目上白纸黑字上写着要,求出最短路.

首先我们一步步分析一下,这道题目的几个关键点.

这道题目的路径代价是什么?
我们发现,这里的路径不同于一般的最短路,每一条路径的最大边是这条路径的花费

题目中有些路径可以清零,这怎么办?
所有关于边的条件或者性质,其实都可以认为是一种特殊边.

这道题目中,有些边可以代价为0,那么我们不妨设置一种特殊边.

比如说(a,b)(a,b)是相连的边,他们代价是cc,那么如果说我们让它免费,不就是又多了一条边,(a,b)(a,b),只不过他们的代价是0?

所谓的路径可以免费,就是多了一条为0的重边.

所以这道题目的性质,转换一下就是,我们可以设置K条为权值0的边.

所以我们可以设置一个数组d[x,p]d[x,p]表示从1号节点到xx号节点,途中经过pp条权值为0的边,

新加入的边是非0边.
那么我们面对每一条新加入的边(x,y,z)(x,y,z)我们的d[y,p]=max(d[x,p],z)d[y,p]=max(d[x,p],z),其中zz为(x,y)(x,y)权值.

新加入的边是0边.
如果新加入的边是权值为0的边,显然是d[y,p+1]=d[x,p]d[y,p+1]=d[x,p].

代码解释
#include <bits/stdc++.h>
using namespace std;
const int N=10000*3+100;
const int M=1100;
int tot,n,m,k,ver[N],Next[N],head[N],edge[N],dis[M][M];
bool vis[M];
queue<int> q;
void spfa(int s)
{
    memset(dis,0x3f,sizeof(dis));
    memset(vis,false,sizeof(vis));
    dis[s][0]=0;
    vis[s]=1;
    q.push(s);
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        vis[x]=0;
        for (int i=head[x]; i ; i=Next[i])
        {
            int j=edge[i],z=ver[i],w=max(dis[x][0],z);
            if (dis[j][0]>w)
            {
                dis[j][0]=w;
                if(!vis[j])
                    q.push(j),vis[j]=1;
            }
            for(int p=1; p<=k; p++)
            {
                int w=min(dis[x][p-1],max(dis[x][p],z));
                if (dis[j][p]>w)
                {
                    dis[j][p]=w;
                    if(!vis[j])
                        q.push(j),vis[j]=1;
                }
            }
        }
    }
}
void add(int a,int b,int c)
{
    edge[++tot]=b;
    ver[tot]=c;
    Next[tot]=head[a];
    head[a]=tot;
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1; i<=m; i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
        add(b,a,c);
    }
    spfa(1);
    int ans=1e9;
    for(int i=0; i<=k; i++)
        ans=min(ans,dis[n][i]);
    if (ans==1e9)
        printf("-1");
    else
        printf("%d",ans);
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/2425/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>
#include <deque>

using namespace std;

const int N = 1010, M = 20010;

int n, m, k;
int h[N], e[M], w[M], ne[M], idx;
int dist[N];
deque<int> q;
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool check(int bound)
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);

    q.push_back(1);
    dist[1] = 0;

    while (q.size())
    {
        int t = q.front();
        q.pop_front();

        if (st[t]) continue;
        st[t] = true;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i], x = w[i] > bound;
            if (dist[j] > dist[t] + x)
            {
                dist[j] = dist[t] + x;
                if (!x) q.push_front(j);
                else q.push_back(j);
            }
        }
    }

    return dist[n] <= k;
}

int main()
{
    cin >> n >> m >> k;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c), add(b, a, c);
    }

    int l = 0, r = 1e6 + 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    if (r == 1e6 + 1) cout << -1 << endl;
    else cout << r << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/141217/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 342. 道路与航线    原题链接    中等
作者：    秦淮岸灯火阑珊 ,  2019-06-09 21:56:33 ,  阅读 1464

13


3
原题链接

题目描述
农夫约翰正在一个新的销售区域对他的牛奶销售方案进行调查。

他想把牛奶送到T个城镇，编号为1~T。

这些城镇之间通过R条道路 (编号为1到R) 和P条航线 (编号为1到P) 连接。

每条道路i或者航线i连接城镇AiAi到BiBi，花费为CiCi。

对于道路，0≤Ci≤10,0000≤Ci≤10,000;然而航线的花费很神奇，花费CiCi可能是负数(−10,000≤Ci≤10,000−10,000≤Ci≤10,000)。

道路是双向的，可以从AiAi到BiBi，也可以从BiBi到AiAi，花费都是CiCi。

然而航线与之不同，只可以从AiAi到BiBi。

事实上，由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策保证：如果有一条航线可以从AiAi到BiBi，那么保证不可能通过一些道路和航线从BiBi回到AiAi。

由于约翰的奶牛世界公认十分给力，他需要运送奶牛到每一个城镇。

他想找到从发送中心城镇S把奶牛送到每个城镇的最便宜的方案。

输入格式
第一行包含四个整数T,R,P,S。

接下来R行，每行包含三个整数（表示一个道路）Ai,Bi,CiAi,Bi,Ci。

接下来P行，每行包含三个整数（表示一条航线）Ai,Bi,CiAi,Bi,Ci。

输出格式
第1..T行：第i行输出从S到达城镇i的最小花费，如果不存在，则输出“NO PATH”。

数据范围
1≤T≤250001≤T≤25000,
1≤R,P≤500001≤R,P≤50000,
1≤Ai,Bi,S≤T1≤Ai,Bi,S≤T,

输入样例：
6 3 3 4
1 2 5
3 4 5
5 6 10
3 5 -100
4 6 -100
1 3 -10
输出样例：
NO PATH
NO PATH
5
0
-95
-100
解题报告
题意理解
一道明显的单源最短路…

思路解析
首先看到这道题目,我们发现这道题目的复杂度,首先确定了是O(nlogn)O(nlogn)级别的,所以说,我们的算法初步确定在dijskra和SPFA上面.

但是我们发现这道题目一个关键点,就是题目中出现了负权边.

一旦出现了负权边,那么我们只能使用SPFA.lyd大佬的算法过于复杂,我们还是来点容易的水水过去吧

但是对于USACO的题目而言,我们发现他们居然恶心地卡SPFA算法,那么我们不得不使用一些玄学优化.

对于SPFA算法而言,它的优化有两种,我们今天使用SLF优化算法.

众所周知,SPFA算法是一种鉴于队列的实现算法.每一次有节点加入队列都是加入队尾.

但是SLF优化,不同于一般的SPFA算法,它是一种利用双端队列算法处理的问题.

如果说当前点所花费的值少于我们当前队头点的值的话,那么我们就将这个节点插入到队头去,否则我们还是插入到队尾.

这个就是非常好用的SLF优化算法.

代码解析
#include <bits/stdc++.h>
using namespace std;
const int N=400000 +100;
int head[N],ver[N],Next[N],edge[N],vis[N],dis[N],tot;
void add_edge(int a,int b,int c)
{
    edge[tot]=b;
    ver[tot]=c;
    Next[tot]=head[a];
    head[a]=tot++;
}
void spfa(int s)
{
    memset(dis,0x3f,sizeof(dis));
    memset(vis,false,sizeof(vis));
    deque<int> q;
    dis[s]=0;
    vis[s]=true;
    q.push_back(s);
    while(q.size())
    {
        int now=q.front();
        vis[now]=false;
        q.pop_front();
        for(int i=head[now]; ~i; i=Next[i])
        {
            int j=edge[i];
            if (dis[j]>dis[now]+ver[i])
            {
                dis[j]=dis[now]+ver[i];
                if (!vis[j])
                {
                    vis[j]=true;
                    if (q.size() && dis[j]<dis[q.front()])
                        q.push_front(j);
                    else
                        q.push_back(j);
                }
            }
        }
    }
}
int main()
{
    int t,r,p,s,x,y,z;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>t>>r>>p>>s;
    memset(head,-1,sizeof(head));
    for(int i=1; i<=r; i++)
    {
        cin>>x>>y>>z;
        add_edge(x,y,z);
        add_edge(y,x,z);
    }
    for(int i=1; i<=p; i++)
    {
        cin>>x>>y>>z;
        add_edge(x,y,z);
    }
    spfa(s);
    for(int i=1; i<=t; i++)
    {
        if (dis[i]==0x3f3f3f3f)
            cout<<"NO PATH"<<endl;
        else
            cout<<dis[i]<<endl;
    }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/2427/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


    1: 题意关键点解析
1).道路是双向的，可以从Ai到Bi，也可以从Bi到Ai，花费都是Ci然而航线与之不同，只可以从Ai到Bi

说明道路是双向边, 航线是单向边
2).由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策：保证如果有一条航线可以从Ai到Bi，那么保证不可能通过一些道路和航线从Bi回到Ai

I. a -A1-> b, 则b无论是通过道路还是航线都不可能回到a了, 说明航线之间是无环的
II. 航线不可能和道路是重边
3).题目要求的就是起点到各个点的最短距离之和

2: 根据上面的描述我们大致能得到图的一个样子


拓展: 用拓扑排序解决dag带负权图的最短路问题


bfs模板

int d[N]; // 存储每个节点的入度数
void topsort()
{
    memset(dis, 0x3f, sizeof dis);
    dis[S] = 0;

    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q.push(i);

    while (q.size())
    {
        int t = q.front();
        q.pop();

        for(int i = h[t] ; i != -1 ; i ++ )
        {
            int j = e[i];
            if(dis[j] > dis[t] + w[i])
                dis[j] = dis[t] + w[i];

            d[j] -- ; // 入度 - 1
            if(!d[j]) q.push(j);
        }
    }
}
dfs模板(tarjan)

void dfs (int u)
{
    for(int i = h[u] ; ~i ; i = ne[i])
    {
        int j = e[i];
        dfs(j);
        q[ ++ tt] = j; // 我们最先加入的点为拓扑序的尾节点, 故而q队列中的序列顺序为top序的逆序
    }   
}
例题
例1
例2

3: 设计算法思路


4: 时间复杂度分析
每个连通块跑一遍dij_heap, m1logn1 + m2logn2 + … + milogni, 我们将他放缩一下 < (m1+m2+…+mi)logn = mlogn

AC代码
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

typedef pair<int, int> pii;

const int N = 25010, M = 200010, inf = 0x3f3f3f3f;

int n, mr, ms, s;
int h[N], w[M], e[M], ne[M], idx;
int id[N];
int cnt;
int dis[N];
bool st[N];
queue<int> q;
vector<int> block[N]; // 连通块数组
int d[N]; // 连通块的入度数组

void add (int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dij_heap(int u)
{
    // 不需要memset(st, 0, sizeof st) 因为每个无向图都是不同的点的编号也不同

    priority_queue<pii, vector<pii>, greater<pii>> pq;

    /*
    与该连通块相连的上一个连通块的点的出边会更新该连通块与之相连的点的dis, 该点也就是这个连通块无向图的起点
    当然这个起点可能为inf, 因为该连通块的航线是起点所在的连通块的入度
    */
    for(int i = 0 ; i < block[u].size() ; i ++ )
        /*
        if(dis[block[u][i]] < inf)
        这里不能加这条语句, 模拟样例就会知道, 因为如果开始s不在第一个入度为零的连通块内的话, 那么优先队列将一个点都
        加不进去使得无法拓展其出边, 导致无法遍历该连通块的航线, 也就无法探索其他连通块了, 将所有点全部加进去就算有inf
        但是我们放到优先队列里面, 后面更新更短的, 会先出队列, 标记了, 就不会对他进行操作了

        影响的是q.push();
        */
            pq.push({dis[block[u][i]], block[u][i]});

    /*
    上一个连通块是由起点拓展出来的最短距离，现连通块的起点也是由是一个连通块的点拓展出来的，所以距离也是到起点的距离
    所以拓展出来的距离都是到起点的距离
    */
    while(pq.size())
    {
        auto t = pq.top();
        pq.pop();

        int x = t.first, y = t.second;

        if(st[y]) continue;
        st[y] = 1;

        for(int i = h[y] ; i != -1 ; i = ne[i])
        {
            int j = e[i];

            if(dis[j] > x + w[i])
            {
                dis[j] = x + w[i];
                if(id[j] == id[y]) pq.push({dis[j], j}); // 同一连通块才放进优先队列，防止了出现负权边, dijkstra无法解决
            }

            // 这样写的话如果前面的条件成立的话后面的条件就不用判断了, 当数据规模很大的时候就减小了常数
            if (id[j] != id[y] && -- d[id[j]] == 0) q.push(id[j]); 

            /*
            不能写成这样不然会tle, 题目时间卡的太严了
            if(id[j] != id[y]) d[id[j]] -- ;
            if(!d[id[j]]) q.push(id[j]);
            */
        }
    }
}

void top_sort()
{
    // memset整张图就将其串成了一张单源最短路的图
    memset(dis, 0x3f, sizeof dis);
    dis[s] = 0;

    for(int i = 1 ; i <= cnt ; i ++ )
        if(!d[i])
            q.push(i);

    while(q.size())
    {
        int t = q.front();
        q.pop();
        dij_heap(t);
    }
}

void dfs (int u, int v)  // flood-fill标记每个点所属的连通分量的编号
{
    id[u] = v;
    block[v].push_back(u);

    for(int i = h[u] ; i != -1 ; i = ne[i])
    {
        int j = e[i];
        if(!id[j]) dfs(j, v);
    }
}

int main ()
{
    scanf("%d%d%d%d", &n, &mr, &ms, &s);

    memset(h, -1, sizeof h);
    for(int i = 0 ; i < mr ; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);

        add(a, b, c);
        add(b, a, c);
    }

    for(int i = 1 ; i <= n ; i ++ )
        if(!id[i])
            dfs(i, ++ cnt);

    for(int i = 0 ; i < ms ; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);

        add(a, b, c);
        d[id[b]] ++ ;
    }

    top_sort();

    for(int i = 1 ; i <= n ; i ++ )
        if(dis[i] > inf / 2) // 见分享带负权图判断最短路径是否存在注意事项
            puts("NO PATH");
        else printf("%d\n", dis[i]);

    return 0;
}

作者：swust-zyh
链接：https://www.acwing.com/activity/content/code/content/272668/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 25010, M = 150010, INF = 0x3f3f3f3f;

int n, mr, mp, S;
int id[N];
int h[N], e[M], w[M], ne[M], idx;
int dist[N], din[N];
vector<int> block[N];
int bcnt;
bool st[N];
queue<int> q;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u, int bid)
{
    id[u] = bid, block[bid].push_back(u);

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!id[j])
            dfs(j, bid);
    }
}

void dijkstra(int bid)
{
    priority_queue<PII, vector<PII>, greater<PII>> heap;

    for (auto u : block[bid])
        heap.push({dist[u], u});

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.y, distance = t.x;
        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if (id[j] != id[ver] && -- din[id[j]] == 0) q.push(id[j]);
            if (dist[j] > dist[ver] + w[i])
            {
                dist[j] = dist[ver] + w[i];
                if (id[j] == id[ver]) heap.push({dist[j], j});
            }
        }
    }
}

void topsort()
{
    memset(dist, 0x3f, sizeof dist);
    dist[S] = 0;

    for (int i = 1; i <= bcnt; i ++ )
        if (!din[i])
            q.push(i);

    while (q.size())
    {
        int t = q.front();
        q.pop();
        dijkstra(t);
    }
}

int main()
{
    cin >> n >> mr >> mp >> S;
    memset(h, -1, sizeof h);

    while (mr -- )
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c), add(b, a, c);
    }

    for (int i = 1; i <= n; i ++ )
        if (!id[i])
        {
            bcnt ++ ;
            dfs(i, bcnt);
        }

    while (mp -- )
    {
        int a, b, c;
        cin >> a >> b >> c;
        din[id[b]] ++ ;
        add(a, b, c);
    }

    topsort();

    for (int i = 1; i <= n; i ++ )
        if (dist[i] > INF / 2) cout << "NO PATH" << endl;
        else cout << dist[i] << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/141218/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


https://www.acwing.com/activity/content/code/content/272668/


AcWing 341. 最优贸易    原题链接    中等
作者：    yxc ,  2019-08-11 17:08:50 ,  阅读 1461

19


3
算法
(SPFA) O(n+km)O(n+km)
先求出：

从 11 走到 ii 的过程中，买入水晶球的最低价格 dmin[i]；
从 ii 走到 nn 的过程中，卖出水晶球的最高价格 dmax[i]；
然后枚举每个城市作为买卖的中间城市，求出 dmax[i] - dmin[i] 的最大值即可。

求 dmin[i] 和 dmax[i] 时，由于不是拓扑图，状态的更新可能存在环，因此不能使用动态规划，只能使用求最短路的方式。
另外，我们考虑能否使用 dijkstra 算法，如果当前 dmin[i] 最小的点是 5，那么有可能存在边 5-> 6, 6-> 7, 7-> 5，假设当前 dmin[5] = 10，则有可能存在 6 的价格是11， 但 7 的价格是3，那么 dmin[5] 的值就应该被更新成3，因此当前最小值也不一定是最终最小值，所以dijkstra算法并不适用，我们只能采用 spfa 算法。

时间复杂度
瓶颈是SPFA，SPFA 算法的时间复杂度是 O(km)O(km)，其中 kk 一般情况下是个很小的常数，最坏情况下是 nn, nn 表示总点数，mm 表示总边数。因此总时间复杂度是 O(km)O(km)。

C++ 代码
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010, M = 2000010;

int n, m;
int price[N];
int h[N], rh[N], e[M], ne[M], idx;
int dmin[N], dmax[N];
bool st[N];

void add(int *h, int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void spfa(int *d, int start, int *h, bool flag)
{
    queue<int> q;
    memset(st, 0, sizeof st);

    if (flag) memset(d, 0x3f, sizeof dmin);

    q.push(start);
    st[start] = true;
    d[start] = price[start];

    while (q.size())
    {
        int t = q.front();
        q.pop();
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (flag && d[j] > min(d[t], price[j]) || !flag && d[j] < max(d[t], price[j]))
            {
                if (flag) d[j] = min(d[t], price[j]);
                else d[j] = max(d[t], price[j]);

                if (!st[j])
                {
                    st[j] = true;
                    q.push(j);
                }
            }
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);
    memset(rh, -1, sizeof rh);

    for (int i = 1; i <= n; i ++ ) scanf("%d", &price[i]);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(h, a, b), add(rh, b, a);
        if (c == 2) add(h, b, a), add(rh, a, b);
    }

    spfa(dmin, 1, h, true);
    spfa(dmax, n, rh, false);

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = max(res, dmax[i] - dmin[i]);

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/solution/content/3709/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


    AcWing 1137. 选择最佳线路    原题链接    简单
作者：    小呆呆 ,  2020-02-10 15:27:10 ,  阅读 250

3


2
引理：
图中有多个起点，多个终点，求任意起点到任意终点的最短路问题，如下图所示


原问题：从每个起点出发，到达任意终点的所有路线的距离的最小值

加上虚拟源点之后的问题：从虚拟源点出发，到达任意终点的所有路线的距离的最小值

其中虚拟源点到起点的权值为0

算法分析
方法一：通过上述引理，可以转换成求从虚拟源点到终点的的最短路问题

方法二：建反向图，从终点开始求到所有点的单源最短路，取每个给定起点的最短长度

代码使用的是方法一

时间复杂度 O(m)O(m)
SPFA 算法的时间复杂度是 O(km)O(km)，其中 kk 一般情况下是个很小的常数，最坏情况下是 nn, nn 表示总点数，mm 表示总边数。因此最坏情况下的复杂度是 O(nm)O(nm)。

参考文献
算法提高课

Java 代码
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class Main{
    static int N = 1010;
    static int M = 21010;
    static int n;
    static int m;
    static int s;
    static int[] h = new int[N];
    static int[] e = new int[M];
    static int[] ne = new int[M];
    static int[] w = new int[M];
    static int idx = 0;
    static int[] dist = new int[N];
    static boolean[] st = new boolean[N];
    static int INF = 0x3f3f3f3f;
    static void add(int a,int b,int c)
    {
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx ++;
    }
    static int spfa()
    {
        Queue<Integer> q = new LinkedList<Integer>();
        Arrays.fill(dist, INF);
        q.add(0);
        dist[0] = 0;
        st[0] = true;

        while(!q.isEmpty())
        {
            int t = q.poll();
            st[t] = false;

            for(int i = h[t];i != -1;i = ne[i])
            {
                int j = e[i];
                if(dist[j] > dist[t] + w[i])
                {
                    dist[j] = dist[t] + w[i];
                    if(!st[j])
                    {
                        q.add(j);
                        st[j] = true;
                    }
                }
            }
        }

        if(dist[s] == INF) return -1;
        return dist[s];
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        while(true)
        {
            String tmp = br.readLine();
            if(tmp == null) break;
            String[] s1 = tmp.split(" ");
            n = Integer.parseInt(s1[0]);
            m = Integer.parseInt(s1[1]);
            s = Integer.parseInt(s1[2]);
            Arrays.fill(h, -1);
            idx = 0;
            while(m -- > 0)
            {
                String[] s2 = br.readLine().split(" ");
                int a = Integer.parseInt(s2[0]);
                int b = Integer.parseInt(s2[1]);
                int c = Integer.parseInt(s2[2]);
                add(a,b,c);
            }
            int cnt = Integer.parseInt(br.readLine().trim());
            String[] s3 = br.readLine().split(" ");
            for(int i = 0;i < cnt;i ++)
            {
                int b = Integer.parseInt(s3[i]);
                add(0,b,0);
            }

            System.out.println(spfa());
        }
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/8386/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, M = 20010, INF = 0x3f3f3f3f;

int n, m, T;
int h[N], e[M], w[M], ne[M], idx;
int dist[N], q[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void spfa()
{
    int scnt;
    scanf("%d", &scnt);

    memset(dist, 0x3f, sizeof dist);

    int hh = 0, tt = 0;
    while (scnt -- )
    {
        int u;
        scanf("%d", &u);
        dist[u] = 0;
        q[tt ++ ] = u;
        st[u] = true;
    }

    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;

        st[t] = false;
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }
}

int main()
{
    while (scanf("%d%d%d", &n, &m, &T) != -1)
    {
        memset(h, -1, sizeof h);
        idx = 0;

        while (m -- )
        {
            int a, b, c;
            scanf("%d%d%d", &a, &b, &c);
            add(a, b, c);
        }

        spfa();

        if (dist[T] == INF) dist[T] = -1;
        printf("%d\n", dist[T]);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/143197/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1131. 拯救大兵瑞恩    原题链接    中等
作者：    xnuohz ,  2020-06-03 00:41:26 ,  阅读 177

3


1
题目描述


输入样例
4 4 9
9
1 2 1 3 2
1 2 2 2 0
2 1 2 2 0
2 1 3 1 0 
2 3 3 3 0
2 4 3 4 1
3 2 3 3 0
3 3 4 3 0
4 3 4 4 0
2
2 1 2 
4 2 1
输出样例
14
算法
(拆点+BFS) O(nm)O(nm)
将迷宫中的二维坐标压缩成一维数组方便枚举，即nn行mm列的迷宫中点(x,y)(x,y)的下标为t=(x−1)∗n+yt=(x−1)∗n+y
设dist[t][state]dist[t][state]表示所有从起点走到tt这个格子，且当前已经拥有的钥匙是statestate的所有路线的集合中的最短距离
用一个10位的二进制数statestate存储每一类🔑的存放情况
初始时，对于没有🔑的单元，只有一种状态dist[t][0]dist[t][0]；对于包含🔑的单元，有两种状态dist[t][0]dist[t][0]和dist[t][state]dist[t][state]（因为只要有钥匙一定是全部带着，否则有可能走回头路）
状态转移的方式分以下2种情况：
拿起所有钥匙（花费时间0）：dist[t][state]=min(dist[t][state],dist[t][0])dist[t][state]=min(dist[t][state],dist[t][0])
向四周移动，只有以下2种情况能走（花费时间1）：dist[t1][state]=min(dist[t1][state],dist[t2][state]+1)dist[t1][state]=min(dist[t1][state],dist[t2][state]+1)
（1）没有门和墙
（2）有门，且有匹配的钥匙
状态转移过程中花费时间只有0或者1，因此考虑使用双端队列BFS
时间复杂度
整个过程分为建图和双端队列广搜，每个单元至多只会入队和出队一次，因此时间复杂度是O(nm)O(nm)
C++ 代码
#include <iostream>
#include <cstring>
#include <deque>
#include <set>
using namespace std;

#define x first
#define y second

typedef pair<int, int> PII;
const int N = 11, M = N * N, E = 400, P = 1 << N;

int n, m, p, k;
int h[M], e[E], w[E], ne[E], idx;
int g[N][N], keys[M], dist[M][P];
bool st[M][P];
set<PII> edges;

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void build() {
    int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            for (int u = 0; u < 4; u ++ ) {
                int x = i + dx[u], y = j + dy[u];
                if (x <= 0 || y <= 0 || x > n || y > m) continue;
                int a = g[i][j], b = g[x][y];
                if (!edges.count({a, b})) add(a, b, 0);
            }
}

int bfs() {
    memset(dist, 0x3f, sizeof dist);
    dist[1][0] = 0;

    deque<PII> q;
    q.push_back({1, 0});

    while (q.size()) {
        PII t = q.front(); q.pop_front();

        if (st[t.x][t.y]) continue;
        st[t.x][t.y] = true;

        if (t.x == n * m) return dist[t.x][t.y];

        if (keys[t.x]) {
            int state = t.y | keys[t.x];
            if (dist[t.x][state] > dist[t.x][t.y]) {
                dist[t.x][state] = dist[t.x][t.y];
                q.push_front({t.x, state});
            }
        }

        for (int i = h[t.x]; ~i; i = ne[i]) {
            int j = e[i];
            if (w[i] && !(t.y >> w[i] - 1 & 1)) continue;
            if (dist[j][t.y] > dist[t.x][t.y] + 1) {
                dist[j][t.y] = dist[t.x][t.y] + 1;
                q.push_back({j, t.y});
            }
        }
    }

    return -1;
}

int main() {
    cin >> n >> m >> p >> k;

    int cnt = 1;

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            g[i][j] = cnt ++ ;

    memset(h, -1, sizeof h);

    for (int i = 0; i < k; i ++ ) {
        int x1, x2, y1, y2, c; cin >> x1 >> y1 >> x2 >> y2 >> c;
        int a = g[x1][y1], b = g[x2][y2];
        if (c) add(a, b, c), add(b, a, c);
        edges.insert({a, b}), edges.insert({b, a});
    }

    build();

    cin >> p;
    for (int i = 0; i < p; i ++ ) {
        int x, y, c; cin >> x >> y >> c;
        keys[g[x][y]] |= 1 << c - 1;
    }

    cout << bfs();

    return 0;
}

作者：xnuohz
链接：https://www.acwing.com/solution/content/14096/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>
#include <deque>
#include <set>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 11, M = 360, P = 1 << 10;

int n, m, k, p;
int h[N * N], e[M], w[M], ne[M], idx;
int g[N][N], key[N * N];
int dist[N * N][P];
bool st[N * N][P];

set<PII> edges;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void build()
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            for (int u = 0; u < 4; u ++ )
            {
                int x = i + dx[u], y = j + dy[u];
                if (!x || x > n || !y || y > m) continue;
                int a = g[i][j], b = g[x][y];
                if (!edges.count({a, b})) add(a, b, 0);
            }
}

int bfs()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1][0] = 0;

    deque<PII> q;
    q.push_back({1, 0});

    while (q.size())
    {
        PII t = q.front();
        q.pop_front();

        if (st[t.x][t.y]) continue;
        st[t.x][t.y] = true;

        if (t.x == n * m) return dist[t.x][t.y];

        if (key[t.x])
        {
            int state = t.y | key[t.x];
            if (dist[t.x][state] > dist[t.x][t.y])
            {
                dist[t.x][state] = dist[t.x][t.y];
                q.push_front({t.x, state});
            }
        }

        for (int i = h[t.x]; ~i; i = ne[i])
        {
            int j = e[i];
            if (w[i] && !(t.y >> w[i] - 1 & 1)) continue;   // 有门并且没有钥匙
            if (dist[j][t.y] > dist[t.x][t.y] + 1)
            {
                dist[j][t.y] = dist[t.x][t.y] + 1;
                q.push_back({j, t.y});
            }
        }
    }

    return -1;
}

int main()
{
    cin >> n >> m >> p >> k;

    for (int i = 1, t = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            g[i][j] = t ++ ;

    memset(h, -1, sizeof h);
    while (k -- )
    {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        int a = g[x1][y1], b = g[x2][y2];

        edges.insert({a, b}), edges.insert({b, a});
        if (c) add(a, b, c), add(b, a, c);
    }

    build();

    int s;
    cin >> s;
    while (s -- )
    {
        int x, y, c;
        cin >> x >> y >> c;
        key[g[x][y]] |= 1 << c - 1;
    }

    cout << bfs() << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/143196/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1134. 最短路计数    原题链接    中等
作者：    AJ小公主 ,  2019-12-08 16:36:36 ,  阅读 350

5


4
记录最短路条数
要求最短路计数首先满足条件是不能存在值为0的环，因为存在的话那么被更新的点的条数就为INF了。
要把图抽象成一种最短路树（拓扑图）。
求最短的算法有以下几种（本人学过的）
BFS 只入队一次，出队一次。可以抽象成拓扑图， 因为它可以保证被更新的点的父节点一定已经是最短距离了，并且这个点的条数已经被完全更新过了。这个性质是核心性质。
dijkstra 每个点只出队一次。也可以抽象成拓扑图， 同理由于每一个出队的点一定已经是最短距离，并且它出队的时候是队列中距离最小的点，这就代表他的最短距离条数已经被完全更新了，所以构成拓扑性质。
bellman_ford算法 spfa 本身不具备拓扑序，因为更新它的点不一定是最短距离，所以会出错。举个例子

但如果图中存在负权边只能用该算法做，也能做但是比较麻烦
先跑一遍spfa找到每个点的最短距离,把最短路拓扑树建立出来，看哪一条边dist[j] == dist[t] + w[i],然后更新它。

作者：AJ小公主
链接：https://www.acwing.com/solution/content/6867/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



3




#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

const int N = 100010, M = 400010, mod = 100003;

int n, m;
int head[N], e[M], ne[M], idx;
int dist[N], cnt[N];  // cnt[i],从1到达i的最短路径的条数
int q[N];

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = head[a];
    head[a] = idx ++;
}

// 不能存在长度为0的环
void bfs() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    cnt[1] = 1;

    int hh = 0, tt = 0;
    q[0] = 1; 

    while (hh <= tt) {
        int t = q[hh ++];

        // 记录一下这个点被更新时,更新他的前驱,可以得到一棵树,树是具有拓扑序的
        // 规定一个点只能被一个前驱更新(如果有多个最短路一样的前驱更新他,也认为只有一个)
        for (int i = head[t]; i != -1; i = ne[i]) {
            int j = e[i];  // 枚举t的所有临边(t可以更新到的点)
            if (dist[j] > dist[t] + 1) {
                dist[j] = dist[t] + 1;  // 如果用t来更新j,那t一定已经求得最小值
                cnt[j] = cnt[t];  // 如果更新了这条路径的话, 那就跟t是同一条路
                q[++ tt] = j;  // 每个点只入队一次
            }else if (dist[j] == dist[t] + 1)  
                cnt[j] = (cnt[j] + cnt[t]) % mod;
        }
    }
}

int main() {
    cin >> n >> m;
    memset(head, -1, sizeof head);

    while (m --){
        int a, b;
        cin >> a >> b;
        add(a, b);
        add(b, a);
    }

    bfs();

    for (int i = 1; i <= n; i ++) cout << cnt[i] << endl;

    return 0;
}

作者：Sean今天AC了吗
链接：https://www.acwing.com/solution/content/20097/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 400010, mod = 100003;

int n, m;
int h[N], e[M], ne[M], idx;
int dist[N], cnt[N];
int q[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    cnt[1] = 1;

    int hh = 0, tt = 0;
    q[0] = 1;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + 1)
            {
                dist[j] = dist[t] + 1;
                cnt[j] = cnt[t];
                q[ ++ tt] = j;
            }
            else if (dist[j] == dist[t] + 1)
            {
                cnt[j] = (cnt[j] + cnt[t]) % mod;
            }
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }

    bfs();

    for (int i = 1; i <= n; i ++ ) printf("%d\n", cnt[i]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/143195/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

BFS
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>

using namespace std;

const int N = 100010, M = 400010, mod = 100003;

int h[N], e[M], ne[M], idx;
void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}

int n, m;
int d[N], cnt[N];
void bfs()
{
    memset(d, 0x3f, sizeof d);
    d[1] = 0;

    queue<int> q;
    q.push(1);
    cnt[1] = 1;

    while(!q.empty())
    {
        int u = q.front();
        q.pop();

        for(int i = h[u]; ~i; i = ne[i])
        {
            int j = e[i], dist = d[u] + 1;

            if(dist < d[j])
            {
                d[j] = dist;
                cnt[j] = cnt[u];
                q.push(j);
            }else if(dist == d[j]){
                cnt[j] = (cnt[j] + cnt[u]) % mod;
            }
        }
    }
}

int main()
{
    memset(h, -1, sizeof h);

    scanf("%d%d", &n, &m);
    while(m --)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }

    bfs();
    for(int i = 1; i <= n; i ++)  printf("%d\n", cnt[i]);
    return 0;
}

作者：滑稽_ωﾉ
链接：https://www.acwing.com/activity/content/code/content/146686/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 383. 观光    原题链接    中等
作者：    whsstory ,  2019-12-08 11:28:14 ,  阅读 502

9


1
不需要跑次短路，用通法来解决这个题。
通法题：逛公园

（而且这题没有毒瘤的0环，容易多了）

先跑一遍最短路把到每个点的最短距离dis[u]dis[u]求出来。
然后dp：设当前考虑的点是u,到这个点的距离是dis[u]+kdis[u]+k,f[k][u]f[k][u]表示到uu,长度为dis[u]+kdis[u]+k的路径数量
它会对dis[v]=dis[u]+w(u,v)dis[v]=dis[u]+w(u,v)的vv产生f[k][v]+=f[k][u]f[k][v]+=f[k][u]的贡献；并且如果k=0,dis[v]+1=dis[u]+w(u,v)k=0,dis[v]+1=dis[u]+w(u,v)还会产生f[1][v]+=f[0][u]f[1][v]+=f[0][u]的贡献
为了消除后效性，需要按照dis[u]dis[u]排序再dp，最后的答案就是f[0][t]+f[1][t]f[0][t]+f[1][t]
时间复杂度瓶颈在于最短路，为O(mlogn)O(mlogn)
/**********/
#define MAXN 2011
#define MAXM 20011
struct Edge
{
    ll v,w,nxt;
}e[MAXM];
ll cnt=0,last[MAXN];
void adde(ll u,ll v,ll w)
{
    ++cnt;
    e[cnt].v=v;e[cnt].w=w;
    e[cnt].nxt=last[u],last[u]=cnt;
}

ll dis[MAXN];
struct node
{
    ll u,dis;
    node(ll _u=0,ll _dis=0)
    {
        u=_u,dis=_dis;
    }
    bool operator <(const node& t)
    const
    {
        return dis>t.dis;
    }
};
std::priority_queue<node>q;
void Dij(ll s)
{
    memset(dis,0x3f,sizeof dis);
    dis[s]=0;
    q.push(node(s,0));
    while(!q.empty())
    {
        ll u=q.top().u,tmp=q.top().dis;q.pop();
        if(dis[u]!=tmp)continue;
        for(ll i=last[u];i;i=e[i].nxt)
        {
            ll v=e[i].v;
            if(umin(dis[v],dis[u]+e[i].w))q.push(node(v,dis[v]));
        }
    }
}
ll f[2][MAXN],ord[MAXN];
bool cmp(ll x,ll y)
{
    return dis[x]<dis[y];
}
void work()
{
    cnt=0;memset(last,0,sizeof last);
    memset(f,0,sizeof f);
    ll n=read(),m=read();
    for(ll i=1;i<=m;++i)
    {
        ll u=read(),v=read(),w=read();
        adde(u,v,w);
    }
    ll s=read(),t=read();
    Dij(s);
    for(ll i=1;i<=n;++i)ord[i]=i;
    std::sort(ord+1,ord+n+1,cmp);
    f[0][s]=1;
    for(ll k=0;k<=1;++k)
        for(ll p=1;p<=n;++p)
        {
            ll u=ord[p];
            //printf("dis[%lld]=%lld\n",u,dis[u]);
            for(ll i=last[u];i;i=e[i].nxt)
            {
                ll v=e[i].v;
                if(dis[u]+e[i].w==dis[v])f[k][v]+=f[k][u];
                if(k==0&&dis[u]+e[i].w==dis[v]+1)f[1][v]+=f[0][u];
            }
        }
    printf("%lld\n",f[0][t]+f[1][t]);
}
int main()
{
    ll task=read();
    while(task--)work();
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/6853/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 1010, M = 20010;

struct Ver
{
    int id, type, dist;
    bool operator> (const Ver &W) const
    {
        return dist > W.dist;
    }
};

int n, m, S, T;
int h[N], e[M], w[M], ne[M], idx;
int dist[N][2], cnt[N][2];
bool st[N][2];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int dijkstra()
{
    memset(st, 0, sizeof st);
    memset(dist, 0x3f, sizeof dist);
    memset(cnt, 0, sizeof cnt);

    dist[S][0] = 0, cnt[S][0] = 1;
    priority_queue<Ver, vector<Ver>, greater<Ver>> heap;
    heap.push({S, 0, 0});

    while (heap.size())
    {
        Ver t = heap.top();
        heap.pop();

        int ver = t.id, type = t.type, distance = t.dist, count = cnt[ver][type];
        if (st[ver][type]) continue;
        st[ver][type] = true;

        for (int i = h[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j][0] > distance + w[i])
            {
                dist[j][1] = dist[j][0], cnt[j][1] = cnt[j][0];
                heap.push({j, 1, dist[j][1]});
                dist[j][0] = distance + w[i], cnt[j][0] = count;
                heap.push({j, 0, dist[j][0]});
            }
            else if (dist[j][0] == distance + w[i]) cnt[j][0] += count;
            else if (dist[j][1] > distance + w[i])
            {
                dist[j][1] = distance + w[i], cnt[j][1] = count;
                heap.push({j, 1, dist[j][1]});
            }
            else if (dist[j][1] == distance + w[i]) cnt[j][1] += count;
        }
    }

    int res = cnt[T][0];
    if (dist[T][0] + 1 == dist[T][1]) res += cnt[T][1];

    return res;
}

int main()
{
    int cases;
    scanf("%d", &cases);
    while (cases -- )
    {
        scanf("%d%d", &n, &m);
        memset(h, -1, sizeof h);
        idx = 0;

        while (m -- )
        {
            int a, b, c;
            scanf("%d%d%d", &a, &b, &c);
            add(a, b, c);
        }
        scanf("%d%d", &S, &T);

        printf("%d\n", dijkstra());
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/143194/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



希望我这次打卡的代码注释部分能有人看到qwq。。
太难了。。。

#include <iostream>
#include <algorithm>
#include <cstring>
#include <complex>
#include <utility>
#include <cstdio>
#include <cctype>
#include <vector>
#include <queue>

using namespace std;

const int N=1005;
const int M=10005;

struct VER
{
    int id,dist,type;
    bool operator>(const VER&x)const
    {
        return dist>x.dist;
    }
};

int n,m;
int s,ed;
int h[N],e[M],ne[M],idx;
int dist[N][2],cnt[N][2],w[M];
bool st[N][2];

inline int read()
{
    int x=0;
    char ch;
    do ch=getchar();
    while(ch==' '||ch=='\n'||ch=='\r');
    while(ch^' '&&ch^'\n'&&ch^'\r'&&~ch)
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x;
}

/*
inline int dijkstra()
{
    memset(dist,0x3f,sizeof dist);
    memset(cnt,0,sizeof cnt);
    memset(st,false,sizeof st);
    dist[s][0]=0,cnt[s][0]=1;
    priority_queue<VER,vector<VER>,greater<VER>> heap;
    heap.push({s,0,0});
    while(heap.size())
    {
        VER t=heap.top();
        heap.pop();
        int ver=t.id,type=t.type,distance=t.dist;
        if(st[ver][type])continue;
        st[ver][type]=true;
        int count=cnt[ver][type];
        for(int i=h[ver];i;i=ne[i])
            if(dist[e[i]][0]>distance+w[i])
            {
                dist[e[i]][1]=dist[e[i]][0];
                dist[e[i]][0]=distance+w[i];
                cnt[e[i]][1]=cnt[e[i]][0];
                cnt[e[i]][0]=count;
                heap.push({e[i],dist[e[i]][1],1});
                heap.push({e[i],dist[e[i]][0],0});
            }
            else if(dist[e[i]][0]==distance+w[i])
                cnt[e[i]][0]+=count;
            else if(dist[e[i]][1]>distance+w[i])
            {
                dist[e[i]][1]=distance+w[i];
                cnt[e[i]][1]=count;
                heap.push({e[i],dist[e[i]][1],1});
            }
            else if(dist[e[i]][1]==distance+w[i])
                dist[e[i]][1]+=count;
    }
    int res=cnt[ed][0];
    if(dist[ed][0]+1==dist[ed][1])
        res+=cnt[ed][1];
    return res;
}
*/

/**
 * 啊，太感人了，虽然没人看，但还是记录一下。
 * 看完题，有点思路，就照着思路写了，
 * 写完之后交上去WA了，怀疑自己的解法并非正解，
 * 于是开始康y总讲解。
 * 康完y总讲解，发现y总讲解和本人代码思路分毫不差。。
 * 于是开始debug
 * debug了一下午，仍然没找出来bug。。
 * 凭我们女生的第六感，感觉是dij写错了，
 * 于是把原先的dij注释掉了，重打了一遍，
 * （注：原先的dij即为上面注释掉的dij，重打的dij即为下面的dij）
 * 然后交了一发，居然就过了。。。
 * 就很神奇。。。
 * 出于对原先代码中bug所在的好奇，
 * 我把代码复制到了原先写的dij上，
 * 开始 ctrl z 加 ctrl y 反复横跳
 * 跳了半天，才发现自己78行的cnt写成了dist。。。
 * （这个bug先不改，留作纪念）
 * 我的心情极为复杂。。。
 * 这个bug我找了一下午。。。
 * 希望我写的能有人看到吧。。
 */

inline int dijkstra()
{
    memset(dist,0x3f,sizeof dist);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    dist[s][0]=0,cnt[s][0]=1;
    priority_queue<VER,vector<VER>,greater<VER>> heap;
    heap.push({s,0,0});
    while(heap.size())
    {
        VER t=heap.top();
        heap.pop();
        int ver=t.id,type=t.type,distance=t.dist;
        if(st[ver][type])continue;
        st[ver][type]=true;
        int count=cnt[ver][type];
        for(int i=h[ver];i;i=ne[i])
            if(dist[e[i]][0]>distance+w[i])
            {
                dist[e[i]][1]=dist[e[i]][0];
                dist[e[i]][0]=distance+w[i];
                cnt[e[i]][1]=cnt[e[i]][0];
                cnt[e[i]][0]=count;
                heap.push({e[i],dist[e[i]][1],1});
                heap.push({e[i],dist[e[i]][0],0});
            }
            else if(dist[e[i]][0]==distance+w[i])
                cnt[e[i]][0]+=count;
            else if(dist[e[i]][1]>distance+w[i])
            {
                dist[e[i]][1]=distance+w[i];
                cnt[e[i]][1]=count;
                heap.push({e[i],dist[e[i]][1],1});
            }
            else if(dist[e[i]][1]==distance+w[i])
                cnt[e[i]][1]+=count;
    }
    int res=cnt[ed][0];
    if(dist[ed][0]+1==dist[ed][1])
        res+=cnt[ed][1];
    return res;
}

int main()
{
    for(int T=read();T--;)
    {
        n=read(),m=read();
        memset(h,0,sizeof h);
        idx=0;
        for(int i=0;i<m;i++)
        {
            int a=read();
            e[++idx]=read(),w[idx]=read();
            ne[idx]=h[a],h[a]=idx;
        }
        s=read(),ed=read();
        printf("%d\n",dijkstra());
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/316145/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



AcWing 1125. 牛的旅行    原题链接    简单
作者：    yingzhaoyang ,  2019-11-24 15:06:05 ,  阅读 477

5


1
对于这道题,经过分析,我们发现:
对于每一个点,一定会有一个点与他联通且与他的距离最远.
再看一眼n的范围,果断使用Floyd算法.
先求出每一个点到其他点的距离,找出用Maxstep[i]代表与点i相距最远的点距离点i的距离.
先记录一下最大的Maxstep[i],记为ans1.
再考虑加边(注意加边必须加在不连通的两个点之间):
我们枚举每一对不连通的点对,考虑在这两个点加边.
加完边后,我们注意到此时的直径应该是Maxstep[i]+dis(i,j)+Maxstep[j].
我们再找出此时最短的一条Maxstep[i]+dis(i,j)+Maxstep[j],记为ans2.
最终答案记为max(ans1,ans2).

Floyd算法标准时间复杂度 O(n3)O(n3)
C++ 代码
#include<bits/stdc++.h>
using namespace std;
#define MAXN 99999999
struct city{
    int x,y;
}p[200];
double step[200][200],Maxstep[200],ans1,ans2=MAXN;
int n,m,Maps[200][200];
char Map;
void F()
{
    for(int k=1;k<=n;k++)//Floyd算法标准三重循环
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(step[i][j]>step[i][k]+step[k][j])
                    step[i][j]=step[i][k]+step[k][j];
}
double len(int x1,int y1,int x2,int y2)
{
    return sqrt(pow((x1-x2),2)+pow((y1-y2),2));
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d %d",&p[i].x,&p[i].y);//记录坐标
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            cin>>Map;
            Maps[i][j]=Map-'0';//获取基本信息
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            if(Maps[i][j])
                step[i][j]=len(p[i].x,p[i].y,p[j].x,p[j].y);//记录信息
            else if(i!=j)   
                step[i][j]=MAXN;//不连通记录为正无穷
        }
    F();//Floyd算法
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            if(step[i][j]!=MAXN)
                Maxstep[i]=max(step[i][j],Maxstep[i]);
            ans1=max(ans1,Maxstep[i]);//先求ans1
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(step[i][j]==MAXN)
                ans2=min(Maxstep[i]+len(p[i].x,p[i].y,p[j].x,p[j].y)+Maxstep[j],ans2);//再求ans2
    double ans=max(ans1,ans2);//最终答案取max
    printf("%.6lf",ans);
    return 0;
}

作者：yingzhaoyang
链接：https://www.acwing.com/solution/content/6512/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

#define x first
#define y second

using namespace std;

typedef pair<double, double> PDD;

const int N = 155;
const double INF = 1e20;

int n;
PDD q[N];
double d[N][N];
double maxd[N];
char g[N][N];

double get_dist(PDD a, PDD b)
{
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> q[i].x >> q[i].y;
    for (int i = 0; i < n; i ++ ) cin >> g[i];

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            if (i == j) d[i][j] = 0;
            else if (g[i][j] == '1') d[i][j] = get_dist(q[i], q[j]);
            else d[i][j] = INF;

    for (int k = 0; k < n; k ++ )
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);

    double r1 = 0;
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < n; j ++ )
            if (d[i][j] < INF / 2)
                maxd[i] = max(maxd[i], d[i][j]);
        r1 = max(r1, maxd[i]);
    }

    double r2 = INF;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            if (d[i][j] > INF / 2)
                r2 = min(r2, maxd[i] + maxd[j] + get_dist(q[i], q[j]));

    printf("%.6lf\n", max(r1, r2));

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/145996/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 343. 排序    原题链接    简单
作者：    Overnoise ,  2019-11-24 15:59:39 ,  阅读 1151

6


没有看Y总视频
在长时间思考过程中


终于yy出了一种方法
floyd求最长路
首先，我来重复一下题目描述的坑爹之处
1.如果在矛盾之前可以成功判断顺序，那么算是成功
2.矛盾和不确定，优先判断是否矛盾
注意一下第1点，就能轻松A题辣

#include<bits/stdc++.h>
using namespace std;
int n,m;
char a,b;
int rood[30][30];
int MAX;
void flyd()//floyd求最长路 
{
    for(int k=0;k<n;k++)
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                if(rood[i][k]&&rood[k][j])
                {
                    rood[i][j]=max(rood[i][j],rood[i][k]+rood[k][j]);
                    MAX=max(MAX,rood[i][j]);//如果 MAX==n-1 那么就排序成功辣（自己想想） 
                }
}
int main()
{
    while(1)
    {
        memset(rood,0,sizeof(rood));
        cin>>n>>m;
        if(!n&&!m)
            break;//嗯，退出 
        int flag=1;//十分普通的标记 
        MAX=0;//见flyd函数注释 
        for(int i=1;i<=m;i++)
        {
            scanf(" %c<%c",&a,&b);//输入 
            int from=b-'A';//强制类型转换 
            int to=a-'A';//同上 
            if(rood[to][from])//判断是否矛盾 
            {
                printf("Inconsistency found after %d relations.\n",i);
                for(int j=i+1;j<=m;j++)//吸收下面的输入 
                    scanf(" %c<%c",&a,&b);
                flag=0;//标记 
                break;//退出 
            }
            rood[from][to]=1;//标记 
            flyd();
            int head=-1;//最大的数 
            for(int i=0;i<n;i++)
            {
                int f=1;
                for(int j=0;j<n&&f;j++)
                    if(rood[j][i])
                        f=0;
                if(f)
                    head=head==-1?i:233;//如果head==-1则赋值为i，如果head！=-1，说明最大值有两个了，赋为特殊值 
            }
            if(head!=-1&&head!=233&&MAX==n-1)//判断是否合法 
            {
                for(int j=i+1;j<=m;j++)//吸收下面的输入 
                    scanf(" %c<%c",&a,&b);
                cout<<"Sorted sequence determined after "<<i<<" relations: ";
                for(int i=n-1;i>0;i--)//挨个输出 
                    for(int j=0;j<n;j++)
                        if(rood[head][j]==i)
                            cout<<char(j+'A');
                cout<<char(head+'A')<<".\n";
                flag=0;
                break;//退出 
            }
        }
        if(flag)//上面两种情况都不满足 
            puts("Sorted sequence cannot be determined.");
    }
    return 0;//Bye~Bye~ 
}

作者：Overnoise
链接：https://www.acwing.com/solution/content/6508/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


传递闭包 O(mn3)O(mn3)
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 26;

int n, m;
bool g[N][N], d[N][N];
bool st[N];

void floyd()
{
    memcpy(d, g, sizeof d);

    for (int k = 0; k < n; k ++ )
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                d[i][j] |= d[i][k] && d[k][j];
}

int check()
{
    for (int i = 0; i < n; i ++ )
        if (d[i][i])
            return 2;

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < i; j ++ )
            if (!d[i][j] && !d[j][i])
                return 0;

    return 1;
}

char get_min()
{
    for (int i = 0; i < n; i ++ )
        if (!st[i])
        {
            bool flag = true;
            for (int j = 0; j < n; j ++ )
                if (!st[j] && d[j][i])
                {
                    flag = false;
                    break;
                }
            if (flag)
            {
                st[i] = true;
                return 'A' + i;
            }
        }
}

int main()
{
    while (cin >> n >> m, n || m)
    {
        memset(g, 0, sizeof g);
        int type = 0, t;
        for (int i = 1; i <= m; i ++ )
        {
            char str[5];
            cin >> str;
            int a = str[0] - 'A', b = str[2] - 'A';

            if (!type)
            {
                g[a][b] = 1;
                floyd();
                type = check();
                if (type) t = i;
            }
        }

        if (!type) puts("Sorted sequence cannot be determined.");
        else if (type == 2) printf("Inconsistency found after %d relations.\n", t);
        else
        {
            memset(st, 0, sizeof st);
            printf("Sorted sequence determined after %d relations: ", t);
            for (int i = 0; i < n; i ++ ) printf("%c", get_min());
            printf(".\n");
        }
    }

    return 0;
}
增量算法 O(mn2)O(mn2)
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 26;

int n, m;
bool d[N][N];
bool st[N];

int check()
{
    for (int i = 0; i < n; i ++ )
        if (d[i][i])
            return 2;

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < i; j ++ )
            if (!d[i][j] && !d[j][i])
                return 0;

    return 1;
}

char get_min()
{
    for (int i = 0; i < n; i ++ )
        if (!st[i])
        {
            bool flag = true;
            for (int j = 0; j < n; j ++ )
                if (!st[j] && d[j][i])
                {
                    flag = false;
                    break;
                }
            if (flag)
            {
                st[i] = true;
                return 'A' + i;
            }
        }
}

int main()
{
    while (cin >> n >> m, n || m)
    {
        memset(d, 0, sizeof d);

        int type = 0, t;
        for (int i = 1; i <= m; i ++ )
        {
            char str[5];
            cin >> str;
            int a = str[0] - 'A', b = str[2] - 'A';

            if (!type)
            {
                d[a][b] = 1;
                for (int x = 0; x < n; x ++ )
                {
                    if (d[x][a]) d[x][b] = 1;
                    if (d[b][x]) d[a][x] = 1;
                    for (int y = 0; y < n; y ++ )
                        if (d[x][a] && d[b][y])
                            d[x][y] = 1;
                }
                type = check();
                if (type) t = i;
            }
        }

        if (!type) puts("Sorted sequence cannot be determined.");
        else if (type == 2) printf("Inconsistency found after %d relations.\n", t);
        else
        {
            memset(st, 0, sizeof st);
            printf("Sorted sequence determined after %d relations: ", t);
            for (int i = 0; i < n; i ++ ) printf("%c", get_min());
            printf(".\n");
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/145995/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 344. 观光之旅    原题链接    中等
作者：    麻烦写注释 ,  2020-02-28 15:57:09 ,  阅读 362

7


3
算法
(Floyd) O(n3)O(n3)
设环的形式是：i<->k<->j , i<–>j （i,j,k不同）
floyd是典型的插点算法，每次插入点k，为此，在点k被[插入前]可计算i-j-k这个环
即此时中间节点为：1~k-1，即我们已经算出了任意i<->j的最短道路，中间经过的节点可以为 (1,2,3,…,k-1)
我们只需枚举所有以k为环中最大节点的环即可。

pos[i][j]:i~j的最短路中经过的点是k(即由这个状态转移过来)，且这个k是此路径中编号最大的点(除i,j)//根据Floyd算法实质决定
这条道路存在以下两条性质
1.在i~j的最短道路中，一定没有环(显然)
2.设i,j之间的最短道路经过点k(不同于i,j)，则i~k , k~j之间必然没有交集

2证：
如果有交集,设交点为k’(k’ < k,根据Floyd算法实质相关)，则存在道路：
i<->k’<->j , 由于[i<->k’] < [i<->k] , [j->k’] < [j->k]
显然这条道路更小，和假设矛盾所以一定没有交集

对于pos[i][j]，如果pos[i][j] == 0 : 说明i~j的最短路没有经过其他节点

因此借用性质2来求解道路，注意书写顺序，确保最后输出顺序正确
每次把i <-> j 之间划分成 i<->k , k<->j

C++ 代码
#include <iostream>
#include <cstring>
#include <string>
#include <vector>

using namespace std ;

const int N = 110 , M = 10010 , INF = 0x3f3f3f3f ;


typedef long long LL ;
int g[N][N] , d[N][N] ;
int pos[N][N] ; //记录当前状态由哪个点转移过来
vector<int> path ;
int n , m ;

//确保顺序正确
void dfs(int i , int j )    //i->j之间的路，输出i到j之间不包括i和j的道路
{
    int k = pos[i][j] ;

    if( k == 0 )    return ;    //如果是0，说明i,j之间不经过除i，j之外的其他点

    dfs(i , k); //i->newk
    path.push_back(k);  //k
    dfs(k , j); //newk->j

}

void get_path(int i , int j , int k )
{
    path.clear() ;
    path.push_back(k);  //边界
    path.push_back(i);
    dfs(i , j) ;    //k->i->j->k
    path.push_back(j);
}

int main()
{
    cin >> n >> m ; 

    memset(g , 0x3f ,sizeof g) ;
    for(int i = 0 ; i <= n ; i++ )  g[i][i] = 0 ;

    int a , b , c ;
    for(int i = 0 ; i < m ; i++ )
    {
        cin >> a >> b >> c ;
        g[a][b] = g[b][a] = min(g[a][b] , c) ;
    }

    memcpy(d , g , sizeof d );  //原图
    long long res = INF ;

    for(int k = 1 ; k <= n ; k++ )
    {
        //至少包含三个点的环所经过的点的最大编号是k
        for(int i = 1 ; i < k ; i++ )  //至少包含三个点，i，j，k不重合
            for(int j = i + 1 ; j < k ; j ++ )
            if(res > (LL)g[i][j] + d[i][k] + d[k][j] )
            {
                res = g[i][j] + d[i][k] + d[k][j] ;
                get_path(i , j , k) ;
            }

        for(int i = 1 ; i <= n ; i++ )
            for(int j = 1 ; j <= n ; j++ )
                if(g[i][j] > g[i][k] + g[k][j])
                {
                    g[i][j] = g[i][k] + g[k][j] ;
                    pos[i][j] = k ; 
                }
    }

    if(res == INF)  
        cout << "No solution." << endl;
    else
    {
        for(auto x : path)
            cout << x << ' ' ;
        cout << endl;
    }

    return 0;
}

作者：麻烦写注释
链接：https://www.acwing.com/solution/content/9256/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, INF = 0x3f3f3f3f;

int n, m;
int d[N][N], g[N][N];
int pos[N][N];
int path[N], cnt;

void get_path(int i, int j)
{
    if (pos[i][j] == 0) return;

    int k = pos[i][j];
    get_path(i, k);
    path[cnt ++ ] = k;
    get_path(k, j);
}

int main()
{
    cin >> n >> m;

    memset(g, 0x3f, sizeof g);
    for (int i = 1; i <= n; i ++ ) g[i][i] = 0;

    while (m -- )
    {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }

    int res = INF;
    memcpy(d, g, sizeof d);
    for (int k = 1; k <= n; k ++ )
    {
        for (int i = 1; i < k; i ++ )
            for (int j = i + 1; j < k; j ++ )
                if ((long long)d[i][j] + g[j][k] + g[k][i] < res)
                {
                    res = d[i][j] + g[j][k] + g[k][i];
                    cnt = 0;
                    path[cnt ++ ] = k;
                    path[cnt ++ ] = i;
                    get_path(i, j);
                    path[cnt ++ ] = j;
                }

        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                if (d[i][j] > d[i][k] + d[k][j])
                {
                    d[i][j] = d[i][k] + d[k][j];
                    pos[i][j] = k;
                }
    }

    if (res == INF) puts("No solution.");
    else
    {
        for (int i = 0; i < cnt; i ++ ) cout << path[i] << ' ';
        cout << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/146018/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



AcWing 345. 牛站 非矩阵乘法做法大杂烩    原题链接    中等
作者：    墨染空 ,  2019-11-10 20:05:08 ,  阅读 852

16


4
由于我太菜了，不会矩阵乘法，所以给同样不会矩阵乘法同学的福利

首先发现这题点很多边很少，实际上有用的点 <=2∗T<=2∗T（因为每条边会触及两个点嘛）

所以我们可以把点的范围缩到 2∗T2∗T来，然后…

算法1 Bellman - Ford O(NT)O(NT)
什么，限制边数？那不就是可爱的 BellmanFordBellmanFord吗？

看看复杂度，嗯嗯 108108 海星，常数超小的我肯定不用吸氧的

#pragma GCC optimize(2)
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
const int N = 205, M = 105;
struct Edge{
    int u, v, w;
}e[M];
int m, n, s, t, adj[N], dis[N], bDis[N], tot;
void inline read(int &x) {
    x = 0;
    char s = getchar();
    while(s > '9' || s < '0') s = getchar();
    while(s <= '9' && s >= '0') x = x * 10 + s - '0', s = getchar();
}
int inline get(int &x) {
    return lower_bound(adj + 1, adj + 1 + tot, x) - adj;
}

int inline bellmanFord(){
    memset(dis, 0x3f, sizeof dis);
    dis[s] = 0;
    for(register int i = 1; i <= n; i++){
        memcpy(bDis, dis, sizeof dis);
        memset(dis, 0x3f, sizeof dis);
        for(register int j = 1; j <= m; j++){
            dis[e[j].v] = min(dis[e[j].v], bDis[e[j].u] + e[j].w);
            dis[e[j].u] = min(dis[e[j].u], bDis[e[j].v] + e[j].w);
        }
    }
    return dis[t];
}



int main(){
    read(n); read(m); read(s); read(t);
    for (register int i = 1; i <= m; i++) {
        read(e[i].w); read(e[i].u); read(e[i].v);
        adj[++tot] = e[i].u;
        adj[++tot] = e[i].v;
    }
    sort(adj + 1, adj + 1 + tot);
    tot = unique(adj + 1, adj + 1 + tot) - adj - 1;
    for (register int i = 1; i <= m; i++) {
        e[i].u = get(e[i].u), e[i].v = get(e[i].v);
    }
    s = get(s), t = get(t);
    printf("%d\n", bellmanFord());
    return 0;
}
真香

算法2 倍增 + Floyd O(T3∗log2N)O(T3∗log2N)
据说这题正解要用矩阵乘法，可我不会，咋办呢？

不如用倍增的思想，把NN拆成二进制下的多个11，我们把每个‘1′‘1′最短路搞出来，然后拼出来最终的最短路，先预处理：

d[i][j][l]d[i][j][l] 表示从 ii 到 jj 恰好经过 2l2l 条边的最短路。

初始化 d[i][j][0]=w[i][j]d[i][j][0]=w[i][j]，剩下为正无穷（注意是恰好 NN 条边，所以 d[i][i][0]d[i][i][0] 也是非法状态）

转移也很好想：

d[i][j][l]=min(d[i][k][l−1]+d[k][j][l−1])d[i][j][l]=min(d[i][k][l−1]+d[k][j][l−1])，对于一个状态 d[i][j][l]d[i][j][l]，枚举中间点 kk 即可，所以预处理复杂度 O(T3∗log2N)O(T3∗log2N)
接下来用二进制拼起来就行辣~，设 g[i]g[i] 为这前几部走完后，从 ss 到 ii 的最短路， f[i]f[i] 为当前到 ii 的最短路，与保卫王国的拼凑法思想差不多，即：

f[i]=min(g[j]+d[j][i][c])f[i]=min(g[j]+d[j][i][c]) 若 NN 的二进制第 cc 位为 11。

#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
const int N = 205, M = 105;
struct Edge{
    int u, v, w;
}e[M];
int m, n, s, t, adj[N], tot, d[N][N][20], f[N], g[N];
int L;

int inline get(int x) {
    return lower_bound(adj + 1, adj + 1 + tot, x) - adj;
}
int main(){
    memset(d, 0x3f, sizeof d);
    scanf("%d%d%d%d", &n, &m, &s, &t);
    L = log2(n);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &e[i].w, &e[i].u, &e[i].v);
        adj[++tot] = e[i].u;
        adj[++tot] = e[i].v;
    }
    sort(adj + 1, adj + 1 + tot);
    tot = unique(adj + 1, adj + 1 + tot) - adj - 1;
    for (int i = 1; i <= m; i++) {
        int u = get(e[i].u), v = get(e[i].v), w = e[i].w;
        d[u][v][0] = d[v][u][0] = min(d[u][v][0], w);
    }
    s = get(s), t = get(t);

    for (int c = 1; c <= L; c++) {
        for (int i = 1; i <= tot; i++) {
            for (int j = 1; j <= tot; j++) {
                for (int k = 1; k <= tot; k++) {
                    d[i][j][c] = min(d[i][j][c], d[i][k][c - 1] + d[k][j][c - 1]);
                }
            }
        }
    }

    memset(g, 0x3f, sizeof g);
    g[s] = 0;
    for (int c = 0; c <= L; c++) {
        if(n >> c & 1) {
            memset(f, 0x3f, sizeof f);
            for (int i = 1; i <= tot; i++) 
                for (int j = 1; j <= tot; j++)
                    f[i] = min(f[i], g[j] + d[j][i][c]);
            memcpy(g, f, sizeof g);
        }
    }
    printf("%d\n", f[t]);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/solution/content/6111/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>
#include <map>

using namespace std;

const int N = 210;

int k, n, m, S, E;
int g[N][N];
int res[N][N];

void mul(int c[][N], int a[][N], int b[][N])
{
    static int temp[N][N];
    memset(temp, 0x3f, sizeof temp);
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                temp[i][j] = min(temp[i][j], a[i][k] + b[k][j]);
    memcpy(c, temp, sizeof temp);
}

void qmi()
{
    memset(res, 0x3f, sizeof res);
    for (int i = 1; i <= n; i ++ ) res[i][i] = 0;

    while (k)
    {
        if (k & 1) mul(res, res, g);    // res = res * g
        mul(g, g, g);   // g = g * g
        k >>= 1;
    }
}

int main()
{
    cin >> k >> m >> S >> E;

    memset(g, 0x3f, sizeof g);
    map<int, int> ids;
    if (!ids.count(S)) ids[S] = ++ n;
    if (!ids.count(E)) ids[E] = ++ n;
    S = ids[S], E = ids[E];

    while (m -- )
    {
        int a, b, c;
        cin >> c >> a >> b;
        if (!ids.count(a)) ids[a] = ++ n;
        if (!ids.count(b)) ids[b] = ++ n;
        a = ids[a], b = ids[b];

        g[a][b] = g[b][a] = min(g[a][b], c);
    }

    qmi();

    cout << res[S][E] << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/146113/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



AcWing 1140. 最短网络    原题链接    简单
作者：    Overnoise ,  2019-11-24 13:42:49 ,  阅读 727

3


就是一个最小生成树模板
我使用的是并查集来建立最小生成树
按距离排序之后就使用并查集判断是否填入此边
具体看代码

#include<bits/stdc++.h>
using namespace std;
struct oppo{
    int from,to,s;
}rood[100000];//存边 
int tot;//记录边的个数 
bool rule(oppo a,oppo b)
{
    return a.s<b.s;
}
int n;//农场的个数 
int x;//en。。。   输入用 
int fa[105];//并查集 
int ans;
int find(int x)//并查集 
{
    return fa[x]==x?x:fa[x]=find(fa[x]);//返回和路径压缩 
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            scanf("%d",&x);
            if(i>j)//防止重复建边，i到j相当于j到i 
            {
                rood[++tot].from=i;
                rood[tot].to=j;
                rood[tot].s=x;      
            }   
        }
    sort(rood+1,rood+tot+1,rule);//c++ 的快乐库函数
    for(int i=1;i<=n;i++)//初始化并查集 
        fa[i]=i;
    for(int i=1;i<=tot;i++)
    {
        int a=find(rood[i].from);
        int b=find(rood[i].to);
        if(a!=b)
        {
            ans+=rood[i].s;
            fa[a]=b;
        }
    }
    cout<<ans<<endl;
    return 0;
}

作者：Overnoise
链接：https://www.acwing.com/solution/content/6497/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
int w[N][N];
int dist[N];
bool st[N];

int prim()
{
    int res = 0;
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], w[t][j]);
    }

    return res;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            cin >> w[i][j];

    cout << prim() << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/148031/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1141. 局域网 prim算法    原题链接    简单
作者：    垫底抽风 ,  2020-06-23 16:33:32 ,  阅读 201

17


1
题目描述
某个局域网内有 nn 台计算机和 kk 条 双向 网线，计算机的编号是 1∼n1∼n。由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。

注意：

对于某一个连接，虽然它是双向的，但我们不将其当做回路。本题中所描述的回路至少要包含两条不同的连接。
两台计算机之间最多只会存在一条连接。
不存在一条连接，它所连接的两端是同一台计算机。
因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 f(i,j)f(i,j) 表示 i,ji,j 之间连接的畅通程度，f(i,j)f(i,j) 值越小表示 i,ji,j 之间连接越通畅。

现在我们需要解决回路问题，我们将除去一些连线，使得网络中没有回路且不影响连通性（即如果之前某两个点是连通的，去完之后也必须是连通的），并且被除去网线的 ∑f(i,j)∑f(i,j) 最大，请求出这个最大值。

输入格式
第一行两个正整数 n,kn,k。

接下来的 kk 行每行三个正整数 i,j,mi,j,m 表示 i,ji,j 两台计算机之间有网线联通，通畅程度为 mm。

输出格式
一个正整数，表示被除去网线的 ∑f(i,j)∑f(i,j) 的最大值。

数据范围
1≤n≤1001≤n≤100
0≤k≤2000≤k≤200
1≤f(i,j)≤10001≤f(i,j)≤1000
输入样例：
5 5
1 2 8
1 3 1
1 5 3
2 4 5
3 4 2
输出样例：
8
算法1
(prim) (n2)O(n2)
题意：给定一张有 nn 个点，kk 条边的无向有环图。要求删掉其中部分边，且不改变图的连通性的情况下，使图中无环且所删边和最大，输出最大的所删边边权权和。

删边权和最大 →→ 剩下边权和最小 →→ 求最小生成树

但是题中并没有说图一定联通，这让这道题恶心了很多。

图不连通，就要先求出连通块，然后对每个连通块，求出其最小生成树。

当然，更巧妙的算法是用 kruskalkruskal，但是用 kruskalkruskal 的题解太多了，这里给出 primprim 的代码。

C++ 代码
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

const int N = 205;

int n, k;           // n 为图中点数，k 为图中边数
int total;          // 存图上所有边的权值总和
int g[N][N];        // prim 存图用的邻接矩阵
vector<int> dcc[N]; // 存所有的连通块
int dcc_cnt;        // 存连通块的数量
int dist[N];        // prim 存到每个点最近的距离用的 dist
bool st[N];         // 一个 st 两用，先用于求连通块，再在 prim 里面每个点是否在生成树中

void dfs(int u)     // dfs 求出所有的连通块
{
    st[u] = true;   // 先将 u 制成 true，表示已经加入已有连通块中了
    dcc[dcc_cnt].push_back(u); // 将点 u 放入该连通块
    for (int i = 1; i <= n; i ++ ) // 从 1 到 n 枚举所有点
        if (g[u][i] < 0x3f3f3f3f && !st[i]) // 如果该点 i 能从 u 走过去，且没加入已有连通块中
            dfs(i); // 那么搜索点 i
}

int prim(int u)     // prim 求连通块 u 中的最小生成树
{
    int res = 0;    // res 记录生成树的大小
    memset(dist, 0x3f, sizeof dist); // 将 dist 制为正无穷
    memset(st, false, sizeof st);    // 由于要多次使用 st，所以每次要先将 st 制成 false
    for (int i = 0; i < dcc[u].size(); i ++ ) // 扩展 dcc[u].size() 次
    {
        int t = -1;
        for (int j = 0; j < dcc[u].size(); j ++ ) // 枚举一下当前连通块 u 中所有点
        {
            int ver = dcc[u][j];                  // 将该点取出
            if (!st[ver] && (t == -1 || dist[t] > dist[ver])) // 如果该点不在生成树中且到该点的距离大于到点 t 的距离
                t = ver;                          // 那么让将 t 改为该点
        }
        if (i) res += dist[t];                    // res 加上到已有生成树中距离最近的点到已有生成树的距离
        st[t] = true;                             // 将该点 t 加入已有生成树
        for (int j = 0; j < dcc[u].size(); j ++ ) // 更新当前连通块中所有点
        {
            int ver = dcc[u][j];                  // 将该点取出
            dist[ver] = min(dist[ver], g[t][ver]);// 更新该点距离
        }
    }
    return res;     // 返回该生成树的大小
}

int main()
{
    scanf("%d%d", &n, &k);
    memset(g, 0x3f, sizeof g); // 将图中所有边的距离初始化为正无穷
    for (int i = 0; i < k; i ++ ) // 读入图
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        g[a][b] = g[b][a] = min(g[a][b], c);
        total += c;
    }
    for (int i = 1; i <= n; i ++ ) // 枚举所有点，求连通块
        if (!st[i])                // 如果该点没有加入已有的任何联通块
        {
            dcc_cnt ++ ;           // 那么建立一个新的连通块
            dfs(i);                // 将该点及该点能到的所有点加入新建的连通块
        }
    for (int i = 1; i <= dcc_cnt; i ++ ) // 枚举所有连通块，求出所有连通块的最小生成树
        total -= prim(i);          // 总权值和减去该最小生成树的大小
    printf("%d\n", total);         // 输出剩下的权值和
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/solution/content/15172/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, M = 210;

int n, m;
struct Edge
{
    int a, b, w;
    bool operator< (const Edge &t)const
    {
        return w < t.w;
    }
}e[M];
int p[N];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    for (int i = 0; i < m; i ++ )
    {
        int a, b, w;
        cin >> a >> b >> w;
        e[i] = {a, b, w};
    }

    sort(e, e + m);

    int res = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = find(e[i].a), b = find(e[i].b), w = e[i].w;
        if (a != b) p[a] = b;
        else res += w;
    }

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/148059/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1142. 繁忙的都市    原题链接    简单
作者：    小呆呆 ,  2020-02-17 18:25:19 ,  阅读 154

5


算法分析
普通的最小生成树：所有边权之和最小

本题的最小生成树：最大的边权最小

在这里我深刻的意识到kruskal本质是让点按照某个规律进行连通，res是特有的属性

做法：kruskal

1、将所有边从小到大排序

2、枚举每条边a,b,权值是w

if a和b不连通，将a，b加进集合，且更新res
时间复杂度 O(mlogm)O(mlogm)
参考文献
算法提高课

Java 代码
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {
    static int N = 310, M = 10010;
    static int n,m;
    static Edge[] edge = new Edge[M];
    static int[] p = new int[N];
    static int find(int x)
    {
        if(p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    static int kruskal()
    {
        int res = 0;
        Arrays.sort(edge,0,m);

        for(int i = 0;i < m;i ++)
        {
            int a = edge[i].a;
            int b = edge[i].b;
            int w = edge[i].w;
            a = find(a);
            b = find(b);
            if(a != b)
            {
                p[a] = b;
                res = w;
            }
        }
        return res;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] s1 = br.readLine().split(" ");
        n = Integer.parseInt(s1[0]);
        m = Integer.parseInt(s1[1]);
        for(int i = 0;i < m;i ++)
        {
            String[] s2 = br.readLine().split(" ");
            int a = Integer.parseInt(s2[0]);
            int b = Integer.parseInt(s2[1]);
            int w = Integer.parseInt(s2[2]);
            edge[i] = new Edge(a,b,w);
        }

        for(int i = 1;i <= n;i ++) p[i] = i;

        System.out.println(n - 1 + " " + kruskal());

    }
}
class Edge implements Comparable<Edge>
{
    int a,b,w;
    Edge(int a,int b,int w)
    {
        this.a = a;
        this.b = b;
        this.w = w;
    }
    @Override
    public int compareTo(Edge o) {
        // TODO 自动生成的方法存根
        return Integer.compare(w, o.w);
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/8683/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


    #include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 310, M = 10010;

int n, m;
struct Edge
{
    int a, b, w;
    bool operator< (const Edge &t) const
    {
        return w < t.w;
    }
}e[M];
int p[N];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) p[i] = i;
    for (int i = 0; i < m; i ++ )
    {
        int a, b, w;
        cin >> a >> b >> w;
        e[i] = {a, b, w};
    }
    sort(e, e + m);

    int res = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = find(e[i].a), b = find(e[i].b), w = e[i].w;
        if (a != b)
        {
            p[a] = b;
            res = w;
        }
    }

    cout << n - 1 << ' ' << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/148078/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1143. 联络员    原题链接    简单
作者：    yingzhaoyang ,  2019-11-24 20:03:49 ,  阅读 201

3


克鲁斯卡尔算法求最小生成树
这道题的难度不大,主要是因为有必选边.
其实可以在输入时就优先处理必选边.
剩下的就是常规的最小生成树了.
具体看代码注释.

时间复杂度 O(nlogn)O(nlogn)
C++ 代码
#include<bits/stdc++.h>
#define N 2010
#define M 10010
using namespace std;
struct node{
    int type,from,to,dis;//type记录当前边的类型,from记录当前边的起点,to记录当前边的终点,dis记录当前边的权值
}e[M];
int n,m,fa[N],k,tot;//k记录当前已选择了几条边,tot记录最终的权值
int find(int x)//并查集基本操作
{
    if(fa[x]==x)
        return x;
    return fa[x]=find(fa[x]);
}
inline void merge(int x,int y)//并查集基本操作
{
    fa[find(y)]=find(x);
}
bool rule(const node &x,const node &y)//按边权从小到大排序
{
    return x.dis<y.dis;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)//并查集初始化
        fa[i]=i;
    for(int i=1;i<=m;i++){
        scanf("%d %d %d %d",&e[i].type,&e[i].from,&e[i].to,&e[i].dis);
        int type=e[i].type,u=e[i].from,v=e[i].to,d=e[i].dis;
        if(type==1){//如果是必选边
            tot+=d;//注意题目要求要加入所有的从u到v的必选边
            if(find(u)!=find(v)){//当前两点不连通
                merge(u,v);//合并
                k++;//边数加一
            }
        }
    }
    sort(e+1,e+1+m,rule);
    for(int i=1;i<=m;i++){//克鲁斯卡尔算法求最小生成树
        if(k==n-1)
            break;
        int type=e[i].type,u=e[i].from,v=e[i].to,d=e[i].dis;
        if(type==1)//必选边已经处理了,直接跳过
            continue;
        if(find(u)!=find(v)){
            merge(u,v);
            tot+=d;
            k++;
        }
    }
    printf("%d\n",tot);
    return 0;//完结撒花
}

作者：yingzhaoyang
链接：https://www.acwing.com/solution/content/6531/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2010, M = 10010;

int n, m;
struct Edge
{
    int a, b, w;
    bool operator< (const Edge &t) const
    {
        return w < t.w;
    }
}e[M];
int p[N];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    int res = 0, k = 0;
    for (int i = 0; i < m; i ++ )
    {
        int t, a, b, w;
        cin >> t >> a >> b >> w;
        if (t == 1)
        {
            res += w;
            p[find(a)] = find(b);
        }
        else e[k ++ ] = {a, b, w};
    }

    sort(e, e + k);

    for (int i = 0; i < k; i ++ )
    {
        int a = find(e[i].a), b = find(e[i].b), w = e[i].w;
        if (a != b)
        {
            p[a] = b;
            res += w;
        }
    }

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/148113/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1144. 连接格点    原题链接    简单
作者：    yingzhaoyang ,  2019-11-24 21:38:56 ,  阅读 313

10


自己yy的算法
自己yy一波....
我们其实可以将每一个点看做一个数.
然后再用类似求最小生成树的方法分别从横向和纵向分别依次合并相邻两点.
如果当前相邻的两点没有连接,就将其合并,边合并边记录答案.

(注意下文中的坐标均指在C++二维数组表示下的坐标)
接下来说一下将坐标转化为数字,其实就相当于给每一个坐标一个编号,那么
我们就将每一个坐标通过一个特定的规则转换为其对应的编号.

具体怎么做,
在此举一个例子:(以n=3,m=5为例)
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
通过这个矩阵,我们顺利的将每一个坐标编上了序号.
例如:坐标(1,1)的编号为1,坐标(1,2)的编号为2,
坐标(2,2)的编号为7,坐标(2,1)的编号为6,以此类推.

容易看出:如果当前的坐标为(x,y),那么他对应的编号就是(x-1)*m+y.

解决了这个问题,剩下的简直就是小儿科了…

时间复杂度 应该是O(nlogn)O(nlogn)吧....
C++ 代码
#include<bits/stdc++.h>
#define N 1010
using namespace std;
int n,m;
int fa[N*N],tot;
int find(int x)//并查集基本操作
{
    if(fa[x]==x)
        return x;
    return fa[x]=find(fa[x]);
}
inline int merge(int x,int y)//并查集基本操作
{
    int fa_x=find(x);
    int fa_y=find(y);
    if(fa_x!=fa_y){
        fa[fa_y]=fa_x;
        return 1;//已经连了一条边
    }
    return 0;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n*m;i++)//并查集初始化
       fa[i]=i;
    int x1,y1,x2,y2;
    while(~scanf("%d %d %d %d",&x1,&y1,&x2,&y2)){
        int u=(x1-1)*m+y1,v=(x2-1)*m+y2;//转换为对应的编号
        merge(u,v);//合并
    }
    for(int i=1;i<=m;i++)//竖向合并一遍
        for(int j=1;j<n;j++){
            int u=(j-1)*m+i,v=j*m+i;//坐标转换
            if(merge(u,v))//当前两点有一条边连接
                tot++;//竖向答案+1
        }
    for(int i=1;i<=n;i++)//横向合并一遍
        for(int j=1;j<m;j++){
            int u=(i-1)*m+j,v=(i-1)*m+j+1;//坐标转换
            if(merge(u,v))//当前两点有一条边连接
                tot+=2;//横向答案+2
        }
    printf("%d\n",tot);
    return 0;
}

作者：yingzhaoyang
链接：https://www.acwing.com/solution/content/6541/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, M = N * N, K = 2 * N * N;

int n, m, k;
int ids[N][N];
struct Edge
{
    int a, b, w;
}e[K];
int p[M];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void get_edges()
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}, dw[4] = {1, 2, 1, 2};

    for (int z = 0; z < 2; z ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
                for (int u = 0; u < 4; u ++ )
                    if (u % 2 == z)
                    {
                        int x = i + dx[u], y = j + dy[u], w = dw[u];
                        if (x && x <= n && y && y <= m)
                        {
                            int a = ids[i][j], b = ids[x][y];
                            if (a < b) e[k ++ ] = {a, b, w};
                        }
                    }
}

int main()
{
    cin >> n >> m;

    for (int i = 1, t = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++, t ++ )
            ids[i][j] = t;

    for (int i = 1; i <= n * m; i ++ ) p[i] = i;

    int x1, y1, x2, y2;
    while (cin >> x1 >> y1 >> x2 >> y2)
    {
        int a = ids[x1][y1], b = ids[x2][y2];
        p[find(a)] = find(b);
    }

    get_edges();

    int res = 0;
    for (int i = 0; i < k; i ++ )
    {
        int a = find(e[i].a), b = find(e[i].b), w = e[i].w;
        if (a != b)
        {
            p[a] = b;
            res += w;
        }
    }

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/148150/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <iostream>
using namespace std;
const int N = 1005;
int n, m, f[N * N], res = 0;
int get(int x) {
    return x == f[x] ? x : f[x] = get(f[x]);
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n * m; i++) f[i] = i;
    int x1, y1, x2, y2;
    while(~scanf("%d%d%d%d", &x1, &y1, &x2, &y2)) {
        int a = (x1 - 1) * m + y1, b = (x2 - 1) * m + y2;
        f[get(a)] = get(b);
    }

    for (int i = 1; i < n; i++) {
        for (int j = 1; j <= m; j++) {
            int a = (i - 1) * m + j, b = i * m + j;
            a = get(a), b = get(b);
            if(a != b) res++, f[a] = b;
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j < m; j++) {
            int a = (i - 1) * m + j, b = (i - 1) * m + j + 1;
            a = get(a), b = get(b);
            if(a != b) res += 2, f[a] = b;
        }
    }
    printf("%d\n", res);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/148232/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1146. 新的开始    原题链接    中等
作者：    yingzhaoyang ,  2019-11-26 08:53:15 ,  阅读 279

6


最小生成树的扩展应用
对于这道题,我们可以假设一个虚拟的”超级发电站”.
而在每一个矿井修建发电站就相当于是从超级发电站向其连一条权值为v[i]的边.
之后我们惊奇的发现这就是一道最小生成树的模板题.
直接上克鲁斯卡尔算法即可..

时间复杂度 O(nlogn)O(nlogn)
C++ 代码
#include<bits/stdc++.h>
#define N 310
using namespace std;
struct node{
    int from,to,dis;
}e[N*N];
int n,v,p[N][N];
int fa[N],tot,cnt,ans;
bool rule(const node &x,const node &y)//按边权从小到大排序
{
    return x.dis<y.dis;
}
int find(int x)//并查集基本操作
{
    if(fa[x]==x)
        return x;
    return fa[x]=find(fa[x]);
}
inline void merge(int x,int y)//并查集基本操作
{
    fa[find(y)]=find(x);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n+1;i++)//并查集初始化
        fa[i]=i;
    for(int i=1;i<=n;i++){
        scanf("%d",&v);
        e[++tot].from=n+1;//从"超级发电站"向该点连一条权值为v的边
        e[tot].to=i;
        e[tot].dis=v;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&p[i][j]);
    for(int i=1;i<n;i++)
        for(int j=i+1;j<=n;j++){
            e[++tot].from=i;
            e[tot].to=j;
            e[tot].dis=p[i][j];
        }
    sort(e+1,e+1+tot,rule);
    for(int i=1;i<=tot;i++){//标准克鲁斯卡尔算法
        int u=e[i].from,v=e[i].to;
        if(find(u)!=find(v)){
            merge(u,v);
            ans+=e[i].dis;
        }
    }
    printf("%d\n",ans);
    return 0;
}

作者：yingzhaoyang
链接：https://www.acwing.com/solution/content/6568/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 310;

int n;
int w[N][N];
int dist[N];
bool st[N];

int prim()
{
    memset(dist, 0x3f, sizeof dist);
    dist[0] = 0;

    int res = 0;
    for (int i = 0; i < n + 1; i ++ )
    {
        int t = -1;
        for (int j = 0; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        res += dist[t];

        for (int j = 0; j <= n; j ++ ) dist[j] = min(dist[j], w[t][j]);
    }

    return res;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
    {
        scanf("%d", &w[0][i]);
        w[i][0] = w[0][i];
    }

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            scanf("%d", &w[i][j]);

    printf("%d\n", prim());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/151256/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1145. 北极通讯网络    原题链接    中等
作者：    术皓 ,  2019-11-22 14:43:14 ,  阅读 315

9


养成先点赞后阅读的好习惯
逃

题目描述
这道题用贪心的思想想一下
就是叫我们先跑一遍最小生成树，然后再删除前k大的边，再输出最大的那条边。（蒟蒻一枚，勿喷）

最小生成树
C++ 代码
#include<bits/stdc++.h>
using namespace std;
const int N=555;

template<class T>void read(T &x)//快读
{
    x=0;bool f=0;char ch=getchar();
    while(ch<'0'||ch>'9') {f|=(ch=='-');ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    x=f?-x:x;
    return;
}

struct stt
{
    int x,y;
}a[555];
struct st
{
    int s,e;
    double d;
}b[555*400];

bool cap(st a,st b)
{
    return a.d<b.d;
}

double js(stt a,stt b)
{
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}//求距离

int f[N];
int n,k;
int cnt;//记录共有多少条边
int get(int x)
{
    if(x==f[x]) return x;
    return f[x]=get(f[x]);
}

int nn;
int main()
{
    read(n),read(k);
    for(int i=1;i<=n;i++)
        read(a[i].x),read(a[i].y),f[i]=i;
    for(int i=1;i<n;i++)
    for(int j=i+1;j<=n;j++)
        b[++cnt].s=i,b[cnt].e=j,b[cnt].d=js(a[i],a[j]);//加入每条边
    //Kruskal算法
    sort(b+1,b+cnt+1,cap);
    for(int i=1;i<=cnt;i++)
    {
        int a=get(b[i].s),bbb=get(b[i].e);
        if(a==bbb) continue;
        nn++;//记录已经加入了多少边
        f[a]=bbb;
        if(nn==n-k)//还剩k条边，即这条边是第k+1大的
        {
            printf("%.2lf",b[i].d);
            return 0;
        }
    }
    return 0;
}

作者：术皓
链接：https://www.acwing.com/solution/content/6438/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 510, M = N * N / 2;

int n, k, m;
struct Edge
{
    int a, b;
    double w;
    bool operator< (const Edge &t) const
    {
        return w < t.w;
    }
}e[M];
PII q[M];
int p[N];

double get_dist(PII a, PII b)
{
    int dx = a.x - b.x;
    int dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> k;
    for (int i = 0; i < n; i ++ ) cin >> q[i].x >> q[i].y;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < i; j ++ )
            e[m ++ ] = {i, j, get_dist(q[i], q[j])};

    sort(e, e + m);
    for (int i = 0; i < n; i ++ ) p[i] = i;

    int cnt = n;
    double res = 0;
    for (int i = 0; i < m; i ++ )
    {
        if (cnt <= k) break;

        int a = find(e[i].a), b = find(e[i].b);
        double w = e[i].w;
        if (a != b)
        {
            p[a] = b;
            cnt -- ;
            res = w;
        }
    }

    printf("%.2lf\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/151271/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 346. 走廊泼水节    原题链接    中等
作者：    Overnoise ,  2019-11-26 08:46:54 ,  阅读 870

3


改一下最小生成树模板就能过辣
在并查集求最小生成树模板上加一个tot数组存这个并查集内节点的个数，再跑最小生成树模板统计答案就AC辣
#include<bits/stdc++.h>
using namespace std;
struct oppo {
    int from,to,s;
} rood[9000000];
int fa[7000];
int tot[7000];
int find(int x) {
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
bool rule(oppo a,oppo b) {
    return a.s<b.s;
}
int n,T;
int ans;
int main() {
    cin>>T;
    while(T--) {
        cin>>n;
        ans=0;
        for(int i=1; i<n; i++)
            scanf("%d%d%d",&rood[i].from,&rood[i].to,&rood[i].s);
        for(int i=1; i<=n; i++) {
            fa[i]=i;
            tot[i]=1;
        }
        sort(rood+1,rood+n,rule);
        for(int i=1; i<n; i++) {
            int a=find(rood[i].from);
            int b=find(rood[i].to);
            fa[b]=a;
            ans+=(rood[i].s+1)*(tot[a]*tot[b]-1);
            tot[a]+=tot[b];
        }
        cout<<ans<<endl;
    }
    return 0;
}

作者：Overnoise
链接：https://www.acwing.com/solution/content/6567/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 346. 走廊泼水节    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-06-12 22:10:06 ,  阅读 1058

13


5
更好的阅读体验

题目描述
给定一棵N个节点的树，要求增加若干条边，把这棵树扩充为完全图，并满足图的唯一最小生成树仍然是这棵树。

求增加的边的权值总和最小是多少。

输入格式
第一行包含整数t，表示共有t组测试数据。

对于每组测试数据，第一行包含整数N。

接下来N-1行，每行三个整数X,Y,Z，表示X节点与Y节点之间存在一条边，长度为Z。

输出格式
每组数据输出一个整数，表示权值总和最小值。

每个结果占一行。

数据范围
N≤6000,Z≤100N≤6000,Z≤100
输入样例：
2
3
1 2 2
1 3 3
4
1 2 3
2 3 4
3 4 5 
输出样例：
4
17 
解题报告
题意理解
这道题目说的很清楚,就是让我们将一个最小生成树的图,添加一些边,使得这张图成为一个完全图.

但是我们这张图的最小生成树,必须还是原来那张图的最小生成树.

也就是说两张图的最小生成树表示是一模一样的.

算法解析
根据上面的信息,我们不难发现这道题目和最小生成树算法联系紧密,那么现在我们的主要问题就在于如何去构造最小生成树.

我们可以考虑最小生成树算法中的Kruskal算法.

首先将所有的边按照从小到大的顺序排序.
此时我们保证了是最小生成树的完美生成法则.

对于每一条边(x,y,w)(x,y,w)而言,他们之间有某种关系.
假如说xx和yy不在同一个连通块(集合)之中,也就是他们之间没有边相连

那么我们相连之后,现在这两个点,各自所在的连通块(集合),都拥有了一个最短边,也就是(x,y,w)(x,y,w).

最小生成树是已经确定了,但是对于这原来两个连通块的其他点怎么办?
首先我们设Sx表示为x之前所在的连通块 那么Sy表示为y之前所在的连通块.
首先我们设Sx表示为x之前所在的连通块 那么Sy表示为y之前所在的连通块.

因为我们不能破坏这个最小生成树,所以我们这原来的两个连通块中的点就必须有如下性质.
假如说点A属于Sx这个集合之中 点B属于Sy这个集合之中.
假如说点A属于Sx这个集合之中 点B属于Sy这个集合之中.

那么点AA与点BB之间的距离,必须要大于之前的ww,否则就会破坏之前的最小生成树
所以说(A,B)之间的距离最小为w+1
所以说(A,B)之间的距离最小为w+1
假如说我们知道
Sx有p个元素,然后Sy有q个元素.
Sx有p个元素,然后Sy有q个元素.

那么将
Sx与Sy连通块的所有点相连.
Sx与Sy连通块的所有点相连.

显然这个两个连通块会增加.
p×q−1条边
p×q−1条边

然后每一条边的最小长度为
w+1
w+1

所以我们会得出
(w+1)×(p∗q−1)为两个连通块成为完全图的最小代价
(w+1)×(p∗q−1)为两个连通块成为完全图的最小代价
代码解析
#include <bits/stdc++.h>
using namespace std;
const int N=1e4+100;
int fa[N],n,m,i,j,k,t,s[N];
long long ans;
struct node
{
    int x,y,w;
} edge[N];
bool cmp(node a,node b)
{
    return a.w<b.w;//排序
}
int find(int x)
{
    return fa[x]==x?x:fa[x]=find(fa[x]);//并查集
}
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        for(int i=1;i<n;i++)
            scanf("%d%d%d",&edge[i].x,&edge[i].y,&edge[i].w);
        for(int i=1;i<=n;i++)
            fa[i]=i,s[i]=1;
        sort(edge+1,edge+n,cmp);
        ans=0;
        for(int i=1;i<n;i++)
        {
            int x=find(edge[i].x),y=find(edge[i].y),w=edge[i].w;
            if (x==y)//在同一个连通块之间了
                continue;
            ans+=(long long)(s[x]*s[y]-1)*(w+1);//计算最少路径
            fa[x]=y;//合并
            s[y]+=s[x];//计算连通块大小.
        }
        printf("%lld\n",ans);//输出答案
    }
    return 0;
}
一张NN个节点的图,要求其中每两个节点之间必须有一条边 ↩

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/2456/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 6010;

int n;
struct Edge
{
    int a, b, w;
    bool operator< (const Edge &t) const
    {
        return w < t.w;
    }
}e[N];
int p[N], size[N];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        cin >> n;
        for (int i = 0; i < n - 1; i ++ )
        {
            int a, b, w;
            cin >> a >> b >> w;
            e[i] = {a, b, w};
        }

        sort(e, e + n - 1);
        for (int i = 1; i <= n; i ++ ) p[i] = i, size[i] = 1;

        int res = 0;
        for (int i = 0; i < n - 1; i ++ )
        {
            int a = find(e[i].a), b = find(e[i].b), w = e[i].w;
            if (a != b)
            {
                res += (size[a] * size[b] - 1) * (w + 1);
                size[b] += size[a];
                p[a] = b;
            }
        }

        cout << res << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/151283/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1148. 秘密的牛奶运输=====    原题链接    中等
作者：    xxh ,  2020-02-08 20:34:27 ,  阅读 269

3


题解 ： https://xiaoxiaoh.blog.csdn.net/article/details/104227780

一、内容
秘密的牛奶运输

农夫约翰要把他的牛奶运输到各个销售点。

运输过程中，可以先把牛奶运输到一些销售点，再由这些销售点分别运输到其他销售点。

运输的总距离越小，运输的成本也就越低。

低成本的运输是农夫约翰所希望的。

不过，他并不想让他的竞争对手知道他具体的运输方案，所以他希望采用费用第二小的运输方案而不是最小的。

现在请你帮忙找到该运输方案。

注意：：

如果两个方案至少有一条边不同，则我们认为是不同方案；
费用第二小的方案在数值上一定要严格小于费用最小的方案；
答案保证一定有解；
输入格式
第一行是两个整数 N,M，表示销售点数和交通线路数；

接下来 M 行每行 3 个整数 x,y,z，表示销售点 x 和销售点 y 之间存在线路，长度为 z。
输出格式

输出费用第二小的运输方案的运输总距离。
数据范围

1≤N≤500,
1≤M≤104,
1≤z≤109,
数据中可能包含重边。
输入样例：

4 4
1 2 100
2 4 200
2 3 250
3 4 100
输出样例：

450
二、思路
根据存在次小生成树与最小生成树只差一条边。
我们可以先通过kruskal求出最小生成树 O(mlogm)
通过这个树初始化某点到其他点的路径中最大边、次大边。 O(n^2^)
遍历所有未在树中的边（u–>v）， 看是否大于u到v的边的最大值， 若大于那么可以替换这条边，若不大于那就再判断是否大于次值，若大于同理进行替换。

三、代码
#include <cstdio>
#include <algorithm> 
typedef long long ll; 
using namespace std;
const int N = 505, M = 1e4 + 5;
struct Edge {
    int u, v, w;
    bool in; //in代表这条边是否在树中 
    bool operator < (const Edge&o) const {
        return w < o.w;
    } 
} edge[M]; 
struct E {
    int v, w, next;
} e[N * 2]; //树的边有N-1条*双向
int n, m, len, h[N], md1[N][N], md2[N][N], p[N]; //md[i][j] 代表i到j点的路径上最大的一条边 
int find(int x) { return x == p[x] ? x : (p[x] = find(p[x]));}
void add(int u, int v, int w) {
    e[++len].v = v; e[len].w = w; e[len].next = h[u]; h[u] = len;
}
void dfs(int s, int u, int fa, int mw1, int mw2) {
    //从s起点出发到其他点 
    md1[s][u] = mw1; md2[s][u] = mw2;
    for (int j = h[u]; j; j = e[j].next) {
        int v = e[j].v; 
        int w = e[j].w;
        if (v != fa) {
            int t1, t2; 
            if (w > mw1) t1 = w, t2 = mw1;
            //这里不能相等 
            else if (w < mw1 && w > mw2) t1 = mw1, t2 = w; 
            dfs(s, v, u, t1, t2);
        }
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) p[i] = i; 
    for (int i = 0; i < m; i++) scanf("%d%d%d", &edge[i].u, &edge[i].v, &edge[i].w);
    sort(edge, edge + m);
    //求出最小生成树 
    ll sum = 0; //求出最小生成树的边权和 
    for (int i = 0; i < m; i++) {
        int u = edge[i].u, v = edge[i].v , w = edge[i].w;
        int fu = find(u), fv = find(v);
        if (fu != fv) {
            sum += w;
            add(u, v, w); add(v, u, w); //构成树
            edge[i].in = true; //代表在树中 
            p[fu] = fv;
        }
    }  
    //通过树 求出i到其他点的路径中的最大边
    for (int i = 1; i <= n; i++) dfs(i, i, -1, 0, 0); 
    ll ans = 1e18;
    for (int i = 0; i < m; i++) {
        if (!edge[i].in) {
            //如果这条边不在最小生成树中 考虑替换
            int w = edge[i].w, u = edge[i].u, v = edge[i].v;
            //如果这条边比u到v的路径中的最大边还大 那么可以替换 不然替换了反而变小 
            if (w > md1[u][v]) ans = min(ans, sum + w - md1[u][v]);
            //如果和最大的边相等 那么判断是否大于次大边 
            else if (w > md2[u][v]) ans = min(ans, sum + w - md2[u][v]);
        } 
    }
    printf("%lld", ans);
    return 0;
} 

作者：xxh
链接：https://www.acwing.com/solution/content/8300/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 510, M = 10010;

int n, m;
struct Edge
{
    int a, b, w;
    bool f;
    bool operator< (const Edge &t) const
    {
        return w < t.w;
    }
}edge[M];
int p[N];
int dist1[N][N], dist2[N][N];
int h[N], e[N * 2], w[N * 2], ne[N * 2], idx;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void dfs(int u, int fa, int maxd1, int maxd2, int d1[], int d2[])
{
    d1[u] = maxd1, d2[u] = maxd2;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j != fa)
        {
            int td1 = maxd1, td2 = maxd2;
            if (w[i] > td1) td2 = td1, td1 = w[i];
            else if (w[i] < td1 && w[i] > td2) td2 = w[i];
            dfs(j, u, td1, td2, d1, d2);
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        edge[i] = {a, b, w};
    }

    sort(edge, edge + m);
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    LL sum = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edge[i].a, b = edge[i].b, w = edge[i].w;
        int pa = find(a), pb = find(b);
        if (pa != pb)
        {
            p[pa] = pb;
            sum += w;
            add(a, b, w), add(b, a, w);
            edge[i].f = true;
        }
    }

    for (int i = 1; i <= n; i ++ ) dfs(i, -1, -1e9, -1e9, dist1[i], dist2[i]);

    LL res = 1e18;
    for (int i = 0; i < m; i ++ )
        if (!edge[i].f)
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            LL t;
            if (w > dist1[a][b])
                t = sum + w - dist1[a][b];
            else if (w > dist2[a][b])
                t = sum + w - dist2[a][b];
            res = min(res, t);
        }

    printf("%lld\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/151327/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 904. 虫洞    原题链接    简单
作者：    Overnoise ,  2019-12-08 17:04:42 ,  阅读 792

3


我没有心态辣！！！
这道题卡了我很久。。。。。
首先说说我哪里被坑了吧
1.普通道路双向，虫洞单向（没有读清楚题的悲伤）
2.没有看y总视频就开始自己yy

一看到题，我就想的一个好方法
1.预处理边，把虫洞当成负边处理存入数组（不建图）
2.枚举起点
3.建反图
4.dfs确定起点在反图上可以到达那些点（相当于在正图上，这些点可以到达起点）
5.建正图，如果边的终点不能到达 第2步枚举的起点（参考第4步）就不加入边（避免不必要的边）
6.spfa一波，如果有负换，输出YES，如果没有负环，那么换个起点继续搜

不出我所料，他超时了 ╮(╯﹏╰）╭
我洋洋洒洒102代码啊啊啊啊！！！


超时代码
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
struct oppo {
    int to,s,nest;
} rood[6005];
int head[600],tot;
int n,m,w,a,b,c;
void add(int from,int to,int s) {
    rood[++tot].s=s;
    rood[tot].to=to;
    rood[tot].nest=head[from];
    head[from]=tot;
}
int vis[600];
int f[600];
int all[600];
stack< int > v;
bool spfa(int x) {
    memset(all,0,sizeof(all));
    memset(vis,10,sizeof(vis));
    memset(f,0,sizeof(f));
    vis[x]=0;
    v.push(x);
    while(v.size()) {
        int lxl=v.top();
        f[lxl]=0;
        v.pop();
        for(int i=head[lxl]; i; i=rood[i].nest) {
            if(vis[lxl]+rood[i].s<vis[rood[i].to]) {
                vis[rood[i].to]=vis[lxl]+rood[i].s;
                all[rood[i].to]=all[lxl]+1;
                if(all[rood[i].to]>n||vis[x]<0) {
                    puts("YES");
                    return 0;
                }
                if(!f[rood[i].to]) {
                    f[rood[i].to]=1;
                    v.push(rood[i].to);
                }
            }
        }
    }
    return 1;
}
int from[6005],to[6005],s[6005];
bool h[600];
void dfs(int x) {
    h[x]=1;
    for(int i=head[x]; i; i=rood[i].nest)
        if(!h[rood[i].to])
            dfs(rood[i].to);
}
int main() {
    int T;
    cin>>T;
    while(T--) {
        memset(h,0,sizeof(h));
        tot=0;
        memset(head,0,sizeof(head));
        cin>>n>>m>>w;
        for(int i=1; i<=m; i++) {
            scanf("%d %d %d",&a,&b,&c);
            from[i]=a;
            to[i]=b;
            s[i]=c;
        }
        for(int i=1; i<=w; i++) {
            scanf("%d %d %d",&a,&b,&c);
            from[m+i]=a;
            to[m+i]=b;
            s[m+i]=-c;
        }
        bool flag=1;
        for(int i=1; i<=n&&flag; i++)
        {
            tot=0;
            memset(head,0,sizeof(head));
            for(int j=1;j<=m+w;j++)
            {
                add(to[j],from[j],s[j]);
                if(i<=m)
                    add(from[j],to[j],s[j]);
            }
            memset(h,0,sizeof(h));
            dfs(i);
            tot=0;
            memset(head,0,sizeof(head));
            for(int j=1; j<=m+w; j++)
                if(h[to[j]]) {
                    add(from[j],to[j],s[j]);
                    if(j<=m)
                        add(to[j],from[j],s[j]);
                }
            flag=spfa(i);
        }
        if(flag)
            puts("NO");
    }
    return 0;
}
改代码的途中，我陷入了对信息学的沉思
为什么！！！！
然后我发现，我为什么要枚举起点呢？？？
直接建图，如果有原图有负环，那么起点就在负环上呀！

我靠（小声BB）
就变成简单的判负环辣！！！
代码如下

#include<bits/stdc++.h>
using namespace std;
struct oppo {
    int to,s,nest;
} rood[6005];
int head[600],tot;
int n,m,w,a,b,c;
void add(int from,int to,int s) {
    rood[++tot].s=s;
    rood[tot].to=to;
    rood[tot].nest=head[from];
    head[from]=tot;
}
int vis[600];
int f[600];
int all[600];
stack< int > v;
bool flag[600];
bool spfa(int x) {
    memset(all,0,sizeof(all));
    memset(vis,10,sizeof(vis));
    memset(f,0,sizeof(f));
    vis[x]=0;
    v.push(x);
    while(v.size()) {
        int lxl=v.top();
        flag[lxl]=1;
        f[lxl]=0;
        v.pop();
        for(int i=head[lxl]; i; i=rood[i].nest) {
            if(vis[lxl]+rood[i].s<vis[rood[i].to]) {
                vis[rood[i].to]=vis[lxl]+rood[i].s;
                all[rood[i].to]=all[lxl]+1;
                if(all[rood[i].to]>n) {
                    puts("YES");
                    return 0;
                }
                if(!f[rood[i].to]) {
                    f[rood[i].to]=1;
                    v.push(rood[i].to);
                }
            }
        }
    }
    return 1;
}
int main() {
    int T;
    cin>>T;
    while(T--) {
        memset(flag,0,sizeof(flag));
        tot=0;
        memset(head,0,sizeof(head));
        cin>>n>>m>>w;
        for(int i=1; i<=m; i++) {
            scanf("%d %d %d",&a,&b,&c);
            add(a,b,c);
            add(b,a,c);
        }
        for(int i=1; i<=w; i++) {
            scanf("%d %d %d",&a,&b,&c);
            add(a,b,-c);
        }
        bool fff=1;
        for(int i=1;i<=n&&fff;i++)
            if(!flag[i])
                fff=fff&&spfa(i);
        if(fff)
            puts("NO");
    }
    return 0;
}

作者：Overnoise
链接：https://www.acwing.com/solution/content/6869/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, M = 5210;

int n, m1, m2;
int h[N], e[M], w[M], ne[M], idx;
int dist[N];
int q[N], cnt[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool spfa()
{
    memset(dist, 0, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    memset(st, 0, sizeof st);

    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        q[tt ++ ] = i;
        st[i] = true;
    }

    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d%d%d", &n, &m1, &m2);
        memset(h, -1, sizeof h);
        idx = 0;
        for (int i = 0; i < m1; i ++ )
        {
            int a, b, c;
            scanf("%d%d%d", &a, &b, &c);
            add(a, b, c), add(b, a, c);
        }
        for (int i = 0; i < m2; i ++ )
        {
            int a, b, c;
            scanf("%d%d%d", &a, &b, &c);
            add(a, b, -c);
        }

        if (spfa()) puts("YES");
        else puts("NO");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/152739/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>
#include <cstring>
#include <complex>
#include <sstream>
#include <utility>
#include <cctype>
#include <cstdio>
#include <vector>

using namespace std;

const int N=505;
const int M=5205;

int n,m,k;
int h[N],e[M],ne[M],idx;
int dist[N],w[M],cnt[N];
int q[N],hh,tt;
bool st[N];

inline int read()
{
    int x=0;
    char ch;
    do ch=getchar();
    while(ch==' '||ch=='\n'||ch=='\r');
    while(ch^' '&&ch^'\n'&&ch^'\r'&&~ch)
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x;
}

inline void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

inline bool spfa()
{
    memset(cnt,0,sizeof cnt);
    memset(dist,0,sizeof dist);
    hh=tt=0;
    for(int i=1;i<=n;i++)
        q[tt++]=i,st[i]=true;
    while(hh!=tt)
    {
        int t=q[hh++];
        if(hh==N)hh=0;
        st[t]=false;
        for(int i=h[t];i;i=ne[i])
            if(dist[e[i]]>dist[t]+w[i])
            {
                dist[e[i]]=dist[t]+w[i];
                cnt[e[i]]=cnt[t]+1;
                if(cnt[e[i]]>n-1)return true;
                if(!st[e[i]])
                {
                    st[e[i]]=true;
                    q[tt++]=e[i];
                    if(tt==N)tt=0;
                }
            }
    }
    return false;
}

int main()
{
    for(int T=read();T--;)
    {
        n=read(),m=read(),k=read();
        memset(h,0,sizeof h);
        idx=0;
        for(int i=0;i<m;i++)
        {
            int a,b,c;
            a=read(),b=read(),c=read();
            add(a,b,c),add(b,a,c);
        }
        for(int i=0;i<k;i++)
        {
            int a,b,c;
            a=read(),b=read(),c=read();
            add(a,b,-c);
        }
        if(spfa())puts("YES");
        else    puts("NO");
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/318962/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

USACO 2006 December Gold



AcWing 361. 观光奶牛    原题链接    中等
作者：    墨染空 ,  2019-11-23 18:32:57 ,  阅读 527

10


3
01规划
设答案为 ansans。

二分答案，设当前二分值为 midmid。

设一个环 SS 的边权为 t1,t2,t3…t1,t2,t3…，点权为 f1,f2,f3…f1,f2,f3…
若 mid<=ansmid<=ans，即存在一个环SS使得 mid<=∑fi∑timid<=∑fi∑ti，变换一下：∑(mid∗ti−fi)<=0∑(mid∗ti−fi)<=0

否则，则 mid>ansmid>ans
每次 checkcheck 的时候，一条 uu 指向 vv，边权为 ww 的边权变为：

w∗mid−fuw∗mid−fu。我们只需检查这个图是否存在负环即可。

时间复杂度
最坏情况存在长度为 LL 的环， ∑ti=L,∑fi=1000L∑ti=L,∑fi=1000L。故答案最大可能是 10001000。

Log2107≈24Log2107≈24
O(24∗LP)O(24∗LP)。判负环的时间一般情况下低于 O(LP)O(LP)。

#include <cstdio>
#include <iostream>
using namespace std;
const int N = 1005, M = 5005;
int n, q[N * M], m, f[N], cnt[N];
int head[N], numE = 0;
double dis[N];
bool vis[N];
struct E{
    int next, v, w;
}e[M];
void add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
}
bool inline check(double mid) {
    int hh = 0, tt = -1;
    for (int i = 1; i <= n; i++)
        vis[i] = true, dis[i] = cnt[i] = 0, q[++tt] = i;
    while(hh <= tt) {
        int u = q[hh++];
        vis[u] = false;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            double w = e[i].w * mid - f[u];
            if(dis[u] + w < dis[v]) {
                dis[v] = dis[u] + w;
                cnt[v] = cnt[u] + 1;
                if(cnt[v] >= n) return true;
                if(!vis[v]) q[++tt] = v;
            }
        }
    }
    return false;
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", f + i);
    for (int i = 1, u, v, w; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w);
    }

    double l = 0, r = 1000, eps = 1e-4;
    while(r - l > eps) {
        double mid = (l + r) / 2;
        if(check(mid)) l = mid;
        else r = mid;
    }
    printf("%.2lf\n", r);
    return 0;
}
10 评论

提交评论

锤子科技未来产品经理   2个月前     回复
我没有用结构体，直接用的链式存储，把代码改写了一下就超时了，大佬知道为什么吗?

#include <cstring>
#include <cstdio>
#include <iostream>
#include <queue>
using namespace std;
const int N = 1005;
int h[N], e[N], ne[N], w[N], cnt[N], f[N];
int n, m;
int idx = 0;
double dis[N];
bool vis[N];

void add(int a, int b, int c)
{
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool inline check(double mid) {
    queue<int> q;
    for (int i = 1; i <= n; i++)
        vis[i] = true, dis[i] = cnt[i] = 0, q.push(i);
    while(q.size()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = h[u]; ~i; i = ne[i]) {
            int v = e[i];
            double k = w[i] * mid - f[u];
            if(dis[u] + k < dis[v]) {
                dis[v] = dis[u] + k;
                cnt[v] = cnt[u] + 1;
                if(cnt[v] >= n) return true;
                if(!vis[v]) 
                {
                   q.push(v);
                   vis[v] = true;
                }
            }
        }
    }
    return false;
}
int main() {
    memset(h, -1, sizeof h);
    cin >> n >> m;

    for(int i = 1; i <= n; i++)
    {
        int d;
        cin >> d;
        f[i] = d;
    }

    for (int i = 1, u, v, w; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w);
    }

    double l = 0, r = 1000, eps = 1e-4;
    while(r - l > eps) {
        double mid = (l + r) / 2;
        if(check(mid)) l = mid;
        else r = mid;
    }
    printf("%.2lf\n", r);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/solution/content/6472/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, M = 5010;

int n, m;
int wf[N];
int h[N], e[M], wt[M], ne[M], idx;
double dist[N];
int q[N], cnt[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, wt[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool check(double mid)
{
    memset(dist, 0, sizeof dist);
    memset(st, 0, sizeof st);
    memset(cnt, 0, sizeof cnt);

    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        q[tt ++ ] = i;
        st[i] = true;
    }

    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] < dist[t] + wf[t] - mid * wt[i])
            {
                dist[j] = dist[t] + wf[t] - mid * wt[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> wf[i];

    memset(h, -1, sizeof h);
    for (int j = 0; j < m; j ++ )
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }

    double l = 0, r = 1e6;
    while (r - l > 1e-4)
    {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }

    printf("%.2lf\n", l);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/152741/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1165. 单词环    原题链接    中等
作者：    lew2018 ,  2020-08-05 12:26:30 ,  阅读 60

2


题目大意
我们有 nn 个字符串，每个字符串都是由 a∼za∼z 的小写英文字母组成的。

如果字符串 AA 的结尾两个字符刚好与字符串 BB 的开头两个字符相匹配，那么我们称 AA 与 BB 能够相连（注意：AA 能与 BB 相连不代表 BB 能与 AA 相连）。

我们希望从给定的字符串中找出一些，使得它们首尾相连形成一个环串（一个串首尾相连也算），我们想要使这个环串的平均长度最大。

如下例：

ababc
bckjaca
caahoynaab
第一个串能与第二个串相连，第二个串能与第三个串相连，第三个串能与第一个串相连，我们按照此顺序相连，便形成了一个环串，长度为 5+7+10=225+7+10=22（重复部分算两次），总共使用了 33 个串，所以平均长度是 223≈7.33223≈7.33
分析
1.建图:
一个比较直观的建图方式是将每个单词作为一个节点,如果这两个单词能够相连,则在这两个单词之间连接一条有向边,此时最多有105105个点,10101010条边,不能接受.
考虑一个对偶的建图方式,将每一个单词看作一条边,其开头两个字符和结尾两个字符为它两边的点.
这样建图的话,节点数就缩小到了675675个(26∗26−126∗26−1),边数为105105条.

2.0/10/1分数规划
我们所要求的答案为∑lens∑lens的最大值,其中ss表示单词个数,lenlen表示每个单词的长度.
可以发现所求问题具有单调性,可以使用二分来求解.
设左端点为ll,右端点为rr,中点为midmid,则当∑lens>mid∑lens>mid时, ∑len−s×mid>0∑len−s×mid>0,则可以将图中的边权设成len[i]−midlen[i]−mid(len[i]len[i]表示当前单词的长度).
在此基础上,原问题可以转化为求当前图中有无正环.

3.优化
在用SPFA求正环的过程中,可以采取一种比较取巧的方法:当求最长路时,经过的点大于某一个数时,我们就可以武断地认为当前图中存在一个正环.

代码
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 700, M = 100010;

int n;
int h[N], e[M], w[M], ne[M], idx;
double dist[N];
int q[N], cnt[N];
bool st[N];

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

bool check(double mid) {
    memset(st, 0, sizeof(st));
    memset(cnt, 0, sizeof(cnt));
    int hh = 0, tt = 0;
    for (int i = 0; i < 676; i++) {
        q[tt++] = i;
        st[i] = true;
    }
    int count = 0;
    while (hh != tt) {
        int t = q[hh++];
        if (hh == N) hh = 0;
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
             if (dist[j] < dist[t] + w[i] - mid) {
                 dist[j] = dist[t] + w[i] - mid;
                 cnt[j] = cnt[t] + 1;
                 if (++count > 10000) return true;
                 if (cnt[j] >= N) return true;
                 if (!st[j]) {
                     q[tt++] = j;
                     if (tt == N) tt = 0;
                     st[j] = true;
                 }
             }
        }
    }
    return false;
}

int main() {
    char str[1010];
    while (scanf("%d", &n)) {
        if (n == 0) break;
        memset(h, -1, sizeof(h));
        idx = 0;
        for (int i = 0; i < n; i++) {
            scanf("%s", str);
            int len = strlen(str);
            if (len >= 2) {
                int left = (str[0] - 'a') * 26 + str[1] - 'a',
                    right = (str[len - 2] - 'a') * 26 + str[len - 1] - 'a';
                add(left, right, len);
            }
        }
        if (!check(0)) puts("No solution");
        else {
            double l = 0, r = 1000;
            while (r - l > 1e-4) {
                double mid = (l + r) / 2;
                if (check(mid)) l = mid;
                else r = mid;
            }
            printf("%lf\n", r);
        }
    }
    return 0;
}

作者：lew2018
链接：https://www.acwing.com/solution/content/17712/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 700, M = 100010;

int n;
int h[N], e[M], w[M], ne[M], idx;
double dist[N];
int q[N], cnt[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool check(double mid)
{
    memset(st, 0, sizeof st);
    memset(cnt, 0, sizeof cnt);

    int hh = 0, tt = 0;
    for (int i = 0; i < 676; i ++ )
    {
        q[tt ++ ] = i;
        st[i] = true;
    }

    int count = 0;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] < dist[t] + w[i] - mid)
            {
                dist[j] = dist[t] + w[i] - mid;
                cnt[j] = cnt[t] + 1;
                if ( ++ count > 10000) return true; // 经验上的trick
                if (cnt[j] >= N) return true;
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    char str[1010];
    while (scanf("%d", &n), n)
    {
        memset(h, -1, sizeof h);
        idx = 0;
        for (int i = 0; i < n; i ++ )
        {
            scanf("%s", str);
            int len = strlen(str);
            if (len >= 2)
            {
                int left = (str[0] - 'a') * 26 + str[1] - 'a';
                int right = (str[len - 2] - 'a') * 26 + str[len - 1] - 'a';
                add(left, right, len);
            }
        }

        if (!check(0)) puts("No solution");
        else
        {
            double l = 0, r = 1000;
            while (r - l > 1e-4)
            {
                double mid = (l + r) / 2;
                if (check(mid)) l = mid;
                else r = mid;
            }

            printf("%lf\n", r);
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/152738/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1169. 糖果(spfa负环做差分约束问题)    原题链接    中等
作者：    仅存老实人 ,  2020-09-11 16:50:40 ,  阅读 49

4


/*
差分约束两大应用

1 求不等式组的可行解
   ⭐源点需要满足的条件: 从源点出发,一定可以走到所有的边
   否则 用单源最短路做的话 有一条边走不到 则该边对应的不等式就无法满足
   某一个点x[i]走不到无所谓(某个点走不到代表它不受限制,x[i]取任意数都可以)
过程:
1 把每个x[i] ≤ x[j] + C[k]不等式转化为一条从x[j]走到x[i]长度为C[k]的边
2 然后在这个图上找一个超级源点,使得该源点一定可以遍历到所有边 
3 从源点求一遍 单源最短路
  3.1 假如存在负环
      x[1]→x[2]→x[3]→x[k]
        ↑ c1   c2   c3 ↓
          ← ← ← ← ← ← 
              ck
    x[2]≤ x[1]+c[1]
         ...
    x[k]≤ x[k-1]+c[k-1]
    x[1]≤ x[k]+c[k]
    对第一个不等式用后面的不等式一直做松弛
    x[2] ≤ x[1]+c[1]
         ≤ x[k]+c[k]+c[1]
         ≤ x[k-1]+c[k-1]+c[k]+c[1]
         ...
         ≤ x[2]+c[2]+...+c[k-1]+c[k]+c[1]
         ≤ x[2]+(小于零的Σc[i])
    x[2] < x[2]
    即矛盾
    得出结论:不等式无解 <=> 存在负环

4 求完单源最短路之后
4.1 存在负环 => 不等式无解
4.2 没有负环 => 求完之后一定是满足这个不等式的 <=> 即一个可行解

x[i] ≤ x[j] + C[k]
  x1 ≤ x2+1
{ x2 ≤ x3+2
  x3 ≤ x1-5
 x1 =  0
 x2 = -1
 x3 = -2

类比最短路
  i→j   求之前 d[j] > d[i]+c 
   c    求完后 d[j] ≤ d[i]+c 
一个图里每个点求完最短距离后每个点的最短距离都有第二个不等式满足
即  任何一个最短路问题 可以 转化为一个差分约束问题
同理  一个差分约束问题 可以 转化为一个单源最短路问题

最长路
   i→j   求之前 d[j] < d[i]+c 
   c     求完后 d[j] ≥ d[i]+c  

2 如何求最大值或者最小值(x[i] for i in range(1,n))
    结论1:如果求的是最小值,则应该求最长路,如果求的是最大值,则应该求最短路
    问题1:如何转化x[i] ≤ c 其中c是一个常数 这类的不等式
    方法:建立一个超级源点,0号点x[0],然后建立0→i 长度是c的边即可
         x[i] ≤ c
            <=>
         x[i] ≤ x[0] + c = 0 + c   

    以求x[i]的最大值为例:所有从x[i]出发,构成的不等式链     
    x[i] ≤ x[j] + c[j] 
         ≤ x[k] + c[k] + c[j]
         ≤ x[0] + c[1]+ c[2]+... + c[j] 
         =   0  + c[1]+ ... + c[j] 
    所计算出的上界,
    最终x[i]的最大值
    =所有上界的最小值
    举例 x[i] ≤ 5
         x[i] ≤ 2
         x[i] ≤ 3
         max(x[i]) = min(5,2,3) = 2
    0 → 1 → 3 → 5 → ... → i
      c1  c3  c5       ci-1
    x[1] ≤ x[0] + c[1] 
    x[3] ≤ x[1] + c[3] 
    x[5] ≤ x[3] + c[5]
    ...
    x[i] ≤ x[i-1] + c[i-1]
    则
    x[i] ≤ x[i-1] + c[i] 
         ≤ x[i-3] + c[i-3] + c[i]
         ...
         ≤ x[0] + c[1] + c[3] + c[i-3] + c[i-1]
    ⭐可以发现Σc[i]就是从0→i的一条路径的长度

    那么
        求x[i]最大值
            <=>
        求所有上界的最小值
            <=>
        求所有从0→i的路径和的最小值
            <=>
        最短路求dist[i]

    同理 求x[i]最小值
            <=>
        求所有下界的最大值
            <=>
        求所有从0→i的路径和的最大值
            <=>
        最长路求dist[i]
*/
/*
本题
1 A = B  <=> A≥B B≥A
2 A < B  <=> B≥A+1
3 A≥B    <=> A≥B
4 A > B  <=> A≥B+1
5 B≥A    <=> B≥A
x≥1  
    } x≥x0+1(超级源点x0=0)
x0=1

举例  x[i] ≥ 5
      x[i] ≥ 2
      x[i] ≥ 3
      min(x[i]) = 5

总共最小值 = min(x[i]最小值) for i in range(n)
           = 求x[i]所有下界的最大值
           = 求所有从0→i的路径和的最大值
           = 最长路求dist[i]
0 → 1 → 3 → 5 → ... → i
c1  c3  c5       ci-1
    x[1] ≥ x[0] + c[1] 
    x[3] ≥ x[1] + c[3] 
    x[5] ≥ x[3] + c[5]
    ...
    x[i] ≥ x[i-1] + c[i-1]
    则
    x[i] ≥ x[i-1] + c[i] 
         ≥ x[i-3] + c[i-3] + c[i]
         ...
         ≥ x[0] + c[1] + c[3] + c[i-3] + c[i-1]
 ⭐可以发现Σc[i]就是从0→i的一条路径的长度

    那么 求x[i]最小值
            <=>
        求所有下界的最大值
            <=>
        求所有从0→i的路径和的最大值
            <=>
        最长路求dist[i]
    即：
    if(d[j]<d[i]+w[i][j])
        d[j] = d[i] + w[i][j]
        建立边数
        最坏情况A = B  <=> A≥B B≥A 2条
             +超级源点和所有点xi建边
             =3*n
*/
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;

typedef long long LL;

const int N = 100010, M = 300010;
int n, m;
int h[N], e[M], w[M], ne[M], idx;
LL dist[N];
int cnt[N];//统计到当前点总共有多少条边了
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx ++;
}

bool spfa()
{
    deque<int> q;
    q.push_back(0);
    st[0] = true;
    //最长路 dist[j] < dist[t] + w[i] 初始化为-INF
    memset(dist,-0x3f,sizeof dist);
    dist[0] = 0;//错因:在memset前初始化0

    while(q.size())
    {
        int t = q.back();
        q.pop_back();
        st[t] = false;//不在栈中 状态=false
        for (int i = h[t]; i!=-1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] < dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n + 1) return false;//有负环 无解
                if (!st[j])
                {
                    q.push_back(j);
                    st[j] = true;
                }
            }
        }
    }
    return true;
}

int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int x, a, b;
        cin >> x >> a >> b;
        if (x == 1) add(b, a, 0), add(a, b, 0);//A=B
        else if (x == 2) add(a, b, 1);//B≥A+1
        else if (x == 3) add(b, a, 0);//A≥B
        else if (x == 4) add(b, a, 1);//A≥B+1
        else add(a, b, 0);//B≥A
    }
    //每个同学都要分到糖果 x[i]≥1
    //超级源点0 x[i] ≥ x[0]+1 <=> x[i] ≥ 1 
    for (int i = 1; i <= n; i ++ ) add(0, i, 1);

    if (!spfa()) cout << "-1" << endl;
    else
    {
        LL res = 0;
        for (int i = 1; i <= n; i ++ ) res += dist[i];
        cout << res << endl;
    }
    return 0;
}

作者：仅存老实人
链接：https://www.acwing.com/solution/content/20514/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010, M = 300010;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
LL dist[N];
int q[N], cnt[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(dist, -0x3f, sizeof dist);
    dist[0] = 0;
    q[0] = 0;
    st[0] = true;

    while (hh != tt)
    {
        int t = q[ -- tt];
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] < dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n + 1) return false;
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    st[j] = true;
                }
            }
        }
    }

    return true;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int x, a, b;
        scanf("%d%d%d", &x, &a, &b);
        if (x == 1) add(b, a, 0), add(a, b, 0);
        else if (x == 2) add(a, b, 1);
        else if (x == 3) add(b, a, 0);
        else if (x == 4) add(b, a, 1);
        else add(a, b, 0);
    }

    for (int i = 1; i <= n; i ++ ) add(0, i, 1);

    if (!spfa()) puts("-1");
    else
    {
        LL res = 0;
        for (int i = 1; i <= n; i ++ ) res += dist[i];
        printf("%lld\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/153383/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N=100010;
const int M=300010;

int n,m;
int h[N],e[M],ne[M],idx;
int dist[N],cnt[N],w[M];
int stk[N],tt;
bool st[N];

inline int read()
{
    int x=0;
    char ch;
    do ch=getchar();while(~ch&&(ch<'0'||ch>'9'));
    for(;ch>='0'&&ch<='9';ch=getchar())
        x=(x<<1)+(x<<3)+(ch^48);
    return x;
}

inline void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

inline long long spfa()
{
    stk[0]=tt=0;
    memset(dist,0xcf,sizeof dist);
    dist[0]=0;
    while(~tt)
    {
        int t=stk[tt--];
        st[t]=false;
        for(int i=h[t];i;i=ne[i])
            if(dist[e[i]]<dist[t]+w[i])
            {
                dist[e[i]]=dist[t]+w[i];
                cnt[e[i]]=cnt[t]+1;
                if(cnt[e[i]]>n)return -1;
                if(!st[e[i]])
                {
                    st[e[i]]=true;
                    stk[++tt]=e[i];
                }
            }
    }
    long long res=0;
    for(int i=1;i<=n;i++)
        res+=dist[i];
    return res;
}

int main()
{
    n=read();
    m=read();
    for(int i=0;i<m;i++)
    {
        int a,b,x;
        x=read(),a=read(),b=read();
        if(x==1)add(b,a,0),add(a,b,0);
        else if(x==2)add(a,b,1);
        else if(x==3)add(b,a,0);
        else if(x==4)add(b,a,1);
        else if(x==5)add(a,b,0);
    }
    for(int i=1;i<=n;i++)
        add(0,i,1);
    printf("%lld",spfa());
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/321388/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 362. 区间 贪心 + 数据结构做法    原题链接    中等
作者：    墨染空 ,  2019-11-24 19:00:15 ,  阅读 412

5


听书上说有贪心 + 数据结构的做法，研究了一下。

朴素贪心
考虑把所有线段按照右端点 bb 从小到大排序，依次考虑每一条线段的要求：

如果已经满足要求则跳过
否则尽量选择靠后的数（因为之后的线段的右端点都在这条线段的右边，这样容错更高）
所以，我们可以建一个数组，d[i]d[i] 表示 ii 数字是否选择（填11或00），扫一遍 [l,r][l,r] 区间求和，然后从后往前贪心放数即可。

对于每条线段需要 O(r−l+1)O(r−l+1)。所以最坏情况下 O(n2)O(n2)。但是轻松 52ms52ms 过了。

#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 50005;
int n, d[N], c[N];
struct Seg{
    int a, b, c;
    bool operator < (const Seg &x) const {
        return b < x.b;
    }
}e[N];
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d%d%d", &e[i].a, &e[i].b, &e[i].c);
    sort(e + 1, e + 1 + n);
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        int l = e[i].a, r = e[i].b, cnt = e[i].c;
        for (int j = l; j <= r; j++)
            cnt -= d[j];
        if(cnt > 0) {
            for (int j = r; j >= l && cnt; j--)
                if(!d[j]) cnt--, ans++, d[j] = 1;
        }
    }
    printf("%d\n", ans);
    return 0;
}
优化
考虑用数据结构优化。

发现我们需要三个操作：

询问 [l,r][l,r] 区间的数字个数
将值为 xx 的位置 +1+1
从后往前，找到比当前位置靠前的下一个 00 的位置。

前两个就是 “区间求和，单调修改”，典型的树状数组。O(nlog250000)O(nlog250000)
第三种操作，可以用并查集优化。为什么可以确保时间复杂度呢？对于每一条线段，最多只有一次会枚举到 11 （即开始的那一次），之后每次枚举都会枚举到 00 的位置，即d[i]=0d[i]=0，然后把它变成 11，而以后就不会访问到了。而一共有 5000050000 个值，所以复杂度是 O(50000logn)O(50000logn)
33ms33ms

#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 50001;
int n, d[N], c[N], f[N];
struct Seg{
    int a, b, c;
    bool operator < (const Seg &x) const {
        return b < x.b;
    }
}e[N];
// 树状数组
int inline ask(int x) {
    int res = 0;
    for (; x; x -= x & -x) res += c[x];
    return res;
}

void inline add(int x) {
    for (; x < N; x += x & -x) c[x]++;
}
// 并茶集：find(x) 表示找到 <= x 中最大的一个是 0 的数
int find(int x) {
    return x == f[x] ? x : f[x] = find(f[x]);
}
int main() {
    scanf("%d", &n);
    for (int i = 0; i < N; i++) f[i] = i;
    for (int i = 1; i <= n; i++) 
        scanf("%d%d%d", &e[i].a, &e[i].b, &e[i].c);
    sort(e + 1, e + 1 + n);
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        int l = e[i].a, r = e[i].b, cnt = e[i].c;
        // 取 [l, r] 选了多少个数
        cnt -= ask(r) - ask(l - 1);
        if(cnt > 0) {
            for (int j = r; j >= l && cnt; ) {
                // d[j] == 1 的情况每条线段至多出现一次
                if(!d[j]) {
                    cnt--, ans++, d[j] = 1;
                    // j 被标记成 1 了，要指向 find(j - 1)
                    f[j] = j - 1;
                    // 维护树状数组
                    add(j);
                };
                if(find(j) != j) j = f[j];
                else j--;
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/solution/content/6528/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 50010, M = 150010;

int n;
int h[N], e[M], w[M], ne[M], idx;
int dist[N];
int q[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void spfa()
{
    memset(dist, -0x3f, sizeof dist);
    dist[0] = 0;
    st[0] = true;
    int hh = 0, tt = 1;
    q[0] = 0;

    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] < dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }
}

int main()
{
    scanf("%d", &n);

    memset(h, -1, sizeof h);
    for (int i = 1; i < N; i ++ )
    {
        add(i - 1, i, 0);
        add(i, i - 1, -1);
    }

    for (int i = 0; i < n; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        a ++, b ++ ;
        add(a - 1, b, c);
    }

    spfa();

    printf("%d\n", dist[50001]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/153384/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


1


/*

s[i] >= s[i - 1];
s[i - 1] >= s[i] - 1
s[b] >= c + s[a - 1]

*/

#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdlib>

using namespace std;

const int N=50010;
const int M=150010;

int n;
int h[N],e[M],ne[M],idx;
int dist[N],cnt[M],w[M];
int q[N],hh,tt;
bool st[N];

inline int read()
{
    int x=0;
    char ch;
    do ch=getchar();while(~ch&&(ch<'0'||ch>'9'));
    for(;ch>='0'&&ch<='9';ch=getchar())
        x=(x<<1)+(x<<3)+(ch^48);
    return x;
}

inline int spfa()
{
    memset(dist,0xcf,sizeof dist);
    dist[1]=0;
    hh=0,tt=1;
    q[0]=1;
    while(hh!=tt)
    {
        int t=q[hh++];
        if(hh==N)hh=0;
        st[t]=false;
        for(int i=h[t];i;i=ne[i])
            if(dist[e[i]]<dist[t]+w[i])
            {
                dist[e[i]]=dist[t]+w[i];
                if(!st[e[i]])
                {
                    st[e[i]]=true;
                    q[tt++]=e[i];
                    if(tt==N)tt=0;
                }
            }
    }
    return dist[50001];
}

inline int add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

int main()
{
    n=read();
    for(int i=1;i<=50001;i++)
        add(i-1,i,0),add(i,i-1,-1);
    for(int i=1;i<=n;i++)
    {
        int a=read();
        e[++idx]=1+read();
        w[idx]=read();
        ne[idx]=h[a];
        h[a]=idx;
    }
    printf("%d\n",spfa());
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/321468/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 1170. 排队布局（差分约束）    原题链接    中等
作者：    Overnoise ,  2019-12-08 20:57:10 ,  阅读 798

1


差分约束模板
一道差分约束的吼题
对于此题，状态无非两种：基友与敌人
那么，就有u-v≤c 或者 u-v≥c
对于u-v≤c，可以用求最短路中的vis[v]=vis[u]+rood[i].s
我们对u−v≥c 转换成 v-u≤−c
这样，我们就可以很愉快的跑路啦
那么建图就酱：

#include<bits/stdc++.h>
using namespace std;
long long n,m,w;
long long a,b,c;
struct oppo {
    long long to,s,next;
} rood[20004];
long long head[1005],tot;
void add(long long from,long long to,long long s) {
    rood[++tot].s=s;
    rood[tot].to=to;
    rood[tot].next=head[from];
    head[from]=tot;
}
long long vis[1004];
long long all[1004];
long long f[1004];
bool flag[1004];
stack< long long > v;
long long spfa(int x) {
    memset(vis,10,sizeof(vis));
    vis[x]=0;
    v.push(x);
    while(v.size()) {
        long long lxl=v.top();
        f[lxl]=0;
        flag[lxl]=1;
        v.pop();
        for(long long i=head[lxl]; i; i=rood[i].next) {
            if(vis[rood[i].to]>vis[lxl]+rood[i].s) {
                vis[rood[i].to]=vis[lxl]+rood[i].s;
                all[rood[i].to]=all[lxl]+1;
                if(all[rood[i].to]>n)
                    return -1;
                if(!f[rood[i].to]) {
                    f[rood[i].to]=1;
                    v.push(rood[i].to);
                }
            }
        }
    }
    return vis[n]==vis[0]?-2:vis[n];
}
int main() {
    cin>>n>>m>>w;
    for(long long i=1; i<n; i++)
        add(i+1,i,0);
    for(long long i=1; i<=m; i++) {
        scanf("%lld%lld%lld",&a,&b,&c);
        add(a,b,c);
    }
    for(long long i=1; i<=w; i++) {
        scanf("%lld%lld%lld",&a,&b,&c);
        add(b,a,-c);
    }
    int ans,fff=0;
    for(int i=1; i<=n; i++)
        if(!flag[i]) {
            ans=spfa(i);
            if(fff) ans=ans==-1?-1:-2;
            if(ans!=-2) break;
            else fff=1;
        }
    cout<<ans<<endl;
    return 0;
}

作者：Overnoise
链接：https://www.acwing.com/solution/content/6879/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, M = 10000 + 10000 + 1000 + 10, INF = 0x3f3f3f3f;

int n, m1, m2;
int h[N], e[M], w[M], ne[M], idx;
int dist[N];
int q[N], cnt[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool spfa(int size)
{
    int hh = 0, tt = 0;
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    memset(cnt, 0, sizeof cnt);

    for (int i = 1; i <= size; i ++ )
    {
        q[tt ++ ] = i;
        dist[i] = 0;
        st[i] = true;
    }

    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    scanf("%d%d%d", &n, &m1, &m2);
    memset(h, -1, sizeof h);

    for (int i = 1; i < n; i ++ ) add(i + 1, i, 0);
    while (m1 -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        if (a > b) swap(a, b);
        add(a, b, c);
    }
    while (m2 -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        if (a > b) swap(a, b);
        add(b, a, -c);
    }

    if (spfa(n)) puts("-1");
    else
    {
        spfa(1);
        if (dist[n] == INF) puts("-2");
        else printf("%d\n", dist[n]);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/153492/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <iostream>
#include <algorithm>
#include <cstring>
#include <complex>
#include <utility>
#include <cstdio>
#include <cctype>
#include <vector>

using namespace std;

const int N=1005;
const int M=21005;

int n,m1,m2;
int h[N],e[M],ne[M],idx;
int dist[N],w[M],cnt[N];
int q[N],hh,tt;
bool st[N];

inline int read()
{
    int x=0;
    char ch;
    do ch=getchar();while(~ch&&(ch<'0'||ch>'9'));
    for(;ch>='0'&&ch<='9';ch=getchar())
        x=(x<<1)+(x<<3)+(ch^48);
    return x;
}

inline bool spfa(int size)
{
    memset(dist,0x3f,sizeof dist);
    memset(cnt,0,sizeof cnt);
    hh=tt=0;
    for(int i=1;i<=size;i++)
    {
        dist[i]=0;
        q[tt++]=i;
        st[i]=true;
    }
    while(hh!=tt)
    {
        int t=q[hh++];
        if(hh==N)hh=0;
        st[t]=false;
        for(int i=h[t];i;i=ne[i])
            if(dist[e[i]]>dist[t]+w[i])
            {
                dist[e[i]]=dist[t]+w[i];
                cnt[e[i]]=cnt[t]+1;
                if(cnt[e[i]]>=n)return false;
                if(!st[e[i]])
                {
                    st[e[i]]=true;
                    q[tt++]=e[i];
                    if(tt==N)tt=0;
                }
            }
    }
    return true;
}

int main()
{
    n=read(),m1=read(),m2=read();
    for(int i=1;i<n;i++)
    {
        e[++idx]=i;
        ne[idx]=h[i+1];
        h[i+1]=idx;
    }
    for(int i=0;i<m1;i++)
    {
        int a=read();
        e[++idx]=read();
        if(e[idx]<a)swap(a,e[idx]);
        w[idx]=read();
        ne[idx]=h[a];
        h[a]=idx;
    }
    for(int i=0;i<m2;i++)
    {
        e[++idx]=read();
        int a=read();
        if(a<e[idx])swap(a,e[idx]);
        w[idx]=-read();
        ne[idx]=h[a];
        h[a]=idx;
    }
    if(!spfa(n))puts("-1");
    else
    {
        spfa(1);
        if(dist[n]==0x3f3f3f3f)puts("-2");
        else    printf("%d\n",dist[n]);
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/321556/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 393. 雇佣收银员    原题链接    中等
作者：    墨染空 ,  2019-11-25 22:22:44 ,  阅读 588

11


1
算法1： 差分约束 + 枚举 O(Tn2028)
由于牵扯到 [i−8+1,i][i−8+1,i] 这段区间的和的约束，所以用前缀和更好表达一些。

设 num[i]num[i]表示 ii 时刻有多少人申请上岗， x[i]x[i] 为 ii 时刻实际上岗的人数 ，ss 为 xx 的前缀和数组。

则应该满足的约束条件是：

上岗人数不能负数，即 s[i]−s[i−1]>=0s[i]−s[i−1]>=0
实际上岗人数不能超过申请人数，即 s[i]−s[i−1]<=num[i]s[i]−s[i−1]<=num[i]
ii 时刻所在人数，即 [i−7,i][i−7,i] 区间内的上岗人数要大于等于最小需求 RR
由于存在环，即 2323 到 2424，再到 00 时刻，所以要分类讨论：

当 i>=8i>=8 时，s[i]−s[i−8]>=R[i]s[i]−s[i−8]>=R[i]
当 i<=7i<=7 时，s[i]+s[24]−s[16+i]>=R[i]s[i]+s[24]−s[16+i]>=R[i]
显然这是一个明显的差分约束问题，由于求最小人数，所以用最长路转化：

s[i]>=s[i−1]s[i]>=s[i−1] 即 add(i−1,i,0)add(i−1,i,0)
s[i]−num[i]<=s[i−1]s[i]−num[i]<=s[i−1] 即 add(i,i−1,−num[i])add(i,i−1,−num[i])
s[i−8]+R[i]<=s[i]s[i−8]+R[i]<=s[i] 即 add(i−8,i,R[i])add(i−8,i,R[i])
s[16+i]+R[i]−s[24]<=s[i]s[16+i]+R[i]−s[24]<=s[i]，不会连边了hhhh
最后一种约束关系我们不会连边的原因无非是出现了三个变量，但我们可以发现：

所有最后一种约束关系都有 s[24]s[24] 变量，其实这个东西就是我们求的答案，所以我们可以枚举 s[24]s[24] 的值，把它变成常量就行啦！然后就可以 add(16+i,i,R[i]−s[24])add(16+i,i,R[i]−s[24])
Tips：Tips：
关于建图，其实可以在线建图，不用僵化建边了嘿嘿。
发现 00 肯定所有点，所以不用创造超级源点了，只需从 00 点出发跑最短路即可。
不要忘了 s[24]=s[24]= 我们枚举的数 cc（要严格等于，实现是 大于等于 + 小于等于）：
s[24]<=cs[24]<=c 即 add(24,0,−c)add(24,0,−c)
s[24]>=cs[24]>=c 即 add(0,24,c)add(0,24,c)
时间复杂度
这个题中的点数 <=26<=26，边数 <=26∗3=78<=26∗3=78，

所以时间复杂度 O(Tn2028)O(Tn2028)，足以 ACAC
5ms5ms 可还行

#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
const int N = 25;
int n, ans, cnt[N], dis[N], R[N], num[N];
int tt, q[N];
bool st[N];
/*
最长路
0 <= Si - S(i - 1)
*/
//把边 (u, v, w) 松弛
bool inline upd(int u, int v, int w) {
    if(dis[u] + w > dis[v]) {
        dis[v] = dis[u] + w;
        cnt[v] = cnt[u] + 1;
        if(cnt[v] >= 25) return false; 
        if(!st[v]) q[++tt] = v, st[v] = true;
    }
    return true;
}

// 返回是否存在可行解
bool spfa() {
    memset(dis, -0x3f, sizeof dis);
    memset(st, false, sizeof st);
    memset(cnt, 0, sizeof cnt);
    // 数组模拟栈 更容易找到环
    tt = 0;
    q[++tt] = 0; dis[0] = 0;
    while(tt) {
        int u = q[tt--];
        st[u] = false;
        // 严格保证 s[24] = ans
        if(u == 0 && !upd(0, 24, ans)) return false;
        if(u == 24 && !upd(24, 0, -ans)) return false;
        // s[i] - s[i - 1] >= 0
        if(u < 24 && !upd(u, u + 1, 0)) return false;
        // s[i] - s[i - 1] <= num[i]
        if(u > 0 && !upd(u, u - 1, -num[u])) return false;
        //s[i] - s[i - 8] >= R[i]
        if(u <= 16 && !upd(u, u + 8, R[u + 8])) return false;
        // s[i] + s[24] - s[24 - i] >= R[i]
        if(u >= 17 && !upd(u, u - 16, R[u - 16] - ans)) return false;
    }
    return true;
}
int main() {
    int T; scanf("%d", &T);
    while(T--) {
        memset(num, 0, sizeof num);
        for (int i = 1; i < N; i++) scanf("%d", R + i);
        scanf("%d", &n);
        for (int i = 1, x; i <= n; i++) 
            scanf("%d", &x), x++, num[x]++;

        bool ok = false;
        // 枚举 s24, s24 就是 答案
        for (ans = 0; ans <= n; ans++) {
            if(spfa()) {
                printf("%d\n", ans);
                ok = true;
                break;
            }
        }
        if(!ok) puts("No Solution");
    }
    return 0;
}
算法2： 差分约束 + 二分 O(T2028logN)
显然，答案具有单调性（若允许上岗的人越多，越容易满足条件）。

所以可以二分答案 LOLLOL。

3ms3ms 可还行

#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
const int N = 25;
int n, cnt[N], dis[N], R[N], num[N];
int tt, q[N];
bool st[N];
/*
最长路
0 <= Si - S(i - 1)
*/
//把边 (u, v, w) 松弛
bool inline upd(int u, int v, int w) {
    if(dis[u] + w > dis[v]) {
        dis[v] = dis[u] + w;
        cnt[v] = cnt[u] + 1;
        if(cnt[v] >= 25) return false; 
        if(!st[v]) q[++tt] = v, st[v] = true;
    }
    return true;
}

// 返回是否存在可行解
bool spfa(int s24) {
    memset(dis, -0x3f, sizeof dis);
    memset(st, false, sizeof st);
    memset(cnt, 0, sizeof cnt);
    // 数组模拟栈 更容易找到环
    tt = 0;
    q[++tt] = 0; dis[0] = 0;
    while(tt) {
        int u = q[tt--];
        st[u] = false;
        // 严格保证 s[24] = s24
        if(u == 0 && !upd(0, 24, s24)) return false;
        if(u == 24 && !upd(24, 0, -s24)) return false;
        // s[i] - s[i - 1] >= 0
        if(u < 24 && !upd(u, u + 1, 0)) return false;
        // s[i] - s[i - 1] <= num[i]
        if(u > 0 && !upd(u, u - 1, -num[u])) return false;
        //s[i] - s[i - 8] >= R[i]
        if(u <= 16 && !upd(u, u + 8, R[u + 8])) return false;
        // s[i] + s[24] - s[24 - i] >= R[i]
        if(u >= 17 && !upd(u, u - 16, R[u - 16] - s24)) return false;
    }
    return true;
}
int main() {
    int T; scanf("%d", &T);
    while(T--) {
        memset(num, 0, sizeof num);
        for (int i = 1; i < N; i++) scanf("%d", R + i);
        scanf("%d", &n);
        for (int i = 1, x; i <= n; i++) 
            scanf("%d", &x), x++, num[x]++;

        int l = 0, r = n;
        while(l < r) {
            int mid = (l + r) >> 1;
            if(spfa(mid)) r = mid;
            else l = mid + 1;
        }
        if(spfa(r)) printf("%d\n", r);
        else puts("No Solution");
    }
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/solution/content/6563/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 30, M = 100, INF = 0x3f3f3f3f;

int n;
int h[N], e[M], w[M], ne[M], idx;
int r[N], num[N];
int dist[N];
int q[N], cnt[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void build(int c)
{
    memset(h, -1, sizeof h);
    idx = 0;
    add(0, 24, c), add(24, 0, -c);
    for (int i = 1; i <= 7; i ++ ) add(i + 16, i, r[i] - c);
    for (int i = 8; i <= 24; i ++ ) add(i - 8, i, r[i]);
    for (int i = 1; i <= 24; i ++ )
    {
        add(i, i - 1, -num[i]);
        add(i - 1, i, 0);
    }
}

bool spfa(int c)
{
    build(c);

    memset(dist, -0x3f, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    memset(st, 0, sizeof st);

    int hh = 0, tt = 1;
    dist[0] = 0;
    q[0] = 0;
    st[0] = true;

    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] < dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= 25) return false;
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }

    return true;
}

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        for (int i = 1; i <= 24; i ++ ) cin >> r[i];
        cin >> n;
        memset(num, 0, sizeof num);
        for (int i = 0; i < n; i ++ )
        {
            int t;
            cin >> t;
            num[t + 1] ++ ;
        }

        bool success = false;
        for (int i = 0; i <= 1000; i ++ )
            if (spfa(i))
            {
                cout << i << endl;
                success = true;
                break;
            }

        if (!success) puts("No Solution");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/153547/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



AcWing 1172. 祖孙询问    原题链接    中等
作者：    Overnoise ,  2019-11-28 16:30:38 ,  阅读 968

5


我发现我在另一个oj上做过，直接发手题解
lca模板
利用dfs找到每个点的父亲和每个点的深度
利用一个循环初始化一个点上面第(1<<i)个父亲是什么
对于每个询问在线跑一遍 倍增求lca
不理解倍增思路看这里
设两点 a,b（a的深度大于b）
首先让a倍增跳到于b同深度
如果此时a,b相等，返回
如果不相等，那么同时向上跳
一个大佬更详细的讲解

#include<bits/stdc++.h>
using namespace std;
int n,q;
int head[100005];
struct oppo{
    int to,next;
}rood[200005];
int tot,start;
void add(int from,int to)
{
    rood[++tot].to=to;
    rood[tot].next=head[from];
    head[from]=tot;
}
int deep[100005];
int fa[100005][25];
void dfs(int x)
{
    for(int i=head[x];i;i=rood[i].next)
        if(!deep[rood[i].to])
        {
            deep[rood[i].to]=deep[x]+1;
            fa[rood[i].to][0]=x;
            dfs(rood[i].to);
        }
}
int lca(int x,int y)
{
    int fff=1;
    if(deep[x]>deep[y])
    {
        swap(x,y);
        fff=2;
    }
    for(int i=20;i>=0;i--)
        if(deep[fa[y][i]]>=deep[x])
            y=fa[y][i];
    if(x==y)
        return fff;
    else
        return 0;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int a,b;
        scanf("%d %d",&a,&b);
        if(b==-1)
            start=a;
        else
        {
            add(a,b);
            add(b,a);
        }
    }
    deep[start]=1;
    dfs(start);
    for(int i=1;i<=20;i++)
        for(int j=1;j<=40000;j++)
            fa[j][i]=fa[fa[j][i-1]][i-1];
    cin>>q;
    for(int i=1;i<=q;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        printf("%d\n",lca(x,y));
    }
    return 0;
}

作者：Overnoise
链接：https://www.acwing.com/solution/content/6576/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。




5


1
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 40010, M = N * 2;

int n, m;
int h[N], e[M], ne[M], idx;
int depth[N], fa[N][16];
int q[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs(int root)
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[root] = 1;
    int hh = 0, tt = 0;
    q[0] = root;
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] > depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k <= 15; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 15; k >= 0; k -- )
        if (depth[fa[a][k]] >= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 15; k >= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}

int main()
{
    scanf("%d", &n);
    int root = 0;
    memset(h, -1, sizeof h);

    for (int i = 0; i < n; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        if (b == -1) root = a;
        else add(a, b), add(b, a);
    }

    bfs(root);

    scanf("%d", &m);
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        int p = lca(a, b);
        if (p == a) puts("1");
        else if (p == b) puts("2");
        else puts("0");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/154772/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstdio>
#include <iostream>
using namespace std;
const int N = 40005, L = 16;
int n, m, rt, fa[N][L], dep[N];
int head[N], numE = 0;
struct E{
    int next, v;
}e[N << 1];
inline void add(int u, int v) {
    e[++numE] = (E) { head[u], v };
    head[u] = numE;
}
void dfs(int u) {
    for (int i = 1; i < L && fa[u][i - 1]; i++)
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].v;
        if(v == fa[u][0]) continue;
        fa[v][0] = u;
        dep[v] = dep[u] + 1;
        dfs(v);
    }
}
int lca(int x, int y) {
    if(dep[x] < dep[y]) swap(x, y);
    for (int i = L - 1; ~i; i--) 
        if(dep[x] - (1 << i) >= dep[y]) x = fa[x][i];
    if(x == y) return x;
    for (int i = L - 1; ~i; i--)
        if(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
    return fa[x][0];
}
int main() {
    scanf("%d", &n);
    for (int i = 1, a, b; i <= n; i++) {
        scanf("%d%d", &a, &b);
        if(b == -1) rt = a;
        else add(a, b), add(b, a);
    }
    dfs(rt);
    scanf("%d", &m);
    while(m--) {
        int x, y; scanf("%d%d", &x, &y);
        int p = lca(x, y);
        puts( p == x ? "1" : p == y ? "2" : "0");
    }
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/154791/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <iostream>
#include <algorithm>
#include <cstring>
#include <complex>

using namespace std;

const int N=40005;
const int M=80005;

int n,root;
int h[N],e[M],ne[M],idx;
int depth[N],fa[N][20];
int q[N],hh,tt;

inline int read()
{
    int x=0;
    char ch;
    do ch=getchar();while(ch^'-'&&(ch<'0'||ch>'9'));
    if(ch=='-')return getchar(),-1;
    for(;ch>='0'&&ch<='9';ch=getchar())
        x=(x<<1)+(x<<3)+(ch^48);
    return x;
}

inline void add(int a,int b)
{
    e[++idx]=b;
    ne[idx]=h[a];
    h[a]=idx;
}

inline void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    depth[0]=0,depth[root]=1;
    q[0]=root;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(depth[e[i]]>depth[t]+1)
            {
                depth[e[i]]=depth[t]+1;
                q[++tt]=e[i];
                fa[e[i]][0]=t;
                for(int k=1;k<16;k++)
                    fa[e[i]][k]=fa[fa[e[i]][k-1]][k-1];
            }
    }
}

int lca(int a,int b)
{
    if(depth[a]<depth[b])swap(a,b);
    for(int k=15;~k;k--)
        if(depth[fa[a][k]]>=depth[b])
            a=fa[a][k];
    if(a==b)return a;
    for(int k=15;~k;k--)
        if(fa[a][k]!=fa[b][k])
            a=fa[a][k],b=fa[b][k];
    return fa[a][0];
}

int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    {
        int a,b;
        a=read(),b=read();
        if(~b)add(a,b),add(b,a);
        else    root=a;
    }
    bfs(root);
    for(int q=read();q--;putchar('\n'))
    {
        int a,b;
        a=read();
        b=read();
        int p=lca(a,b);
        if(p==a)putchar(49);
        else if(p==b)putchar(50);
        else putchar(48);
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/321841/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1171. 距离    原题链接    中等
作者：    小呆呆 ,  2020-02-25 20:55:05 ,  阅读 351

3


算法分析
Tarjan – 离线求LCA
在线做法：读一个询问，处理一个，输出一个
离线做法：读完全部询问，再全部处理完，再全部输出

在深度优先遍历时，将所有点分成三大类

2号点：代表已经访问并结束回溯

1号点：代表正在访问

0号点：代表还没有访问过

其中所有2号点和正在搜索的1号点路径中已经通过并查集合并成一个集合



1、先求出所有点到根结点的距离depth[]，设x号点和y号点的最近公共祖先是p,则x和y的最近距离等于depth[x] + depth[y] - 2 * depth[p]

2、在深度优先遍历1号点中的u点的时候，需要把u的查询的另外一个点的最短距离进行计算并存储，最后把u点合并到上一结点的集合

时间复杂度 O(n+m)O(n+m)
参考文献
算法提高课

Java 代码
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class Main{
    static int N = 10010, M = N * 2;
    static int[] h = new int[N];
    static int[] e = new int[M];
    static int[] w = new int[M];
    static int[] ne = new int[M];
    static int idx = 0;
    static Map<Integer,List<Pair>> query = new HashMap<Integer,List<Pair>>();
    static int[] dist = new int[N];
    static int[] st = new int[N];
    static int[] p = new int[N];
    static int[] res = new int[M * 2];
    static int find(int x)
    {
        if(p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    static void add(int a,int b,int c)
    {
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx ++;
    }
    static void dfs(int u,int father)
    {
        for(int i = h[u];i != -1;i = ne[i])
        {
            int j = e[i];
            if(j == father) continue;
            dist[j] = dist[u] + 1;
            dfs(j,u);
        }
    }
    //所有节点分为三种状态
    //2 代表已经访问并结束回溯
    //1 代表正在访问
    //0 代表还没有访问到
    static void tarjan(int u)
    {
        st[u] = 1;
        for(int i = h[u];i != -1;i = ne[i])
        {
            int j = e[i];
            if(st[j] == 0)
            {
                tarjan(j);
                p[j] = u;
            }
        }
        if(query.containsKey(u))
        {
            for(Pair pair : query.get(u))
            {
                int y = pair.first;
                int id = pair.id;
                //已经回溯结束
                if(st[y] == 2)
                {
                    int anc = find(y);
                    res[id] = dist[u] + dist[y] - dist[anc] * 2;
                }
            }
        }

        st[u] = 2;
    }
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int m = scan.nextInt();

        for(int i = 1;i <= n;i ++) p[i] = i;

        Arrays.fill(h, -1);
        for(int i = 0;i < n - 1;i ++)
        {
            int a = scan.nextInt();
            int b = scan.nextInt();
            int c = scan.nextInt();
            add(a,b,c);
            add(b,a,c);
        }
        for(int i = 0;i < m;i ++)
        {
            int a = scan.nextInt();
            int b = scan.nextInt();
            if(a != b)
            {
                if(!query.containsKey(a)) query.put(a,new LinkedList<Pair>());
                query.get(a).add(new Pair(b,i));
                if(!query.containsKey(b)) query.put(b,new LinkedList<Pair>());
                query.get(b).add(new Pair(a,i));
            }
        }
        //计算每个点到根结点的距离
        dfs(1,-1);
        tarjan(1);

        for(int i = 0;i < m;i ++) System.out.println(res[i]);
    }
}
class Pair
{
    //first存查询的另外一个点，id存查询编号
    int first,id;
    Pair(int first,int id)
    {
        this.first = first;
        this.id = id;
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/9034/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef pair<int, int> PII;

const int N = 10010, M = N * 2;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int dist[N];
int p[N];
int res[M];
int st[N];
vector<PII> query[N];   // first存查询的另外一个点，second存查询编号

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u, int fa)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j == fa) continue;
        dist[j] = dist[u] + w[i];
        dfs(j, u);
    }
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void tarjan(int u)
{
    st[u] = 1;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            tarjan(j);
            p[j] = u;
        }
    }

    for (auto item : query[u])
    {
        int y = item.first, id = item.second;
        if (st[y] == 2)
        {
            int anc = find(y);
            res[id] = dist[u] + dist[y] - dist[anc] * 2;
        }
    }

    st[u] = 2;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        if (a != b)
        {
            query[a].push_back({b, i});
            query[b].push_back({a, i});
        }
    }

    for (int i = 1; i <= n; i ++ ) p[i] = i;

    dfs(1, -1);
    tarjan(1);

    for (int i = 0; i < m; i ++ ) printf("%d\n", res[i]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/154795/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 356. 次小生成树    原题链接    困难
作者：    秦淮岸灯火阑珊 ,  2019-07-17 20:53:49 ,  阅读 1116

8


1
优秀的博客体验,点开有惊喜
原题链接

题目描述
给定一张NN 个点MM条边的无向图，求无向图的严格次小生成树。

设最小生成树的边权之和为sumsum，严格次小生成树就是指边权之和大于sumsum的生成树中最小的一个。

输入格式
第一行包含两个整数NN和MM。

接下来MM行，每行包含三个整数x，y，zx，y，z，表示点xx和点yy之前存在一条边，边的权值为zz。

输出格式
包含一行，仅一个数，表示严格次小生成树的边权和。(数据保证必定存在严格次小生成树)

数据范围
N≤105M≤3∗105
N≤105M≤3∗105
输入样例：
5 6 
1 2 1 
1 3 2 
2 4 3 
3 5 4 
3 4 3 
4 5 6 
输出样例：
11
解题报告
题意理解
要你构造一棵nn个节点的严格次小生成树.

算法解析
分析条件
题目中给出的关键点,就是严格和次小.

什么是严格
就是题目强制要求严格单调性,不可以有==号的出现.

什么是次小
我们应该都知道,最小生成树,它要求边集合的边总和最小,那么次小生成树,要求边集合的边总和只比最小生成树边集合权值大.

总结性质
有至少一个（严格）次小生成树，和最小生成树之间只有一条边的差异。和真理只有一点差异,那就是出题人毒瘤

我们来粗略证明一下.(强行伪证)

我们知道最小生成树,是由n−1n−1条构成的.

那么其他的M−N+1M−N+1就是多余边.

假如说我们把一条多余边(x,y,z)(x,y,z),加入到了最小生成树中,那么一定会在(x,y)(x,y)之间的路径上形成一个环.

那么这个环上面,最大的边称之为
Val1
Val1

次大的边,称之为
Val2
Val2

而且为了保证严格这个单调性质,我们必须设
Val1>Val2最大的边一定大于次大的边
Val1>Val2最大的边一定大于次大的边

接下来,我们就需要好好分析一下这条多余边了.

我们知道多余边,替换任何一条树上的一条边,都会使得最小生成树,不再最小

为什么?

因为最小生成树上的每一条边,一定是满足贪心性质下的最小的边.为什么啊?相信你的直觉啊

这个证明,我们使用的克鲁斯卡尔算法,已经告诉我们为什么.真相只有一个,我懒了

总而言之,言而总之,我们现在知道了这条多余边的加入.,一定会产生非最小生成树.

我们不妨令
ans=最小生成树边权之和
ans=最小生成树边权之和

假如说我们将多余边,替换掉最大权值边.
Val1==>z此时我们发现当前生成树W=ans+z−Val1W=最小生成边权之和+加上多余边−最大权值边
Val1==>z此时我们发现当前生成树W=ans+z−Val1W=最小生成边权之和+加上多余边−最大权值边

这一轮替换,我们可以认为这棵生成树有潜力成为次小生成树.

然后,我们发现,换一换次大边,也是可以的.

我们将多余边,强行替换掉次大权值边.
Val2==>z此时当前生成树W=ans+z−Val2W=最小生成树之和+加入多余边−次大权值边
Val2==>z此时当前生成树W=ans+z−Val2W=最小生成树之和+加入多余边−次大权值边

现在所有的候选生成树都出来了,但是我们面临一个非常严重的问题.

我们如何快速计算,一条路径上的最大边,和次大边.

动态规划
我们可以当前需要知道的状态,无非就是两个.

一条路径上的最大边
一条路径上的严格次大边
所以说,我们不妨就按照倍增数组的思路,去制造两个新数组.

最大边数组
严格次大边数组
f[x][k]=f[fa[x][k−1]][k−1]
f[x][k]=f[fa[x][k−1]][k−1]
这是我们非常熟悉的Lca倍增数组.

然后咱们现在其实,手上掌握的最有力的性质,就是最值性质.

我们假设一条路径是由三段构造而成.

是三段,不是就三个点.
a=>c,c=>b,b=>a
a=>c,c=>b,b=>a


我们发现
A=>B的最大值其实等于max(A=>C最大值,B=>C最大值)
A=>B的最大值其实等于max(A=>C最大值,B=>C最大值)

这就是区间最值性质.

不过严格次大边,就比较麻烦了,不慌,咱们慢慢画图来.

为了下面简述方面,我们设置一下变量.
A=>C上最大边权为ValA,C次大边权为VA,CC=>B上最大边权为ValB,C次大边权为VB,CA=>B上最大边权为ValA,B次大边权为VA,B
A=>C上最大边权为ValA,C次大边权为VA,CC=>B上最大边权为ValB,C次大边权为VB,CA=>B上最大边权为ValA,B次大边权为VA,B

巧计一下,Val字母多,所以是最大边权,V字母少,所以是次大边权.

我们分类讨论一下,三种情况.

①第一段最大值=第二段最大值
ValA,C=ValB,C
ValA,C=ValB,C

我们发现两段居然最大值一样.

次大边权就只能
VA,B=max(VA,C,VB,C)
VA,B=max(VA,C,VB,C)

②第一段最大值<第二段最大值.

那么此时,次大边权是可以取第一段最大值.

因为此时总段的最大值,一定是第二段最大值.
ValA,B=ValB,C因此VA,B可以=ValA,C
ValA,B=ValB,C因此VA,B可以=ValA,C

综上所述,我们总结下来就是.
VA,B=max(ValA,C,VB,C)
VA,B=max(ValA,C,VB,C)

③第一段最大值>第二段最大值.

那么此时,次大边权是可以取第二段最大值.

因为此时总段的最大值,一定是第一段最大值.
ValA,B=ValA,C因此VA,B可以=ValB,C
ValA,B=ValA,C因此VA,B可以=ValB,C

同样,总结一下.
VA,B=max(ValB,C,vA,B)
VA,B=max(ValB,C,vA,B)

然后我们将A,B,CA,B,C具体化一下.

A其实就是起始节点.

C其实就是A跳跃了2i−12i−1格节点.

B其实就是A跳跃了2i2i格节点.

广告时间:发现还是有点模糊,咱们的直播课会讲解的非常清晰,画图肯定少不了.

代码解析
#include <bits/stdc++.h>
using namespace std;
#define INF 1e16
const int N=1e5+200;
const int M=6*1e5+300;
int head[M],edge[M],Next[M],ver[M],tot,fa[M],n,m,father[N][32],deep[N];
long long dp[2][N][32],val1,val2,ans_max,ans;
struct node
{
    int x,y,z,vis;
} s[M];
int cmp(node a,node b)
{
    return a.z<b.z;
}
struct Edge
{
    void init2()
    {
        memset(head,0,sizeof(head));
        tot=0;
    }
    void add_edge(int a,int b,int c)
    {
        edge[++tot]=b;
        ver[tot]=c;
        Next[tot]=head[a];
        head[a]=tot;
    }
    int find(int x)
    {
        return x==fa[x]?x:fa[x]=find(fa[x]);
    }
    void Kruskal()
    {
        sort(s+1,s+1+m,cmp);
        for(int i=1; i<=m; i++)
        {
            int a=find(s[i].x),b=find(s[i].y);
            if (a==b)
                continue;
            s[i].vis=1;
            fa[a]=b;
            ans+=s[i].z;
            add_edge(s[i].x,s[i].y,s[i].z);
            add_edge(s[i].y,s[i].x,s[i].z);
        }
    }
    void bfs(int root)
    {
        deep[root]=0;
        queue<int> q;
        q.push(root);
        while(q.size())
        {
            int x=q.front(),len=(int)log2(deep[x]+1);
            q.pop();
            for(int i=head[x]; i; i=Next[i])
            {
                int y=edge[i];
                if(y==father[x][0])
                    continue;
                deep[y]=deep[x]+1;
                father[y][0]=x,dp[0][y][0]=ver[i],dp[1][y][0]=-INF;
                q.push(y);
                for(int t=1; t<=len; t++)
                {
                    father[y][t]=father[father[y][t-1]][t-1];
                    if(dp[0][y][t-1]!=dp[0][father[y][t-1]][t-1])
                    {
                        dp[0][y][t]=max(dp[0][y][t-1],dp[0][father[y][t-1]][t-1]);
                        dp[1][y][t]=min(dp[0][y][t-1],dp[0][father[y][t-1]][t-1]);
                    }
                    else
                    {
                        dp[0][y][t]=dp[0][y][t-1];
                        dp[1][y][t]=max(dp[1][y][t-1],dp[1][father[y][t-1]][t-1]);
                    }
                }
            }
        }
    }
    inline void update2(int x)
    {
        if(x>val1)
            val2=val1,val1=x;
        else if(x>val2 && x!=val1)
            val2=x;
    }
    inline void update(int x, int t)
    {
        update2(dp[0][x][t]);
        update2(dp[1][x][t]);
    }
    inline void Lca(int x, int y)
    {
        val1=val2=-INF;
        if(deep[x]<deep[y])
            swap(x,y);
        while(deep[x]>deep[y])
        {
            int t=(int)log2(deep[x]-deep[y]);
            update(x,t),x=father[x][t];
        }
        if(x==y)
            return;
        for(int t=(int)log2(deep[x]); t>=0; t--)
        {
            if(father[x][t]!=father[y][t])
            {
                update(x,t),update(y,t);
                x=father[x][t];
                y=father[y][t];
            }
        }
        update(x,0),update(y,0);
    }
} g1;
int main()
{
//  freopen("stdin.in","r",stdin);
//  freopen("stdout.out","w",stdout);
    scanf("%d%d",&n,&m);
    g1.init2();
    for(int i=1; i<=m; i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        s[i].x=a,s[i].y=b,s[i].z=c;
        fa[i]=i;
    }
    g1.Kruskal();
    g1.bfs(1);
    ans_max=INF;
    for(int i=1; i<=m; i++)
    {
        if(!s[i].vis)
        {
            g1.Lca(s[i].x,s[i].y);
            if(val1!=s[i].z)
                ans_max=min(ans_max,ans-val1+s[i].z);
            else
                ans_max=min(ans_max,ans-val2+s[i].z);
        }
    }
    printf("%lld\n",ans_max);
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/2884/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 356. 次小生成树(LCT)    原题链接    困难
作者：    whsstory ,  2020-05-21 11:03:03 ,  阅读 266

3


1
考虑先求出一棵最小生成树,边权之和为sumsum.

考虑加入一条非树边(u,v,w)(u,v,w).显然用它替换掉树上u→vu→v路径中的某一条边,得到的新生成树权值和必然不小于sumsum(否则与最小生成树的定义违背).因此替换多条边是不优的.
显然用这条边替换掉边权尽量大的边(但要边权之和必须小于sumsum) 更优.记u→vu→v路径上的最大边权是mxmx,严格次大边权是secsec.若mx<wmx<w,则可以替换掉mxmx,新生成树权值和为sum−mx+wsum−mx+w.否则mx=wmx=w(注意不会有非树边满足w<mxw<mx,否则替换会得到更小的最小生成树,与定义违背),只能替换secsec,新生成树权值和为sum−sec+wsum−sec+w
需要一个数据结构支持查询链上最大边权,次大边权的操作.树剖+线段树/ST表,LCT均可.这里我采用了LCT,时间复杂度为(mlogn)O(mlog⁡n),空间线性.
由于LCT常数较大而本题时限较短,需要卡常.我卡了50min,你呢
若使用LCT,有个细节是LCT无法直接维护边权,可以用边权转点权的技巧常数更大了

/**********/
#define MAXN 300011
struct DSU//并查集,用于求最小生成树
{
    ll fa[MAXN];
    void build(ll n){for(ll i=1;i<=n;++i)fa[i]=i;}
    ll find(ll x)
    {
        if(fa[x]==x)return x;
        return fa[x]=find(fa[x]);
    }
    bool uni(ll u,ll v)
    {
        u=find(u),v=find(v);
        if(u==v)return 0;
        fa[u]=v;return 1;
    }
}s;
struct edge
{
    ll u,v,w;
    bool operator <(const edge& t)const{return w<t.w;}
}e[MAXN];
std::vector<ll>g[MAXN];
bool used[MAXN];
ll Kru(ll n,ll m)
{
    std::sort(e+1,e+m+1);
    s.build(n);
    ll ans=0;
    for(ll i=1;i<=m;++i)
        if(s.uni(e[i].u,e[i].v))
        {
            ans+=e[i].w;
            g[e[i].u].push_back(e[i].v),g[e[i].v].push_back(e[i].u);
            used[i]=1;
        }
    return ans;
}
struct LCT//LCT,维护链上最大边权和严格次大边权
{
    ll fa[MAXN],son[MAXN][2],val[MAXN], maxv[MAXN],sec[MAXN],tag[MAXN], tot;
    void init(ll n){tot=n;}
    void pushup(ll x)//卡常过的pushup
    {
        ll l=son[x][0],r=son[x][1];
        maxv[x]=max(max(maxv[l],maxv[r]),val[x]);
        sec[x]=0;
        if(maxv[l]<maxv[x])umax(sec[x],maxv[l]);
        else umax(sec[x],sec[l]);
        if(val[x]<maxv[x])umax(sec[x],val[x]);
        if(maxv[r]<maxv[x])umax(sec[x],maxv[r]);
        else umax(sec[x],sec[r]); 
    }
    void pushdown(ll x)
    {
        if(tag[x])
        {
            std::swap(son[x][0],son[x][1]);
            tag[son[x][0]]^=1,tag[son[x][1]]^=1;
            tag[x]=0;
        }
    }
    bool not_root(ll x){return son[fa[x]][0]==x||son[fa[x]][1]==x;}
    void rotate(ll x)
    {
        ll y=fa[x],z=fa[y],k=(son[y][1]==x);
        if(not_root(y))son[z][son[z][1]==y]=x;
        fa[x]=z;
        son[y][k]=son[x][!k],fa[son[x][!k]]=y;
        son[x][!k]=y,fa[y]=x;
        pushup(y);//再pushu(x)就会TLE
    }
    ll s[MAXN];
    void splay(ll x)
    {
        ll top=0;
        s[++top]=x;
        for(ll y=x;not_root(y);y=fa[y])s[++top]=fa[y];
        while(top)pushdown(s[top--]);
        while (not_root(x))
        {
            ll y=fa[x];
            if(not_root(y))rotate((son[y][1]==x)==(son[fa[y]][1]==y)?y:x);
            rotate(x);
        }
        pushup(x);        
    }
    void access(ll x)
    {
        for(ll y=0;x;y=x,x=fa[x])
            splay(x),son[x][1]=y;
    }
    void make_root(ll x){access(x),splay(x),tag[x]^=1;}
    void link(ll x,ll y)
    {
        make_root(x);
        fa[x]=y;
    }
    void merge(ll x,ll y,ll v)
    {
        val[++tot]=v;
        link(x,tot),link(y,tot);
    }
    pll split(ll x,ll y)//求链上最大边权和严格次大边权
    {
        make_root(x),access(y),splay(y);
        return pll(maxv[y],sec[y]);
    }
}lct;
int main()
{
    ll n=read(),m=read();
    for(ll i=1;i<=m;++i)e[i].u=read(),e[i].v=read(),e[i].w=read();
    ll sum=Kru(n,m);
    lct.init(n);
    for(ll i=1;i<=m;++i)
        if(used[i])lct.merge(e[i].u,e[i].v,e[i].w);
    ll ans=INF;
    for(ll i=1;i<=m;++i)
    {
        if(used[i])continue;
        pll mx=lct.split(e[i].u,e[i].v);
        if(mx.first<e[i].w)umin(ans,sum-mx.first+e[i].w);
        else umin(ans,sum-mx.second+e[i].w);
    }
    printf("%lld",ans);
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/13453/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010, M = 300010, INF = 0x3f3f3f3f;

int n, m;
struct Edge
{
    int a, b, w;
    bool used;
    bool operator< (const Edge &t) const
    {
        return w < t.w;
    }
}edge[M];
int p[N];
int h[N], e[M], w[M], ne[M], idx;
int depth[N], fa[N][17], d1[N][17], d2[N][17];
int q[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

LL kruskal()
{
    for (int i = 1; i <= n; i ++ ) p[i] = i;
    sort(edge, edge + m);
    LL res = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = find(edge[i].a), b = find(edge[i].b), w = edge[i].w;
        if (a != b)
        {
            p[a] = b;
            res += w;
            edge[i].used = true;
        }
    }

    return res;
}

void build()
{
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i ++ )
        if (edge[i].used)
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            add(a, b, w), add(b, a, w);
        }
}

void bfs()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    q[0] = 1;
    int hh = 0, tt = 0;
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] > depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                d1[j][0] = w[i], d2[j][0] = -INF;
                for (int k = 1; k <= 16; k ++ )
                {
                    int anc = fa[j][k - 1];
                    fa[j][k] = fa[anc][k - 1];
                    int distance[4] = {d1[j][k - 1], d2[j][k - 1], d1[anc][k - 1], d2[anc][k - 1]};
                    d1[j][k] = d2[j][k] = -INF;
                    for (int u = 0; u < 4; u ++ )
                    {
                        int d = distance[u];
                        if (d > d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d;
                        else if (d != d1[j][k] && d > d2[j][k]) d2[j][k] = d;
                    }
                }
            }
        }
    }
}

int lca(int a, int b, int w)
{
    static int distance[N * 2];
    int cnt = 0;
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 16; k >= 0; k -- )
        if (depth[fa[a][k]] >= depth[b])
        {
            distance[cnt ++ ] = d1[a][k];
            distance[cnt ++ ] = d2[a][k];
            a = fa[a][k];
        }
    if (a != b)
    {
        for (int k = 16; k >= 0; k -- )
            if (fa[a][k] != fa[b][k])
            {
                distance[cnt ++ ] = d1[a][k];
                distance[cnt ++ ] = d2[a][k];
                distance[cnt ++ ] = d1[b][k];
                distance[cnt ++ ] = d2[b][k];
                a = fa[a][k], b = fa[b][k];
            }
        distance[cnt ++ ] = d1[a][0];
        distance[cnt ++ ] = d1[b][0];
    }

    int dist1 = -INF, dist2 = -INF;
    for (int i = 0; i < cnt; i ++ )
    {
        int d = distance[i];
        if (d > dist1) dist2 = dist1, dist1 = d;
        else if (d != dist1 && d > dist2) dist2 = d;
    }

    if (w > dist1) return w - dist1;
    if (w > dist2) return w - dist2;
    return INF;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        edge[i] = {a, b, c};
    }

    LL sum = kruskal();
    build();
    bfs();

    LL res = 1e18;
    for (int i = 0; i < m; i ++ )
        if (!edge[i].used)
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            res = min(res, sum + lca(a, b, w));
        }
    printf("%lld\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/154825/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

严格次小生成树
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>

using namespace std;

typedef long long LL;

const int N = 100010, M = 600010, INF = 0x3f3f3f3f;

struct Edges{
    int a, b, w;
    bool used;
    bool operator< (const struct Edges &W) const{
        return w < W.w;
    }
}edges[M];

int n, m;
int f[N];

int find(int x)
{
    if(f[x] != x)  f[x] = find(f[x]);
    return f[x];
}

LL kruskal()
{
    for(int i = 1; i <= n; i ++)  f[i] = i;

    LL res = 0;
    for(int i = 0; i < m; i ++)
    {
        int a = find(edges[i].a), b = find(edges[i].b), w = edges[i].w;
        if(a != b)
        {
            f[a] = b;
            res += w;
            edges[i].used = true;
        }
    }
    return res;
}

int h[N], e[N * 2], w[N * 2], ne[N * 2], idx;
void add(int a, int b, int c)
{
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx ++;
}

void build()
{
    memset(h, -1, sizeof h);
    for(int i = 0; i < m; i ++)
        if(edges[i].used)
        {
            int a = edges[i].a, b = edges[i].b, c = edges[i].w;
            add(a, b, c);
            add(b, a, c);
        }
}

int depth[N];
int fa[N][17];                  //fa[u][i]为点u向上跳2^i步的位置
int d1[N][17], d2[N][17];       //d1,d2[u][i]分别为点u向上条2^i步的最大边和[严格]次大边（小于最大边的最大边）的边权

void bfs()
{
    depth[1] = 1;

    queue<int> q;
    q.push(1);

    while(!q.empty())
    {
        int u = q.front();  q.pop();

        for(int i = h[u]; ~i; i = ne[i])
        {
            int j = e[i];
            if(!depth[j])
            {
                depth[j] = depth[u] + 1;
                q.push(j);

                fa[j][0] = u;
                d1[j][0] = w[i], d2[j][0] = -INF;

                for(int k = 1; k < 17; k ++)
                {
                    int t = fa[j][k - 1];
                    fa[j][k] = fa[t][k - 1];

                    int dist[4] = {d1[j][k - 1], d2[j][k - 1], d1[t][k - 1], d2[t][k - 1]};

                    d1[j][k] = d2[j][k] = -INF;
                    for(int l = 0; l < 4; l ++)
                    {
                        int d = dist[l];
                        if(d > d1[j][k])  d2[j][k] = d1[j][k], d1[j][k] = d;        //d严格>d1, d2 = d1, d1 = d, d1严格>d2
                        else if(d < d1[j][k] && d > d2[j][k])  d2[j][k] = d;        //d2 < d < d1, d2 = d, d1严格>d2
                    }
                }
            }
        }
    }
}

int lca(int a, int b, int w)            //返回a到b路径上小于w的最大边权
{
    int res = 0;

    if(depth[a] < depth[b])  swap(a, b);

    for(int i = 16; i >= 0; i --)
        if(depth[fa[a][i]] >= depth[b])
        {
            if(d1[a][i] < w)  res = max(res, d1[a][i]);
            else  res = max(res, d2[a][i]);
            a = fa[a][i];
        }

    if(a == b)  return res;

    for(int i = 16; i >= 0; i --)
        if(fa[a][i] != fa[b][i])
        {
            if(d1[a][i] < w)  res = max(res, d1[a][i]);
            else  res = max(res, d2[a][i]);
            if(d1[b][i] < w)  res = max(res, d1[b][i]);
            else  res = max(res, d2[b][i]);
            a = fa[a][i];
            b = fa[b][i];
        }
    if(d1[a][0] < w)  res = max(res, d1[a][0]);
    else  res = max(res, d2[a][0]);
    if(d1[b][0] < w)  res = max(res, d1[b][0]);
    else  res = max(res, d2[b][0]);

    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 0; i < m; i ++)  scanf("%d%d%d", &edges[i].a, &edges[i].b, &edges[i].w);
    sort(edges, edges + m);

    LL sum = kruskal();
    build();
    bfs();

    LL res = 1e18;
    for(int i = 0; i < m; i ++)
        if(!edges[i].used)
        {
            int a = edges[i].a, b = edges[i].b, w = edges[i].w;
            res = min(res, sum + w - lca(a, b, w));
        }
    printf("%lld", res);
    return 0;
}

作者：滑稽_ωﾉ
链接：https://www.acwing.com/activity/content/code/content/157441/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>
#include <cstring>
#include <complex>
#include <utility>
#include <sstream>

using namespace std;

typedef long long ll;

const int N=100010;
const int M=300010;
const int K=17;
const int INF=0x3f3f3f3f;

struct Edge
{
    int a,b,w;
    bool used;
    bool operator<(const Edge x)const
    {
        return w<x.w;
    }
}edges[M];

int n,m;
int h[N],e[M],w[M],ne[M],idx;
int fa[N][K],depth[N];
int d1[N][K],d2[N][K],p[N];
int q[N],hh,tt;

inline int read()
{
    int x=0;
    char ch;
    bool fx=false;
    do ch=getchar();while(~ch&&ch!='-'&&(ch<'0'||ch>'9'));
    for(;ch>='0'&&ch<='9';ch=getchar())
        x=(x<<1)+(x<<3)+(ch^48);
    return fx?-x:x;
}

int find(int x)
{
    if(p[x]!=x)p[x]=find(p[x]);
    return p[x];
}

ll kruskal()
{
    for(int i=1;i<=n;i++)
        p[i]=i;
    sort(edges,edges+m);
    ll res=0;
    for(int i=0;i<m;i++)
    {
        int a=find(edges[i].a);
        int b=find(edges[i].b);
        if(a!=b)
        {
            p[a]=b;
            res+=edges[i].w;
            edges[i].used=true;
        }
    }
    return res;
}

inline void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

inline void build()
{
    for(int i=0;i<m;i++)
        if(edges[i].used)
        {
            add(edges[i].a,edges[i].b,edges[i].w);
            add(edges[i].b,edges[i].a,edges[i].w);
        }
}

inline void bfs()
{
    memset(depth,0x3f,sizeof depth);
    depth[0]=0,depth[1]=1,q[0]=1;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(depth[e[i]]>depth[t]+1)
            {
                depth[e[i]]=depth[t]+1;
                q[++tt]=e[i];
                fa[e[i]][0]=t;
                d1[e[i]][0]=w[i],d2[e[i]][0]=-INF;
                for(int k=1;k<17;k++)
                {
                    fa[e[i]][k]=fa[fa[e[i]][k-1]][k-1];
                    int distance[4]={d1[e[i]][k-1],d2[e[i]][k-1],d1[fa[e[i]][k-1]][k-1],d2[fa[e[i]][k-1]][k-1]};
                    d1[e[i]][k]=d2[e[i]][k]=-INF;
                    for(int d=0;d<4;d++)
                    {
                        int dist=distance[d];
                        if(dist>d1[e[i]][k])d2[e[i]][k]=d1[e[i]][k],d1[e[i]][k]=dist;
                        else if(dist!=d1[e[i]][k]&&dist>d2[e[i]][k])d2[e[i]][k]=dist;
                    }
                }
            }
    }
}

int lca(int a,int b,int w)
{
    static int distance[N*2];
    int cnt=0;
    if(depth[a]<depth[b])swap(a,b);
    for(int k=16;~k;k--)
        if(depth[fa[a][k]]>=depth[b])
        {
            distance[cnt++]=d1[a][k];
            distance[cnt++]=d2[a][k];
            a=fa[a][k];
        }
    if(a!=b)
    {
        for(int k=16;~k;k--)
            if(fa[a][k]!=fa[b][k])
            {
                distance[cnt++]=d1[a][k];
                distance[cnt++]=d2[a][k];
                distance[cnt++]=d1[b][k];
                distance[cnt++]=d2[b][k];
                a=fa[a][k],b=fa[b][k];
            }
        distance[cnt++]=d1[a][0];
        distance[cnt++]=d1[b][0];
    }
    int dist1=-INF,dist2=-INF;
    for(int i=0;i<cnt;i++)
    {
        int d=distance[i];
        if(d>dist1)dist2=dist1,dist1=d;
        else if(d!=dist1&&d>dist2)dist2=d;
    }
    if(w>dist1)return w-dist1;
    if(w>dist2)return w-dist2;
    return INF;
}

int main()
{
    n=read(),m=read();
    for(int i=0;i<m;i++)
    {
        edges[i].a=read();
        edges[i].b=read();
        edges[i].w=read();
        edges[i].used=false;
    }
    ll sum=kruskal();
    build();
    bfs();
    ll res=1e18;
    for(int i=0;i<m;i++)
        if(!edges[i].used)
        {
            res=min(res,sum+lca(edges[i].a,edges[i].b,edges[i].w));
        }
    cout<<res;
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/321944/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 352. 闇の連鎖    原题链接    困难
作者：    秦淮岸灯火阑珊 ,  2019-07-14 21:43:58 ,  阅读 745

13


3
题目描述
传说中的暗之连锁被人们称为 Dark。

Dark 是人类内心的黑暗的产物，古今中外的勇者们都试图打倒它。

经过研究，你发现 Dark 呈现无向图的结构，图中有 N 个节点和两类边，一类边被称为主要边，而另一类被称为附加边。

Dark 有 N – 1 条主要边，并且 Dark 的任意两个节点之间都存在一条只由主要边构成的路径。

另外，Dark 还有 M 条附加边。

你的任务是把 Dark 斩为不连通的两部分。

一开始 Dark 的附加边都处于无敌状态，你只能选择一条主要边切断。

一旦你切断了一条主要边，Dark 就会进入防御模式，主要边会变为无敌的而附加边可以被切断。

但是你的能力只能再切断 Dark 的一条附加边。

现在你想要知道，一共有多少种方案可以击败 Dark。

注意，就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。

输入格式
第一行包含两个整数 N 和 M。

之后 N – 1 行，每行包括两个整数 A 和 B，表示 A 和 B 之间有一条主要边。

之后 M 行以同样的格式给出附加边。

输出格式
输出一个整数表示答案。

数据范围
N≤100000M≤200000,数据保证答案不超过231−1
N≤100000M≤200000,数据保证答案不超过231−1
输入样例：
4 1 
1 2 
2 3 
1 4 
3 4 
输出样例：
3
解题报告
题意理解
这道题目题意比较绕,我们来一步步剖解这道题目.题目解剖学,人体解剖学

一颗n−1n−1条主要边的树,然后增加了mm条附加边.
我们只能删除一条主要边,一条附加边,一种边叫做主要边,一种边叫做附加边.
要求删除两条边后,这棵树不再是连通的.
我们需要统计,有多少种方案可以使得不连通,输出方案数.
算法解析
附加边到底有什么用处?
对于每一条连接x,y节点的(x,y),其实我们都可以认为这条边,连接了(x,y)这条路径上的所有点.
对于每一条连接x,y节点的(x,y),其实我们都可以认为这条边,连接了(x,y)这条路径上的所有点.

当没有了主要边的时候,其实附加边就是我们的主要边.
所以说,附加边(x,y),就是将树上x,y之间的路径上的每条主要边,都覆盖了一次.
所以说,附加边(x,y),就是将树上x,y之间的路径上的每条主要边,都覆盖了一次.

因为当(x,y)(x,y)路径上的任意一条主要边消失后,他都可以成为主要边,去维护连通性.

因此现在我们的问题模型转化了.

给定一个n−1n−1条边的树,求每一条树边,被非树边覆盖了多少次

树边也就是主要边
非树边也就是附加边
那么这就是一个树上差分统计覆盖次数问题了.
每一条附加边,使得(x,y)节点的路径上,每一个节点的权值+1.
每一条附加边,使得(x,y)节点的路径上,每一个节点的权值+1.
此时我们的问题,变成了如何统计方案数.

我们来好好地分类讨论一下主要边,身上的附加边.
1.主要边被覆盖了0次,即上面只有0条附加边.
1.主要边被覆盖了0次,即上面只有0条附加边.

我们发现删除完这条主要边后,随意删除一条附加边,我们都可以让树不连通.也就是mm种方案.



只要删除(2,4)(2,4)这条红边,那么随意一条附加边,都可以满足条件.
2.主要边覆盖1次,即上面只有一条附加边
2.主要边覆盖1次,即上面只有一条附加边

我们发现删除完这条主要边后,我们只能删除这条主要边的附加边.也就是11种方案.

也就是删除咱们图上面的(3,7)(3,7)红边,然后我们只能删除那条上面的紫色边.
3.主要边覆盖大于1次,即上面有多条附加边
3.主要边覆盖大于1次,即上面有多条附加边

我们发现,怎么删除,总能连通.于是00种方案.

代码解析
#include <bits/stdc++.h>
using namespace std;
const int N=100000+200;
int n,m,ans;
struct LCA
{
    int head[N<<1],Next[N<<1],edge[N<<1],ver[N<<1],tot;
    int deep[N],fa[N][22],lg[N],date[N];
    inline void init()
    {
        memset(head,0,sizeof(head));
        memset(deep,0,sizeof(deep));
        tot=0;
    }
    inline void add_edge(int a,int b,int c)
    {
        edge[++tot]=b;
        ver[tot]=a;
        Next[tot]=head[a];
        head[a]=tot;
    }
    inline void dfs(int x,int y)
    {
        deep[x]=deep[y]+1;//深度是父亲节点+1
        fa[x][0]=y;//2^0=1,也就是父亲节点
        for(int i=1; (1<<i)<=deep[x]; i++) //2^i<=deep[x]也就是别跳出根节点了
            fa[x][i]=fa[fa[x][i-1]][i-1];
        for(int i=head[x]; i; i=Next[i]) //遍历所有的出边
            if (edge[i]!=y)//避免回到父亲节点
                dfs(edge[i],x);//自己的儿子节点, 自己是父亲节点
        return ;
    }
    inline int Lca(int x,int y)//Lca过程
    {
        if (deep[x]<deep[y])//x节点默认深度深一些,在下面
            swap(x,y);//交换
        while(deep[x]>deep[y])//还没有同一高度
            x=fa[x][lg[deep[x]-deep[y]]-1];//往上面跳跃,deep[x]-deep[y]是高度差.-1是为了防止deep[x]<deep[y]
        if(x==y)//意外发现,y就是(x,y)的Lca
            return x;
        for(int i=lg[deep[x]]; i>=0; i--)
            if (fa[x][i]!=fa[y][i])//没有跳到Lca
            {
                x=fa[x][i];//旋转跳跃
                y=fa[y][i];//我闭着眼
            }
        return fa[x][0];//父亲节点就是Lca,因为本身是离着Lca节点最近的节点,也就是Lca的儿子节点.
    }
    inline int query(int x,int f)//f是x节点的父亲节点
    {
        for(int i=head[x]; i; i=Next[i]) //所有出边
        {
            int j=edge[i];//出边
            if (j!=f)//不是父亲节点
            {
                query(j,x);//访问儿子节点
                date[x]+=date[j];//累加子树节点的值
                if(date[j]==0)
                    ans+=m;
                else if(date[j]==1)
                    ans++;
            }
        }
    }
    inline int update(int x,int y)//修改操作,x,y节点构成的路径统一+1
    {
        date[x]++;
        date[y]++;
        date[Lca(x,y)]-=2;
    }
} g1;
int main()
{
    scanf("%d%d",&n,&m);
    g1.init();
    for(int i=1; i<n; i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        g1.add_edge(a,b,0);//加边
        g1.add_edge(b,a,0);//无向图
    }
    for(int i=1; i<=n; i++)
        g1.lg[i]=g1.lg[i-1]+(1<<g1.lg[i-1]==i);//处理log数组的关系
    g1.dfs(1,0);
    for(int i=1; i<=m; i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        g1.update(a,b);//附加边
    }
    g1.query(1,0);
    printf("%d\n",ans);
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/2830/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = N * 2;

int n, m;
int h[N], e[M], ne[M], idx;
int depth[N], fa[N][17];
int d[N];
int q[N];
int ans;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    int hh = 0, tt = 0;
    q[0] = 1;

    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] > depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k <= 16; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 16; k >= 0; k -- )
        if (depth[fa[a][k]] >= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 16; k >= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}

int dfs(int u, int father)
{
    int res = d[u];
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j != father)
        {
            int s = dfs(j, u);
            if (s == 0) ans += m;
            else if (s == 1) ans ++ ;
            res += s;
        }
    }

    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }

    bfs();

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        int p = lca(a, b);
        d[a] ++, d[b] ++, d[p] -= 2;
    }
    dfs(1, -1);
    printf("%d\n", ans);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/154841/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1174. 受欢迎的牛    原题链接    中等
作者：    Overnoise ,  2020-01-15 09:52:49 ,  阅读 780

6


1
请不要在意不忍直视的函数名
分析来自： https://www.luogu.com.cn/blog/zyb2624936151/tarjan
注：明星==最受欢迎的牛
首先，不难发现，如果这所有的牛都存在同一个强联通分量里。那么它们一定互相受欢迎。

那么，我们怎么来找明星呢。

很简单，找出度为00的强联通分量中的点。这样可以保证所有的人都喜欢它，但是它不喜欢任何人，所以说不存在还有人事明星。

此题还有一个特殊情况：

如果有两个点分别满足出度为零的条件，则没有明星，这样无法满足所有的牛喜欢他。

有了上边的解释，题目就不是那么难了，代码如下

#include<bits/stdc++.h>
using namespace std;
int n,m,a,b;
struct oppo {
    int to,next;
} rood[50004];
bool f[10004];
int head[10004],tot,t[10004],ans;
int dfn[10004],low[10004],time_,vis[10004],all,belong[10004];
void add(int from,int to) {
    rood[++tot].to=to;
    rood[tot].next=head[from];
    head[from]=tot;
}
stack< int > v;
void Tarjan(int x) {
    dfn[x]=low[x]=++time_;
    v.push(x);
    vis[x]=1;
    for(int i=head[x]; i; i=rood[i].next) {
        if(!dfn[rood[i].to])
            Tarjan(rood[i].to);
        low[x]=min(low[x],low[rood[i].to]);
    }
    if(dfn[x]==low[x]) {
        belong[x]=++all;
        int y;
        do {
            y=v.top();
            v.pop();
            belong[y]=all;
            t[all]++;
        } while(y!=x);
    }
}
int main() {
    cin>>n>>m;
    for(int i=1; i<=m; i++) {
        scanf("%d %d",&a,&b);
        add(a,b);
    }
    for(int i=1; i<=n; i++)
        if(!dfn[i]) Tarjan(i);
    for(int i=1; i<=n; i++)
        for(int j=head[i]; j; j=rood[j].next)
            if(belong[i]!=belong[rood[j].to])
                f[belong[i]]=1;
    for(int i=1; i<=all; i++)
        if(!f[i])
            if(ans) {
                puts("0");
                return 0;
            } else
                ans=t[i];
    cout<<ans<<endl;
    return 0;
}

作者：Overnoise
链接：https://www.acwing.com/solution/content/7566/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010, M = 50010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, Size[N];
int dout[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            Size[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }

    for (int i = 1; i <= n; i ++ )
        if (!dfn[i])
            tarjan(i);

    for (int i = 1; i <= n; i ++ )
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a != b) dout[a] ++ ;
        }

    int zeros = 0, sum = 0;
    for (int i = 1; i <= scc_cnt; i ++ )
        if (!dout[i])
        {
            zeros ++ ;
            sum += Size[i];
            if (zeros > 1)
            {
                sum = 0;
                break;
            }
        }

    printf("%d\n", sum);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/155842/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 367. 学校网络    原题链接    中等
作者：    番茄酱 ,  2020-01-26 19:33:49 ,  阅读 411

8


2
分析
TarjanTarjan 缩点将原图转化成 DAGDAG，统计每个强连通分量的出度入度，起点数量为 srcsrc，终点数量为 desdes。对于一个强连通分量，其中只要有一所学校获得新软件那么整个分量都能获得。

问题一
结论
只要把软件给所有起点即可，答案为起点个数 srcsrc。

证明
所有起点都无法由别的点到达，因此每个起点必须分配一个软件，而对于其他所有点，一定存在前驱，一定能由某一个起点走到，也就是说从所有起点出发，能遍历整个图。因此只需要给所有起点各一个软件即可。

问题二
结论
若 scc_cnt=1scc_cnt=1（只有一个强连通分量），则不需要连新的边，答案为 00。
若 scc_cnt>1scc_cnt>1，则答案为 max(src,des)max(src,des)。
证明（yxc讲解总结）
结论 11 正确性显然，下面证明结论 22。

设缩点后的 DAGDAG 中，起点（入度为 00）的集合为 PP，终点（出度为 00）的集合为 QQ。分以下两种情况讨论：

|P|≤|Q||P|≤|Q|
① 若 |P|=1|P|=1，则只有一个起点，并且这个起点能走到所有点，只要将每一个终点都向这个起点连一条边，那么对于图中任意一点，都可以到达所有点，新加的边数为 |Q||Q|。

② 若 |P|≥2|P|≥2，则 |Q|≥|P|≥2|Q|≥|P|≥2，此时至少存在 22 个起点 p1,p2p1,p2，22 个终点 q1,q2q1,q2，满足 p1p1 能走到 q1q1，p2p2 能走到 q2q2。（反证法：如果不存在两个起点能走到不同的终点，则所有的起点一定只能走到同一个终点，而终点至少有两个，发生矛盾，假设不成立）。如下图：



那么我们可以从 q1q1 向 p2p2 新连一条边，那么此时起点和终点的个数都会减少一个（p2p2 不再是起点，q1q1 不再是终点），因此只要以这种方式，连接新边 |P|−1|P|−1 条，则 |P′|=1|P′|=1，而 |Q′|=|Q|−(|P|−1)|Q′|=|Q|−(|P|−1)，由 ① 得，当 |P′|=1|P′|=1 时，需要再连 |Q′||Q′| 条新边，那么总添加的新边数量为 |P|−1+|Q|−(|P|−1)=|Q||P|−1+|Q|−(|P|−1)=|Q|。

|Q|≤|P||Q|≤|P|
与情况 11 对称，此时答案为 |P||P|。

综上所述，scc_cnt>1scc_cnt>1 时，问题二的答案为 max(|P|,|Q|)max(|P|,|Q|) 即 max(src,des)max(src,des)。

代码
#include <bits/stdc++.h>

using namespace std;

const int N = 110, M = N * N;

int n;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], tt;
bool in_stk[N];
int id[N], sz[N], scc_cnt;
int din[N], dout[N];

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void tarjan(int u) {
    dfn[u] = low[u] = ++timestamp;
    stk[++tt] = u, in_stk[u] = true;
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        } else if (in_stk[j]) {
            low[u] = min(low[u], dfn[j]);
        }
    }
    if (dfn[u] == low[u]) {
        ++scc_cnt;
        int v;
        do {
            v = stk[tt--];
            in_stk[v] = false;
            id[v] = scc_cnt;
            sz[scc_cnt]++;
        } while (v != u);
    }
} 

int main() {
    cin >> n;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i++) {
        int t;
        while (cin >> t, t) add(i, t);
    }
    for (int i = 1; i <= n; i++) {
        if (!dfn[i]) tarjan(i);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = h[i]; ~j; j = ne[j]) {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a != b) dout[a]++, din[b]++;
        }
    }
    int src = 0, des = 0;
    for (int i = 1; i <= scc_cnt; i++) {
        if (!din[i]) src++;
        if (!dout[i]) des++;
    }
    printf("%d\n", src);
    if (scc_cnt == 1) puts("0");
    else printf("%d\n", max(src, des));
    return 0;
}

作者：番茄酱
链接：https://www.acwing.com/solution/content/4663/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, M = 10010;

int n;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt;
int din[N], dout[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
        } while (y != u);
    }
}

int main()
{
    cin >> n;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ )
    {
        int t;
        while (cin >> t, t) add(i, t);
    }

    for (int i = 1; i <= n; i ++ )
        if (!dfn[i])
            tarjan(i);

    for (int i = 1; i <= n; i ++ )
        for (int j = h[i]; j != -1; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a != b)
            {
                dout[a] ++ ;
                din[b] ++ ;
            }
        }

    int a = 0, b = 0;
    for (int i = 1; i <= scc_cnt; i ++ )
    {
        if (!din[i]) a ++ ;
        if (!dout[i]) b ++ ;
    }

    printf("%d\n", a);
    if (scc_cnt == 1) puts("0");
    else printf("%d\n", max(a, b));

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/155866/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1175. 最大半连通子图 缩点+dp    原题链接    中等
作者：    xxh ,  2020-02-12 21:54:59 ,  阅读 295

2


题解 ==============================================================

一、内容
　一个有向图G=(V,E)称为半连通的(Semi-Connected)，如果满足：?u,v∈V，满足u→v或v→u，即对于图中任意
两点u，v,存在一条u到v的有向路径或者从v到u的有向路径。若G'=(V',E')满足V'?V，E'是E中所有跟V'有关的边，
则称G'是G的一个导出子图。若G'是G的导出子图，且G'半连通，则称G'为G的半连通子图。若G'是G所有半连通子图
中包含节点数最多的，则称G'是G的最大半连通子图。给定一个有向图G，请求出G的最大半连通子图拥有的节点数K
，以及不同的最大半连通子图的数目C。由于C可能比较大，仅要求输出C对X的余数。
Input

　　第一行包含两个整数N，M，X。N，M分别表示图G的点数与边数，X的意义如上文所述接下来M行，每行两个正整
数a, b，表示一条有向边(a, b)。图中的每个点将编号为1,2,3…N，保证输入中同一个(a,b)不会出现两次。N ≤1
00000, M ≤1000000；对于100%的数据， X ≤10^8
Output

　　应包含两行，第一行包含一个整数K。第二行包含整数C Mod X.
Sample Input

6 6 20070603
1 2
2 1
1 3
2 4
5 6
6 4
Sample Output

3
3
二、思路
首先强连通分量必定是半连通子图。当我们建立出强连通图的拓扑图的时候，从入度为0的点出发，能走的所有最长的路径便是最大半连通子图。
dp[i]: 代表拓扑序从起点 到 i这个点最大的节点数。 cnt[i]：代表从起点到i的最大方案数。
直接在拓扑图上dp一下即可。
注意缩点后，每个点可能和其他点有多条边，这个时候我们应该去掉重边。 因为最大半连通子图包括的是所有边，不同的连通子图只会因为点不相同而不同。
三、代码
#include <cstdio>
#include <algorithm>
#include <unordered_map>
#include <iostream>
typedef long long ll;
using namespace std;
const int N = 1e5 + 5, M = 2e6 + 5; 
struct E{ int v, next;} e[M];
int n, m, mod, num, u, v, top, len, h[N], sh[N], scc_cnt, id[N], scc[N], low[N], stack[N], dfn[N], dp[N], cnt[N];
bool in_st[N];
unordered_map<ll, int> mp;
void add(int h[], int u, int v) {
    e[++len].v = v; e[len].next = h[u]; h[u] = len;
} 
void tarjan(int u) {
    dfn[u] = low[u] = ++num;
    stack[++top] = u; in_st[u] = true;
    for (int j = h[u]; j; j = e[j].next)  {
        int v = e[j].v;
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (in_st[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        ++scc_cnt; int v;
        do {
            v = stack[top--]; in_st[v] = false;
            id[v] = scc_cnt; scc[scc_cnt]++; //连通分量的节点数++ 
        } while (u != v);
    }
}
int main() {
    scanf("%d%d%d", &n, &m, &mod);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &u, &v); add(h, u, v);
    }
    for (int u = 1; u <= n; u++) if (!dfn[u]) tarjan(u);
    //建立SCC拓扑图
    for (int u = 1; u <= n; u++) {
        for (int j = h[u]; j; j = e[j].next) {
            int v = e[j].v;
            if (id[u] != id[v]) {
                ll hash = id[u] * N + id[v];
                if (!mp.count(hash)) {
                    mp[hash]++; add(sh, id[u], id[v]);
                }
            }
        }
    } 
    //通过拓扑图进行dp求最大节点数 dp[]保存这条链的节点总数 cnt保存方案数 
    for (int u = scc_cnt; u >= 1; u--) {
        if (!dp[u]) dp[u] = scc[u], cnt[u] = 1; //代表它是入度为0的起点 
        for (int j = sh[u]; j; j = e[j].next) {
            int v = e[j].v;
            if (dp[v] < dp[u] + scc[v]) {
                dp[v] = dp[u] + scc[v];
                cnt[v] = cnt[u];
            } else if (dp[v] == dp[u] + scc[v]) cnt[v] = (cnt[v] + cnt[u]) % mod; 
        }
    } 
    //最后求一下最大值 
    int maxv = -1, c = 0;
    for (int u = scc_cnt; u >= 1; u--) {
        if (maxv < dp[u]) {
            maxv = dp[u];
            c = cnt[u];         
        } else if (maxv == dp[u]) c = (c + cnt[u]) % mod;
    }
    printf("%d\n%d", maxv, c);
    return 0; 
} 

作者：xxh
链接：https://www.acwing.com/solution/content/8495/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_set>

using namespace std;

typedef long long LL;

const int N = 100010, M = 2000010;

int n, m, mod;
int h[N], hs[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, scc_size[N];
int f[N], g[N];

void add(int h[], int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            scc_size[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    memset(h, -1, sizeof h);
    memset(hs, -1, sizeof hs);

    scanf("%d%d%d", &n, &m, &mod);
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(h, a, b);
    }

    for (int i = 1; i <= n; i ++ )
        if (!dfn[i])
            tarjan(i);

    unordered_set<LL> S;    // (u, v) -> u * 1000000 + v
    for (int i = 1; i <= n; i ++ )
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            LL hash = a * 1000000ll + b;
            if (a != b && !S.count(hash))
            {
                add(hs, a, b);
                S.insert(hash);
            }
        }

    for (int i = scc_cnt; i; i -- )
    {
        if (!f[i])
        {
            f[i] = scc_size[i];
            g[i] = 1;
        }
        for (int j = hs[i]; ~j; j = ne[j])
        {
            int k = e[j];
            if (f[k] < f[i] + scc_size[k])
            {
                f[k] = f[i] + scc_size[k];
                g[k] = g[i];
            }
            else if (f[k] == f[i] + scc_size[k])
                g[k] = (g[k] + g[i]) % mod;
        }
    }

    int maxf = 0, sum = 0;
    for (int i = 1; i <= scc_cnt; i ++ )
        if (f[i] > maxf)
        {
            maxf = f[i];
            sum = g[i];
        }
        else if (f[i] == maxf) sum = (sum + g[i]) % mod;

    printf("%d\n", maxf);
    printf("%d\n", sum);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/155884/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 368. 银河 SCC + 差分约束    原题链接    中等
作者：    xxh ,  2020-02-13 13:32:05 ,  阅读 347

2


题解 ： https://xiaoxiaoh.blog.csdn.net/article/details/104294442

一、内容
银河中的恒星浩如烟海，但是我们只关注那些最亮的恒星。

我们用一个正整数来表示恒星的亮度，数值越大则恒星就越亮，恒星的亮度最暗是 1。

现在对于 N 颗我们关注的恒星，有 M 对亮度之间的相对关系已经判明。

你的任务就是求出这 N 颗恒星的亮度值总和至少有多大。
输入格式

第一行给出两个整数 N 和 M。

之后 M 行，每行三个整数 T, A, B，表示一对恒星(A, B)之间的亮度关系。恒星的编号从 1 开始。

如果 T = 1，说明 A 和 B 亮度相等。
如果 T = 2，说明 A 的亮度小于 B 的亮度。
如果 T = 3，说明 A 的亮度不小于 B 的亮度。
如果 T = 4，说明 A 的亮度大于 B 的亮度。
如果 T = 5，说明 A 的亮度不大于 B 的亮度。
输出格式

输出一个整数表示结果。

若无解，则输出 -1。
数据范围

N≤100000,M≤100000
输入样例：

5 7 
1 1 2 
2 3 2 
4 4 1 
3 4 5 
5 4 5 
2 3 5 
4 5 1
输出样例：

11
二、思路
根据题目所给关系可以建立不等式：


三、代码
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5, M = 6 * N;
struct E {int v, w, next;} e[M];
int n, m, a, b, x, len, h[N], sh[N], top, num, id[N], scc_cnt, stack[N], dfn[N], low[N], scc[N], d[N]; 
bool in_st[N], vis[N];
void add(int h[], int u, int v, int w) {
    e[++len].v = v; e[len].next = h[u]; e[len].w = w; h[u] = len; 
}
void tarjan(int u) {
    dfn[u] = low[u] = ++num;
    stack[++top] = u; in_st[u] = true;
    for (int j = h[u]; j; j = e[j].next) {
        int v = e[j].v;
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (in_st[v]) low[u] = min(low[u], dfn[v]);
    } 
    if (dfn[u] == low[u]) {
        ++scc_cnt; int v;
        do {
            v = stack[top--]; in_st[v] = false;
            scc[scc_cnt]++; id[v] = scc_cnt; 
        } while (u != v); 
    }
}
int dfs(int u) {
    int ans = 0;
    vis[u] = true;
    for (int j = h[u]; j; j = e[j].next) {
        int v = e[j].v;
        if (id[u] == id[v]) ans += e[j].w;
        if (vis[v] || id[u] != id[v]) continue;
        ans += dfs(v);
    }
    return ans;
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &x, &a, &b);
        if (x == 1) add(h, b, a, 0), add(h, a, b, 0); 
        else if (x == 2) add(h, a, b, 1); 
        else if (x == 3) add(h, b, a, 0);
        else if (x == 4) add(h, b, a, 1);
        else if (x == 5) add(h, a, b, 0);
    }
    //建立超级源点 
    for (int i = 1; i <= n; i++) add(h, 0, i, 1);
    tarjan(0);
    //判断是否有强连通分量 边权大于0
    bool ok = false;
    for (int i = 0; i <= n; i++) {
        if (dfs(i)) {
            ok = true; 
            break;
        }
    } 
    if (ok) printf("-1");
    else {
        for (int u = 0; u <= n; u++) {
            for (int j = h[u]; j; j = e[j].next) {
                int v = e[j].v;
                if (id[u] != id[v]) add(sh, id[u], id[v], e[j].w);
            }
        }
        //根据拓扑图进行dp
        for (int u = scc_cnt; u >= 1; u--) {
            for (int j = sh[u]; j; j = e[j].next) {
                int v = e[j].v;
                if (d[v] < d[u] + e[j].w) d[v] = d[u] + e[j].w;
            }
        }
        ll ans = 0;
        for (int i = 1; i <= scc_cnt; i++) ans += d[i] * scc[i];
        printf("%lld", ans); 
    }
    return 0; 
} 

作者：xxh
链接：https://www.acwing.com/solution/content/8509/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010, M = 600010;

int n, m;
int h[N], hs[N], e[M], ne[M], w[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, size[N];
int dist[N];

void add(int h[], int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            size[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    memset(hs, -1, sizeof hs);

    for (int i = 1; i <= n; i ++ ) add(h, 0, i, 1);

    while (m -- )
    {
        int t, a, b;
        scanf("%d%d%d", &t, &a, &b);
        if (t == 1) add(h, b, a, 0), add(h, a, b, 0);
        else if (t == 2) add(h, a, b, 1);
        else if (t == 3) add(h, b, a, 0);
        else if (t == 4) add(h, b, a, 1);
        else add(h, a, b, 0);
    }

    tarjan(0);

    bool success = true;
    for (int i = 0; i <= n; i ++ )
    {
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a == b)
            {
                if (w[j] > 0)
                {
                    success = false;
                    break;
                }
            }
            else add(hs, a, b, w[j]);
        }
        if (!success) break;
    }

    if (!success) puts("-1");
    else
    {
        for (int i = scc_cnt; i; i -- )
        {
            for (int j = hs[i]; ~j; j = ne[j])
            {
                int k = e[j];
                dist[k] = max(dist[k], dist[i] + w[j]);
            }
        }

        LL res = 0;
        for (int i = 1; i <= scc_cnt; i ++ ) res += (LL)dist[i] * size[i];

        printf("%lld\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/155909/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <climits>
#include <utility>
#include <sstream>
#include <cctype>
#include <cstdio>
#include <vector>

using namespace std;

const int N=100005;
const int M=600005;

int n,m;
int w[M],e[M],ne[M],idx;
int dfn[N],low[N],sz[N];
int id[N],h[N],hs[N];
int stk[N],tt;
bool in_stk[N];
int timestamp,scc_cnt;
int dist[N];

inline int read()
{
    int x=0;
    char ch;
    bool fx=false;
    do ch=getchar();while(~ch&&ch!='-'&&(ch<'0'||ch>'9'));
    if(ch=='-')fx=true,ch=getchar();
    for(;ch>='0'&&ch<='9';ch=getchar())
        x=(x<<1)+(x<<3)+(ch^48);
    return fx?-x:x;
}

inline void add(int h[],int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++timestamp;
    stk[++tt]=u,in_stk[u]=true;
    for(int i=h[u];i;i=ne[i])
        if(!dfn[e[i]])
        {
            tarjan(e[i]);
            low[u]=min(low[u],low[e[i]]);
        }
        else if(in_stk[e[i]])
            low[u]=min(low[u],dfn[e[i]]);
    if(low[u]==dfn[u])
    {
        int y;
        scc_cnt++;
        do
        {
            y=stk[tt--];
            in_stk[y]=false;
            id[y]=scc_cnt;
            sz[scc_cnt]++;
        }while(y!=u);
    }
}

int main()
{
    n=read(),m=read();
    for(int i=0;i<m;i++)
    {
        int a,b,t;
        t=read(),a=read(),b=read();
        if(t==1)add(h,a,b,0),add(h,b,a,0);
        else if(t==2)add(h,a,b,1);
        else if(t==3)add(h,b,a,0);
        else if(t==4)add(h,b,a,1);
        else add(h,a,b,0);
    }
    for(int i=1;i<=n;i++)
        add(h,0,i,1);
    tarjan(0);
    bool success=true;
    for(int i=0;i<=n&&success;i++)
        for(int j=h[i];j&&success;j=ne[j])
            if(id[i]!=id[e[j]])
                add(hs,id[i],id[e[j]],w[j]);
            else if(w[j]>0)
                success=false;
    if(!success)puts("-1");
    else
    {
        for(int i=scc_cnt;i;i--)
            for(int j=hs[i];j;j=ne[j])
                dist[e[j]]=max(dist[e[j]],dist[i]+w[j]);
        long long res=0;
        for(int i=1;i<=scc_cnt;i++)
            res+=dist[i]*1ll*sz[i];
        printf("%lld",res);
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/326106/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 395. 冗余路径    原题链接    简单
作者：    Jayfeather ,  2019-08-30 15:48:31 ,  阅读 395

2


1
题目描述
求一个图补成边双图的最少加边数。

样例
7 7
1 2
2 3
3 4
2 5
4 5
5 6
5 7
2
算法1
(Tarjan) O(n)O(n)
TarjanTarjan e-DCC缩点，然后将叶子节点数+1后除2就是答案。

因为我们只要把所有的叶子节点连起来，那么这些节点到其他点就有两种走法（原树上和新加的边上），其他点也是如此。

C++ 代码
#include <iostream>
#include <cstdio>
using namespace std;
struct edge{
    int to,next;
}s[2][20200];
int ls[2],head[2][10010];
void link(int k,int a,int b){
    s[k][ls[k]].to=b;
    s[k][ls[k]].next=head[k][a];
    head[k][a]=ls[k]++;
}
int pre[10010];
int belong[10010];
int getf(int u){
    return belong[u];
}
int dfs(int k,int u,int f,int &endx){
    int le=0;
    endx=u;
    pre[u]=f;
    for(int i=head[k][u],y,tmp,tmp2;i;i=s[k][i].next)
        if((y=s[k][i].to)!=f){
            if((tmp=dfs(k,y,u,tmp2))>le){
                le=tmp;
                endx=tmp2;
            }
        }
    return le+1;
}
int dfn[3010],low[3010],stamp;
int sta[3010],top;
int ins[3010];
int ind[3010];
int pc[3010][3010];
int cnt;
void tarjan(int u,int fa){
    dfn[u]=low[u]=++stamp;
    sta[++top]=u;ins[u]=1;
    int y;
    for(int i=head[0][u];i;i=s[0][i].next)
        if((y=s[0][i].to)!=fa){
            if(!dfn[y]){
                tarjan(y,u);
                low[u]=min(low[u],low[y]);
            }
            else
            if(ins[y])
                low[u]=min(low[u],dfn[y]);
        }
    if(low[u]==dfn[u]){
        cnt++;
        do{
            y=sta[top--];
            ins[y]=0;
            belong[y]=cnt;
        }while(y!=u);
    }
}
int edk=0;
int main(){
    freopen("path.in","r",stdin);
    freopen("path.out","w",stdout);
    ls[0]=ls[1]=1;
    int n,m,a,b;
    cin>>n>>m;
    for(int i=0;i<m;i++){
        scanf("%d%d",&a,&b);
        link(edk,a,b);link(edk,b,a);//连边
    }
    for(int i=1;i<=n;i++)
        if(!dfn[i])
            tarjan(i,0);//缩点
    for(int i=1;i<=n;i++)
        for(int j=head[edk][i],y;j;j=s[edk][j].next)
            if(getf(i)!=getf(y=s[edk][j].to)&&!pc[getf(i)][getf(y)]){
                pc[getf(i)][getf(y)]=1;
                link(edk^1,getf(i),getf(y));
                ind[getf(y)]++;//找叶子节点
            }
    int ans=1;
    for(int i=1;i<=cnt;i++) ans+=ind[i]==1;//连接它的边只有1个即叶子
    printf("%d",ans/2);
    return 0;
}

作者：Jayfeather
链接：https://www.acwing.com/solution/content/4248/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 5010, M = 20010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
int id[N], dcc_cnt;
bool is_bridge[M];
int d[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u, int from)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j, i);
            low[u] = min(low[u], low[j]);
            if (dfn[u] < low[j])
                is_bridge[i] = is_bridge[i ^ 1] = true;
        }
        else if (i != (from ^ 1))
            low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ dcc_cnt;
        int y;
        do {
            y = stk[top -- ];
            id[y] = dcc_cnt;
        } while (y != u);
    }
}

int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }

    tarjan(1, -1);

    for (int i = 0; i < idx; i ++ )
        if (is_bridge[i])
            d[id[e[i]]] ++ ;

    int cnt = 0;
    for (int i = 1; i <= dcc_cnt; i ++ )
        if (d[i] == 1)
            cnt ++ ;

    printf("%d\n", (cnt + 1) / 2);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/157010/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


算法思路
根据题意 就是求删除图中的一个点使得图中的连通块数目最大，并求出这个最大值。
如果这个图是一个树的话啊，那么可以用dfs求解O(N)但是是一个图可能存在环用dfs会相当麻烦，因此利用割点来求会方便很多。对于整个图来说假如有cnt个连通块，如果一个连通块i不存在割点，那么最大值就是cnt + 1, 如果连通块存在割点，那么最大值就是cnt - 1 + x(删除割点剩余的连通块数目 + x本身算一个点)；

void tarjon(int u)
{
    dfn[u] = low[u] = ++ timestamp; //时间戳
    int cnt = 0; // 记录u下面有几个连通块
    for(int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if(!dfn[j])
        {
            tarjon(j);
            low[u] = min(low[u], low[j]);
            if(dfn[u] <= low[j])cnt ++; //如果满足条件那么u是割点，记录u下面连接几个连通块
        }
        else low[u] = min(low[u], dfn[j]); // 更新low[u];
    }
    if(root != u)cnt ++; // 如果u不是根节点 再把u的父节点的连通块加上
    ans = max(ans, cnt); // 最后取一个最大值
} 

作者：AJ小公主
链接：https://www.acwing.com/solution/content/15793/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010, M = 30010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int root, ans;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;

    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (low[j] >= dfn[u]) cnt ++ ;
        }
        else low[u] = min(low[u], dfn[j]);
    }

    if (u != root) cnt ++ ;

    ans = max(ans, cnt);
}

int main()
{
    while (scanf("%d%d", &n, &m), n || m)
    {
        memset(dfn, 0, sizeof dfn);
        memset(h, -1, sizeof h);
        idx = timestamp = 0;

        while (m -- )
        {
            int a, b;
            scanf("%d%d", &a, &b);
            add(a, b), add(b, a);
        }

        ans = 0;
        int cnt = 0;
        for (root = 0; root < n; root ++ )
            if (!dfn[root])
            {
                cnt ++ ;
                tarjan(root);
            }

        printf("%d\n", ans + cnt - 1);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/157030/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 396. 矿场搭建    原题链接    简单
作者：    夏日 ,  2019-11-07 20:23:14 ,  阅读 370

3


此题需要大力讨论，WA了三次
首先，肯定要跑一遍缩点，缩完是一棵树
发现只连了一个割点的dcc一定要有一个出口，不然割点断了就GG了，即使这个出口断了，也能找到“另一个”出口
注意，这里推到的前提条件，“另一个出口”，如果这个出口不存在怎么办？即缩完就剩一个点了，这种情况待会再说，不妨先讨论至少有俩点
回来，我们显然可以在每个只“连了一个割点的dcc”放一个出口，方案数用乘法原理一乘即可
再次注意，这里怎么求“只连了一个割点的DCC”
一种显然的思路是缩完点在遍历一次/缩点时存下每个强联通分量都有哪些点，这显然不方便
我一开始考虑边缩点边求，最终又犯了一个错误，即“根节点”在没跑完缩点之前，我们不知道它是不是个割点，所以需要特判，如果它是割点，则累加正确，不是割点的话会在它所属的dcc（唯一），多累加一个割点数目，我们应该减去。
然后考虑就缩成一个点怎么办，那必须要放俩出口，来防止单一出口爆炸的情况，注意这里的前提条件，“能放下两个出口么？即n=1时怎么办”，发现题目里没有直接给出n，而是通过边间接给出，那么n至少为2，不会有坑
方案数显然为n选2的组合数
到此已经可以AC，但仍没有结束
题面并没有保证图是连通的，如果直接划分成多个dcc，很容易在特判“只有一个强联通分量”的情况出错，比较好的实现方法是在做之前直接划分出联通块，划归成子问题，最后乘法原理累加答案
题面并没有保证点的编号的范围，也就是说需要离散化

upd: 代码已更新，考虑了多个联通块的问题，去掉了离散化

#include <iostream>
#include <cstdio>
#include <vector>
#include <cstring>

#define rint register int
#define lint long long
#define isnum(x) ('0' <= (x) && (x) <= '9')
template<typename tint>
inline void readint(tint& x) {
    int f = 1; char ch = getchar(); x = 0;
    for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1;
    for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0';
    x *= f;
}
using namespace std;
const int maxn = 100000 + 10;
const int maxm = 2 * maxn;

int n, m;
int head[maxn], ev[maxm], nxt[maxm], totedge = 1;
inline void addedge(int nu, int nv) {
    ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;
}

int dfn[maxn], low[maxn], totdfn = 0;
int s[maxn], stop = 0;
int cut[maxn], totdcc = 0;
vector<int> dcc[maxn];
// 点双联通分量不要在线！！

void dfs(int x, int fa) {
    dfn[x] = low[x] = ++totdfn, s[++stop] = x;
    if(head[x] == 0) ++totdcc, dcc[totdcc].push_back(x); // 特判孤立点
    for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) {
        if(dfn[y] == 0) dfs(y, x), low[x] = min(low[x], low[y]);
        else low[x] = min(low[x], dfn[y]);
    }
    if(fa && low[x] >= dfn[fa]) { // 根节点不需要
        ++totdcc, cut[fa]++;
        do dcc[totdcc].push_back(s[stop]);
        while(s[stop--] != x);
        dcc[totdcc].push_back(fa);
    }
    if(fa == 0) cut[x] = cut[x] >= 2 ? cut[x] : 0;
}

void clear() {
    int msize = sizeof(int) * (n + 1);
    memset(head, 0, msize), totedge = 1;
    memset(dfn, 0, msize), memset(low, 0, msize), totdfn = 0;
    memset(cut, 0, msize);
    for(rint i=1; i<=totdcc; i++) dcc[i].clear();
    stop = totdcc = 0;
    n = 0;
}

int main() {
    int T = 0;
    while(cin >> m && m) {
        int nu, nv;
        while(m--) {
            readint(nu), readint(nv);
            n = max(n, max(nu, nv));
            addedge(nu, nv), addedge(nv, nu);
        }
        int ans_cnt = 0;
        lint ans_det = 1;
        for(rint x=1; x<=n; x++) {
            if(dfn[x]) continue;
            int pre = totdcc + 1;
            dfs(x, 0);
            if(pre == totdcc) {
                if(dcc[totdcc].size() > 1)
                    ans_cnt += 2, ans_det *= dcc[totdcc].size() * (dcc[totdcc].size() - 1) / 2;
            } else {
                for(rint i=pre; i<=totdcc; i++) {
                    int now_cut = 0;
                    for(rint j=0; j<dcc[i].size(); j++) {
                        if(cut[dcc[i][j]]) now_cut++;
                    }
                    if(now_cut == 1) ans_cnt++, ans_det *= dcc[i].size() - 1;
                }
            }

        }
        printf("Case %d: %d %lld\n", ++T, ans_cnt, ans_det);
        clear();
    }
    return 0;
}

作者：夏日
链接：https://www.acwing.com/solution/content/5973/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef unsigned long long ULL;

const int N = 1010, M = 1010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
int dcc_cnt;
vector<int> dcc[N];
bool cut[N];
int root;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;

    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }

    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}

int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);

        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }

        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);

        int res = 0;
        ULL num = 1;
        for (int i = 1; i <= dcc_cnt; i ++ )
        {
            int cnt = 0;
            for (int j = 0; j < dcc[i].size(); j ++ )
                if (cut[dcc[i][j]])
                    cnt ++ ;

            if (cnt == 0)
            {
                if (dcc[i].size() > 1) res += 2, num *= dcc[i].size() * (dcc[i].size() - 1) / 2;
                else res ++ ;
            }
            else if (cnt == 1) res ++, num *= dcc[i].size() - 1;
        }

        printf("Case %d: %d %llu\n", T ++, res, num);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/157068/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 257. 关押罪犯    原题链接    中等
作者：    yxc ,  2019-07-23 23:26:45 ,  阅读 1113

11


4
算法
(二分，染色法判断二分图) O((N+M)logC)O((N+M)logC)
将罪犯当做点，罪犯之间的仇恨关系当做点与点之间的无向边，边的权重是罪犯之间的仇恨值。
那么原问题变成：将所有点分成两组，使得各组内边的权重的最大值尽可能小。

我们在 [0,109][0,109] 之间枚举最大边权 limitlimit，当 limitlimit 固定之后，剩下的问题就是：

判断能否将所有点分成两组，使得所有权值大于 limitlimit 的边都在组间，而不在组内。也就是判断由所有点以及所有权值大于 limitlimit 的边构成的新图是否是二分图。
判断二分图可以用染色法，时间复杂度是 O(N+M)O(N+M)，其中 NN 是点数，MM 是边数，可以参考AcWing 860. 染色法判定二分图。

为了加速算法，我们来考虑是否可以用二分枚举 limitlimit， 假定最终最大边权的最小值是 AnsAns:

那么当 limit∈[ans,109]limit∈[ans,109] 时，所有边权大于 limitlimit 的边，必然是所有边权大于 AnsAns 的边的子集，因此由此构成的新图也是二分图。
当 limit∈[0,ans−1]limit∈[0,ans−1] 时，由于 ansans 是新图可以构成二分图的最小值，因此由大于 limitlimit 的边构成的新图一定不是二分图。
所以整个区间具有二段性，可以二分出分界点 ansans 的值。二分算法模板可以参考这篇。
时间复杂度分析
总共二分 logClogC 次，其中 CC 是边权的最大值，每次二分使用染色法判断二分图，时间复杂度是 O(N+M)O(N+M)，其中 NN 是点数，MM 是边数。因此总时间复杂度是 O((N+M)logC)O((N+M)logC)。

C++ 代码
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20010, M = 200010;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int color[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool dfs(int u, int c, int limit)
{
    color[u] = c;
    for (int i = h[u]; ~i; i = ne[i])
    {
        if (w[i] <= limit) continue;
        int j = e[i];
        if (color[j])
        {
            if (color[j] == c) return false;
        }
        else if (!dfs(j, 3 - c, limit)) return false;
    }

    return true;
}

bool check(int limit)
{
    memset(color, 0, sizeof color);

    for (int i = 1; i <= n; i ++ )
        if (color[i] == 0)
            if (!dfs(i, 1, limit))
                return false;
    return true;
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
        add(b, a, c);
    }

    int l = 0, r = 1e9;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    printf("%d\n", l);
    return 0;
}

作者：yxc
链接：https://www.acwing.com/solution/content/3042/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20010, M = 200010;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int color[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool dfs(int u, int c, int mid)
{
    color[u] = c;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (w[i] <= mid) continue;
        if (color[j])
        {
            if (color[j] == c) return false;
        }
        else if (!dfs(j, 3 - c, mid)) return false;
    }

    return true;
}

bool check(int mid)
{
    memset(color, 0, sizeof color);
    for (int i = 1; i <= n; i ++ )
        if (!color[i])
            if (!dfs(i, 1, mid))
                return false;
    return true;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }

    int l = 0, r = 1e9;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    printf("%d\n", r);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/158085/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 372. 棋盘覆盖    原题链接    中等
作者：    whsstory ,  2020-01-13 11:05:00 ,  阅读 389

7


考虑一个格子(i,j)(i,j):

i+ji+j为偶数:不妨记这样的格子为白格子.
i+ji+j为奇数:不妨记这样的格子为黑格子.
如果这个白格子没有被禁止,那么就让它向周围没有被禁止的黑格子连有向边,表示 如果选择这条边(在这两个格子上放骨牌)会对答案有1的贡献.显然白格子周围都是黑格子,所以白格子之间不会有边.那么这就是一个二分图最大匹配的模型,跑一下就好了.

最多O(n2)O(n2)个点,O(n2)O(n2)条边,所以时间复杂度O(n4)O(n4)
/**********/省略快读
#define MAXN 20011
struct Edge
{
    ll v,nxt;
}e[MAXN<<2|1];
ll cnt=0,last[MAXN];
void adde(ll u,ll v)
{
    ++cnt;
    e[cnt].v=v;
    e[cnt].nxt=last[u],last[u]=cnt;
}

ll p[MAXN];
bool vis[MAXN];
bool dfs(ll u)//二分图最大匹配
{
    for(ll i=last[u];i;i=e[i].nxt)
    {
        ll v=e[i].v;
        if(!vis[v])
        {
            vis[v]=1;
            if(!p[v]||dfs(p[v]))
            {
                p[v]=u;
                return 1;
            }
        }
    }
}
bool a[111][111];
const ll mx[4]={0,1,0,-1},my[4]={1,0,-1,0};
int main()
{
    ll n=read(),t=read();
    for(ll i=1;i<=t;++i)
    {
        ll x=read(),y=read();
        a[x][y]=1;
    }
    for(ll i=1;i<=n;++i)
        for(ll j=1;j<=n;++j)
        {
            if(((i+j)&1)||a[i][j])continue;//不是白色格子,或者被禁止了,就跳过
            for(ll op=0;op<4;++op)
            {
                ll x=i+mx[op],y=j+my[op];
                if(x>0&&x<=n&&y>0&&y<=n&&!a[x][y])adde((i-1)*n+j,(x-1)*n+y);//加边
            }
        }
    ll ans=0;
    for(ll i=1;i<=n;++i)
        for(ll j=1;j<=n;++j)
        {
            if((i+j)&1)continue;
            memset(vis,0,sizeof vis);
            if(dfs((i-1)*n+j))++ans;
        }
    printf("%lld",ans);
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/7540/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 110;

int n, m;
PII match[N][N];
bool g[N][N], st[N][N];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

bool find(int x, int y)
{
    for (int i = 0; i < 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a && a <= n && b && b <= n && !g[a][b] && !st[a][b])
        {
            st[a][b] = true;
            PII t = match[a][b];
            if (t.x == -1 || find(t.x, t.y))
            {
                match[a][b] = {x, y};
                return true;
            }
        }
    }

    return false;
}

int main()
{
    cin >> n >> m;

    while (m -- )
    {
        int x, y;
        cin >> x >> y;
        g[x][y] = true;
    }

    memset(match, -1, sizeof match);

    int res = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if ((i + j) % 2 && !g[i][j])
            {
                memset(st, 0, sizeof st);
                if (find(i, j)) res ++ ;
            }

    cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/158090/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 376. 机器任务 ===== 最小点覆盖    原题链接    简单
作者：    xxh ,  2020-02-22 20:19:26 ,  阅读 345

4


1
题解 ： https://xiaoxiaoh.blog.csdn.net/article/details/104449622

一、内容
As we all know, machine scheduling is a very classical problem in computer science and has been studied for a very long history. Scheduling problems differ widely in the nature of the constraints that must be satisfied and the type of schedule desired. Here we consider a 2-machine scheduling problem.

There are two machines A and B. Machine A has n kinds of working modes, which is called mode_0, mode_1, ..., mode_n-1, likewise machine B has m kinds of working modes, mode_0, mode_1, ... , mode_m-1. At the beginning they are both work at mode_0.

For k jobs given, each of them can be processed in either one of the two machines in particular mode. For example, job 0 can either be processed in machine A at mode_3 or in machine B at mode_4, job 1 can either be processed in machine A at mode_2 or in machine B at mode_4, and so on. Thus, for job i, the constraint can be represent as a triple (i, x, y), which means it can be processed either in machine A at mode_x, or in machine B at mode_y.

Obviously, to accomplish all the jobs, we need to change the machine's working mode from time to time, but unfortunately, the machine's working mode can only be changed by restarting it manually. By changing the sequence of the jobs and assigning each job to a suitable machine, please write a program to minimize the times of restarting machines.
Input

The input file for this program consists of several configurations. The first line of one configuration contains three positive integers: n, m (n, m < 100) and k (k < 1000). The following k lines give the constrains of the k jobs, each line is a triple: i, x, y.

The input will be terminated by a line containing a single zero.
Output

The output should be one integer per line, which means the minimal times of restarting machine.
Sample Input

5 5 10
0 1 1
1 1 2
2 1 3
3 1 4
4 2 1
5 2 2
6 2 3
7 2 4
8 3 3
9 4 3
0
Sample Output

3
二、思路


三、代码
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 105, M = 2e3 + 5;
struct E{int v, next;} e[M];
int n, m, k, no, u, v, len, h[N], mat[N];
bool vis[N];
void add(int u, int v) {e[++len].v = v; e[len].next = h[u]; h[u] = len;}
bool dfs(int u) {
    for (int j = h[u]; j; j = e[j].next) {
        int v = e[j].v;
        if (vis[v]) continue; vis[v] = true;
        if (!mat[v] || dfs(mat[v])) {
            mat[v] = u; return true;
        }
    } 
    return false;
}
int main() {    
    while (scanf("%d", &n), n) {
        scanf("%d%d", &m, &k);
        memset(h, 0, sizeof(h)); len = 0;
        memset(mat, 0, sizeof(mat));
        for (int i = 1; i <= k; i++) {
            scanf("%d%d%d", &no, &u, &v);
            if (!u || !v) continue;
            add(u, v);  
        } 
        int ans = 0;
        for (int i = 1; i < n; i++) {
            memset(vis, false, sizeof(vis));
            if (dfs(i)) ans++;
        }
        printf("%d\n", ans);
    }
    return 0;
}

作者：xxh
链接：https://www.acwing.com/solution/content/8921/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m, k;
int match[N];
bool g[N][N], st[N];

bool find(int x)
{
    for (int i = 0; i < m; i ++ )
        if (!st[i] && g[x][i])
        {
            st[i] = true;
            if (match[i] == -1 || find(match[i]))
            {
                match[i] = x;
                return true;
            }
        }

    return false;
}

int main()
{
    while (cin >> n, n)
    {
        cin >> m >> k;
        memset(g, 0, sizeof g);
        memset(match, -1, sizeof match);

        while (k -- )
        {
            int t, a, b;
            cin >> t >> a >> b;
            if (!a || !b) continue;
            g[a][b] = true;
        }

        int res = 0;
        for (int i = 0; i < n; i ++ )
        {
            memset(st, 0, sizeof st);
            if (find(i)) res ++ ;
        }

        cout << res << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/158104/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 378. 骑士放置=====最大独立集    原题链接    简单
作者：    xxh ,  2020-02-23 13:38:55 ,  阅读 316

2


1
题解 ： https://xiaoxiaoh.blog.csdn.net/article/details/104458880

一、内容
给定一个 N*M 的棋盘，有一些格子禁止放棋子。

问棋盘上最多能放多少个不能互相攻击的骑士（国际象棋的“骑士”，类似于中国象棋的“马”，按照“日”字攻击，但没有中国象棋“别马腿”的规则）。
输入格式

第一行包含三个整数N,M,T，其中T表示禁止放置的格子的数量。

接下来T行每行包含两个整数x和y，表示位于第x行第y列的格子禁止放置，行列数从1开始。
输出格式

输出一个整数表示结果。
数据范围

1≤N,M≤100
输入样例：

2 3 0
输出样例：

4
二、思路


三、代码
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 105;
int dx[8] = {-2, -2, 2, 2, -1, -1, 1, 1};
int dy[8] = {-1, 1, -1, 1, -2, 2, -2, 2};
bool g[N][N], vis[N][N];
int n, m, t, x, y;
pair<int, int> mat[N][N];
bool dfs(int x, int y) {
    for (int i = 0; i < 8; i++) {
        int fx = x + dx[i], fy = y + dy[i];
        if (fx <= 0 || fy <= 0 || fx > n || fy > m || g[fx][fy] || vis[fx][fy]) continue; vis[fx][fy] = true; 
        int px = mat[fx][fy].first, py = mat[fx][fy].second;
        if ((!px && !py) || dfs(px, py)) {
            mat[fx][fy] = make_pair(x, y); return true;
        }
    }
    return false;
}
int main() {
    scanf("%d%d%d", &n, &m, &t);
    for (int i = 1; i <= t; i++) {
        scanf("%d%d", &x, &y); g[x][y] = 1;
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (g[i][j] || ((i + j) & 1)) continue;
            memset(vis, false, sizeof(vis));
            if (dfs(i, j)) ans++;
        }
    }
    printf("%d\n", n * m - t - ans);
    return 0;
}

作者：xxh
链接：https://www.acwing.com/solution/content/8945/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 110;

int n, m, k;
PII match[N][N];
bool g[N][N], st[N][N];

int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2};
int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};

bool find(int x, int y)
{
    for (int i = 0; i < 8; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a < 1 || a > n || b < 1 || b > m) continue;
        if (g[a][b]) continue;
        if (st[a][b]) continue;

        st[a][b] = true;

        PII t = match[a][b];
        if (t.x == 0 || find(t.x, t.y))
        {
            match[a][b] = {x, y};
            return true;
        }
    }

    return false;
}

int main()
{
    cin >> n >> m >> k;

    for (int i = 0; i < k; i ++ )
    {
        int x, y;
        cin >> x >> y;
        g[x][y] = true;
    }

    int res = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            if (g[i][j] || (i + j) % 2) continue;
            memset(st, 0, sizeof st);
            if (find(i, j)) res ++ ;
        }

    cout << n * m - k - res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/158111/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

    发现个有意思的现象，为什么本题中把 dx 和 dy 的方向定义相互交换一下，代码执行效率能立马提升四倍呢？


AcWing 379. 捉迷藏    原题链接    中等
作者：    Anoxia_3 ,  2020-06-23 11:50:21 ,  阅读 195

8


1
最小路径覆盖：针对一个有向无环图(DAG),用最少条互不相交路径，覆盖所有点。（其中互不相交是指点不重复）

结论：最小路径点覆盖（最小路径覆盖） = 总点数 - 最大匹配

证明：
1.建图
求最小路径覆盖用到拆点，一个点分成两个点，分别表示出点和入点，
那么从点i->j的一条边就用，从左边的出点i连到右边的入点j’表示，
于是得到的图是一个二分图，因为所有的边都是在左部和右部之间的，内部没有点。

2.转化
此时将原图中的每一条路径转化到新图中，因为原图中的路径互不相交，所以每一个点最多只有一个出度和入度，
这就意味着在新图中，左部每一个点最多只会向右部连一条边，右部的点最多只会有一条边连入，每个点最多只会属于一条边。
①原图中的一条路径<=>新图中的一组匹配（新图中每一个点最多只会属于一条边）
②原图中每一条路径的终点（没有出边）<=>新图左部的非匹配点

3.推导
求原图中互不相交路径数<=>求路径终点数最少<=>求左部非匹配点最少<=>求最大匹配

拓展：
最小路径重复点覆盖：在最小路径覆盖问题的基础上，去掉互不相交。

结论：记原图G，求传递闭包后的图G’，则G的最小路径重复点覆盖=G’的最小路径覆盖

在该题中，记最小路径重复点覆盖数为cnt，该题的答案就是cnt
证明：
①k<=cnt
这cnt条路径覆盖了所有的点，所以所求的k个点一定要从这cnt条路径中的点选，
并且每条路径上最多选一个点，所以k<=cnt
②k>=cnt
构造：将cnt条路径的终点都放到一个集合E中，记next(E)返回的是从E中的每个点出发能到的所有点的集合
分类讨论：
i)E ∩ next(E) = Ø ，此时E内的点不能相互到达，说明E中所有的点就是一种k=cnt的方案
ii)E ∩ next(E) ≠ Ø ， 对于E中的任何一个点p，让这个点反向走，直到这个点走到一个不在next(E-p)中的点，可证当这个点走到起点时肯定不在next(E-p)中。
反证法：如果这个点走到起点，仍在next(E-p)中，说明p所在的路径的起点可以被其他路径到达，那么这条路径就没有存在的意义可以省去，不满足最小路径重复点覆盖。
所以此时同样可以在每一条路径中选出一个点，使得这些点之间两两不可到达，即k=cnt

C++ 代码

#include <iostream>
#include <cstring>

using namespace std;

const int N = 210 , M = 30010;

bool d[N][N];
bool st[N];
int n , m;
int match[N];

bool find(int x)
{
    for(int i = 1 ; i <= n ; i++)
    {
        if(d[x][i] && !st[i])
        {
            st[i] = true;
            if(!match[i] || find(match[i]))
            {
                match[i] = x;
                return true;
            }
        }
    }
    return false;
}

int main()
{
    cin >> n >> m;

    while(m--)
    {
        int a , b;
        cin >> a >> b;
        d[a][b] = true;
    }

    for(int k = 1 ; k <= n ; k++)//求传递闭包
        for(int i = 1 ; i <= n ; i++)
            for(int j = 1 ; j <= n ; j++)
                d[i][j] |= d[i][k] & d[k][j];

    int res = 0;
    for(int i = 1 ; i <= n ; i++)
    {
        memset(st , 0 , sizeof st);
        if(find(i)) res++;
    }

    cout << n - res << endl;
    return 0;
}

作者：Anoxia_3
链接：https://www.acwing.com/solution/content/15162/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 210, M = 30010;

int n, m;
bool d[N][N], st[N];
int match[N];

bool find(int x)
{
    for (int i = 1; i <= n; i ++ )
        if (d[x][i] && !st[i])
        {
            st[i] = true;
            int t = match[i];
            if (t == 0 || find(t))
            {
                match[i] = x;
                return true;
            }
        }

    return false;
}

int main()
{
    scanf("%d%d", &n, &m);
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        d[a][b] = true;
    }

    // 传递闭包
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] |= d[i][k] & d[k][j];

    int res = 0;
    for (int i = 1; i <= n; i ++ )
    {
        memset(st, 0, sizeof st);
        if (find(i)) res ++ ;
    }

    printf("%d\n", n - res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/158128/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1123. 铲雪车    原题链接    简单
作者：    wuwendongxi ,  2019-11-13 11:02:28 ,  阅读 371

1


1
题目描述
随着白天越来越短夜晚越来越长，我们不得不考虑铲雪问题了。

整个城市所有的道路都是双向车道,道路的两个方向均需要铲雪。因为城市预算的削减，整个城市只有 1 辆铲雪车。

铲雪车只能把它开过的地方（车道）的雪铲干净，无论哪儿有雪，铲雪车都得从停放的地方出发，游历整个城市的街道。

现在的问题是：最少要花多少时间去铲掉所有道路上的雪呢？

输入格式
输入数据的第 1 行表示铲雪车的停放坐标 (x,y)，x,y 为整数，单位为米。

下面最多有4000行，每行给出了一条街道的起点坐标和终点坐标，坐标均为整数，所有街道都是笔直的，且都是双向车道。

铲雪车可以在任意交叉口、或任何街道的末尾任意转向，包括转 U 型弯。

铲雪车铲雪时前进速度为 20 千米/时，不铲雪时前进速度为 50 千米/时。

保证：铲雪车从起点一定可以到达任何街道。

输出格式
输出铲掉所有街道上的雪并且返回出发点的最短时间，精确到分钟，四舍五入到整数。

输出格式为”hours:minutes”，minutes不足两位数时需要补前导零。
具体格式参照样例。

数据范围
−106≤x,y≤106
所有位置坐标绝对值不超过 106。

样例
输入样例：

0 0
0 0 10000 10000
5000 -10000 5000 10000
5000 10000 10000 10000
输出样例：

3:55
样例解释
输出结果表示共需3小时55分钟。

分析：
明确：
1. 道路是双车道（来去可回起点）
2. 从停放的地方出发，游历整个城市的街道（与短路径无关）

注意：单位（/1000)

AC 代码
#include <iostream>
#include <cmath>
using namespace std;
long long m,n,x1,yy,x2,y2;
double a1,b1,a2,b2,sum;
double yunsuan(double t1,double t2,double t3,double t4)
{
    return (double)sqrt(abs(t3-t1)*abs(t3-t1)+abs(t4-t2)*abs(t4-t2));
}
int main()
{
    cin>>m>>n;
    while(cin>>x1>>yy>>x2>>y2)
    {
        a1=(double)x1/1000*1.0;
        b1=(double)yy/1000*1.0;
        a2=(double)x2/1000*1.0;
        b2=(double)y2/1000*1.0;
        sum+=yunsuan(a1,b1,a2,b2);
    }
    m=(double)sum/10*1.0;
    cout<<m<<':';
    m=sum*6-m*60+0.5;
    if(m<10) cout<<'0';
    cout<<m<<endl;
    return 0;
}

作者：wuwendongxi
链接：https://www.acwing.com/solution/content/6192/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

int main()
{
    double x1, y1, x2, y2;
    cin >> x1 >> y1;

    double sum = 0;
    while (cin >> x1 >> y1 >> x2 >> y2)
    {
        double dx = x1 - x2;
        double dy = y1 - y2;
        sum += sqrt(dx * dx + dy * dy) * 2;
    }

    int minutes = round(sum / 1000 / 20 * 60);
    int hours = minutes / 60;
    minutes %= 60;

    printf("%d:%02d\n", hours, minutes);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/159766/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double x1,x2,y1,y2,sum;
    cin>>x1>>y1;
    while(cin>>x1>>y1>>x2>>y2)sum+=hypot(x1-x2,y1-y2);
    int res=sum*0.006+0.5;
    printf("%d:%.2d\n",res/60,res%60);
    return 0;
}

AcWing 1184. 欧拉回路    原题链接    简单
作者：    Overnoise ,  2020-02-10 12:43:55 ,  阅读 869

2


相信很多同学都卡在超时
其他原理我就不阐述了
就讲讲我是怎么克服超时的

为什么会超时
算法本身是线性的
但在删边时由于我们只是标记一下
就要重复遍历一个边好多遍

怎么克服这个呢？
就要在删边上做优化
我用的是前向星存图
类比链表的删点的方法
直接把这个边从链上拆下来
下次再遍历这个点的边时，这个边就不会被遍历

程序如下：
#include<bits/stdc++.h>
using namespace std;
int t,n,m,a,b;
struct oppo{
    int to,next;
}rood[500005];
int head[100005],tot=1;
void add(int from,int to)
{
    rood[++tot].to=to;
    rood[tot].next=head[from];
    head[from]=tot;
}
stack< int > ans;
bool flag[400005];
int all;
void dfs(int x)
{
    int tot=0;
    for(int i=head[x];i;i=head[x]){
        head[x]=rood[i].next;
        if(flag[i/t-t%2])
            continue;
        flag[i/t-t%2]=1;
        dfs(rood[i].to);
        all++;
        if(t==1)
            ans.push(i/t-t%2);
        else
            ans.push((i/t-t%2)*pow(-1,i%2));
    }
}
int pd[100005];
int dp[100005];
int main()
{
    cin>>t;
    if(t==1)//我为什么要交换呢？？？
        t=2;//因为代码打完了才发现 t的1,2 读题是理解反了
    else
        t=1;
    cin>>n>>m;
    if(t==1){
        for(int i=1;i<=m;i++){
            scanf("%d %d",&a,&b);
            add(a,b);
            pd[a]++;
            dp[b]++;
        }
        for(int i=1;i<=n;i++)
            if(pd[i]!=dp[i]){
                puts("NO");
                return 0;
            }
    }
    else if(t==2){
        for(int i=1;i<=m;i++){
            scanf("%d %d",&a,&b);
            add(a,b);add(b,a);
            pd[a]++;
            pd[b]++;
        }
        for(int i=1;i<=n;i++)
            if(pd[i]%2){
                puts("NO");
                return 0;
            }
    }
    for(int i=1;i<=n;i++)
        if(head[i]){
            dfs(i);
            break;
        }
    if(all!=m){
        puts("NO");
        return 0;
    }
    puts("YES");
    while(ans.size()){
        printf("%d ",ans.top());
        ans.pop();
    }
    return 0;
}

作者：Overnoise
链接：https://www.acwing.com/solution/content/8102/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 400010;

int type;
int n, m;
int h[N], e[M], ne[M], idx;
bool used[M];
int ans[M], cnt;
int din[N], dout[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    for (int &i = h[u]; ~i;)
    {
        if (used[i])
        {
            i = ne[i];
            continue;
        }

        used[i] = true;
        if (type == 1) used[i ^ 1] = true;

        int t;

        if (type == 1)
        {
            t = i / 2 + 1;
            if (i & 1) t = -t;
        }
        else t = i + 1;

        int j = e[i];
        i = ne[i];
        dfs(j);

        ans[ ++ cnt] = t;
    }
}

int main()
{
    scanf("%d", &type);
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
        if (type == 1) add(b, a);
        din[b] ++ , dout[a] ++ ;
    }

    if (type == 1)
    {
        for (int i = 1; i <= n; i ++ )
            if (din[i] + dout[i] & 1)
            {
                puts("NO");
                return 0;
            }
    }
    else
    {
        for (int i = 1; i <= n; i ++ )
            if (din[i] != dout[i])
            {
                puts("NO");
                return 0;
            }
    }

    for (int i = 1; i <= n; i ++ )
        if (h[i] != -1)
        {
            dfs(i);
            break;
        }

    if (cnt < m)
    {
        puts("NO");
        return 0;
    }

    puts("YES");
    for (int i = cnt; i; i -- ) printf("%d ", ans[i]);
    puts("");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/159788/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1124. 骑马修栅栏    原题链接    中等
作者：    皓首不倦 ,  2020-08-24 18:46:39 ,  阅读 88

0


···

’‘’
求解字典序最小的欧拉路径
‘’‘

from collections import Counter
class MergeSetExt:
def init(self, max_key_val = 0, trans_key_func=None):
if trans_key_func is not None and max_key_val > 0:
# 如果能够提供转换key的回调，并查集内部用线性表存储
self.trans_key_callback = trans_key_func
self.m = [-1 for _ in range(max_key_val+1)]
self.__root2cluster_size = [0 for _ in range(max_key_val+1)]
else:
# 如果不能提供转换key的回调，并查集内部用hash表存储
self.trans_key_callback = None
self.m = {}
self.__root2cluster_size = {}
self.__root_cnt = 0

def getRoot(self, node):
    buf = []
    root = self.trans_key_callback(node) if self.trans_key_callback else node
    while self.m[root] != root:
        buf.append(root)
        root = self.m[root]
    for key in buf:
        self.m[key] = root

    return root

def merge(self, a, b):
    orig_a, orig_b = a, b
    if self.trans_key_callback:
        a, b = self.trans_key_callback(a), self.trans_key_callback(b)

    for node in [a, b]:
        if (self.trans_key_callback is None and node not in self.m) or (self.trans_key_callback is not None and self.m[node] == -1):
            self.m[node] = node
            self.__root2cluster_size[node] = 1
            self.__root_cnt += 1

    root1 = self.getRoot(orig_a)
    root2 = self.getRoot(orig_b)
    if root1 != root2:
        self.m[root1] = root2

        self.__root2cluster_size[root2] += self.__root2cluster_size[root1]
        if self.trans_key_callback:
            self.__root2cluster_size[root1] = 0
        else:
            self.__root2cluster_size.pop(root1)
        self.__root_cnt -= 1


def getRootNum(self):
    return self.__root_cnt
class Hierholzer:
# 点序号为1, 2, 3, … node_num
def init(self, edges, node_num):
self.edges = edges[::]
self.node_num = node_num

# 返回欧拉路径，loop_path为True时候返回欧拉回路, keep_min_order为True时候保持路径的字典序最小
def getEulerPath(self, loop_path=False, keep_min_order=False):

    # 判断是否有欧拉路径，返回可能的起点
    def __get_start_nodes(edges):
        if len(edges) == 0:
            return True

        node2degree = Counter()
        merge_set = MergeSetExt(max_key_val=self.node_num, trans_key_func=lambda x : x)
        for (a, b) in edges:
            node2degree[a] += 1
            node2degree[b] += 1
            merge_set.merge(a, b)

        if merge_set.getRootNum() != 1:
            return False

        odd_nodes = []
        for node, degree in node2degree.items():
            if degree & 1:
                odd_nodes.append(node)

        if len(odd_nodes) != 0 and len(odd_nodes) != 2:
            return None

        if loop_path:
            return [node for node in node2degree.keys()] if len(odd_nodes) == 0 else None
        else:
            return odd_nodes if len(odd_nodes) == 2 else [node for node in node2degree.keys()]


    start_nodes = __get_start_nodes(self.edges)
    if start_nodes is None:
        return None

    if len(self.edges) == 0:
        return []

    curPath, loop = [], []
    link = {}
    for (a, b) in self.edges:
        if a not in link:
            link[a] = {}
        if b not in link:
            link[b] = {}

        if b not in link[a]:
            link[a][b] = 1
        else:
            link[a][b] += 1

        if a not in link[b]:
            link[b][a] = 1
        else:
            link[b][a] += 1

    if len(link) == 1:
        # 只有一个点的特殊情况，肯定全部都是自环，特殊处理
        node = None
        for key in link:
            node = key
            break

        return [node] * (len(self.edges) + 1)

    # 无向图不论是求欧拉路径还是欧拉回路，都可以随便选一个起点
    curNode = start_nodes[0] if keep_min_order == False else min(start_nodes)
    edge_cnt = -1  # 累计已经找的边的数量

    visited = set()
    while edge_cnt < len(self.edges):
        curPath.append(curNode)

        if curNode in visited:
            # 找到新的环，进行退栈
            while len(curPath):
                node = curPath[-1]
                if len(link[node]) > 0:
                    if not keep_min_order:
                        next = None
                        for key in link[node].keys():
                            next = key
                            break
                    else:
                        next = min(link[node].keys())

                    link[node][next] -= 1
                    if link[node][next] == 0:
                        link[node].pop(next)

                    link[next][node] -= 1
                    if link[next][node] == 0:
                        link[next].pop(node)

                    curNode = next
                    break
                else:
                    curPath.pop(-1)
                    loop.append(node)
                    edge_cnt += 1
        else:
            visited.add(curNode)

            if len(link[curNode]) > 0:
                if not keep_min_order:
                    next = None
                    for key in link[curNode].keys():
                        next = key
                        break
                else:
                    next = min(link[curNode].keys())

                link[curNode][next] -= 1
                if link[curNode][next] == 0:
                    link[curNode].pop(next)

                link[next][curNode] -= 1
                if link[next][curNode] == 0:
                    link[next].pop(curNode)

                curNode = next
            else:
                curPath.pop(-1)

    return loop[::-1]
import sys
m = int(input())
edges = []
for i in range(m):
s = sys.stdin.readline()
a, b = map(int, s.split())
edges.append((a, b))

algo = Hierholzer(edges, node_num=500)
path = algo.getEulerPath(loop_path=False, keep_min_order=True)
for node in path:
print(node)

···

作者：皓首不倦
链接：https://www.acwing.com/solution/content/19197/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510;

int n = 500, m;
int g[N][N];
int ans[1100], cnt;
int d[N];

void dfs(int u)
{
    for (int i = 1; i <= n; i ++ )
        if (g[u][i])
        {
            g[u][i] --, g[i][u] -- ;
            dfs(i);
        }
    ans[ ++ cnt] = u;
}

int main()
{
    cin >> m;
    while (m -- )
    {
        int a, b;
        cin >> a >> b;
        g[a][b] ++, g[b][a] ++ ;
        d[a] ++, d[b] ++ ;
    }

    int start = 1;
    while (!d[start]) start ++ ;
    for (int i = 1; i <= n; i ++ )
        if (d[i] % 2)
        {
            start = i;
            break;
        }

    dfs(start);

    for (int i = cnt; i; i -- ) printf("%d\n", ans[i]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/159798/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1185. 单词游戏    原题链接    简单
作者：    minux ,  2020-07-07 11:17:29 ,  阅读 89

2


c++ Union Find判Euler Path
#include <iostream>
#include <cstring>

using namespace std;

const int N=30; // 26个字母的顶点
int din[N], dout[N]; // 顶点的出度和入度
bool vis[N]; // 记录使用到的字母
int fa[N]; // union find set
int T, n;

inline int find(int x){return x==fa[x]?fa[x]:fa[x]=find(fa[x]);}
inline void init(){for(int i=0; i<26; ++i) fa[i]=i;}

int main(){
    string word;
    cin>>T;
    while(T--){
        cin>>n;
        memset(din, 0x00, sizeof din);
        memset(dout, 0x00, sizeof dout);
        memset(vis, 0x00, sizeof vis);
        init();
        for(int i=0; i<n; ++i){
            cin>>word;
            int x=word[0]-'a';
            int y=word.back()-'a';
            vis[x]=vis[y]=true;
            // 建立一条由x指向y的有向边
            dout[x]++;
            din[y]++;
            // 设置在同一个连通分量中
            fa[find(x)]=find(y);
        }

        // 判断度数
        int s=0, e=0;
        bool ok=true;
        for(int i=0; i<26; ++i)
            if(din[i]!=dout[i]){
                if(din[i]==dout[i]+1) ++e;
                else if(din[i]+1==dout[i]) ++s;
                else {ok=false; break;}
            }
        // 有向图Euler path判定
        // 或者起点和终点数量都是0(形成环)
        // 或者起点和终点数量都是1
        if(!(!s&&!e||s==1 && e==1)) ok=false;

        // 判断连通性
        int fv=-1;
        for(int i=0; i<26; ++i){
            if(vis[i]){
                if(fv==-1) fv=find(i);
                else if(fv!=find(i)){ok=false; break;}
            }
        }

        if(ok) cout<<"Ordering is possible."<<endl;
        else cout<<"The door cannot be opened."<<endl;
    }

    return 0;
}
c++ DFS判Euler Path
#include <iostream>
#include <cstring>

using namespace std;

const int N=30; // 26个字母的顶点
int din[N], dout[N]; // 顶点的出度和入度
int g[N][N];
int T, n, cnt;

void dfs(int u){
    for(int i=0; i<26; ++i){
        if(g[u][i]){
            ++cnt;
            --g[u][i];
            dfs(i);
        }
    }
}

int main(){
    string word;
    cin>>T;
    while(T--){
        cnt=0;
        cin>>n;
        memset(din, 0x00, sizeof din);
        memset(dout, 0x00, sizeof dout);
        memset(g, 0x00, sizeof g);
        for(int i=0; i<n; ++i){
            cin>>word;
            int x=word[0]-'a';
            int y=word.back()-'a';
            // 建立一条由x指向y的有向边
            dout[x]++;
            din[y]++;
            g[x][y]++;
        }

        // 判断度数
        int s=0, e=0;
        bool ok=true;
        for(int i=0; i<26; ++i)
            if(din[i]!=dout[i]){
                if(din[i]==dout[i]+1) ++e;
                else if(din[i]+1==dout[i]) ++s;
                else {ok=false; break;}
            }
        // 有向图Euler path判定
        // 或者起点和终点数量都是0(形成环)
        // 或者起点和终点数量都是1
        if(!(!s&&!e||s==1 && e==1)) ok=false;

        // 判断连通性
        int start=0;
        while(!dout[start]) ++start;
        for(int i=start; i<26; ++i){
            if(dout[i]==din[i]+1) {start=i; break;}
        }
        dfs(start);
        if(cnt!=n) ok=false;
        if(ok) cout<<"Ordering is possible."<<endl;
        else cout<<"The door cannot be opened."<<endl;
    }

    return 0;
}

作者：minux
链接：https://www.acwing.com/solution/content/15851/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 30;

int n;
int din[N], dout[N], p[N];
bool st[N];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    char str[1010];

    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d", &n);
        memset(din, 0, sizeof din);
        memset(dout, 0, sizeof dout);
        memset(st, 0, sizeof st);
        for (int i = 0; i < 26; i ++ ) p[i] = i;

        for (int i = 0; i < n; i ++ )
        {
            scanf("%s", str);
            int len = strlen(str);
            int a = str[0] - 'a', b = str[len - 1] - 'a';
            st[a] = st[b] = true;
            dout[a] ++, din[b] ++ ;
            p[find(a)] = find(b);
        }

        int start = 0, end = 0;
        bool success = true;
        for (int i = 0; i < 26; i ++ )
            if (din[i] != dout[i])
            {
                if (din[i] == dout[i] + 1) end ++ ;
                else if (din[i] + 1 == dout[i]) start ++ ;
                else
                {
                    success = false;
                    break;
                }
            }

        if (success && !(!start && !end || start == 1 && end == 1)) success = false;

        int rep = -1;
        for (int i = 0; i < 26; i ++ )
            if (st[i])
            {
                if (rep == -1) rep = find(i);
                else if (rep != find(i))
                {
                    success = false;
                    break;
                }
            }

        if (success) puts("Ordering is possible.");
        else puts("The door cannot be opened.");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/159803/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1191. 家谱树    原题链接    简单
作者：    ABlyh ,  2020-07-31 15:18:19 ,  阅读 63

2


代码
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int ne[N],e[N],h[N],idx;
int n,m;
void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
int q[N];
int din[N];
bool bfs()
{
    int hh=0,tt=-1;
    for(int i=1;i<=n;i++)
    {
        if(din[i]==0) q[++tt]=i;
    }
    while(hh<=tt)
    {
        int u=q[hh++];
        for(int i=h[u];~i;i=ne[i])
        {
            int v=e[i];
            din[v]--;
            if(din[v]==0)
            {
                q[++tt]=v;
            }
        }
    }
    return hh==n;
}
int main()
{
    memset(h,-1,sizeof(h));
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int a;
        while(cin>>a&&a!=0)
        {
            add(i,a);
            din[a]++;
        }
    }
    bfs();
    for(int i=0;i<n;i++)
    {
        cout<<q[i]<<' ';
    }
    return 0;

}
核心
拓扑排序

作者：ABlyh
链接：https://www.acwing.com/solution/content/17435/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, M = N * N / 2;

int n;
int h[N], e[M], ne[M], idx;
int q[N];
int d[N];

void add (int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void topsort()
{
    int hh = 0, tt = -1;
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if ( -- d[j] == 0)
                q[ ++ tt] = j;
        }
    }
}

int main()
{
    cin >> n;
    memset(h, -1, sizeof h);

    for (int i = 1; i <= n; i ++ )
    {
        int son;
        while (cin >> son, son)
        {
            add(i, son);
            d[son] ++ ;
        }
    }

    topsort();

    for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/160311/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1192. 奖金    原题链接    简单
作者：    小呆呆 ,  2020-02-12 18:32:25 ,  阅读 219

2


算法分析
跑一次拓扑排序整理出所有编号在图中的前后关系

dist[i]：表示i点在拓扑图中离起点的最远距离(可能存在多起点)，dist[起点] == 100,边的权值为1

时间复杂度 O(n+m)O(n+m)
参考文献
算法提高课

Java 代码
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {
    static int N = 10010,M = 20010;
    static int n;
    static int m;
    static int[] h = new int[N];
    static int[] e = new int[M];
    static int[] ne = new int[M];
    static int idx = 0;
    static int[] qv = new int[N];
    static int qidx = 0;
    static int[] d = new int[N];
    static int[] dist = new int[N];
    static void add(int a,int b)
    {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx ++;
    }
    static boolean topsort()
    {
        Queue<Integer> q = new LinkedList<Integer>();
        for(int i = 1;i <= n;i ++)
        {
            if(d[i] == 0)
            {
                q.add(i);
                qv[qidx ++] = i;
            }
        }

        while(!q.isEmpty())
        {
            int t = q.poll();

            for(int i = h[t];i != -1;i = ne[i])
            {
                int j = e[i];
                if(-- d[j] == 0)
                {
                    q.add(j);
                    qv[qidx ++] = j;
                }

            }
        }
        return qidx == n;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] s1 = br.readLine().split(" ");
        n = Integer.parseInt(s1[0]);
        m = Integer.parseInt(s1[1]);
        Arrays.fill(h, -1);
        while(m -- > 0)
        {
            String[] s2 = br.readLine().split(" ");
            int a = Integer.parseInt(s2[0]);
            int b = Integer.parseInt(s2[1]);
            add(b,a);
            d[a] ++;
        }

        if(!topsort()) System.out.println("Poor Xed");
        else 
        {
            for(int i = 1;i <= n;i ++) dist[i] = 100;

            for(int i = 0;i < qidx;i ++)
            {
                int j = qv[i];
                for(int k = h[j];k != -1;k = ne[k])
                {
                    int x = e[k];
                    dist[x] = Math.max(dist[x], dist[j] + 1);
                }
            }

            int res = 0;
            for(int i = 1;i <= n;i ++) res += dist[i];
            System.out.println(res);
        }
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/8485/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010, M = 20010;

int n, m;
int h[N], e[M], ne[M], idx;
int q[N];
int d[N];
int dist[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool topsort()
{
    int hh = 0, tt = -1;
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if ( -- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    return tt == n - 1;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(b, a);
        d[a] ++ ;
    }

    if (!topsort()) puts("Poor Xed");
    else
    {
        for (int i = 1; i <= n; i ++ ) dist[i] = 100;
        for (int i = 0; i < n; i ++ )
        {
            int j = q[i];
            for (int k = h[j]; ~k; k = ne[k])
                dist[e[k]] = max(dist[e[k]], dist[j] + 1);
        }

        int res = 0;
        for (int i = 1; i <= n; i ++ ) res += dist[i];

        printf("%d\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/160323/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 164. 可达性统计    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-03 15:36:41 ,  阅读 1759

12


2
题目描述
给定一张N个点M条边的有向无环图，分别统计从每个点出发能够到达的点的数量。

输入格式
第一行两个整数N,M，接下来M行每行两个整数x,y，表示从x到y的一条有向边。

输出格式
输出共N行，表示每个点能够到达的点的数量。

数据范围

1≤N,M≤300001≤N,M≤30000
样例
输入样例：
10 10
3 8
2 3
2 5
5 9
5 9
2 3
3 9
4 8
2 10
4 9
输出样例：
1
6
3
3
2
1
1
1
1
1
拓扑排序+bitset二进制数组
有向无环图是拓扑排序的必要条件,而且这道题目明确告诉我们统计从每个点出发能够到达的点的数量,也就是说统计这个点可以抵达的个数,这样的话我们只需要再开一个数组f.f[i]表示i这个点的可以抵达点的数量.我们很快就可以发现性质.
f[i]=所有出边上点的交集.既然如此的话,我们不妨开一个二进制数组来进行并集|运算即可.
感谢大佬@一苇指出问题

C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N=3e4+10;
int net[N],head[N],ver[N],deg[N],tot,cnt,a[N],n,m;
bitset<N> f[N];
void add(int x,int y)//链式前向星加边
{
    ver[++tot]=y;
    net[tot]=head[x];
    head[x]=tot;
    deg[y]++;//deg为入度
}
void topsort(void)
{
    queue<int> q;
    for(int i=1;i<=n;i++)
        if (deg[i]==0)
            q.push(i);
    while(q.size())
    {
        int x=q.front();
        a[++cnt]=x;
        q.pop();
        for(int i=head[x];i;i=net[i])//链式前向星访问
        {
            int y=ver[i];
            deg[y]--;
            if (!deg[y])//入读为0,可以加入候选队列之中
                q.push(y);
        }
    }

}
void calc()
{
    for (int j = cnt; j; j--)
    {
        int x=a[j];
        f[x][x]=1;
        for (int i=head[x];i;i=net[i])
        {
            int y=ver[i];
            f[x]|=f[y];//求出集合
        }
    }
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        cin>>x>>y;
        add(x,y);
    }
    topsort();
    calc();
    for(int i=1;i<=n;i++)
        cout<<f[i].count()<<endl;//统计1的个数,也就是到达了多少个点
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/949/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>

using namespace std;

const int N = 30010, M = 30010;

int n, m;
int h[N], e[M], ne[M], idx;
int d[N], q[N];
bitset<N> f[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void topsort()
{
    int hh = 0, tt = -1;
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if ( -- d[j] == 0)
                q[ ++ tt] = j;
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
        d[b] ++ ;
    }

    topsort();

    for (int i = n - 1; i >= 0; i -- )
    {
        int j = q[i];
        f[j][j] = 1;
        for (int k = h[j]; ~k; k = ne[k])
            f[j] |= f[e[k]];
    }

    for (int i = 1; i <= n; i ++ ) printf("%d\n", f[i].count());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/160335/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
#include <iostream>
#include <algorithm>
#include <cstring>
#include <complex>
#include <climits>
#include <cstdlib>
#include <cctype>
#include <cstdio>
#include <vector>
#include <bitset>

using namespace std;

const int N=30005;

int n,m;
int h[N],e[N],ne[N],idx;
int d[N],q[N],hh=1,tt;
bitset<N> f[N];

inline int read()
{
    int x=0;
    char ch;
    bool fx=false;
    do ch=getchar();while(~ch&&ch!='-'&&(ch<48||ch>57));
    if(ch=='-')fx=true,ch=getchar();
    for(;ch>47&&ch<58;ch=getchar())
        x=(x<<1)+(x<<3)+(ch^48);
    return fx?-x:x;
}

inline void add(int a,int b)
{
    e[++idx]=b;
    ne[idx]=h[a];
    h[a]=idx;
}

int main()
{
    n=read(),m=read();
    for(int i=0;i<m;i++)
    {
        int a,b;
        a=read(),b=read();
        add(a,b),d[b]++;
    }
    for(int i=1;i<=n;i++)
        if(!d[i])
            q[++tt]=i;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!--d[e[i]])
                q[++tt]=e[i];
    }
    for(int i=n;i;i--)
    {
        f[q[i]][q[i]]=1;
        for(int j=h[q[i]];j;j=ne[j])
            f[q[i]]|=f[e[j]];
    }
    for(int i=1;i<=n;i++)printf("%d\n",f[i].count());
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/329131/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 456. 车站分级    原题链接    中等
作者：    小呆呆 ,  2020-02-13 23:00:50 ,  阅读 353

5


1
算法分析
拓扑排序 + 虚拟点

题目描述：如果这趟车次停靠了火车站x，则始发站、终点站之间所有级别大于等于火车站x的都必须停靠

翻译过来：停靠过的车站的等级一定严格大于为停靠过的车站的等级，因此车站的等级均有严格的大小关系，则不存在环，因此可以用拓扑排序每个车站在图中的大小关系，使用动态规划求出车站等级最大的最小值(方法和 Acwing 1192奖金 类似)

在建边的时候，最坏情况下是有1000趟火车，每趟有1000个点，每趟上限有500个点停站，则有(1000 - 500)个点不停站，不停站的点都向停站的点连有向边，则总共有500 * 500 * 1000 = 2.5 * 10^8,则会超内存，如果用邻接矩阵存储，需要遍历所有的边，遍历的次数也是2.5 * 10^8，因此会超时，所以在每趟火车所有不停站的点向所有停站的点连有向边时，中间添加一个ver辅助结点，如下图连接方式



dist[i]：表示i点在拓扑图中离起点的最远距离(可能存在多起点)，dist[起点] == 1,边的权值为1

时间复杂度 O(n+m)O(n+m)
参考文献
算法提高课

Java 代码
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class Main {
    static int N = 2010,M = 1000010;
    static int n;
    static int m;
    static int[] h = new int[N];
    static int[] e = new int[M];
    static int[] w = new int[M];
    static int[] ne = new int[M];
    static int idx = 0;
    static int[] d = new int[N];
    static int[] qv = new int[N];
    static int qidx = 0;
    static boolean[] st = new boolean[N];
    static int[] dist = new int[N];
    static void add(int a,int b,int c)
    {
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx ++;
    }
    static void topsort()
    {
        Queue<Integer> q = new LinkedList<Integer>();
        for(int i = 1;i <= n + m;i ++)
        {
            if(d[i] == 0)
            {
                q.add(i);
                qv[qidx ++] = i;
            }
        }

        while(!q.isEmpty())
        {
            int t = q.poll();
            for(int i = h[t];i != -1;i = ne[i])
            {
                int j = e[i];
                if(-- d[j] == 0)
                {
                    q.add(j);
                    qv[qidx ++] = j;
                }
            }
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] s1 = br.readLine().split(" ");
        n = Integer.parseInt(s1[0]);
        m = Integer.parseInt(s1[1]);
        Arrays.fill(h, -1);
        for(int i = 1;i <= m;i ++)
        {
            String[] s2 = br.readLine().split(" ");
            Arrays.fill(st, false);
            int start = n,end = 1;
            for(int j = 1;j < s2.length;j ++)
            {
                int x = Integer.parseInt(s2[j]); 
                start = Math.min(start, x); 
                end = Math.max(end, x); 
                st[x] = true;
            }
            int ver = n + i;//虚拟结点
            for(int j = start;j <= end;j ++)
            {
                if(!st[j]) 
                {
                    add(j,ver,0);//该点向虚拟结点连一条权值为0的边
                    d[ver] ++;
                }
                else 
                {
                    add(ver,j,1);//虚拟结点向该点连一条权值为1的边
                    d[j] ++;
                }
            }
        }

        topsort();
        for(int i = 1;i <= n;i ++) dist[i] = 1;
        for(int i = 0;i < n + m;i ++)
        {
            int j = qv[i];
            for(int k = h[j];k != -1;k = ne[k])
            {
                int x = e[k];
                dist[x] = Math.max(dist[x], dist[j] + w[k]);
            }
        }
        int res = 0;
        for(int i = 1;i <= n;i ++) res = Math.max(res, dist[i]);
        System.out.println(res);
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/8537/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2010, M = 1000010;

int n, m;
int h[N], e[M], ne[M], w[M], idx;
int q[N], d[N];
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    d[b] ++ ;
}

void topsort()
{
    int hh = 0, tt = -1;
    for (int i = 1; i <= n + m; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if ( -- d[j] == 0)
                q[ ++ tt] = j;
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    for (int i = 1; i <= m; i ++ )
    {
        memset(st, 0, sizeof st);
        int cnt;
        scanf("%d", &cnt);
        int start = n, end = 1;
        while (cnt -- )
        {
            int stop;
            scanf("%d", &stop);
            start = min(start, stop);
            end = max(end, stop);
            st[stop] = true;
        }

        int ver = n + i;
        for (int j = start; j <= end; j ++ )
            if (!st[j]) add(j, ver, 0);
            else add(ver, j, 1);
    }

    topsort();

    for (int i = 1; i <= n; i ++ ) dist[i] = 1;
    for (int i = 0; i < n + m; i ++ )
    {
        int j = q[i];
        for (int k = h[j]; ~k; k = ne[k])
            dist[e[k]] = max(dist[e[k]], dist[j] + w[k]);
    }

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = max(res, dist[i]);

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/160360/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


1


#include <iostream>
#include <algorithm>
#include <cstring>
#include <complex>
#include <climits>
#include <cstdlib>
#include <sstream>
#include <utility>
#include <cctype>
#include <cstdio>

using namespace std;

const int N=2005;
const int M=2000005;

int n,m;
int h[N],e[M],ne[M],idx;
int d[N],q[N],hh,tt=-1;
int dist[N],w[M];
bool st[N];

inline int read()
{
    int x=0;
    char ch;
    bool fx=false;
    do ch=getchar();while(~ch&&ch!='-'&&(ch<48||ch>57));
    if(ch=='-')fx=true,ch=getchar();
    for(;ch>47&&ch<58;ch=getchar())
        x=(x<<1)+(x<<3)+(ch^48);
    return fx?-x:x;
}

inline void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx++;
    d[b]++;
}

int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        memset(st,false,sizeof st);
        int start=n,end=1;
        for(int T=read(),stop;T--;)
        {
            stop=read();
            start=min(start,stop);
            end=max(end,stop);
            st[stop]=true;
        }
        int ver=n+i;
        for(int j=start;j<=end;j++)
            if(st[j])add(ver,j,1);
            else    add(j,ver,0);
    }
    for(int i=1;i<=n+m;i++)
        if(!d[i])
            q[++tt]=i;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!--d[e[i]])
                q[++tt]=e[i];
    }
    for(int i=1;i<=n;i++)dist[i]=1;
    for(int i=0;i<n+m;i++)
        for(int j=h[q[i]];j;j=ne[j])
            dist[e[j]]=max(dist[e[j]],dist[q[i]]+w[j]);
    int res=0;
    for(int i=1;i<=n;i++)
        res=max(res,dist[i]);
    printf("%d\n",res);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/329163/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1097. 池塘计数    原题链接    简单
作者：    yingzhaoyang ,  2019-11-08 15:25:20 ,  阅读 598

7


题目描述
农夫约翰有一片 N∗M 的矩形土地。

最近，由于降雨的原因，部分土地被水淹没了。

现在用一个字符矩阵来表示他的土地。

每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。

现在，约翰想知道他的土地中形成了多少片池塘。

每组相连的积水单元格集合可以看作是一片池塘。

每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。

请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。

样例
输入样例：

10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.

输出样例:

3

其实这道题完全可以用深搜.
直接搜索每一个“ W ”周围是否还有“ W ”.
如果有，就将其变为“ . ”.
再统计答案即可.

时间复杂度 O(我不知道)O(我不知道)
C++ 代码
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,a[1010][1010];
char Map[1010][1010];
int dx[8]={1,0,-1,0,1,-1,1,-1},dy[8]={0,1,0,-1,1,-1,-1,1};//方向数组
void dfs(int x,int y)
{
    Map[x][y]='.';
    for(int i=0;i<8;i++)
        if(Map[x+dx[i]][y+dy[i]]=='W')
            dfs(x+dx[i],y+dy[i]);
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>Map[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(Map[i][j]=='W'){//找到“ W ”.
                dfs(i,j);
                ans++;//统计答案
            }
    printf("%d\n",ans);
    return 0;
}

作者：yingzhaoyang
链接：https://www.acwing.com/solution/content/5859/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n, m;
char g[N][N];
PII q[M];
bool st[N][N];

void bfs(int sx, int sy)
{
    int hh = 0, tt = 0;
    q[0] = {sx, sy};
    st[sx][sy] = true;

    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        for (int i = t.x - 1; i <= t.x + 1; i ++ )
            for (int j = t.y - 1; j <= t.y + 1; j ++ )
            {
                if (i == t.x && j == t.y) continue;
                if (i < 0 || i >= n || j < 0 || j >= m) continue;
                if (g[i][j] == '.' || st[i][j]) continue;

                q[ ++ tt] = {i, j};
                st[i][j] = true;
            }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

    int cnt = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (g[i][j] == 'W' && !st[i][j])
            {
                bfs(i, j);
                cnt ++ ;
            }

    printf("%d\n", cnt);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/130752/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1098. 城堡问题    原题链接    简单
作者：    烛之武 ,  2020-01-21 10:43:58 ,  阅读 441

C++ 代码
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std ;

typedef pair<int,int> PII ;
const int N = 50 ;

int g[N][N] ;
int dist[N][N] ;
int dx[] = {0,-1,0,1}, dy[] = {-1,0,1,0} ;
int n,m ;

int bfs(int x,int y){
    dist[x][y] = 0 ;
    queue<PII> q ;
    q.push({x,y}) ;

    int cnt = 0 ;
    while(q.size()){
        PII ele = q.front() ;
        q.pop() ;
        cnt ++ ;
        int x = ele.first, y = ele.second ;
        for(int i=0;i<4;i++){
            if(!(g[x][y]>>i&1)){
                int a = x + dx[i],b = y + dy[i] ;
                if(dist[a][b] == -1){
                    dist[a][b] = dist[x][y] + 1 ;
                    q.push({a,b}) ;
                }
            }
        }
    }
    return cnt ;
}

int main(){
    scanf("%d%d",&n,&m) ;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            scanf("%d",&g[i][j]) ;
        }
    }

    int res = 0,maxv = 0 ;
    memset(dist,-1,sizeof dist) ;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(dist[i][j] == -1){
                res ++ ;
                maxv = max(maxv,bfs(i,j)) ;
            }
        }
    }
    printf("%d\n",res) ;
    printf("%d\n",maxv) ;

    return 0 ;
}

作者：烛之武
链接：https://www.acwing.com/solution/content/7771/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 55, M = N * N;

int n, m;
int g[N][N];
PII q[M];
bool st[N][N];

int bfs(int sx, int sy)
{
    int dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0};

    int hh = 0, tt = 0;
    int area = 0;

    q[0] = {sx, sy};
    st[sx][sy] = true;

    while (hh <= tt)
    {
        PII t = q[hh ++ ];
        area ++ ;

        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= m) continue;
            if (st[a][b]) continue;
            if (g[t.x][t.y] >> i & 1) continue;

            q[ ++ tt] = {a, b};
            st[a][b] = true;
        }
    }

    return area;
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            cin >> g[i][j];

    int cnt = 0, area = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (!st[i][j])
            {
                area = max(area, bfs(i, j));
                cnt ++ ;
            }

    cout << cnt << endl;
    cout << area << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/130772/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1106. 山峰和山谷    原题链接    中等
作者：    Overnoise ,  2019-11-08 14:58:21 ,  阅读 970

7


#include<bits/stdc++.h>
using namespace std;
int n,ans1,ans2;
bool f[1005][1005];
int MAP[1005][1005];
struct oppo{
    int x,y;
}mi;
queue< oppo > v;
int kx[10]={1,-1,0,0,1,1,-1,-1};
int ky[10]={0,0,1,-1,1,-1,-1,1};
void bfs(int x,int y)
{
    bool flag1=0,flag2=0;
    int h=MAP[x][y];
    f[x][y]=1;
    mi.x=x;
    mi.y=y;
    v.push(mi);
    while(v.size())
    {
        oppo lxl=v.front();
        v.pop();
        for(int i=0;i<8;i++)
        {
            int tx=lxl.x+kx[i];
            int ty=lxl.y+ky[i];
            if(tx<=0||ty<=0||tx>n||ty>n)
                continue;
            if(MAP[tx][ty]==h&&!f[tx][ty])
            {
                mi.x=tx;
                mi.y=ty;
                f[tx][ty]=1;
                v.push(mi);
            }
            else if(MAP[tx][ty]>h)
                flag1=1;
            else if(MAP[tx][ty]<h)
                flag2=1;
        }
    }
    if(!flag1)
        ans1++;
    if(!flag2)
        ans2++;
}
int main()
{
    //freopen("grz.in","r",stdin);
    //freopen("grz.out","w",stdout);
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            cin>>MAP[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(!f[i][j])
                bfs(i,j);
    cout<<ans1<<" "<<ans2<<endl;
    return 0;
}

作者：Overnoise
链接：https://www.acwing.com/solution/content/6004/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n;
int h[N][N];
PII q[M];
bool st[N][N];

void bfs(int sx, int sy, bool& has_higher, bool& has_lower)
{
    int hh = 0, tt = 0;
    q[0] = {sx, sy};
    st[sx][sy] = true;

    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        for (int i = t.x - 1; i <= t.x + 1; i ++ )
            for (int j = t.y - 1; j <= t.y + 1; j ++ )
            {
                if (i == t.x && j == t.y) continue;
                if (i < 0 || i >= n || j < 0 || j >= n) continue;
                if (h[i][j] != h[t.x][t.y]) // 山脉的边界
                {
                    if (h[i][j] > h[t.x][t.y]) has_higher  = true;
                    else has_lower = true;
                }
                else if (!st[i][j])
                {
                    q[ ++ tt] = {i, j};
                    st[i][j] = true;
                }
            }
    }
}

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            scanf("%d", &h[i][j]);

    int peak = 0, valley = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            if (!st[i][j])
            {
                bool has_higher = false, has_lower = false;
                bfs(i, j, has_higher, has_lower);
                if (!has_higher) peak ++ ;
                if (!has_lower) valley ++ ;
            }

    printf("%d %d\n", peak, valley);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/130795/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



    AcWing 1076. 迷宫问题    原题链接    简单
作者：    AJ小公主 ,  2019-11-27 11:50:26 ,  阅读 631

8


算法1
BFS
其他的都很好理解，就是我写的时候有一个问题，找了好久最后找到啦~~
就是在打印路线的时候我直接用原来的变量进行更新的就比如我用
en.x = tath[en.x][en.y].x; （1）
en.y = path[en.x][en.y].y; （2）

看着没有问题，但其实在1式中end.x已经被更新了，我却用这个已经被更新的变量去更新上一次还未更新的en.y所以答案肯定就错误啦~~，因此需要把变量保存下来，然后用上一次的变量去更新这一次的值。

时间复杂度
参考文献
C++ 代码
#include <queue>
#include <iostream>
#include <algorithm>
#define x first
#define y second

using namespace std;
typedef pair<int, int> PII;
const int N = 1010;

int g[N][N];
PII memory[N][N];

int st[N][N];
int n;

void bfs()
{
    queue<PII> q;
    q.push({n - 1,  n - 1});
    st[n - 1][n - 1] = true;
    int dx[] = {0, -1, 0, 1}, dy[] = {-1, 0, 1, 0};
    while(q.size())
    {
        auto t = q.front();
        q.pop();
        for(int i = 0; i < 4; i ++)
        {
            int x = dx[i] + t.x, y = dy[i] + t.y;
            if(x < 0 || x >= n || y < 0 || y >= n)continue;
            if(st[x][y])continue;
            if(g[x][y] == 1)continue;
            q.push({x, y});
            st[x][y] = true;
            memory[x][y] = t;
        }
    }
}

int main()
{
    cin >> n;
    for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
            cin >> g[i][j];
    bfs();
    PII end = {0, 0};
    cout << 0 << ' ' << 0 << endl;

    while(end.x != n - 1 || end.y != n - 1)
    {
        printf("%d %d\n", memory[end.x][end.y].x, memory[end.x][end.y].y);
        int x = end.x, y = end.y;
        end.x = memory[x][y].x, end.y = memory[x][y].y;
    }

    return 0;
}

作者：AJ小公主
链接：https://www.acwing.com/solution/content/6596/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1076. 迷宫问题
作者：    yxc ,  2019-10-16 22:13:08 ,  阅读 662

5


1
#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n;
int g[N][N];
PII q[M];
PII pre[N][N];

void bfs(int sx, int sy)
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    int hh = 0, tt = 0;
    q[0] = {sx, sy};

    memset(pre, -1, sizeof pre);
    pre[sx][sy] = {0, 0};
    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= n) continue;
            if (g[a][b]) continue;
            if (pre[a][b].x != -1) continue;

            q[ ++ tt] = {a, b};
            pre[a][b] = t;
        }
    }
}

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            scanf("%d", &g[i][j]);

    bfs(n - 1, n - 1);

    PII end(0, 0);

    while (true)
    {
        printf("%d %d\n", end.x, end.y);
        if (end.x == n - 1 && end.y == n - 1) break;
        end = pre[end.x][end.y];
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/130866/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 188. 武士风度的牛    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-08 15:45:35 ,  阅读 918

4


1
原题链接
更好的阅读体验

题目描述
农民John有很多牛，他想交易其中一头被Don称为The Knight的牛。

这头牛有一个独一无二的超能力，在农场里像Knight一样地跳（就是我们熟悉的象棋中马的走法）。

虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个x，y的坐标图来表示。

这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了The Knight的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。

现在你的任务是，确定The Knight要想吃到草，至少需要跳多少次。

The Knight的位置用’K’来标记，障碍的位置用’*’来标记，草的位置用’H’来标记。

这里有一个地图的例子：

             11 | . . . . . . . . . .
             10 | . . . . * . . . . . 
              9 | . . . . . . . . . . 
              8 | . . . * . * . . . . 
              7 | . . . . . . . * . . 
              6 | . . * . . * . . . H 
              5 | * . . . . . . . . . 
              4 | . . . * . . . * . . 
              3 | . K . . . . . . . . 
              2 | . . . * . . . . . * 
              1 | . . * . . . . * . . 
              0 ----------------------
                                    1 
                0 1 2 3 4 5 6 7 8 9 0 
The Knight 可以按照下图中的A,B,C,D…这条路径用5次跳到草的地方（有可能其它路线的长度也是5）：


             11 | . . . . . . . . . .
             10 | . . . . * . . . . .
              9 | . . . . . . . . . .
              8 | . . . * . * . . . .
              7 | . . . . . . . * . .
              6 | . . * . . * . . . F<
              5 | * . B . . . . . . .
              4 | . . . * C . . * E .
              3 | .>A . . . . D . . .
              2 | . . . * . . . . . *
              1 | . . * . . . . * . .
              0 ----------------------
                                    1
                0 1 2 3 4 5 6 7 8 9 0
输入格式
第1行： 两个数，表示农场的列数C(C<=150)和行数R(R<=150)。

第2..R+1行: 每行一个由C个字符组成的字符串，共同描绘出牧场地图。

输出格式
一个整数，表示跳跃的最小次数。

样例
输入样例：
10 11
..........
....*.....
..........
...*.*....
.......*..
..*..*...H
*.........
...*...*..
.K........
...*.....*
..*....*..
输出样例：
5
广度优先搜索
一般来说走迷宫,最少步数这种题目,都是广度优先搜索.记住读入上面的有梗,然后修改一下一般走路方式就好了.
C++ 代码
#include <bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
#define mk(a,b) make_pair(a,b)
#define fir(i,a,b) for(int i=a;i<=b;i++)
const int dx[8]= {1,2,2, 1,-1,-2,-2,-1};//中国象棋马的正确走路姿势
const int dy[8]= {2,1,-1,-2,-2,-1,1,2};//一头不遵循国际象棋,而遵循中国象棋的外国牛
char s[160][160];
int n,m,dis[160][160];
pii st,ed;
queue<pii> q;
bool check(int x,int y)
{
    return x>=1 && x<=n && y>=1 && y<=m && s[x][y]!='*' && dis[x][y]==-1;//在范围内;且不是障碍物;第一次被访问
}
void st_ed(void)//找起点和终点
{
    fir(i,1,n)
    fir(j,1,m)
    {
        if (s[i][j]=='K')
        {
            st.first=i;
            st.second=j;
        }
        if (s[i][j]=='H')
        {
            ed.first=i;
            ed.second=j;
        }
    }
}
int bfs(void)
{
    memset(dis,-1,sizeof(dis));
    q.push(mk(st.first,st.second));//压入起点
    dis[st.first][st.second]=0;
    while(q.size())
    {
        pii now=q.front();
        q.pop();
        fir(i,0,7)
        {
            int x=now.first+dx[i],y=now.second+dy[i];//拓展
            if (check(x,y))//满足条件
            {
                dis[x][y]=dis[now.first][now.second]+1;
                q.push(mk(x,y));
                if (x==ed.first && y==ed.second)//到达终点了
                    return dis[x][y];
            }
        }
    }
    return -1;//然而并没有无解情况
}
int main()
{
    //freopen("stdin.in","r",stdin);
    scanf("%d%d\n",&m,&n);//读入要小心,不然就会Game Over,你就会发现你从第三组后面的数据死活无法AC.
    fir(i,1,n)
    scanf("%s",s[i]+1);//读入从字符1开始
    st_ed();
    cout<<bfs();
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/976/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 155, M = N * N;

int n, m;
char g[N][N];
PII q[M];
int dist[N][N];

int bfs()
{
    int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};
    int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};

    int sx, sy;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (g[i][j] == 'K')
                sx = i, sy = j;

    int hh = 0, tt = 0;
    q[0] = {sx, sy};

    memset(dist, -1, sizeof dist);
    dist[sx][sy] = 0;

    while (hh <= tt)
    {
        auto t = q[hh ++ ];

        for (int i = 0; i < 8; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= m) continue;
            if (g[a][b] == '*') continue;
            if (dist[a][b] != -1) continue;
            if (g[a][b] == 'H') return dist[t.x][t.y] + 1;

            dist[a][b] = dist[t.x][t.y] + 1;
            q[ ++ tt] = {a, b};
        }
    }

    return -1;
}

int main()
{
    cin >> m >> n;

    for (int i = 0; i < n; i ++ ) cin >> g[i];

    cout << bfs() << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/130867/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1100. 抓住那头牛（玄学优化）    原题链接    简单
作者：    hyc_noi ,  2020-06-30 18:14:03 ,  阅读 136

9


题目描述
农夫知道一头牛的位置，想要抓住它。

农夫和牛都位于数轴上，农夫起始位于点 NN，牛位于点 KK。

农夫有两种移动方式：

从 XX 移动到 X−1X−1 或 X+1X+1，每次移动花费一分钟
从 XX 移动到 2∗X2∗X，每次移动花费一分钟
假设牛没有意识到农夫的行动，站在原地不动。

农夫最少要花多少时间才能抓住牛？

输入格式
共一行，包含两个整数NN和KK。

输出格式
输出一个整数，表示抓到牛所花费的最少时间。

数据范围
0≤N,K≤1050≤N,K≤105
样例
输入样例：

5 17
输出样例：

4
算法1
(普通的bfs)
有三种情况，每次都扩展题目里的三种状态就行了。为了不出现死循环，这里要判个重。如果之前有步数记录，则说明走过这个地方，不考虑。

算法2
(我的玄学优化bfs)
其实可以发现，虽然数轴是无限的，但是如果到了零以下，是没有牛的，而且则只有一种方案可以让农夫重新到正数：t−>t+1t−>t+1(这不是自讨苦吃嘛，走的还更远了。我相信农夫不会傻到这种程度)
然后，我们又发现，加一也不能大于牛最大可能在的地方（这个大家都懂吧）。
最后可以发现，如果从牛最大可能在的地方再乘2，就必须往回走了。而且如果先往回走再乘2，一定更优。因为如果那样的话，就相当于一次性走了两步。所以，一定不会大于牛最大可能在的地方。而且，因为1e5是一个偶数，所以乘2后一定是两格两格走，不会有特殊情况。如果是奇数可能会出现本来只走一格，先减一再乘2后还是走一格。

嗯，等等，是不是只有这一个特殊情况呢？
没错，你的猜想是对的，所以，是奇数就减一再与k比较。我们成功优化。

你以为这样就完了吗？
不可能的！
不难发现，如果一个数大于k，则只能选择t−>t−1t−>t−1，所以我们可以判断一下，t是否大于k。如果大于，则只执行t−>t−1t−>t−1。当然，我们还可以在开始判断一下，如果是，则直接输出n-k。

你以为这样就完了吗？
真的完了。（本蒟蒻想不出来了）
C++ 代码
#include<bits/stdc++.h>
using namespace std;
const int NN=1e5;
int n,k,sum[NN+4];
int bfs()
{
    queue<int>q;
    q.push(n);
    while(q.size())
    {
        int t=q.front();
        if(t==k)
            return sum[t];
        q.pop();
        if(t+1<=NN&&t+1<=k&&!sum[t+1])//玄学优化
        {
            sum[t+1]=sum[t]+1;
            q.push(t+1);
        }
        if(t-1>=0&&!sum[t-1])//玄学优化
        {
            sum[t-1]=sum[t]+1;
            q.push(t-1);
        }
        if(t*2<=NN&&t*2-(k&1)<=k&&!sum[t*2])//玄学优化
        {
            sum[t*2]=sum[t]+1;
            q.push(t*2);
        }
    }
}
int main()
{
    scanf("%d%d",&n,&k);
    if(n>k)//玄学优化
    {
        printf("%d",n-k);
        return 0;
    }
    printf("%d",bfs());
    return 0;
}
优化代码
少量优化(因为不优化会数组越界)
优化了一半的时间，数据大点可以保证不TLE

作者：hyc_noi
链接：https://www.acwing.com/solution/content/11117/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n, k;
int q[N];
int dist[N];

int bfs()
{
    memset(dist, -1, sizeof dist);
    dist[n] = 0;
    q[0] = n;

    int hh = 0, tt = 0;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        if (t == k) return dist[k];

        if (t + 1 < N && dist[t + 1] == -1)
        {
            dist[t + 1] = dist[t] + 1;
            q[ ++ tt] = t + 1;
        }
        if (t - 1 >= 0 && dist[t - 1] == -1)
        {
            dist[t - 1] = dist[t] + 1;
            q[ ++ tt] = t - 1;
        }
        if (t * 2 < N && dist[t * 2] == -1)
        {
            dist[t * 2] = dist[t] + 1;
            q[ ++ tt] = t * 2;
        }
    }

    return -1;
}

int main()
{
    cin >> n >> k;

    cout << bfs() << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/130865/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



AcWing 173. 矩阵距离    原题链接    简单
作者：    小呆呆 ,  2020-01-30 18:22:11 ,  阅读 350

3


算法分析
多源bfs问题

将所有源点加入到队列，求出所有多源起点到所有点的最短距离
注意：由于输出数据过多，Java的同学需要用BufferWriter输出,否则会报错

时间复杂度 O(n2)O(n2)
参考文献
算法提高课

Java 代码
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main{
    static int N = 1010;
    static int n ;
    static int m ;
    static char[][] g = new char[N][N];
    static int[][] dist = new int[N][N];
    static int[] dx = new int[] {-1,0,1,0};
    static int[] dy = new int[] {0,1,0,-1};
    static void bfs()
    {
        Queue<PIIs> q = new LinkedList<PIIs>();
        for(int i = 0;i < n;i ++) Arrays.fill(dist[i], -1);
        for(int i = 0;i < n;i ++)
            for(int j = 0;j < m;j ++)
            {
                if(g[i][j] == '1')
                {
                    dist[i][j] = 0;
                    q.add(new PIIs(i,j));
                }
            }
        while(!q.isEmpty())
        {
            PIIs t = q.poll();
            for(int i = 0;i < 4;i ++)
            {
                int a = t.x + dx[i];
                int b = t.y + dy[i];
                if(a < 0 || a >= n || b < 0 || b >= m) continue;
                if(dist[a][b] != -1) continue;
                dist[a][b] = dist[t.x][t.y] + 1;
                q.add(new PIIs(a,b));
            }
        }
    }
    public static void main(String[] args) throws IOException {
        Scanner scan = new Scanner(System.in);
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
        n = scan.nextInt();
        m = scan.nextInt();
        for(int i = 0;i < n;i ++)
        {
            char[] charArray = scan.next().toCharArray();
            for(int j = 0;j < m;j ++)
            {
                g[i][j] = charArray[j];
            }
        }
        bfs();
        for(int i = 0;i < n;i ++)
        {
            for(int j = 0;j < m;j ++)
            {
                out.write(dist[i][j] + " ");
            }
            out.write("\n");
        }
        out.flush();
    }
}
class PIIs
{
    public int x;
    public int y;
    public PIIs(int x,int y)
    {
        this.x = x;
        this.y = y;
    }
}

作者：小呆呆
链接：https://www.acwing.com/solution/content/8019/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



AcWing 173. 矩阵距离    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-07 14:58:42 ,  阅读 1050

12


5
原题链接

题目描述
给定一个N行M列的01矩阵A，A[i][j] 与 A[k][l] 之间的曼哈顿距离定义为：

dist(A[i][j],A[k][l])=|i−k|+|j−l|
dist(A[i][j],A[k][l])=|i−k|+|j−l|

输出一个N行M列的整数矩阵B，其中：

B[i][j]=min1≤x≤N,1≤y≤M,A[x][y]=1dist(A[i][j],A[x][y])
B[i][j]=min1≤x≤N,1≤y≤M,A[x][y]=1dist(A[i][j],A[x][y])

输入格式
第一行两个整数n,m。

接下来一个N行M列的01矩阵，数字之间没有空格。

输出格式
一个N行M列的矩阵B，相邻两个整数之间用一个空格隔开。

数据范围
1≤N,M≤10001≤N,M≤1000
样例
输入样例：
3 4
0001
0011
0110
输出样例：
3 2 1 0
2 1 0 0
1 0 0 1
搜索+性质探索
这道题目我们主要要注意转换原题,原题告诉我们要求最短路,这个我们不能改变,但是原题说让我们求每个数与1的距离,那么我们只需要记住一点,那就是BFS具有层次单调性,且最重要的是天生自带flood-fill问题的解法.
flood-fill问题:一个起点到其他位置的最少步数.
这道题目我们完全可以认为是多起点问题,也就是说,我们直接将所有为1的点,加入到状态队列之中,那么这道题目就解决了.
C++ 代码
//重点部分写注释
#include <bits/stdc++.h>
#define mk(a,b) make_pair(a,b)
using namespace std;
const int N=1100;
queue<pair<int,int> >q;//p.first为x坐标,p.second为y坐标
pair<int,int> now;//队列中临时坐标
int a[N][N],n,m,d[N][N];//定义地图a,最短路径地图d
int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};//上下左右四个方向的坐标变换
bool check(pair<int,int> Next)
{
    int x=Next.first,y=Next.second;//x坐标,y坐标
    if (x>=1 && x<=n && y>=1 && y<=m && d[x][y]==-1)//坐标在地图内,而且这个点没有被拓展过
    {
        d[x][y]=d[now.first][now.second]+1;//上一步+1,更新步数
        return true;
    }
    return false;
}
int main()
{
    scanf("%d %d\n",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            char ch=getchar();
            a[i][j]=ch-'0';//字符变成数字
            d[i][j]=-1;//顺便初始化d数组,初始都为-1
            if (a[i][j])//这个点是1
            {
                d[i][j]=0;//自然是为0.
                q.push(mk(i,j));//将这个点加入到状态队列之中,因为它为可拓展点
            }
        }
        getchar();//读入换行符
    }
    while(q.size())//队列不空
    {
        now=q.front();//取出队头
        q.pop();//用完就出队
        for(int i=0;i<4;i++)
        {
            pair<int,int> Next=mk(now.first+dx[i],now.second+dy[i]);//x坐标进入下一步,y坐标进入下一步
            if (check(Next))//检测是否合法
                q.push(Next);//满足条件入队
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
            cout<<d[i][j]<<" ";
        cout<<endl;
    }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/970/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n, m;
char g[N][N];
PII q[M];
int dist[N][N];

void bfs()
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    memset(dist, -1, sizeof dist);

    int hh = 0, tt = -1;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            if (g[i][j] == '1')
            {
                dist[i][j] = 0;
                q[ ++ tt] = {i, j};
            }

    while (hh <= tt)
    {
        auto t = q[hh ++ ];

        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 1 || a > n || b < 1 || b > m) continue;
            if (dist[a][b] != -1) continue;

            dist[a][b] = dist[t.x][t.y] + 1;
            q[ ++ tt] = {a, b};
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%s", g[i] + 1);

    bfs();

    for (int i = 1; i <= n; i ++ )
    {
        for (int j = 1; j <= m; j ++ ) printf("%d ", dist[i][j]);
        puts("");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/131617/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1107. 魔板    原题链接    简单
作者：    Dear_You ,  2019-11-08 22:12:56 ,  阅读 543

8


1
自我想法
说实话，在Y老师用unordered_map时我是真的不明白，也许是我太弱了。于是我想有没有可以直接用map的方法

题目描述
这是一张有 8 个大小相同的格子的魔板：

1 2 3 4
8 7 6 5
我们知道魔板的每一个方格都有一种颜色。

这 8 种颜色用前 8 个正整数来表示。

可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。

对于上图的魔板状态，我们用序列 (1,2,3,4,5,6,7,8) 来表示，这是基本状态。

这里提供三种基本操作，分别用大写字母 A，B，C 来表示（可以通过这些操作改变魔板的状态）：

A：交换上下两行；
B：将最右边的一列插入到最左边；
C：魔板中央对的4个数作顺时针旋转。


你要编程计算用最少的基本操作完成基本状态到特殊状态的转换，输出基本操作序列。

输入样例
2 6 8 4 5 7 3 1

输入样例
7
BCABCCB
分析
对于这道题，我们可以开两个map数组，一个记录状态，另一个记录前驱，而对应的每个操作，我们其实不用像
Y老师那样专业，数组模拟也能做到，最后得到答案后，在一个一个往回跳，判断每次对应的操作就行了，最后统一输出
代码
//#pragma GCC optimize(3,"inline","Ofast","fast-math","no-stack-protector","unroll-loops")
//#pragma GCC target("sse","sse2","sse3","sse4","avx","avx2","popcnt")

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map>

#define RG register
#define ll long long
#define INF 0x3f3f3f3f

using namespace std;

const int N=9;

int tot;
char a[N*N];

map<string,string>pre;
map<string,int>dist;

queue<string>q;

inline string Get_1(string k)
{
    string res="";
    for (int i=7;i>=4;i--) res+=k[i];
    for (int i=3;i>=0;i--) res+=k[i];
    return res;
}//对行列变换 

inline string Get_3(string k)
{
    string res="";
    res+=k[0];
    res+=k[6];
    res+=k[1];
    res+=k[3];
    res+=k[4];
    res+=k[2];
    res+=k[5];
    res+=k[7];

    return res;
}//一个一个加 

inline string Get_2(string k)
{
    string res="";
    res+=k[3];
    for (int i=0;i<3;i++) res+=k[i];
    for (int i=5;i<8;i++) res+=k[i];
    res+=k[4];
    return res;
}

inline void BFS(string end)
{
    string v0="12345678";
    if(end==v0) return ;

    dist[v0]=0;
    q.push(v0);

    while(!q.empty())
    {
        string k=q.front();q.pop();
        string x[4];
        x[0]=Get_1(k);
        x[1]=Get_2(k);
        x[2]=Get_3(k);

        for (int i=0;i<3;i++)
        {
            string str=x[i];
            if(dist[str]==0)
            {
                dist[str]=dist[k]+1;
                pre[str]=k;
                if(str==end) break;
                q.push(str);
            }
        }
    }
}

inline void check(string end)
{
    string op=pre[end];
    if(op[0]==end[7]&&op[1]==end[6]&&op[2]==end[5]&&op[3]==end[4])
    {
        a[++tot]='A';
        return ;
    }
    else if(op[1]==end[2]&&op[2]==end[5]&&op[6]==end[1]&&op[5]==end[6])
    {
        a[++tot]='C';
        return ;
    }
    else a[++tot]='B';
}

int main()
{
    string end="";
    int x;
    for (int i=0;i<8;i++)
    {
        cin>>x;
        end+=char(x+'0');
    }

    BFS(end);

    cout<<dist[end]<<"\n";

    string vo="12345678";
    while(end!=vo)
    {
        check(end);
        end=pre[end];
    }

    if(dist[end])
        for (int i=tot;i>=1;i--) cout<<a[i];

    return 0;
}

作者：Dear_You
链接：https://www.acwing.com/solution/content/6011/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <queue>

using namespace std;

char g[2][4];
unordered_map<string, pair<char, string>> pre;
unordered_map<string, int> dist;

void set(string state)
{
    for (int i = 0; i < 4; i ++ ) g[0][i] = state[i];
    for (int i = 7, j = 0; j < 4; i --, j ++ ) g[1][j] = state[i];
}

string get()
{
    string res;
    for (int i = 0; i < 4; i ++ ) res += g[0][i];
    for (int i = 3; i >= 0; i -- ) res += g[1][i];
    return res;
}

string move0(string state)
{
    set(state);
    for (int i = 0; i < 4; i ++ ) swap(g[0][i], g[1][i]);
    return get();
}

string move1(string state)
{
    set(state);
    int v0 = g[0][3], v1 = g[1][3];
    for (int i = 3; i >= 0; i -- )
    {
        g[0][i] = g[0][i - 1];
        g[1][i] = g[1][i - 1];
    }
    g[0][0] = v0, g[1][0] = v1;
    return get();
}

string move2(string state)
{
    set(state);
    int v = g[0][1];
    g[0][1] = g[1][1];
    g[1][1] = g[1][2];
    g[1][2] = g[0][2];
    g[0][2] = v;
    return get();
}

int bfs(string start, string end)
{
    if (start == end) return 0;

    queue<string> q;
    q.push(start);
    dist[start] = 0;

    while (!q.empty())
    {
        auto t = q.front();
        q.pop();

        string m[3];
        m[0] = move0(t);
        m[1] = move1(t);
        m[2] = move2(t);

        for (int i = 0; i < 3; i ++ )
            if (!dist.count(m[i]))
            {
                dist[m[i]] = dist[t] + 1;
                pre[m[i]] = {'A' + i, t};
                q.push(m[i]);
                if (m[i] == end) return dist[end];
            }
    }

    return -1;
}

int main()
{
    int x;
    string start, end;
    for (int i = 0; i < 8; i ++ )
    {
        cin >> x;
        end += char(x + '0');
    }

    for (int i = 1; i <= 8; i ++ ) start += char('0' + i);

    int step = bfs(start, end);

    cout << step << endl;

    string res;
    while (end != start)
    {
        res += pre[end].first;
        end = pre[end].second;
    }

    reverse(res.begin(), res.end());

    if (step > 0) cout << res << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/131637/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



AcWing 175. 电路维修    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-07 20:37:14 ,  阅读 1691

12


2
原题链接
更好的阅读体验

题目描述
达达是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女翰翰，从而被收留在地球上。

翰翰的家里有一辆飞行车。

有一天飞行车的电路板突然出现了故障，导致无法启动。

电路板的整体结构是一个R行C列的网格（R,C≤500），如下图所示。



每个格点都是电线的接点，每个格子都包含一个电子元件。

电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。

在旋转之后，它就可以连接另一条对角线的两个接点。

电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。

达达发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。

她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。

不过，电路的规模实在是太大了，达达并不擅长编程，希望你能够帮她解决这个问题。

输入格式
输入文件包含多组测试数据。

第一行包含一个整数T，表示测试数据的数目。

对于每组测试数据，第一行包含正整数R和C，表示电路板的行数和列数。

之后R行，每行C个字符，字符是”/”和”"中的一个，表示标准件的方向。

输出格式
对于每组测试数据，在单独的一行输出一个正整数，表示所需的缩小旋转次数。

如果无论怎样都不能使得电源和发动机之间连通，输出NO SOLUTION。

数据范围
1≤R,C≤5001≤R,C≤500
1≤T≤51≤T≤5
只需要按照下面的方式旋转标准件，就可以使得电源和发动机之间连通。



样例
输入样例：
1
3 5
\\/\\
\\///
/\\\\
输出样例：
1
样例解释
样例的输入对应于题目描述中的情况。
双端队列+广度优先搜索
首先把电路板上每一个格子点(交叉点)看作无向图中的节点,我们认为两个节点x和y是某个小方格的两个对角,那么如果说x和y的线段’',那么我们可以认为边权为0,反之如果x和y线段是’/’,那么我们的边权视为1,说明要旋转一次才能够连上.
现在我们得到了一张完美的边权0或1的无向图,那么和普通广搜一样,我们唯一的改变就是,如果说当前新状态的边权为0,那么我们就放到队头先走,因为我们要满足两端性和单调性,而为了这个单调性,如果说当前新状态边权为1,那么我们就只能压入到队尾.
具体小细节就看代码吧.hh
C++ 代码
#include<bits/stdc++.h>
using namespace std;
#define fir(i,a,b) for(int i=a;i<=b;i++)
const int N=510;
const int dxy1[4][2]= {{1,1},{-1,-1},{1,-1},{-1,1}},dxy2[4][2]= {{1,1},{0,0},{1,0},{0,1}};//两种不同走法(因为两种线路),所以要两个方向数组
struct node
{
    int x,y;
};
int t,n,m,ans=1e8,dis[N][N];
char s[N][N];
bool vis[N][N];
deque<node> q;//双端队列
int check(int x,int y)
{
    return x>=0 && x<=n && y>=0 && y<=m;//范围内
}
void bfs()
{
    vis[0][0]=1;
    memset(vis,0,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));//初始化最大值
    q.push_front(node {0,0});//0开始,是因为读入的不是坐标,而是两种线路,然后你就会发现其实坐标点是要从0开始的,当然你n+1,m+1也是可以的
    dis[0][0]=0;
    while(q.size())
    {
        node now=q.front();
        q.pop_front();
        fir(i,0,3)//四种方向
        {
            int tx=now.x+dxy1[i][0],t1=now.x+dxy2[i][0];//如果是'\'
            int ty=now.y+dxy1[i][1],t2=now.y+dxy2[i][1];//如果是'/'
            int tt=(s[t1][t2] != (i<=1? '\\':'/'));//转义字符要双写,这里用到了三目运算符
            if(check(tx,ty) && dis[tx][ty]>dis[now.x][now.y]+tt)//check成功,并且当前值更加优秀
            {
                dis[tx][ty]=dis[now.x][now.y]+tt;
                if(tt)
                    q.push_back(node {tx,ty});//边权值为1
                else
                    q.push_front(node {tx,ty});//边权值为0
            }
        }
    }
}
int main()
{
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        fir(i,1,n)
        fir(j,1,m)
        cin>>s[i][j];
        bfs();
        if(dis[n][m]<1e8)//如果找到了方案
            cout<<dis[n][m]<<endl;
        else
            cout<<"NO SOLUTION"<<endl;
    }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/971/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>
#include <deque>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 510, M = N * N;

int n, m;
char g[N][N];
int dist[N][N];
bool st[N][N];

int bfs()
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    dist[0][0] = 0;
    deque<PII> q;
    q.push_back({0, 0});

    char cs[] = "\\/\\/";
    int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1};
    int ix[4] = {-1, -1, 0, 0}, iy[4] = {-1, 0, 0, -1};

    while (q.size())
    {
        PII t = q.front();
        q.pop_front();

        if (st[t.x][t.y]) continue;
        st[t.x][t.y] = true;

        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a > n || b < 0 || b > m) continue;

            int ca = t.x + ix[i], cb = t.y + iy[i];
            int d = dist[t.x][t.y] + (g[ca][cb] != cs[i]);

            if (d < dist[a][b])
            {
                dist[a][b] = d;

                if (g[ca][cb] != cs[i]) q.push_back({a, b});
                else q.push_front({a, b});
            }
        }
    }

    return dist[n][m];
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d%d", &n, &m);
        for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

        int t = bfs();

        if (t == 0x3f3f3f3f) puts("NO SOLUTION");
        else printf("%d\n", bfs());
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/132139/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 190. 字串变换    原题链接    中等
作者：    yxc ,  2019-10-19 16:09:43 ,  阅读 1050

16


4
算法
(BFS,双向BFS) O((LN)5)O((LN)5)
假设每次决策数量是 KK，那么如果直接BFS，最坏情况下的搜索空间是 K10K10，非常大，所以会TLE或者MLE。

如果采用双向BFS，则可以把搜索空间降到 2K52K5。在实际测试中只需 20ms 左右，剪枝效果很好。

BFS的扩展方式是：分别枚举在原字符串中使用替换规则的起点，和所使用的的替换规则。

时间复杂度
假设字符串长度是 LL，替换规则一共有 NN 个，则：

在最坏情况下每次会从字符串的每个位置开始，使用全部的 NN 种替换规则，因此总共会有 LNLN 种扩展方式，从起点和终点最多会分别扩展5步，因此总搜索空间是 2(LN)52(LN)5。

在BFS过程中，空间中的每个状态只会被遍历一次，因此时间复杂度是 O((LN)5)O((LN)5)。

参考文献
C++ 代码
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <queue>

using namespace std;

const int N = 6;

int n;
string a[N], b[N];

int extend(queue<string>& q, unordered_map<string, int>& da, unordered_map<string, int>& db, string a[], string b[])
{
    for (int k = 0, sk = q.size(); k < sk; k ++ )
    {
        string t = q.front();
        q.pop();

        for (int i = 0; i < t.size(); i ++ )
            for (int j = 0; j < n; j ++ )
                if (t.substr(i, a[j].size()) == a[j])
                {
                    string state = t.substr(0, i) + b[j] + t.substr(i + a[j].size());
                    if (da.count(state)) continue;
                    if (db.count(state)) return da[t] + 1 + db[state];
                    da[state] = da[t] + 1;
                    q.push(state);
                }
    }

    return 11;
}

int bfs(string A, string B)
{
    queue<string> qa, qb;
    unordered_map<string, int> da, db;
    qa.push(A), da[A] = 0;
    qb.push(B), db[B] = 0;

    while (qa.size() && qb.size())
    {
        int t;
        if (qa.size() <= qb.size()) t = extend(qa, da, db, a, b);
        else t= extend(qb, db, da, b, a);

        if (t <= 10) return t;
    }

    return 11;
}

int main()
{
    string A, B;
    cin >> A >> B;
    while (cin >> a[n] >> b[n]) n ++ ;

    int step = bfs(A, B);
    if (step > 10) puts("NO ANSWER!");
    else printf("%d\n", step);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/solution/content/5434/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 178. 第K短路    原题链接    困难
作者：    叶枫 ,  2019-09-28 07:09:20 ,  阅读 896

13


3
写在前面
学习算法的日子又到了~~

IdeaIdea
提供以下几种方法

暴搜


输出-1(是的，输出-1)

有算法的暴力

DijkstraDijkstra
DijkstraDijkstra的本质是贪心，复杂度为O(n2)O(n2)，堆优化后为O((m+n)log(m+n))O((m+n)log⁡(m+n))
SPFASPFA
学长说最好不要用，因为它死了
A∗A∗
yy总有视频讲解，不懂的同学可以去看看，这里我就不再赘述了
下面直接进行A∗A∗的讲解



所以，发现想出ff很关键，,ff要尽量大但不超过最优解



第几次出队就是第几短,于是终点出了kk次就是第kk短路了

按照DijkstraDijkstra的思想,我们每次取出d[x]+f[x]d[x]+f[x] 最小的

然后更新所有能到达的点

发现f[x]f[x] 可以取到终点的距离,这样尽量大且一定比现在的解小

于是先倒着DijkstraDijkstra一遍(搞出ff)

然后A∗A∗,直到终点第kk次。

OKOK,上代码

CodeCode
Code1Code1
//Dijstra 暴力版
const int maxx=1001;
struct Node{
    int v,to,next;
}e[maxn<<1];
int head[maxx],dis[maxx];
int len,tot,n,m,v,S,T,K;
bool vis[maxn];
priority_queue<pair<int,int> >q;
inline void add(int x,int y,int z){
    e[++tot].v=y; e[tot].to=z;
    e[tot].next=head[x]; head[x]=tot;
}
inline bool dfs(int x){
    if(x==T) return true;
    vis[x]=true;
    for(int i=head[x];i;i=e[i].next){
        int y=e[i].v;
        if(!vis[y]) if(dfs(y)==true) 
            return true;
    }
    return false;
}
inline void dijkstra(){
    if(!dfs(S)){puts("-1");return;}
    q.push(make_pair(0,S));
    if(S==T) v=-1;
    while(q.size()){
        int d=q.top().first,x=q.top().second; q.pop();
        if(x==T){
            if(++v==K){printf("%d",-d);return;}
            len=0;
        }
        else if(++len==maxx*15)break;//防止搜过多 
        for(int i=head[x];i;i=e[i].next){
            int y=e[i].v;
            q.push(make_pair(d-e[i].to,y));
        }
    }
    puts("-1");
}
signed main(){
    n=read(); m=read();
    for(int i=1;i<=m;i++){
        int x=read(),y=read(),z=read();
        add(x,y,z);
    }
    S=read(); T=read(); K=read();
    dijkstra();
    return 0;
} 
Code2Code2
//Dijkstra + A*

const int maxx=1001;
struct Node{
    int y,to,next;
}e[maxn],e1[maxn];
int head[maxx],tot,head1[maxx],cnt;//head1为反向边 
int n,m,dis[maxx],S,T,K,vis[maxx];
inline void add(int x,int y,int z){
    e[++tot]=(Node){y,z,head[x]};
    head[x]=tot;
}
inline void add1(int x,int y,int z){//反边 
    e1[++cnt]=(Node){y,z,head1[x]};
    head1[x]=cnt;
}
priority_queue<pair<int,int> >q;//注意：这是大根堆 
inline void dijkstra(){
    mem(dis,0x3f); mem(vis,-1);
    dis[T]=0;
    q.push(make_pair(0,T));
    while(q.size()){
        int x=q.top().second;q.pop();
        if(!vis[x])continue; vis[x]=0;//每个点只贡献一次
        for(int i=head1[x];i;i=e1[i].next){
            int y=e1[i].y;
            if(dis[y]>dis[x]+e1[i].to){
                dis[y]=dis[x]+e1[i].to;
                q.push(make_pair(-dis[y],y));
            }
        }
    }
}
inline void A_star(){
    if(dis[S]==dis[0]){puts("-1");return;}//不连通 
    if(S==T) K++;//路径必须有边吧。 
    mem(vis,0);
    q.push(make_pair(-dis[S],S));
    while(q.size()){
        int x=q.top().second,d=-q.top().first-dis[x];
        q.pop(); vis[x]++;
        if(vis[T]==K){printf("%d",d);return;}
        for(int i=head[x];i;i=e[i].next){
            int y=e[i].y;
            if(vis[y]!=K)q.push(make_pair(-d-e[i].to-dis[y],y));
//重要剪枝——因为默认为大根堆并且每次取最小值，所以必须插入相反数或重载运算符。 
        }
    }
    puts("-1"); 
}
signed main(){
    n=read(); m=read();
    for(int i=1;i<=m;i++){
        int x=read(),y=read(),z=read();
        add(x,y,z); add1(y,x,z);
    }
    S=read(); T=read(); K=read();
    dijkstra();//跑反图，求出优秀的估价函数
    A_star(); 
    return 0;
}   
Code3Code3
//给出同学的 SPFA + A*,喜欢用spfa的同学可以看一眼
const int N=100010;
int tot,tc,n,m,s,t,k,x,y,l;
int lin[N],linc[N],vis[N],f[N]; 
struct gg {
    int x,y,next,v;
}a[N],e[N];

struct node {
    int pos,f,dis;
    bool operator<(node a)const{
        return a.f+a.dis<f+dis;
    }
};

inline void add(int x,int y,int v) {
    a[++tot].y=y;
    a[tot].next=lin[x];
    a[tot].v=v;
    lin[x]=tot;
}

inline void add_c(int x,int y,int v) {
    e[++tc].y=y;
    e[tc].next=linc[x];
    e[tc].v=v;
    linc[x]=tc;
}

inline void spfa(int t) {
    queue<int> q;
    memset(f,0x3f,sizeof(f));
    memset(vis,0,sizeof(vis));
    q.push(t); f[t]=0; vis[t]=1;
    while(q.size()) {
        int x=q.front(); q.pop(); vis[x]=0;
        for(int i=lin[x];i;i=a[i].next) {
            int y=a[i].y;
            if(f[y]>f[x]+a[i].v) {
                f[y]=f[x]+a[i].v;
                if(!vis[y]) {
                    vis[y]=1;
                    q.push(y);
                }
            }
        }
    }
}

priority_queue<node>q;

inline int astar() {
    if(f[s]==0x3f) return -1; 
    int ts[N];
    memset(ts,0,sizeof(ts));
    node tmp,h;
    h.pos=s; h.f=0; h.dis=0;
    q.push(h);
    while(q.size()) {
        node x=q.top(); q.pop();
        ts[x.pos]++;
        if(ts[x.pos]==k&&x.pos==t) return x.dis;
        if(ts[x.pos]>k) continue;
        for(int i=linc[x.pos];i;i=e[i].next) {
            tmp.pos=e[i].y;
            tmp.f=f[e[i].y];
            tmp.dis=x.dis+e[i].v;
            q.push(tmp);
        }
    }
    return -1;
}

int main() {
    read(n); read(m);
    if(m==0) {cout<<"-1"<<endl; return 0;}
    for(int i=1;i<=m;i++) {
        read(x); read(y); read(l);
        add(y,x,l);
        add_c(x,y,l);
    }
    read(s); read(t); read(k); 
    if(s==t)++k;
    spfa(t);
    cout<<astar()<<endl;
    return 0;
}

作者：叶枫
链接：https://www.acwing.com/solution/content/4903/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;
typedef pair<int, PII> PIII;

const int N = 1010, M = 200010;

int n, m, S, T, K;
int h[N], rh[N], e[M], w[M], ne[M], idx;
int dist[N], cnt[N];
bool st[N];

void add(int h[], int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dijkstra()
{
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, T});

    memset(dist, 0x3f, sizeof dist);
    dist[T] = 0;

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.y;
        if (st[ver]) continue;
        st[ver] = true;

        for (int i = rh[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[ver] + w[i])
            {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j], j});
            }
        }
    }
}

int astar()
{
    priority_queue<PIII, vector<PIII>, greater<PIII>> heap;
    heap.push({dist[S], {0, S}});

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.y.y, distance = t.y.x;
        cnt[ver] ++ ;
        if (cnt[T] == K) return distance;

        for (int i = h[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if (cnt[j] < K)
                heap.push({distance + w[i] + dist[j], {distance + w[i], j}});
        }
    }

    return -1;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    memset(rh, -1, sizeof rh);

    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(h, a, b, c);
        add(rh, b, a, c);
    }
    scanf("%d%d%d", &S, &T, &K);
    if (S == T) K ++ ;

    dijkstra();
    printf("%d\n", astar());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/132735/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 179. 八数码    原题链接    中等
作者：    庶 ,  2019-08-28 23:16:55 ,  阅读 903

4


4
题目描述
在一个3×3的网格中，1~8这8个数字和一个“X”恰好不重不漏地分布在这3×3的网格中。
例如：
1 2 3
X 4 6
7 5 8
在游戏过程中，可以把“X”与其上、下、左、右四个方向之一的数字交换（如果存在）。
我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：
1 2 3
4 5 6
7 8 X
例如，示例中图形就可以通过让“X”先后与右、下、右三个方向的数字交换成功得到正确排列。
交换过程如下：
1 2 3 1 2 3 1 2 3 1 2 3
X 4 6 4 X 6 4 5 6 4 5 6
7 5 8 7 5 8 7 X 8 7 8 X
把“X”与上下左右方向数字交换的行动记录为“u”、“d”、“l”、“r”。
现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。
输入格式
输入占一行，将3×3的初始网格描绘出来。
例如，如果初始网格如下所示：
1 2 3
x 4 6
7 5 8
则输入为：1 2 3 x 4 6 7 5 8
输出格式
输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。
如果不存在解决方案，则输出”unsolvable”。

样例
输入样例：
2  3  4  1  5  x  7  6  8 
输出样例
ullddrurdllurdruldr
算法1
(bfs) O(不知道)O(不知道)
宽度优先搜索,搜索过程中存下每个字符串的夫串和移动方式,得到最终状态后根据夫串依此向前搜索,得到移动方式

C++ 代码
#include <iostream>
#include <algorithm>
#include <cstring>
#include <unordered_map>
#include <queue>
#include <vector>

using namespace std;

char d[5] = "drul";  //根据p[i]得到移动方式
int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
string ed = "12345678x";

unordered_map<string, int> p;
unordered_map<string, string> pp;

bool bfs(string s)
{
    queue<string> q;

    q.push(s);
    p[s] = 0;

    while (q.size())     //宽度优先搜索
    {
        string sh = q.front();
        q.pop();
        string h = sh;

        if (sh == ed) return true;

        int k = sh.find('x');
        int x = k / 3, y = k % 3;   //求出坐标
        for (int i = 0; i < 4; i ++ ) //可能的移动方式
        {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < 3 && b >= 0 && b < 3)
            {

                int t = a * 3 + b;
                swap(sh[k], sh[t]);
                if (!p.count(sh))
                {
                    p[sh] = i;   //存下移动方式
                    pp[sh] = h;  //存下夫串
                    q.push(sh);
                }
                swap(sh[t], sh[k]);
            }
        }
    }

    return false;
}

int main()
{
    string s, c;
    for (int i = 0; i < 9; i ++ ) cin >> c, s += c;

    if (bfs(s))
    {
        vector<char> arr;
        string t = ed;
        while(t != s)
        {
            arr.push_back(d[p[t]]);  //将移动方式存下   
            t = pp[t]; 
        }
        for (int i = arr.size() - 1; i >= 0; i -- )
        cout << arr[i];
        cout << endl;
    }
    else cout << "unsolvable" << endl;


    return 0;
}

作者：庶
链接：https://www.acwing.com/solution/content/4212/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


    #include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#include <unordered_map>

using namespace std;

int f(string state)
{
    int res = 0;
    for (int i = 0; i < state.size(); i ++ )
        if (state[i] != 'x')
        {
            int t = state[i] - '1';
            res += abs(i / 3 - t / 3) + abs(i % 3 - t % 3);
        }
    return res;
}

string bfs(string start)
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    char op[4] = {'u', 'r', 'd', 'l'};

    string end = "12345678x";
    unordered_map<string, int> dist;
    unordered_map<string, pair<string, char>> prev;
    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> heap;

    heap.push({f(start), start});
    dist[start] = 0;

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        string state = t.second;

        if (state == end) break;

        int step = dist[state];
        int x, y;
        for (int i = 0; i < state.size(); i ++ )
            if (state[i] == 'x')
            {
                x = i / 3, y = i % 3;
                break;
            }
        string source = state;
        for (int i = 0; i < 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < 3 && b >= 0 && b < 3)
            {
                swap(state[x * 3 + y], state[a * 3 + b]);
                if (!dist.count(state) || dist[state] > step + 1)
                {
                    dist[state] = step + 1;
                    prev[state] = {source, op[i]};
                    heap.push({dist[state] + f(state), state});
                }
                swap(state[x * 3 + y], state[a * 3 + b]);
            }
        }
    }

    string res;
    while (end != start)
    {
        res += prev[end].second;
        end = prev[end].first;
    }
    reverse(res.begin(), res.end());
    return res;
}

int main()
{
    string g, c, seq;
    while (cin >> c)
    {
        g += c;
        if (c != "x") seq += c;
    }

    int t = 0;
    for (int i = 0; i < seq.size(); i ++ )
        for (int j = i + 1; j < seq.size(); j ++ )
            if (seq[i] > seq[j])
                t ++ ;

    if (t % 2) puts("unsolvable");
    else cout << bfs(g) << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/132758/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1112. 迷宫    原题链接    简单
作者：    AJ小公主 ,  2019-11-28 17:03:32 ,  阅读 359

3


1
算法 DFS
遇到的问题

我在写DFS的时候
for(int i = 0; i < 4; i ++)
{
int a = x + dx[i], b = y + dy[i];
if(a < 0 || a >= n || b < 0 || b >= n)continue;
if(g[a][b] == ‘#’)continue;
if(st[a][b])continue;
if(dfs(a, b))return true;
//dfs(a, b); 我写的是这种形式，后来想了想这样写是不对的， 因为你这样的话就算后续已经找到了出口，但是不能传到第一次dfs的地方所以WA掉了。
}
return false;

C++ 代码
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

char g[N][N];
bool st[N][N];
int n;
int l1, r1, l2, r2;
int dx[] = {0, -1, 0, 1}, dy[] = {-1, 0, 1, 0};
bool dfs(int x, int y)
{
    if(x == l2 && y == r2)return true;
    st[x][y] = true;
    for(int i = 0; i < 4; i ++)
    {
        int a = x + dx[i], b = y + dy[i];
        if(a < 0 || a >= n || b < 0 || b >= n)continue;
        if(g[a][b] == '#')continue;
        if(st[a][b])continue;
        if(dfs(a, b))return true;
    }
    return false;
}

int main()
{
    int T;
    cin >> T;
    while(T --)
    {
        memset(st, false, sizeof st);
        cin >> n;
        for(int i = 0; i < n; i ++) cin >> g[i];
        cin >> l1 >> r1 >> l2 >> r2;
        if(g[l1][r1] == '#' || g[l2][r2] == '#')
        {
            puts("NO");
            continue;
        }
        if(dfs(l1, r1))puts("YES");
        else puts("NO");
    }
    return 0;
}

作者：AJ小公主
链接：https://www.acwing.com/solution/content/6616/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
char g[N][N];
int xa, ya, xb, yb;
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
bool st[N][N];

bool dfs(int x, int y)
{
    if (g[x][y] == '#') return false;
    if (x == xb && y == yb) return true;

    st[x][y] = true;

    for (int i = 0; i < 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a < 0 || a >= n || b < 0 || b >= n) continue;
        if (st[a][b]) continue;
        if (dfs(a, b)) return true;
    }

    return false;
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d", &n);
        for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);
        scanf("%d%d%d%d", &xa, &ya, &xb, &yb);

        memset(st, 0, sizeof st);
        if (dfs(xa, ya)) puts("YES");
        else puts("NO");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/134071/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 1113. 红与黑    原题链接    简单
作者：    Overnoise ,  2019-11-08 21:33:41 ,  阅读 1015

4


1
直接套用模板
请不要在意变量名和数组模拟队列

参考代码
#include<bits/stdc++.h>
using namespace std;
struct huawel{
    int x,y;
}a[999];
int m,n,book[99][99],ks,js,tx,ty;
int kx[4]={0,1,0,-1};
int ky[4]={1,0,-1,0};
char t;
int main()
{
    while(1)
    {
        ks=0;js=0;
        cin>>n>>m;
        if(m==0&&n==0)
        break;
        for(int i=1;i<=m;i++)
        {
            while(1)
            {
                t=cin.peek();
                if(t=='.'||t=='@'||t=='#')
                break;
                cin.get();
            }
            for(int j=1;j<=n;j++)
            {
                t=getchar();
                if(t=='.')
                book[i][j]=0;
                else
                book[i][j]=1;
                if(t=='@')
                {
                    a[ks].x=i;
                    a[ks].y=j;
                    ks++;
                }
            }
        }
        while(ks>js)
        {
            for(int i=0;i<4;i++)
            {
                tx=a[js].x+kx[i];
                ty=a[js].y+ky[i];
                if(tx<=m&&ty<=n&&tx>0&&ty>0&&book[tx][ty]==0)
                {
                    book[tx][ty]=1;
                    a[ks].x=tx;
                    a[ks].y=ty;
                    ks++;
                }
            }
            js++;
        }
        cout<<js<<endl;
    }
    return 0;
}

作者：Overnoise
链接：https://www.acwing.com/solution/content/6031/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


include <iostream>
#include <algorithm>

using namespace std;

const int N = 25;

int n, m;
char g[N][N];
bool st[N][N];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

int dfs(int x, int y)
{
    int cnt = 1;

    st[x][y] = true;
    for (int i = 0; i < 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a < 0 || a >= n || b < 0 || b >= m) continue;
        if (g[a][b] != '.') continue;
        if (st[a][b]) continue;

        cnt += dfs(a, b);
    }

    return cnt;
}

int main()
{
    while (cin >> m >> n, n || m)
    {
        for (int i = 0; i < n; i ++ ) cin >> g[i];

        int x, y;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < m; j ++ )
                if (g[i][j] == '@')
                {
                    x = i;
                    y = j;
                }

        memset(st, 0, sizeof st);
        cout << dfs(x, y) << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/134130/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>

using namespace std;

const int N=25;
const int dx[4]={1,0,-1,0};
const int dy[4]={0,1,0,-1};

int n,m;
int sx,sy;
bool g[N][N];

int dfs(int x,int y)
{
    int sum=1;
    g[x][y]=false;
    for(int i=0;i<4;i++)
    {
        int nx=x+dx[i],ny=y+dy[i];
        if(g[nx][ny])sum+=dfs(nx,ny);
    }
    return sum;
}

int main()
{
    while(scanf("%d %d\n",&m,&n),n&&m)
    {
        for(int i=1;i<=n;i++,getchar())
            for(int j=1;j<=m;j++)
            {
                char ch=getchar();
                if(ch=='@')sx=i,sy=j;
                g[i][j]=ch=='.';
            }
        printf("%d\n",dfs(sx,sy));
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/306291/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#pragma GCC optimize(2)//吸口氧气
#pragma GCC optimize(3)//吸口臭氧
#include<bits/stdc++.h>
using namespace std;
int m,n,qdx,qdy,tx,ty,t;
int kx[8]={1,1,2,2,-2,-2,-1,-1};
int ky[8]={2,-2,1,-1,1,-1,2,-2};
int book[105][105],ans,mix[99],miy[99];
void vivo(int x,int y,int all)
{
    if(all==0)
    {
        ans++;
        return;
    }
    for(int i=0;i<8;i++)
    {
        tx=x+kx[i];
        ty=y+ky[i];
        if(tx>=0&&ty>=0&&tx<m&&ty<n&&book[tx][ty]==0)
        {
            book[tx][ty]=1;
            mix[all]=tx;
            miy[all]=ty;
            vivo(tx,ty,all-1);
            tx=x+kx[i];
            ty=y+ky[i];
            book[tx][ty]=0;
        }
    }
}
int main()
{
    cin>>t;
    while(t--)
    {
        cin>>m>>n>>qdx>>qdy;
        book[qdx][qdy]=1;
        vivo(qdx,qdy,m*n-1);
        book[qdx][qdy]=0;
        cout<<ans<<endl;
        ans=0;
    }
    return 0;
}

作者：Overnoise
链接：https://www.acwing.com/solution/content/6010/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10;

int n, m;
bool st[N][N];
int ans;
int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2};
int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};

void dfs(int x, int y, int cnt)
{
    if (cnt == n * m)
    {
        ans ++ ;
        return;
    }
    st[x][y] = true;

    for (int i = 0; i < 8; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a < 0 || a >= n || b < 0 || b >= m) continue;
        if (st[a][b]) continue;
        dfs(a, b, cnt + 1);
    }

    st[x][y] = false;
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        int x, y;
        scanf("%d%d%d%d", &n, &m, &x, &y);

        memset(st, 0, sizeof st);
        ans = 0;
        dfs(x, y, 1);

        printf("%d\n", ans);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/134135/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1117. 单词接龙    原题链接    简单
作者：    叁秋. ,  2019-11-09 15:40:52 ,  阅读 471

5


用的substr.
首先，我们的知道substr的一种用法，比较多的都是两个参数，但其实，一个参数也可以。 如下：

我们在此处用的就是第1种方法。
其余的注释很详细了吧…应该:

#include<bits/stdc++.h>
using namespace std;
int maxlen=0;
int newlen=0;
int n;
string str[22];
int ok[22];
int pipei(string &str1,string &str2) {
    if(str1.length()==1) {
        if(str2[0]==str1[0])
            return str2.length();
        return 0;
    } else {
        for(int i=1; i<str1.length(); i++) {
            string temp1=str1.substr(str1.length()-i);
            string temp2=str2.substr(0,i);
            if(temp1==temp2)
                return str2.length()-i;
        }
    }
    return 0;
}
void dfs(string &s) {
    for(int i=0; i<n; i++) {
        int temp=pipei(s,str[i]);
        if(temp && ok[i]<2) {
            ok[i]++;
            newlen+=temp;
            if(newlen>maxlen) maxlen=newlen;
            dfs(str[i]);
            ok[i]--;
            newlen-=temp;
        }
    }
}
int main() {
    cin>>n;
    for(int i=0; i<n; i++)
        cin>>str[i];
    string cr;
    cin>>cr;
    dfs(cr);
    cout<<maxlen<<endl;
    return 0;
}

作者：叁秋.
链接：https://www.acwing.com/solution/content/6069/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 21;

int n;
string word[N];
int g[N][N];
int used[N];
int ans;

void dfs(string dragon, int last)
{
    ans = max((int)dragon.size(), ans);

    used[last] ++ ;

    for (int i = 0; i < n; i ++ )
        if (g[last][i] && used[i] < 2)
            dfs(dragon + word[i].substr(g[last][i]), i);

    used[last] -- ;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> word[i];
    char start;
    cin >> start;

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
        {
            string a = word[i], b = word[j];
            for (int k = 1; k < min(a.size(), b.size()); k ++ )
                if (a.substr(a.size() - k, k) == b.substr(0, k))
                {
                    g[i][j] = k;
                    break;
                }
        }

    for (int i = 0; i < n; i ++ )
        if (word[i][0] == start)
            dfs(word[i], i);

    cout << ans << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/134145/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1118. 分成互质组    原题链接    简单
作者：    orzorz ,  2020-03-23 21:14:05 ,  阅读 485

10


1
枚举每一组可以放哪些元素。

代码及巨无霸详解注释
#include<iostream>
#include<cstring>
using namespace std;

const int N = 10;
int n;
int a[N];//n个整数
int ans = N;//由于是求最小值，这里初始化为最大值

int g[N][N];//分组
int st[N];

int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}

bool check(int g[],int x,int start){
    for(int i=0;i<start;i++){
        if(gcd(g[i],x)>1) return false;
    }
    return true;
}

//当前要放在哪个分组；要放在该分组的第几个位置；从哪个位置开始选择元素【组合套路(定一个遍历顺序)】；当前已分组完毕的元素个数
void dfs(int gr,int gc,int start,int cnt){
    if(gr>=ans) return;//剪枝 + 防止死循环
    if(cnt==n) ans=gr;

    bool flag=true;//从start开始找，是否有元素不能放到gr组中

    for(int i=start;i<n;i++){
        if(!st[i]&&check(g[gr],a[i],gc)){
            st[i]=true;
            g[gr][gc]=a[i];
            dfs(gr,gc+1,i+1,cnt+1);
            st[i]=false;
            flag=false;            
        }
    }
    //新开一个分组

    //由于dfs每层之间确定了顺序，所以期间是会有元素被漏掉的，【比如一开始你找的一串序列(1)是1,2,3,4 但是第二次(2)是1,3,4 很显然此时
    //(2)还有一个3没有得到分组，需要从start=0开始再把它找出来！  因此这样做仿佛有点浪费时间呢！！】

    //因此当所有元素都不能放进当前分组的时候 或者 当start=n-1了但是元素没有全部分组完毕时，要重新从start=0开始找，并且一定要有st数组！！！不然会把一个元素重复的分组！
    if(flag) dfs(gr+1,0,0,cnt);

}

int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];

    //为什么一开始gr从1开始但是分组只开了10个呢？
    //首先这样的话可以直接通过gr就得到当前分了多少组；其次由于ans初始化即为10，因此当打算开第10个分组时，会被弹回，数组不会越界
    dfs(1,0,0,0);


    cout<<ans;

    return 0;
}
枚举每个元素可以放在哪一组

代码及注释
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

const int N=10;
int a[N];
vector<int> g[N];
int n;
int ans=10;
int len=0;

int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}

bool check(int c,int x){
    for(int i=0;i<g[c].size();i++){
        if(gcd(g[c][i],x)>1) return false;
    }
    return true;
}

void dfs(int u){
    if(u==n){
        ans=min(ans,len);
        return;
    }

    //每个元素的方法即——放到当前已经存在的组中  或者  放到新开的组中

    for(int i=0;i<len;i++){
        if(check(i,a[u])){
            g[i].push_back(a[u]);
            dfs(u+1);
            g[i].pop_back();
        }
    }
   //可见这里的len代表着的是当前开辟数组的个数
    g[len++].push_back(a[u]);
    dfs(u+1);
    g[--len].pop_back();
}

int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];

    dfs(0);

    cout<<ans;
    return 0;
}
对于以上的两种搜索的顺序其实可以想象一下这样的一种情景。即你有n个篮子你要用它们去装水果，每个篮子只能装对应种类的水果。
那么第一种方法就相当于是，你把水果任意的排成一排，然后拿着一个篮子从第一个水果开始一个个的往后看，看看能能放到你的这个篮子中。
对于第二种方法相当于是，你把篮子放一排，你拿着水果，然后一个个的往下看，看看能不能放在篮子里

作者：orzorz
链接：https://www.acwing.com/solution/content/10364/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

按顺序考虑每一个数，考虑把他放在哪个组里面。
40ms40ms
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;
const int N = 10;
int gcd(int x, int y) {
    return y ? gcd(y, x % y) : x;
}
int n, a[N], ans = N, len;
vector<int> g[N];
bool inline check(int u, int c) {
    for (int i = 0; i < g[c].size(); i++)
        if(gcd(g[c][i], u) > 1) return false;
    return true;
}
void dfs(int u) {
    if(u == n) {
        ans = min(ans, len);
        return;
    }
    for(int i = 0; i < len; i++) {
        if(check(a[u], i)) {
            g[i].push_back(a[u]);
            dfs(u + 1);
            g[i].pop_back();
        }
    }
    g[len++].push_back(a[u]);
    dfs(u + 1);
    g[--len].pop_back();
}
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", a + i);
    dfs(0);
    printf("%d\n", ans);


作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/137029/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10;

int n;
int p[N];
int group[N][N];
bool st[N];
int ans = N;

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

bool check(int group[], int gc, int i)
{
    for (int j = 0; j < gc; j ++ )
        if (gcd(p[group[j]], p[i]) > 1)
            return false;
    return true;
}

void dfs(int g, int gc, int tc, int start)
{
    if (g >= ans) return;
    if (tc == n) ans = g;

    bool flag = true;
    for (int i = start; i < n; i ++ )
        if (!st[i] && check(group[g], gc, i))
        {
            st[i] = true;
            group[g][gc] = i;
            dfs(g, gc + 1, tc + 1, i + 1);
            st[i] = false;

            flag = false;
        }

    if (flag) dfs(g + 1, 0, tc, 0);
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> p[i];

    dfs(1, 0, 0, 0);

    cout << ans << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/134221/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 165. 小猫爬山    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-03 18:34:00 ,  阅读 1891

15


3
题目描述
翰翰和达达饲养了N只小猫，这天，小猫们要去爬山。

经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕>_<）。

翰翰和达达只好花钱让它们坐索道下山。

索道上的缆车最大承重量为W，而N只小猫的重量分别是C1、C2……CNC1、C2……CN。

当然，每辆缆车上的小猫的重量之和不能超过W。

每租用一辆缆车，翰翰和达达就要付1美元，所以他们想知道，最少需要付多少美元才能把这N只小猫都运送下山？

输入格式
第1行：包含两个用空格隔开的整数，N和W。

第2..N+1行：每行一个整数，其中第i+1行的整数表示第i只小猫的重量Ci。

输出格式
输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。

数据范围
1≤N≤181≤N≤18
1≤Ci≤W≤1081≤Ci≤W≤108
样例
输入样例：
5 1996
1
2
1994
12
29
输出样例：
2
搜索
这道题目我们肯定是搜索了,我们发现这道题目有两个可以剪枝的部分,一个是如果当前的答案已经大于了我们已知的最小答案,不用说直接return返回即可.第二个剪枝则是,我们可以将小猫的体重从大到小排序,这样我们的搜索树就会缩短许多,至于为什么,因为我们的剩余空间就变小了,然后可选择的猫也就少了.
C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N=20;
long long ans=1e7,a[N],p[N];
int n,m;
int cmp(long long a,long long b)
{
    return a>b;
}
void dfs(long long x,long long cnt)
{
    if (cnt>=ans)//剪枝1
        return ;
    if (x==n+1)
    {
        ans=min(ans,cnt);
        return ;
    }
    for(int i=1;i<=cnt;i++)//枚举当前每一辆新车
        if (p[i]+a[x]<=m)//如果这辆车装得下这只小猫的话
        {
            p[i]+=a[x];
            dfs(x+1,cnt);
            p[i]-=a[x];
        }
    p[cnt+1]=a[x];//开新车
    dfs(x+1,cnt+1);
    p[cnt+1]=0;//回溯
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    sort(a+1,a+1+n,cmp);//小猫体重排序
    dfs(1,0);
    cout<<ans;
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/951/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


include <iostream>
#include <algorithm>

using namespace std;

const int N = 20;

int n, m;
int w[N];
int sum[N];
int ans = N;

void dfs(int u, int k)
{
    // 最优性剪枝
    if (k >= ans) return;
    if (u == n)
    {
        ans = k;
        return;
    }

    for (int i = 0; i < k; i ++ )
        if (sum[i] + w[u] <= m) // 可行性剪枝
        {
            sum[i] += w[u];
            dfs(u + 1, k);
            sum[i] -= w[u]; // 恢复现场
        }

    // 新开一辆车
    sum[k] = w[u];
    dfs(u + 1, k + 1);
    sum[k] = 0; // 恢复现场
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ ) cin >> w[i];

    // 优化搜索顺序
    sort(w, w + n);
    reverse(w, w + n);

    dfs(0, 0);

    cout << ans << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/136433/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 166. 数独    原题链接    中等
作者：    秦淮岸灯火阑珊 ,  2019-02-04 15:42:48 ,  阅读 2324

22


7
题目描述
数独是一种传统益智游戏，你需要把一个9 × 9的数独补充完整，使得图中每行、每列、每个3 × 3的九宫格内数字1~9均恰好出现一次。

请编写一个程序填写数独。



输入格式
输入包含多组测试用例。

每个测试用例占一行，包含81个字符，代表数独的81个格内数据（顺序总体由上到下，同行由左到右）。

每个字符都是一个数字（1-9）或一个”.”（表示尚未填充）。

您可以假设输入中的每个谜题都只有一个解决方案。

文件结尾处为包含单词“end”的单行，表示输入结束。

输出格式
每个测试用例，输出一行数据，代表填充完全后的数独。

样例
输入样例：
.2738..1..1...6735.......293.5692.8...........6.1745.364.......9518...7..8..6534.
......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.
end
输出样例：
527389416819426735436751829375692184194538267268174593643217958951843672782965341
416837529982465371735129468571298643293746185864351297647913852359682714128574936

搜索+剪枝(位运算,排除等效冗余,优化搜索顺序)
搜索不用说,相信你一眼就可以看到是搜索算法,问题是这道题目纯搜索明显是要时间爆炸的,所以我们得剪枝.
优化搜索顺序:很明显,我们肯定是从当前能填合法数字最少的位置开始填数字
排除等效冗余:任意一个状态下,我们只需要找一个位置填数即可,而不是找所有的位置和可填的数字.
位运算:很明显这里面check判定很多,我们必须优化这个check,所以我们可以对于,每一行,每一列,每一个九宫格,都利用一个九位二进制数保存,当前还有哪些数字可以填写.
lowbit:我们这道题目当前得需要用lowbit运算取出当前可以能填的数字.
C++ 代码
#include <bits/stdc++.h>
using namespace std;
#define fir(i,a,b) for(int i=a;i<=b;i++)
char str[10][10];
int r[9],c[9],g[9],cnt[512],num[512],tot;
inline int gc(int x, int y)//将二维数组变成一维数组
{
    return ((x/3)*3)+(y/3);
}
inline void pd(int x, int y, int z)//位运算,修改当前位数z,第z位1变为0,0变为1.
{
    r[x]^=1<<z;//横坐标
    c[y]^=1<<z;//纵坐标
    g[gc(x,y)]^=1<<z;//九宫格
}
inline int lowbit(int x)//得到当前可以选择的合法数值.
{
    return x&(-x);
}
inline bool dfs(int now)
{
    if (now==0)
        return 1;
    int temp=10,x,y;
    fir(i,0,8)
    fir(j,0,8)
    {
        if (str[i][j]!='.')
            continue;
        int val=r[i] & c[j] & g[gc(i,j)];//判断这一位是否合法,1为合法,0为不合法
        if (!val)
            return 0;
        if (cnt[val]<temp)//找到当前能填合法数字最小的位置
        {
            temp=cnt[val];
            x=i,y=j;
        }
    }
    int val=r[x] & c[y] & g[gc(x, y)];
    for (; val; val-=lowbit(val))
    {
        int z=num[lowbit(val)];
        str[x][y]='1'+z;
        pd(x,y,z);
        if (dfs(now-1))//下一位
            return 1;
        pd(x,y,z);//回溯
        str[x][y]='.';
    }
    return 0;
}
int main()
{
//  freopen("stdin.in","r",stdin);
    for (int i=0; i<1<<9; i++)
        for (int j=i; j; j-=lowbit(j))
            cnt[i]++;
    fir(i,0,8)
    num[1<<i]=i;
    char s[100];
    while (~scanf("%s",s) && s[0]!='e')
    {
        fir(i,0,8)
        fir(j,0,8)
        str[i][j]=s[i*9+j];
        fir(i,0,8)
        r[i]=c[i]=g[i]=(1<<9)-1;//初始的是否都是合法的
        tot=0;
        fir(i,0,8)
        fir(j,0,8)
        if (str[i][j]!='.')
            pd(i,j,str[i][j]-'1');//这一位已经选择
        else
            tot++;//统计需要修改的个数
//      cout<<tot<<endl;
        dfs(tot);
        fir(i,0,8)
        fir(j,0,8)
        s[i*9+j]=str[i][j];//答案输出
        puts(s);
    }
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/956/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 9, M = 1 << N;

int ones[M], map[M];
int row[N], col[N], cell[3][3];
char str[100];

void init()
{
    for (int i = 0; i < N; i ++ )
        row[i] = col[i] = (1 << N) - 1;

    for (int i = 0; i < 3; i ++ )
        for (int j = 0; j < 3; j ++ )
            cell[i][j] = (1 << N) - 1;
}

void draw(int x, int y, int t, bool is_set)
{
    if (is_set) str[x * N + y] = '1' + t;
    else str[x * N + y] = '.';

    int v = 1 << t;
    if (!is_set) v = -v;

    row[x] -= v;
    col[y] -= v;
    cell[x / 3][y / 3] -= v;
}

int lowbit(int x)
{
    return x & -x;
}

int get(int x, int y)
{
    return row[x] & col[y] & cell[x / 3][y / 3];
}

bool dfs(int cnt)
{
    if (!cnt) return true;

    int minv = 10;
    int x, y;
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            if (str[i * N + j] == '.')
            {
                int state = get(i, j);
                if (ones[state] < minv)
                {
                    minv = ones[state];
                    x = i, y = j;
                }
            }

    int state = get(x, y);
    for (int i = state; i; i -= lowbit(i))
    {
        int t = map[lowbit(i)];
        draw(x, y, t, true);
        if (dfs(cnt - 1)) return true;
        draw(x, y, t, false);
    }

    return false;
}

int main()
{
    for (int i = 0; i < N; i ++ ) map[1 << i] = i;
    for (int i = 0; i < 1 << N; i ++ )
        for (int j = 0; j < N; j ++ )
            ones[i] += i >> j & 1;

    while (cin >> str, str[0] != 'e')
    {
        init();

        int cnt = 0;
        for (int i = 0, k = 0; i < N; i ++ )
            for (int j = 0; j < N; j ++, k ++ )
                if (str[k] != '.')
                {
                    int t = str[k] - '1';
                    draw(i, j, t, true);
                }
                else cnt ++ ;

        dfs(cnt);

        puts(str);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/136449/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

const int N=9;
const int M=512;

int ones[M],map[M];
int row[N],col[N],cell[3][3];
char str[100];

inline int lowbit(int x)
{
    return x&-x;
}

inline int get(int x,int y)
{
    return row[x]&col[y]&cell[x/3][y/3];
}

inline int getones(int x)
{
    int sum=0;
    for(;x;x-=lowbit(x))
        sum++;
    return sum;
}

inline void draw(int x,int y,int t,bool isset)
{
    if(isset)str[x*9+y]=t+49;
    else    str[x*9+y]='.';
    int v=1<<t;
    if(isset)v=-v;
    row[x]+=v;
    col[y]+=v;
    cell[x/3][y/3]+=v;
}

bool dfs(int cnt)
{
    if(!cnt)return true;
    int x,y,minv=10;
    for(int i=0;i<9;i++)
        for(int j=0;j<9;j++)
            if(str[i*9+j]=='.')
            {
                int state=get(i,j);
                if(ones[state]<minv)
                {
                    minv=ones[state];
                    x=i,y=j;
                }
            }
    int state=get(x,y);
    for(int i=state;i;i-=lowbit(i))
    {
        int t=map[lowbit(i)];
        draw(x,y,t,true);
        if(dfs(cnt-1))return true;
        draw(x,y,t,false);
    }
    return false;
}

int main()
{
    for(int i=0;i<9;i++)
        map[1<<i]=i;
    for(int i=0;i<512;i++)
        ones[i]=getones(i);
    while(cin>>str,str[0]^'e')
    {
        for(int i=0;i<9;i++)
            row[i]=M-1;
        for(int i=0;i<9;i++)
            col[i]=M-1;
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                cell[i][j]=M-1;
        int cnt=0;
        for(int i=0,k=0;i<9;i++)
            for(int j=0;j<9;j++,k++)
                if(str[k]^'.')
                    draw(i,j,str[k]-49,true);
                else cnt++;
        dfs(cnt);
        puts(str);
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/307225/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 167. 木棒    原题链接    中等
作者：    秦淮岸灯火阑珊 ,  2019-02-04 15:55:48 ,  阅读 1637

19


4
此题请注意:如果你发现你的算法无比的优秀,没有任何错误,但是死活就是不能对,WA的一次又一次,那么温馨提示您:请自动忽略大于50的数据,没错这就是一个数据出题人的锅.而且还就是不说出来.
题目描述
乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。

然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。

请你设计一个程序，帮助乔治计算木棒的可能最小长度。

每一节木棍的长度都用大于零的整数表示。

输入格式
输入包含多组数据，每组数据包括两行。

第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。

第二行是截断以后，所得到的各节木棍的长度。

在最后一组数据之后，是一个零。

输出格式
为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。

样例
输入样例：
9
5 2 1 5 2 1 5 2 1
4
1 2 3 4
0
输出样例：
6
5
搜索+剪枝
下面为剪枝细目表
优化搜索序列:优先选择较长的木棍
排除等效冗余:要求先后加入的木棍有单调性,因为先来一根长度为x的木棍,再来一个长度为y的木棍,其实他们反过来是一样的,既然如此当然要有单调性.
排除等效冗余:对于当前木棍,记录最近一次尝试拼接失败的木棍,因为它失败了,那么肯定之后不能尝试再次凭借和他长度一模一样的木棍.因为他们是一模一样,没有任何差别,那么A死了,后面的A自然也得死,虽然他们下标不一样.
排除等效冗余:如果第一次尝试拼入木棍就失败的话,那么这个分治必然也是失败的,因为在拼入这些木棍前,面对的原始木棍都是还没有拼接的,他们都是等效的.
C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N=100;
int a[N],n,m,max_val,sum,i,len,cnt,vis[N],true_n;
int cmp(int a,int b)//从大到小排序
{
    return a>b;
}
int dfs(int cnm,int cab,int last)//cnm为当前第几段了,cab记录当前段的长度,last为上一次已经选过的值
{
    if (cnm>cnt)//满足条件了
        return true;
    if (cab==len)//如果发现这一段已经用完了,下一段接着来.
        return dfs(cnm+1,0,1);
    int fail=0;//记录上一次失败的值,如果这次还是的话,那么肯定是不能选择的
    for(int i=last;i<=true_n;i++)
        if (!vis[i] && a[i]!=fail && cab+a[i]<=len)//没有被访问,不是上一次失败的值,长度满足在len以内
        {
            vis[i]=1;
            if (dfs(cnm,cab+a[i],i+1))//开始下一次dfs
                return true;
            fail=a[i];//失败了,当然要记录了
            vis[i]=0;//这个数没有选择
            if (cab==0 || cab+a[i]==len)//如果cab为0,或者相加正好是len,但是失败了,那么一定是失败了.
                return false;
        }
    return false;//所有的都失败了,那么肯定是失败的.
}
int main()
{
    ios::sync_with_stdio(false);
    while(cin>>n && n)
    {
        int x;
        max_val=0,sum=0;true_n=0;
        for(i=1;i<=n;i++)
        {
            cin>>x;
            if (x>50)//自动忽略掉
                continue;
            true_n++;//这才是真正的n QAQ
            a[true_n]=x;
            max_val=max(max_val,a[true_n]);
            sum+=a[true_n];
        }
        sort(a+1,a+1+true_n,cmp);//排序优化搜索顺序
        for(len=max_val;len<=sum;len++)//优化
        {
            if (sum%len)//如果除不尽,肯定不满足题意
                continue;
            cnt=sum/len;//计算出cnt多少段
            memset(vis,0,sizeof(vis));//初始化
            if (dfs(1,0,1))//搜索成功,最小值就是它
                break;
        }
        cout<<len<<endl;
    }
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/957/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 70;

int n;
int w[N];
int sum, length;
bool st[N];

bool dfs(int u, int cur, int start)
{
    if (u * length == sum) return true;
    if (cur == length) return dfs(u + 1, 0, 0);

    for (int i = start; i < n; i ++ )
    {
        if (st[i] || cur + w[i] > length) continue;

        st[i] = true;
        if (dfs(u, cur + w[i], i + 1)) return true;
        st[i] = false;

        if (!cur || cur + w[i] == length) return false;

        int j = i;
        while (j < n && w[j] == w[i]) j ++ ;
        i = j - 1;
    }

    return false;
}

int main()
{
    while (cin >> n, n)
    {
        memset(st, 0, sizeof st);
        sum = 0;

        for (int i = 0; i < n; i ++ )
        {
            cin >> w[i];
            sum += w[i];
        }

        sort(w, w + n);
        reverse(w, w + n);

        length = 1;
        while (true)
        {
            if (sum % length == 0 && dfs(0, 0, 0))
            {
                cout << length << endl;
                break;
            }
            length ++ ;
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/136462/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
#include <algorithm>
#include <cstdio>
#include <cstring>

using namespace std;

const int N=66;

int n;
int sum;
int length;
int w[N];
bool state[N];

inline void swapw(int i,int j)
{
    if(i^j)w[i]^=w[j],w[j]^=w[i],w[i]^=w[j];
}

bool dfs(int u,int s,int start)
{
    if(u*length==sum)return true;
    if(s==length)return dfs(u+1,0,0);
    for(int i=start;i<n;i++)
        if(!state[i]&&s+w[i]<=length)
        {
            state[i]=true;
            if(dfs(u,s+w[i],i+1))
                return true;
            state[i]=false;
            if(!s||s+w[i]==length)return false;
            while(i<n&&w[i]==w[i+1])
                i++;
        }
    return false;
}

int main()
{
    while(cin>>n,n)
    {
        sum=0;
        memset(state,false,sizeof state);
        for(int i=0;i<n;i++)
        {
            cin>>w[i];
            sum+=w[i];
        }
        sort(w,w+n);
        for(int i=0,j=n-1;i<j;i++,j--)
            swapw(i,j);
        for(length=1;;length++)
            if(sum%length==0&&dfs(0,0,0))
            {
                printf("%d\n",length);
                break;
            }
    }
    return 0;


作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/307246/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 168. 生日蛋糕    原题链接    中等
作者：    melody ,  2019-08-27 09:26:26 ,  阅读 766

13


3
本人的原文章出处： https://blog.csdn.net/qq_43093454/article/details/100055362

题面
题目背景
7月17日是Mr.W的生日，ACM-THU为此要制作一个体积为Nπ的M层
生日蛋糕，每层都是一个圆柱体。
设从下往上数第i(1<=i<=M)层蛋糕是半径为Ri, 高度为Hi的圆柱。当i< M时，要求 RiRi > Ri+1Ri+1 且 HiHi>Hi+1Hi+1。
由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积Q最小。
令Q= Sπ
请编程对给出的N和M，找出蛋糕的制作方案（适当的Ri和Hi的值），使S最小。
（除Q外，以上所有数据皆为正整数）
输入输出格式
输入格式
有两行，第一行为N（N<=20000），表示待制作的蛋糕的体积为Nπ；第二行为M(M<=15)，表示蛋糕的层数为M。
输出格式
仅一行，是一个正整数S（若无解则S=0）。
输入输出样例
输入样例 #1
100
2
输出样例 #1
68

理清题面
给出的条件是体积为n，层数是m层；
之后要求的是使得最小的表面积Q=sπ的最小的s的值；
程序需要做的事情是依次的确定每一层的半径R和高度H；
蛋糕的面积包括的是所有层的裸露的部分的面积（这个面积等价于最后一层的下表面积）和所有的侧面积；
所有层的裸露的部分的面积可以在m层的时候就直接加上。
从零分到达ac的心路历程
一开始的时候，就是完全没有思路，更像是没有这道题的方向，这道题应该要往哪方面入手，我不知道，我也没有想出来。

之后我看见了题目中有若s无解则s等于0，所以我直接输出了0。但是0分，脑子一想，发现自己真的没谁了，怎么可能会有无解的情况，只要n，m给定了，基本上整个蛋糕的雏形就已经出现了，那么就肯定会是有解的啊！！所以绝对不可能会有s=0的情况。

之后，我就又磨了将近一天，发现不会，这什么玩意题啊，根本套不上我写的任何模板。。。

再之后，我就翻看了题解，噢~ 原来是dfs。。。看到是dfs之后，我就又开始自己想思路，毕竟我自己认为dfs什么的没有什么难度，之后就瞬间打脸，我连dfs从哪里下手都不知道，我真服了我自己了，估计又是自己自诩清高，没有真正地了解过什么才是dfs。

再之后，我就打开了我亲爱的蓝皮书，一字一字的翻看，结果还是看不懂，我就开始颓了，在海亮的时候就已经开始要着手打这道题的代码，但是这种状态一直持续到今天上午，我才敲完这道题，还是在磨着题解的情况下，我才敲完了这一道题。。

所以说，骚年，要“开始”学习dfs了。

分享一波我给蓝皮书的正解代码打的注释：

//Author:XuHt
#include <cmath> 
#include <iostream>
#include <algorithm>
using namespace std;
const int INF = 0x7fffffff;
int n, m;/*n，m是给定的体积以及层数*/
int minv[30], mins[30], ans = INF;
int h[30], r[30], s = 0, v = 0;

void dfs(int dep) {
    if (!dep) {/*还在搜索的过程中*/
        if (v == n) ans = min(ans, s);/*体积已经全部用完了,此时的不合法的状态下的面积一定比合法的面积小*/
        return;
    }
/*sqrt(n - v):数学公式可以把半径进一步的缩小；
而r[dep + 1] - 1是因为当前dep层一定是比dep+1层小的,最少小一,这样子的话下面一层就会有更多的选择,h同r;
r[dep] >= dep是因为如果r小于dep的话,那么之后的层数一定不够m层,所以该结果不合法*/
    for (r[dep] = min((int)sqrt(n - v), r[dep + 1] - 1); r[dep] >= dep; r[dep]--)/*确定半径*/
        for (h[dep] = min((int)((double)(n-v) / r[dep] / r[dep]), h[dep+1] - 1); h[dep] >= dep; h[dep]--) 
        {
            if (v + minv[dep-1] > n) continue;
            if (s + mins[dep-1] > ans) continue;
            if (s + (double)2 * (n - v) / r[dep] > ans) continue;/*鬼畜剪枝*/
            /*用剩余体积估计之后的比实际要小的需要用到的表面积+s判断当前状态是否可行*/
            if (dep == m) s += r[dep] * r[dep];/*所有层的裸露的部分的面积*/
            s += 2 * r[dep] * h[dep];/*s=2rπh*/
            v += r[dep] * r[dep] * h[dep];/*v=r*r*πh*/
            dfs(dep - 1); 
            if (dep == m) s -= r[dep] * r[dep];/*回溯的现场还原*/
            s -= 2 * r[dep] * h[dep];
            v -= r[dep] * r[dep] * h[dep];
        }
}

int main() {
    cin >> n >> m;
    minv[0] = mins[0] = 0;/*初始化处理从上到下的每一层之前的最小的体积以及侧面积*/
    for (int i = 1; i <= m; i++) {
        minv[i] = minv[i-1] + i * i * i;/*有要求每一层的半径和高度都应该是逐个递增的*/
        mins[i] = mins[i-1] + i * i;
    }
    h[m+1] = r[m+1] = INF;/*因为一共只需要m层,在搜索的for循环中有体现*/
    dfs(m);/*搜索的顺序是从最大的一层到最小的一层*/
    cout << ans << endl;
    return 0;
}
心路完了。

思路
思路呢，还是要好好想想的，下回在更。（已补更）

由于深度一定(m),所以使用深度优先搜索；
就像是上面的题面理解上说的那样，程序要做的就是一个个试试，判断自己此时的半径和高度是否合法；
但是思考一下即使m只有15，若是把所有的情况（所有的半径和高都找出来并且达到相互匹配的地步）一一都列举出来的话，也还是会超时，所以要考虑所有的可行的剪枝；
考虑剪枝：
搜索顺序上的剪枝：从体积大的盘子搜到体积小的盘子。（这样的话若是方案不合法在一个大的的时候就可以直接扔掉不要，但是如果是小的的话，可能就要试很多个。）
可行性剪枝1：当 当前的体积+之后预测到的自己认为的最优的体积>n 的时候就可以直接舍弃这一个不合法的方案。（当前的加上最优的都已经是不合法的了，还能怎么办？）
可行性剪枝2：上下界剪枝。根据多年的数学学习把半径和高度的冗余的状态全部都丢掉不要。（数学公式回来再补充）
最优性剪枝1：在dfs的过程中可能会有很多次搜索到不合法的方案，若是不合法的方案用到的面积刚好等于n的时候（也就是说给定的面积全部都用完了），那么最优解的ans一定小于此时的答案，这个时候在ban掉这个方案之前可以对答案进行进一步的更新；
最优性剪枝2: 若 当前的面积+之后预测到的自己认为的最优的面积>ans 的时候就可以直接舍弃这一个不优秀的方案，因为他没有答案小。
还有一个鬼畜剪枝，如上一份代码中的标注。（回来再更）
之后就要考虑上面挖的坑了：

如何找到自己认为的最优的体积/面积？

思考一下，若此时已经给了蛋糕的轮廓，那么在不考虑体积的情况下，怎么样才会最优？

使得当前的蛋糕最小；
使得上下层之间的蛋糕的差距最小（最好是只相差1）
那么根据上面的两点我们就可以做出预处理，我们把最小的一层的半径和高度都定做1，之后的每一层依次加一，这样的话就是最优秀的/最小的了。

为什么这样子可行？

可以在思考一下，此时我们预处理出来的是体积最小的最优情况，那么若此时的状态加上最优的都不行的话，更何况是在给定的体积>=最优的体积的情况下呢？当然是答案只会比我们预测的要多而不会少。

注意在s没有被更新的情况下，输出0。

放一波代码
//Author:melody
#include<bits/stdc++.h>
using namespace std;

const int maxx=0x7ffff;

int n,m;
int minv[30],mins[30];
int h[30],r[30],ans=maxx;
int v,s;

void dfs(int dep)
{
    if(!dep)/*剪枝3:所有的不合法方案也可以让ans缩小范围*/
    {
        if(v==n)    ans=min(ans,s);
        return ;
    }
    for(r[dep]=min((int)sqrt(n-v), r[dep+1]-1); r[dep]>=dep; r[dep]--)/*剪枝4:缩小上下边界*/
        for(h[dep]=min((int)((double)(n-v)/r[dep]*r[dep]), h[dep+1]-1); h[dep]>=dep; h[dep]--)
        {
            if(v+minv[dep]>n)   continue;/*剪枝5:估计的最小面积比给定的大是不合法的*/
            if(s+mins[dep]>ans) continue;/*剪枝6:估计的最小面积比当前答案大是不优秀的*/
            if(2*(n-v)/r[dep]+s>ans)    continue;/*剪枝7:鬼畜的数学剪枝*/
            if(dep==m)  s+=r[dep]*r[dep];
            s+=2*r[dep]*h[dep];
            v+=r[dep]*r[dep]*h[dep];
            dfs(dep-1);
            if(dep==m)  s-=r[dep]*r[dep];
            s-=2*r[dep]*h[dep];
            v-=r[dep]*r[dep]*h[dep];
        }
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;++i)/*剪枝1:预处理最小的体积和表面积*/
    {
        minv[i]=minv[i-1]+i*i*i;
        mins[i]=mins[i-1]+i*i;
    }
    h[m+1]=r[m+1]=maxx;
    dfs(m);//剪枝2:搜索顺序的优化
    if(ans==maxx)   puts("0");
    else printf("%d\n",ans); 
    return 0;
}
最后的知识小分享
我曾经问过cdqc学长一个问题：为什么生日蛋糕这道题需要用搜索写？我拿到题的时候就压根没有想过搜索这一方面，换句话说，怎么知道一道题是搜索题？

学长如是说：

首先看一下这道题想不想你写过的图论，DP，数据结构等一些算法；
其次再看一下这道题想不想你写过的某一道鬼畜题；
然后审查一番这道题有没有想自己曾经写过的某一类搜索题；
最后若都不是的话，就往搜索方面想。
补充：put使用的时候不可以是put(0)应该是put("0")。

作者：melody
链接：https://www.acwing.com/solution/content/4187/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 25, INF = 1e9;

int n, m;
int minv[N], mins[N];
int R[N], H[N];
int ans = INF;

void dfs(int u, int v, int s)
{
    if (v + minv[u] > n) return;
    if (s + mins[u] >= ans) return;
    if (s + 2 * (n - v) / R[u + 1] >= ans) return;

    if (!u)
    {
        if (v == n) ans = s;
        return;
    }

    for (int r = min(R[u + 1] - 1, (int)sqrt(n - v)); r >= u; r -- )
        for (int h = min(H[u + 1] - 1, (n - v) / r / r); h >= u; h -- )
        {
            int t = 0;
            if (u == m) t = r * r;
            R[u] = r, H[u] = h;
            dfs(u - 1, v + r * r * h, s + 2 * r * h + t);
        }
}

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= m; i ++ )
    {
        minv[i] = minv[i - 1] + i * i * i;
        mins[i] = mins[i - 1] + 2 * i * i;
    }

    R[m + 1] = H[m + 1] = INF;

    dfs(m, 0, 0);

    if (ans == INF) ans = 0;
    cout << ans << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/136866/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 170. 加成序列(ida*)    原题链接    简单
作者：    hyc_noi ,  2020-02-29 12:18:30 ,  阅读 423

10


题目描述
满足如下条件的序列 XX（序列中元素被标号为 1、2、3…m1、2、3…m ）被称为“加成序列”：

1、X[1]=11、X[1]=1
2、X[m]=n2、X[m]=n
3、X[1]<X[2]<…<X[m−1]<X[m]3、X[1]<X[2]<…<X[m−1]<X[m]
4、对于每个k（2≤k≤m）都存在两个整数i和j（1≤i,j≤k−1，i和j可相等），使得X[k]=X[i]+X[j]。4、对于每个k（2≤k≤m）都存在两个整数i和j（1≤i,j≤k−1，i和j可相等），使得X[k]=X[i]+X[j]。
你的任务是：给定一个整数 nn，找出符合上述条件的长度 mm 最小的“加成序列”。

如果有多个满足要求的答案，只需要找出任意一个可行解。

输入样例
5
7
12
15
77
0
输出样例
1 2 4 5
1 2 4 6 7
1 2 4 8 12
1 2 4 5 10 15
1 2 4 8 9 17 34 68 77
算法1
(普通的迭代加深)
其实本题目比较大众化，nn 只有100

(其实如果我来出题我不会这么便宜你们的)
我们发现，最优情况下 log100log100 是7到8的范围，但绝对答案层不止这点

可就算是放宽了算，乘3也只有30左右

深度很浅，很容易想到迭代加深

(期待的TLE没有出现)

接下来该我表演了
算法2
(我的迭代加深其实就是一个小小的ida*)
我们知道，每次选最大的就可以使序列最短

那就选最后出现的啊

没错，每次就乘一个2，那就是左移一个2d−u+12d−u+1
你以为这样就完了吗？
不可能的！
可以发现，我们当前的数是可以被最后一个数加上其他数组成的。而且如果太小了，对答案也是没有贡献的。所以，又优化了时间复杂度！

你以为这样就完了吗？
真的完了 （本蒟蒻想不出来了）
C++ 代码
#include<bits/stdc++.h>
using namespace std;
const int NN=104;
int sum[NN],n;
bool st[NN];
bool dfs(int u,int d)
{
    if(u==d+1)
    {
        if(sum[d]==n)
        {
            for(int i=1;i<=d;i++)
                printf("%d ",sum[i]);
            puts("");
            return true;
        }
        else
            return false;
    }
    if((sum[u-1]<<(d-u+1))<n)//精髓！
        return false;
    if(u>d)
        return false;
    for(int j=u-1;j>0;j--)//精髓！
        if(!st[sum[u-1]+sum[j]])
        {
            sum[u]=sum[u-1]+sum[j];
            st[sum[u]]=true;
            if(dfs(u+1,d))
            {
                st[sum[u]]=false;
                return true;
            }
            st[sum[u]]=false;
        }
    return false;
}
int main()
{
    while(scanf("%d",&n)&&n)
    {
        int d=1;
        sum[1]=1;
        while(!dfs(2,d))
            d++;
    }
    return 0;
}
算法一测试时间
算法二测试时间
优化了1/3的时间,数据大点可以保证不tle
我试了一下，算法二可以1000000都不tle(当然，不能保证，但100000是妥妥的)

作者：hyc_noi
链接：https://www.acwing.com/solution/content/6859/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
int path[N];

bool dfs(int u, int k)
{
    if (u == k) return path[u - 1] == n;

    bool st[N] = {0};
    for (int i = u - 1; i >= 0; i -- )
        for (int j = i; j >= 0; j -- )
        {
            int s = path[i] + path[j];
            if (s > n || s <= path[u - 1] || st[s]) continue;
            st[s] = true;
            path[u] = s;
            if (dfs(u + 1, k)) return true;
        }

    return false;
}

int main()
{
    path[0] = 1;
    while (cin >> n, n)
    {
        int k = 1;
        while (!dfs(1, k)) k ++ ;

        for (int i = 0; i < k; i ++ ) cout << path[i] << ' ';
        cout << endl;
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/136954/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 171. 送礼物    原题链接    简单
作者：    秦淮岸灯火阑珊 ,  2019-02-07 08:37:49 ,  阅读 1041

6


2
原题连接

题目描述
达达帮翰翰给女生送礼物，翰翰一共准备了N个礼物，其中第i个礼物的重量是G[i]。

达达的力气很大，他一次可以搬动重量之和不超过W的任意多个物品。

达达希望一次搬掉尽量重的一些物品，请你告诉达达在他的力气范围内一次性能搬动的最大重量是多少。

输入格式
第一行两个整数，分别代表W和N。

以后N行，每行一个正整数表示G[i]。

输出格式
仅一个整数，表示达达在他的力气范围内一次性能搬动的最大重量。

数据范围
1≤N≤451≤N≤45
1≤W,G[i]≤231−11≤W,G[i]≤231−1
样例
输入样例：
20 5
7
5
4
18
1
输出样例：
19
双向搜索+剪枝
首先这道题目肯定是要搜索的,因为如果说用DP做的话,那么这个W值太大了,但是如果说只是普通搜索的话,那么O(2^N)的复杂度足以超时,而且这道题目重点就是,我们已经知道了初态而且还知道了终态,既然如此的话,我们可以选择双向搜索.
根据双向搜索的性质,我们大致可以确定当前搜索的范围,首先从前一半个物品中,挑选任意多个物品,然后将这些物品的权值总和加入到数组S中,然后我们就会发现在这个S数组中有很多很多的重复的数值,既然如此,我们不妨将他们统统都删掉,至于如何删掉,相信STL中的unique可以满足你的需求.然后我们现在前半部分搜索完后,开始搜索后半部分,至于后半部分搜索,其实和前半部分一模一样,只是我们需要二分找到当前可以填写的最大值.
现在我们已经确定好了搜索后,我们就需要剪枝了.
优化搜索顺序:我们可以将物品从大到小排序,然后再开始搜索
选择适当的折半搜索点:根据LYD大佬亲身随机试验,我们发现如果第1~n/2+2个物品为前一半的时候,我们的时间是最快的不要问我为什么,因为实验和数据告诉我们真相
C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N=(1<<24)+1;
long long ans,n,m,a[N],s[N],n_2;
long long find(int val)//二分查找
{
    int l=1,r=n_2,check=m-val;//最大可以承受的值
    while(l<r)
    {
        int mid=(l+r+1)>>1;
        if (s[mid]<=check)
            l=mid;
        else
            r=mid-1;
    }
    ans=max(ans,s[l]+val);//当前最大值与全局最大值开始比较
}
int cmp(long long a,long long b)
{
    return a>b;
}
int dfs(int x,long long sum)
{
    if (x==(n/2+2)+1)
    {
        s[++n_2]=sum;//新的权值出现,压入数组中
        return true;//返回必不可少,否则RE
    }
    dfs(x+1,sum);//不放这个进去
    if (sum+a[x]<=m)//可以放进去
        dfs(x+1,sum+a[x]);
}
int dfs2(int x,int sum)
{
//  cout<<x<<endl;
    if (x==n+1)
    {
        find(sum);//求出当前可以填充的最大值
        return true;
    }   
    dfs2(x+1,sum);
    if (sum+a[x]<=m)//如果可以放进去
        dfs2(x+1,sum+a[x]);
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>m>>n;
    for(int i=1; i<=n; i++)
        cin>>a[i];
    sort(a+1,a+1+n,cmp);//从大到小排序
    dfs(1,0);
    sort(s+1,s+n_2+1);
    n_2=unique(s+1,s+n_2+1)-(s+1);//去掉重复后,多少个数
    dfs2(n/2+3,0);
    cout<<ans<<endl;
    return 0;
}

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/968/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 46;

int n, m, k;
int w[N];
int weights[1 << 25], cnt = 1;
int ans;

void dfs1(int u, int s)
{
    if (u == k)
    {
        weights[cnt ++ ] = s;
        return;
    }

    dfs1(u + 1, s);
    if ((LL)s + w[u] <= m) dfs1(u + 1, s + w[u]);
}

void dfs2(int u, int s)
{
    if (u >= n)
    {
        int l = 0, r = cnt - 1;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if ((LL)s + weights[mid] <= m) l = mid;
            else r = mid - 1;
        }
        ans = max(ans, s + weights[l]);
        return;
    }

    dfs2(u + 1, s);
    if ((LL)s + w[u] <= m) dfs2(u + 1, s + w[u]);
}

int main()
{
    cin >> m >> n;
    for (int i = 0; i < n; i ++ ) cin >> w[i];

    sort(w, w + n);
    reverse(w, w + n);

    k = n / 2 + 2;
    dfs1(0, 0);

    sort(weights, weights + cnt);
    cnt = unique(weights, weights + cnt) - weights;

    dfs2(k, 0);

    cout << ans << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/136981/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


AcWing 180. 排书    原题链接    中等
作者：    yxc ,  2019-08-22 11:23:34 ,  阅读 845

14


1
算法
(IDA*) O(5604)O(5604)
先考虑每一步的决策数量：
当抽取长度为 ii 的一段时，有 n−i+1n−i+1 种抽法，对于每种抽法，有 n−in−i 种放法。另外，将某一段向前移动，等价于将跳过的那段向后移动，因此每种移动方式被算了两遍，所以每个状态总共的分支数量是：∑ni=1(n−i)∗(n−i+1)/2=(15∗14+14∗13+…+2∗1)/2=560∑i=1n(n−i)∗(n−i+1)/2=(15∗14+14∗13+…+2∗1)/2=560。

考虑在四步以内解决，最多有 56045604 个状态，会超时。
可以使用双向BFS或者IDA*来优化。

我们用IDA*来解决此题。
估价函数：

估价函数需要满足：不大于实际步数
在最终状态下，每本书后面的书的编号应该比当前书多1。
每次移动最多会断开三个相连的位置，再重新加入三个相连的位置，因此最多会将3个错误的连接修正，所以如果当前有 tottot 个连接，那么最少需要 ⌈tot/3⌉⌈tot/3⌉ 次操作。
因此当前状态 ss 的估价函数可以设计成 f(s)=⌈tot/3⌉f(s)=⌈tot/3⌉。
如果当前层数加上 f(s)f(s) 大于迭代加深的层数上限，则直接从当前分支回溯。

时间复杂度
理论上最多搜索 56045604 个状态，使用IDA*后实际搜索的状态数量很少。

参考文献
本题解参考《算法竞赛进阶指南》 0x28 IDA* 一节。

C++ 代码
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 15;

int n;
int q[N], w[5][N];

int f()
{
    int res = 0;
    for (int i = 0; i + 1 < n; i ++ )
        if (q[i + 1] != q[i] + 1)
            res ++ ;
    return (res + 2) / 3;
}

bool check()
{
    for (int i = 0; i < n; i ++ )
        if (q[i] != i + 1)
            return false;
    return true;
}

bool dfs(int depth, int max_depth)
{
    if (depth + f() > max_depth) return false;
    if (check()) return true;

    for (int l = 0; l < n; l ++ )
        for (int r = l; r < n; r ++ )
            for (int k = r + 1; k < n; k ++ )
            {
                memcpy(w[depth], q, sizeof q);
                int x, y;
                for (x = r + 1, y = l; x <= k; x ++, y ++ ) q[y] = w[depth][x];
                for (x = l; x <= r; x ++, y ++ ) q[y] = w[depth][x];
                if (dfs(depth + 1, max_depth)) return true;
                memcpy(q, w[depth], sizeof q);
            }
    return false;
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d", &n);
        for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

        int depth = 0;
        while (depth < 5 && !dfs(0, depth)) depth ++ ;
        if (depth >= 5) puts("5 or more");
        else printf("%d\n", depth);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/solution/content/4050/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


    AStar 最坏情况O(log25604)O(log25604)
用AStarAStar算法做了这题，程序跑了408ms408ms。
相比于IDA∗IDA∗的100ms100ms左右要慢上不少。
且A∗A∗由于是bfsbfs，代码长度也较长。

跑的慢的原因应该有两点：

用了三个STLSTL，垃圾STL毁我青春
这题的指数暴涨，是560560，所以loglog反而比前几次叠加要大。
使用的估价函数是一样的，即：

h(n)=⌈相邻位置不对的对数3⌉h(n)=⌈相邻位置不对的对数3⌉
估价函数详细的证明 & 解释见 y总的题解。

总结了一下应该在何时选择 A∗A∗ 或 IDA∗IDA∗：

需要最小字典序时，状态表示很大，指数增长较快时，使用IDA∗IDA∗
若状态容易表示，指数增长较慢时，使用A∗A∗（注意需要最小字典序时不能用A∗A∗，因为他不是按照顺序搜索的）。
C++ 代码
#include <cstdio>
#include <iostream>
#include <unordered_set>
#include <queue>
using namespace std;
typedef unsigned long long ULL;
const int N = 15, B = 17;
int n;
struct State{
    //v表示当前的状态，step表示步数，f表示当前估计值（答案）
    int v[N], step, f;
    //重载小于号
    bool operator < (const State &x) const{
        return f > x.f;
    }
}Start;
//检测是否到了目标状态
bool check(State x){
    for(int i = 0; i < n; i++)
        if(x.v[i] != i + 1) return false;
    return true;
}
//用于检测一个状态是否已经访问过了
unordered_set<ULL> s;
priority_queue<State> q;

//hash
ULL get(State x){
    ULL res = 0;
    for(int i = 0; i < n; i++)
        res = res * B + x.v[i];
    return res;
}
int f(State x){
    int res = 0;
    for(int i = 1; i < n; i++)
        if(x.v[i] - 1 != x.v[i - 1]) res++;
    return res % 3 ? res / 3 + 1 : res / 3;
}
int bfs(){
    while(q.size()) q.pop();
    Start.step = 0; Start.f = f(Start);
    q.push(Start); s.insert(get(Start));
    while(!q.empty()){
        State u = q.top(); q.pop();
        if(u.f >= 5) return 5;
        if(check(u)) return u.step;
        for(int l = 1; l < n; l++){
            for(int i = 0; i + l - 1 < n; i++){
                int j = i + l - 1;
                for(int k = i + l; k < n; k++){
                    State v; 
                    for(int f = 0; f < n; f++) v.v[f] = u.v[f];
                    for(int f = j + 1, t = i; f <= k; f++, t++)
                        v.v[t] = u.v[f];
                    for(int f = i, t = i + k - j; f <= j; f++, t++)
                        v.v[t] = u.v[f];
                    if(s.count(get(v)) > 0) continue; 
                    s.insert(get(v));
                    v.step = u.step + 1;
                    v.f = v.step + f(v);
                    q.push(v);
                }
            }
        }
    }
    return 5;
}

int main(){
    int T; scanf("%d", &T);
    while(T--){
        s.clear();
        scanf("%d", &n);
        for(int i = 0; i < n; i++)
            scanf("%d", &Start.v[i]);
        int res = bfs();
        if(res >= 5) puts("5 or more");
        else printf("%d\n", res);
    }
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/solution/content/4073/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 181. 回转游戏    原题链接    简单
作者：    yxc ,  2019-08-22 15:06:53 ,  阅读 605

9


2
算法
(IDA*, DFS) O(7k)O(7k)
本题采用 IDA* 算法，即迭代加深的 A* 算法。

估价函数：

统计中间8个方格中出现次数最多的数出现了多少次，记为 kk 次。
每次操作会从中间8个方格中移出一个数，再移入一个数，所以最多会减少一个不同的数。
因此估价函数可以设为 8−k8−k。
剪枝：

记录上一次的操作，本次操作避免枚举上一次的逆操作。
如何保证答案的字典序最小？

由于最短操作步数是一定的，因此每一步枚举时先枚举字典序小的操作即可。
时间复杂度
假设答案最少需要 kk 步，每次需要枚举 77 种不同操作（除了上一步的逆操作），因此最坏情况下需要枚举 7k7k 种方案。但加入启发函数后，实际枚举到的状态数很少。

C++ 代码
/*
      0     1
      2     3
4  5  6  7  8  9  10
      11    12
13 14 15 16 17 18 19
      20    21
      22    23
*/


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 24;

int q[N];
int op[8][7] = {
    {0, 2, 6, 11, 15, 20, 22},
    {1, 3, 8, 12, 17, 21, 23},
    {10, 9, 8, 7, 6, 5, 4},
    {19, 18, 17, 16, 15, 14, 13},
    {23, 21, 17, 12, 8, 3, 1},
    {22, 20, 15, 11, 6, 2, 0},
    {13, 14, 15, 16, 17, 18, 19},
    {4, 5, 6, 7, 8, 9, 10}
};
int center[8] = {6, 7, 8, 11, 12, 15, 16, 17};
int opposite[8] = {5, 4, 7, 6, 1, 0, 3, 2};

int path[100];

int f()
{
    static int sum[4];
    memset(sum, 0, sizeof sum);
    for (int i = 0; i < 8; i ++ ) sum[q[center[i]]] ++ ;

    int s = 0;
    for (int i = 1; i <= 3; i ++ ) s = max(s, sum[i]);
    return 8 - s;
}

bool check()
{
    for (int i = 1; i < 8; i ++ )
        if (q[center[i]] != q[center[0]])
            return false;
    return true;
}

void operation(int x)
{
    int t = q[op[x][0]];
    for (int i = 0; i < 6; i ++ ) q[op[x][i]] = q[op[x][i + 1]];
    q[op[x][6]] = t;
}

bool dfs(int depth, int max_depth, int last)
{
    if (depth + f() > max_depth) return false;
    if (check()) return true;

    for (int i = 0; i < 8; i ++ )
    {
        if (opposite[i] == last) continue;
        operation(i);
        path[depth] = i;
        if (dfs(depth + 1, max_depth, i)) return true;
        operation(opposite[i]);
    }

    return false;
}

int main()
{
    while (scanf("%d", &q[0]), q[0])
    {
        for (int i = 1; i < N; i ++ ) scanf("%d", &q[i]);
        int depth = 0;
        while (!dfs(0, depth, -1))
        {
            depth ++ ;
        }
        if (!depth) printf("No moves needed");
        for (int i = 0; i < depth; i ++ ) printf("%c", 'A' + path[i]);
        printf("\n%d\n", q[6]);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/solution/content/4056/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

/*

           0     1
           A     B

           0     1
           2     3
7 H  4  5  6  7  8  9  10  C 2
           11    12
6 G  13 14 15 16 17 18 19  D 3
           20    21
           22    23

           F     E
           5     4

*/

#include <iostream>
#include <algorithm>
#include <cstring>
#include <utility>
#include <complex>

#define space putchar(' ')
#define enter putchar('\n')

using namespace std;

const int N=24;
const int M=1000;
const int SIZEC=8;

const int op[8][7]=
{
    {0,2,6,11,15,20,22},
    {1,3,8,12,17,21,23},
    {10,9,8,7,6,5,4},
    {19,18,17,16,15,14,13},
    {23,21,17,12,8,3,1},
    {22,20,15,11,6,2,0},
    {13,14,15,16,17,18,19},
    {4,5,6,7,8,9,10}
};
const int opposite[8]={5,4,7,6,1,0,3,2};
const int center[8]={6,7,8,11,12,15,16,17};

int q[N];
int path[M];
int state[SIZEC];

inline int read()
{
    int x=0;
    char ch;
    do ch=getchar();while(ch==' '||ch=='\n');
    while(ch^' '&&ch^'\n'&&ch^'\r'&&~ch)
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x;
}

inline int lowbit(int x)
{
    return x&-x;
}

inline int max(int a,int b)
{
    return a>b?a:b;
}

inline int min(int a,int b)
{
    return a<b?a:b;
}

inline void umax(int &a,int b)
{
    if(a<b)a=b;
}

inline void umin(int &a,int b)
{
    if(a>b)a=b;
}

inline int abs(int x)
{
    return x>0?x:-x;
}

inline void swap(int &a,int &b)
{
    if(a^b)
    {
        a^=b;
        b^=a;
        a^=b;
    }
}

int f()
{
    memset(state,0,sizeof state);
    int sum=0;
    for(int i=0;i<8;i++)
        if(++state[q[center[i]]]>sum)
            sum=state[q[center[i]]];
    return 8-sum;
}

void operate(int x)
{
    int t=q[op[x][0]];
    for(int i=0;i<6;i++)
        q[op[x][i]]=q[op[x][i+1]];
    q[op[x][6]]=t;
}

bool dfs(int depth,int max_depth,int last)
{
    if(depth+f()>max_depth)return false;
    if(!f())return true;
    for(int i=0;i<8;i++)
        if(opposite[i]^last)
        {
            operate(i);
            path[depth]=i;
            if(dfs(depth+1,max_depth,i))return true;
            operate(opposite[i]);
        }
    return false;
}

int main()
{
    for(q[0]=read();q[0];q[0]=read())
    {
        for(int i=1;i<N;i++)
            q[i]=read();
        int depth=0;
        while(!dfs(0,depth,-1))depth++;
        if(depth)
        {
            for(int i=0;i<depth;i++)
                putchar(path[i]+65);
            enter;
        }
        else
            puts("No moves needed");
        printf("%d\n",q[center[0]]);
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/311616/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1015. 摘花生：DP与空间复杂度的优化    原题链接    简单
作者：    dasongshu ,  2020-02-11 11:31:03 ,  阅读 448

5


2
题目描述
Hello Kitty想摘点花生送给她喜欢的米老鼠。

她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。

地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。

Hello Kitty只能向东或向南走，不能向西或向北走。

问Hello Kitty最多能够摘到多少颗花生。

输入格式
第一行是一个整数T，代表一共有多少组数据。

接下来是T组数据。

每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。

每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。

输出格式
对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。

样例
输入样例：
2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
输出样例：
8
16
思路
状态表示
集合：定义f[i][j]为从(1, 1)到达(i, j)的所有方案
属性：最大值
状态转移
(i, j)从(i-1, j)即上方过来
(i, j)从(i, j-1)即左方过来
空间压缩
f[i][j]只需要用到这一层和上一层的f元素，所以可以压缩成滚动数组。在此之上，还可以直接压缩成一维数组。
算法1
DP：空间复杂度O(n2)O(n2)
#include<iostream>
using namespace std;

const int N = 105;
int a[N][N], f[N][N];
int q, row, col;

int main()
{
    cin >> q;
    while(q--){
        cin >> row >> col;
        for(int i = 1; i <= row; i++){
            for(int j = 1; j <= col; j++){
                cin >> a[i][j];
            }
        }

        // f[i][j]指的是到(i, j)的最大花生数
        for(int i = 1; i <= row; i++){
            for(int j = 1; j <= col; j++){
                f[i][j] = max(f[i-1][j], f[i][j-1]) + a[i][j];
            }
        }

        cout << f[row][col] << endl;
    }

    return 0;
}
算法2
DP:滚动数组，空间复杂度O(n)O(n)
#include<cstring>
#include<iostream>
using namespace std;

const int N = 105;
int a[2][N], f[2][N], q, n, m;

int main()
{
    cin >> q;
    while(q--){
        cin >> n >> m;

        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                cin >> a[i&1][j];
                f[i&1][j] = max(f[i&1][j-1], f[(i-1)&1][j]) + a[i&1][j];
            }
        }
        cout << f[n&1][m] << endl;

        memset(f, 0, sizeof f);
    }
}
算法3
DP:空间复杂度O(n)O(n)
#include<cstring>
#include<iostream>
using namespace std;

const int N = 105;
int a[N][N], f[N], q, n, m;

int main()
{
    cin >> q;
    while(q--){
        cin >> n >> m;

        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                cin >> a[i][j];
            }
        }

        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                f[j] = max(f[j], f[j-1]) + a[i][j];
            }
        }
        cout << f[m] << endl;

        // 由于多组样例，而二维数组解法由于f[0][...]和f[...][0]都为0，所以没有问题。对于一维数组，上一样例的f数组需要清零，否则影响结果
        memset(f, 0, sizeof f);
    }
}

作者：dasongshu
链接：https://www.acwing.com/solution/content/8422/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m;
int w[N][N];
int f[N][N];

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
                scanf("%d", &w[i][j]);

        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j];

        printf("%d\n", f[n][m]);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/112796/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。




此题数据没有负数，若有负数，需要处理 把所有的数字处理成负无穷即可
/*****************************************
Problem Name  : 
******************************************/
#include <queue>
#include <math.h>
#include <stack>
#include <stdio.h>
#include <iostream>
#include <string.h>
#include <algorithm>
using namespace std;
#define LL long long
const int N = 100 + 10;
int a[N][N];
int dp[N][N];
int n;
int main()
{
    cin >> n;
    for(int i = 1 ; i <= n ; i++)
        for(int j = 1 , x; j <= n ; j++)
        {
            cin >> x;
            if(i == 1)
                dp[i][j] = dp[i][j-1] + x;
            else if(j == 1)
                dp[i][j] = dp[i-1][j] + x;
            else 
                dp[i][j] = min(dp[i-1][j] , dp[i][j-1]) + x;
        }
    cout << dp[n][n] << endl;
}

作者：呼和
链接：https://www.acwing.com/solution/content/4532/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, INF = 1e9;

int n;
int w[N][N];
int f[N][N];

int main()
{
    scanf("%d", &n);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            scanf("%d", &w[i][j]);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == 1 && j == 1) f[i][j] = w[i][j];    // 特判左上角
            else
            {
                f[i][j] = INF;
                if (i > 1) f[i][j] = min(f[i][j], f[i - 1][j] + w[i][j]);   // 只有不在第一行的时候，才可以从上面过来
                if (j > 1) f[i][j] = min(f[i][j], f[i][j - 1] + w[i][j]);   // 只有不在第一列的时候，才可以从左边过来
            }

    printf("%d\n", f[n][n]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/112797/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1027. 方格取数    原题链接    简单
作者：    清南 ,  2019-09-15 13:44:27 ,  阅读 1269

20


7
算法1
(三维DP) O(n3)O(n3)
把 f[i1][j1][i2][j2]f[i1][j1][i2][j2] 转化为 f[k][i1][i2]f[k][i1][i2]
其中 k==i1+j1==i2+j2k==i1+j1==i2+j2
等价于 f[i1][k−i1][i2][k−i2]f[i1][k−i1][i2][k−i2]
这样在处理 两次走到相同点的时候，可以转化为

i1==i2i1==i2 或者 j1==j2j1==j2 判断其中之一即可

由f[i1][j1−1][i2][j2−1]f[i1][j1−1][i2][j2−1] 转化为f[k−1][i1][i2]f[k−1][i1][i2]
因为 k−1==i1+j1−1==i2+j2−1k−1==i1+j1−1==i2+j2−1
同理可得

f[i1−1][j1][i2−1][j2]==f[k−1][i1−1][i2−1]f[i1−1][j1][i2−1][j2]==f[k−1][i1−1][i2−1]
f[i1][j1−1][i2−1][j2]==f[k−1][i1][i2−1]f[i1][j1−1][i2−1][j2]==f[k−1][i1][i2−1]
f[i1−1][j1][i2][j2−1]==f[k−1][i1−1][i2]f[i1−1][j1][i2][j2−1]==f[k−1][i1−1][i2]
注意 kk的范围 2−n+n2−n+n，因为 刚开始的时候k==i1+j1==2k==i1+j1==2
j1 和 j2 要判断范围 ，因为 他们是从 k转化过来的，不能超过地图的边界范围

判断 两次取同一个格子的时候 满足以下条件
k==kk==k
i1==i2i1==i2
因此 j1==k−i1==j2==k−i2,w[i1][j2]==w[i2][j2]j1==k−i1==j2==k−i2,w[i1][j2]==w[i2][j2]
时间复杂度
O(n3)O(n3)
参考文献
算法提高课 DP 第一讲

C++ 代码
#include <bits/stdc++.h>
using namespace std;
const int N = 15;
int w[N][N],f[N*2][N][N];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int n ,x,y,z;
    cin >> n;
    while(cin >> x >> y >> z,x && y && z) w[x][y] = z;
    for(int k = 2;k <= n + n; ++k){
        for(int i1 = 1;i1 <= n; ++i1){
            for(int i2 = 1;i2 <= n; ++i2){
                int j1 = k - i1 , j2 = k - i2;
                if(j1 >= 1 && j1 <= n && j2 >= 1 && j2 <= n){
                    int t = w[i1][j1];
                    if(i1 != i2) t += w[i2][j2];
                    int &x = f[k][i1][i2];
                    x = max(x , f[k-1][i1-1][i2-1] + t);
                    x = max(x , f[k-1][i1-1][i2] + t);
                    x = max(x , f[k-1][i1][i2-1] + t);
                    x = max(x , f[k-1][i1][i2] + t);
                }
            }
        }
    }
    cout << f[n+n][n][n] << endl;


    return 0;
}

作者：清南
链接：https://www.acwing.com/solution/content/4578/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 15;

int n;
int w[N][N];
int f[N * 2][N][N];

int main()
{
    scanf("%d", &n);

    int a, b, c;
    while (cin >> a >> b >> c, a || b || c) w[a][b] = c;

    for (int k = 2; k <= n + n; k ++ )
        for (int i1 = 1; i1 <= n; i1 ++ )
            for (int i2 = 1; i2 <= n; i2 ++ )
            {
                int j1 = k - i1, j2 = k - i2;
                if (j1 >= 1 && j1 <= n && j2 >= 1 && j2 <= n)
                {
                    int t = w[i1][j1];
                    if (i1 != i2) t += w[i2][j2];
                    int &x = f[k][i1][i2];
                    x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);
                    x = max(x, f[k - 1][i1 - 1][i2] + t);
                    x = max(x, f[k - 1][i1][i2 - 1] + t);
                    x = max(x, f[k - 1][i1][i2] + t);
                }
            }

    printf("%d\n", f[n + n][n][n]);
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/112798/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 275. 传纸条    原题链接    简单
作者：    yxc ,  2019-08-18 23:02:48 ,  阅读 1680

35


6
算法
(线性DP) O(n3)O(n3)
首先考虑路径有交集该如何处理。
可以发现交集中的格子一定在每条路径的相同步数处。因此可以让两个人同时从起点出发，每次同时走一步，这样路径中相交的格子一定在同一步内。

状态表示：f[k, i, j] 表示两个人同时走了k步，第一个人在 (i, k - i) 处，第二个人在 (j, k - j)处的所有走法的最大分值。

状态计算：按照最后一步两个人的走法分成四种情况：

两个人同时向右走，最大分值是 f[k - 1, i, j] + score(k, i, j)；
第一个人向右走，第二个人向下走，最大分值是 f[k - 1, i, j - 1] + score(k, i, j)；
第一个人向下走，第二个人向右走，最大分值是 f[k - 1, i - 1, j] + score(k, i, j)；
两个人同时向下走，最大分值是 f[k - 1, i - 1, j - 1] + score(k, i, j)；
注意两个人不能走到相同格子，即i和j不能相等。

时间复杂度
一共有 O(n3)O(n3) 个状态，每个状态需要 O(1)O(1) 的计算量，因此总时间复杂度是 O(n3)O(n3)。

C++ 代码
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 55;

int n, m;
int g[N][N];
int f[N * 2][N][N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            scanf("%d", &g[i][j]);

    for (int k = 2; k <= n + m; k ++ )
        for (int i = max(1, k - m); i <= n && i < k; i ++ )
            for (int j = max(1, k - m); j <= n && j < k; j ++ )
                for (int a = 0; a <= 1; a ++ )
                    for (int b = 0; b <= 1; b ++ )
                    {
                        int t = g[i][k - i];
                        if (i != j || k == 2 || k == n + m)
                        {
                            t += g[j][k - j];
                            f[k][i][j] = max(f[k][i][j], f[k - 1][i - a][j - b] + t);
                        }
                    }

    printf("%d\n", f[n + m][n][n]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/solution/content/3954/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 1017. 怪盗基德的滑翔翼    原题链接    简单
作者：    TaoZex ,  2019-09-16 13:27:12 ,  阅读 624

5


1
确定滑行方向后就转化为了LIS问题,原问题相当于正向和反向以ai为结尾的最长上升子序列长度，确定滑行方向后就转化为了LIS问题,原问题相当于正向和反向以ai为结尾的最长上升子序列长度，
分别正向和反向各进行一次LIS，取得最大值即可。分别正向和反向各进行一次LIS，取得最大值即可。
#include<bits/stdc++.h>
using namespace std;

const int N=110;
int a[N],f[N];

int main(){
    int T;
    cin>>T;
    while(T--){
        int n;
        cin>>n;
        memset(a,0,sizeof(a));
        memset(f,0,sizeof(f));

        for(int i=1;i<=n;i++) cin>>a[i];

        int res=0;
        for(int i=1;i<=n;i++){
            f[i]=1;
            for(int j=1;j<i;j++){
                if(a[j]<a[i]){
                    f[i]=max(f[i],f[j]+1);  //注意是f[i]
                }
            }
            res=max(res,f[i]);
        }

        for(int i=n;i>=1;i--){
            f[i]=1;
            for(int j=n;j>i;j--){
                if(a[j]<a[i]){
                    f[i]=max(f[i],f[j]+1);
                }
            }
            res=max(res,f[i]);
        }
        cout<<res<<endl;
    }
}
也可以转化为正向的最长上升子序列和正向的最长下降子序列也可以转化为正向的最长上升子序列和正向的最长下降子序列
#include<bits/stdc++.h>
using namespace std;

const int N=110;
int f[N];
int a[N];
int T,n;
int main(){
    cin>>T;
    while(T--){
        memset(f,0,sizeof(f));
        cin>>n;

        for(int i=1;i<=n;i++) cin>>a[i];

        int res=0;
        for(int i=1;i<=n;i++){
            f[i]=1;
            for(int j=1;j<i;j++){
                if(a[j]<a[i]){
                    f[i]=max(f[i],f[j]+1);
                }
            }
            res=max(res,f[i]);
        }

        for(int i=1;i<=n;i++){
            f[i]=1;
            for(int j=1;j<i;j++){
                if(a[j]>a[i]){
                    f[i]=max(f[i],f[j]+1);
                }
            }
            res=max(res,f[i]);
        }
        cout<<res<<endl;
    }
}

作者：TaoZex
链接：https://www.acwing.com/solution/content/4599/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
int h[N];
int f[N];

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d", &n);
        for (int i = 0; i < n; i ++ ) scanf("%d", &h[i]);

        int res = 0;
        for (int i = 0; i < n; i ++ )
        {
            f[i] = 1;
            for (int j = 0; j < i; j ++ )
                if (h[i] < h[j])
                    f[i] = max(f[i], f[j] + 1);
            res = max(res, f[i]);
        }

        memset(f, 0, sizeof f);
        for (int i = n - 1; i >= 0; i -- )
        {
            f[i] = 1;
            for (int j = n - 1; j > i; j -- )
                if (h[i] < h[j])
                    f[i] = max(f[i], f[j] + 1);
            res = max(res, f[i]);
        }

        printf("%d\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/112799/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 1017. 怪盗基德的滑翔翼    原题链接    简单
作者：    P云 ,  2020-02-19 05:46:52 ,  阅读 272

5


1
题目描述
可爱哄睡小故事系列题/大雾

怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。

而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。

有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。

不得已，怪盗基德只能操作受损的滑翔翼逃脱。

假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。

初始时，怪盗基德可以在任何一幢建筑的顶端。

他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。

因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。

他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。

请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？

输入格式
输入数据第一行是一个整数KK，代表有KK组测试数据。

每组测试数据包含两行：第一行是一个整数N，代表有NN幢建筑。第二行包含NN个不同的整数，每一个对应一幢建筑的高度hh，按照建筑的排列顺序给出。

输出格式
对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。

数据范围
1≤K≤1001≤K≤100
1≤N≤1001≤N≤100
0<h<100000<h<10000
样例
输入样例：
7
1 7 3 5 9 4 8
输出样例：
18
算法
(最长上升子序列) O(n2)O(n2)
如果要求经过楼房数量最多的话，当然必须从两端起飞啦~
这样的话只要分别求出从左端点和右端点开始的最长上升子序列的长度就可以啦，只是LIS的简单的拓展噢。

时间复杂度
朴素的LIS扫了两遍而已啦，所以还是O(n2)O(n2)呢www

C++ 代码
#include <iostream>
using namespace std;
const int N = 110;
int a[N], fl[N], fr[N], n;
int main()
{
    int K;
    cin >> K;
    while(K --)
    {
        cin >> n;
        for(int i = 1; i <= n; i ++) cin >> a[i];
        for(int i = 0; i < N; i ++) fl[i] = 1, fr[i] = 1;
        for(int i = 2; i <= n; i ++)
            for(int j = 1; j < i; j ++)
                if(a[j] < a[i])
                    fr[i] = max(fr[i], fr[j] + 1);
        for(int i = n - 1; i >= 1; i --)
            for(int j = n; j > i; j --)
                if(a[j] < a[i])
                    fl[i] = max(fl[i], fl[j] + 1);
        int maxn = -1;
        for(int i = 1; i <= n; i ++) maxn = max(maxn, max(fl[i], fr[i]));
        cout << maxn << endl;
    }
}

作者：P云
链接：https://www.acwing.com/solution/content/8755/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 1014. 登山-另一个双dp数组的思路    原题链接    简单
作者：    houghstc ,  2019-09-16 04:57:02 ,  阅读 658

5


1
双状态dp
对于第i个景点为终点的子序列，当我们遍历它之前任意景点j的时候，我们可以按照两种情况来考虑：

如果高度i > 高度 j, 且我们想要延长我们的子序列，来得到一个更长的解，那么我们正在考虑的这个子序列必须是严格上升的。因为题目里要求的是一旦下降，就不能再开始上升。

如果高度i < 高度 j, 且我们想要延长我们的子序列，来得到一个更长的解，那么以j为终点的子序列有两种可能：
– case1: 严格上升的，即队伍还没有开始往下走
– case2: 先严格上升，再严格下降，即队伍已经开始往下走了（队伍从头开始一直在往下走也包括在这种情况里面）

这样我们可以维护两个dp数组
dp_inc[i] : 表示以第i个景点为终点的最长严格单调上升子序列的长度
dp_dec[i] : 表示以第i个景点为结束的最长子序列的长度，这个子序列先严格上升，再严格下降。其中严格上升的部分，长度大于等于0。严格下降的部分，长度大于等于1

状态转移：

对于j < i, 高度i > 高度 j: dp_inc[i] = dp_inc[j]+1 // 常规单调上升子序列
对于j < i, 高度i < 高度 j: dp_dec[i] = max(dp_inc[j]+1, dp_dec[j]+1) // dp_inc[i]+1 对应上面case 1， dp_dec[j]+1 对应上面case 2
最终的结果就是这两个数组的所有值的最大值。

时间复杂度
O(n2)O(n2)
C++ 代码
#include <iostream>

using namespace std;

const int N = 1010;

int h[N];
int dp_inc[N];
int dp_dec[N];

int main()
{
    int n;
    cin >> n;

    int res = 0;
    for(int i = 0; i < n; ++i)
    {
        cin >> h[i];

        dp_inc[i] = 1, dp_dec[i] = 1;
        for(int j = 0; j < i; ++j)
        {
            if(h[j] < h[i])
                dp_inc[i] = max(dp_inc[i], dp_inc[j]+1);
            if(h[j] > h[i])
                dp_dec[i] = max(dp_dec[i], max(dp_inc[j]+1, dp_dec[j]+1));
        }

        res = max(res, max(dp_inc[i], dp_dec[i]));
    }

    cout << res << endl;

    return 0;
}

作者：houghstc
链接：https://www.acwing.com/solution/content/4590/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n;
int h[N];
int f[N], g[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &h[i]);

    for (int i = 0; i < n; i ++ )
    {
        f[i] = 1;
        for (int j = 0; j < i; j ++ )
            if (h[i] > h[j])
                f[i] = max(f[i], f[j] + 1);
    }

    for (int i = n - 1; i >= 0; i -- )
    {
        g[i] = 1;
        for (int j = n - 1; j > i; j -- )
            if (h[i] > h[j])
                g[i] = max(g[i], g[j] + 1);
    }

    int res = 0;
    for (int i = 0; i < n; i ++ ) res = max(res, f[i] + g[i] - 1);

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/112800/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
AcWing 482. 合唱队形    原题链接    中等
作者：    yxc ,  2019-08-14 00:18:33 ,  阅读 614

10


算法
(线性DP,最长上升子序列) O(n2)O(n2)
假设最优解的中心是第 ii 个人，则 T1,T2,…,TiT1,T2,…,Ti 一定是以 TiTi 结尾的最长上升子序列。
同理，TK,TK−1,…,TiTK,TK−1,…,Ti 也一定是以 TiTi 结尾的最长上升子序列。

因此可以先预处理出：

从前往后以每个点结尾的最长上升子序列长度 f[i]；
从后往前以每个点结尾的最长上升子序列长度 g[i]；
那么以 kk 为中心的最大长度就是 f[k] + g[k] - 1，遍历 k = 1, 2, ..., n 取最大值即为答案。

求最长上升子序列问题(LIS)可以参考 AcWing 895. 最长上升子序列。

时间复杂度
本题数据范围只有 100，因此可以用朴素的LIS求解方式，时间复杂度是 O(n2)O(n2)，使用贪心 + 二分可以将时间复杂度优化到 O(nlogn)O(nlogn)，具体可以参考 AcWing 896. 最长上升子序列 II。

C++ 代码
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
int h[N];
int f[N], g[N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &h[i]);
    for (int i = 1; i <= n; i ++ )
    {
        f[i] = 1;
        for (int j = 1; j < i; j ++ )
            if (h[j] < h[i])
                f[i] = max(f[i], f[j] + 1);
    }

    for (int i = n; i; i -- )
    {
        g[i] = 1;
        for (int j = n; j > i; j -- )
            if (h[j] < h[i])
                g[i] = max(g[i], g[j] + 1);
    }

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = max(res, f[i] + g[i] - 1);

    printf("%d\n", n - res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/solution/content/3805/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

AcWing 1012. 友好城市    原题链接    简单
作者：    P云 ,  2020-02-19 07:17:51 ,  阅读 195

5


题目描述
Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。

北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。

每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。

编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。

输入格式
第1行，一个整数NN，表示城市数。

第2行到第n+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。

输出格式
仅一行，输出一个整数，表示政府所能批准的最多申请数。

数据范围
1≤N≤50001≤N≤5000
0≤xi≤100000≤xi≤10000
样例
输入样例：
7
22 4
2 6
10 3
15 12
9 8
17 17
4 2
输出样例：
4
算法
(线性DP，最长上升子序列) O(n2)O(n2)
我们将一边的城市坐标从小到大排序，可以发现令航线不交错的方法即为找到另一边的城市坐标的最长上升子序列。然后就转换成了一道LIS裸题了ww

时间复杂度
数据范围只有5000，用朴素版O(n2)O(n2)就可以啦~

C++ 代码
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
typedef pair<int, int> PII;
const int N = 5010;
int f[N], n;
int main()
{
    cin >> n;
    vector<PII> cities;
    for(int i = 1; i <= n; i ++)
    {
        int a, b;
        cin >> a >> b;
        cities.push_back({a, b});
    }
    sort(cities.begin(), cities.end());
    for(int i = 0; i <= n; i ++) f[i] = 1;
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j < i; j ++)
            if(cities[j - 1].second < cities[i - 1].second)
            //注意 我们的vector数组cities的下标是从0开始的
            //想避免这个问题还可以在最前面往里面push一个{-2e9, 2e9}补齐下标即可。
                f[i] = max(f[i], f[j] + 1);
    int maxn = -1;
    for(int i = 1; i <= n; i ++) maxn = max(maxn, f[i]);
    cout << maxn;
}

作者：P云
链接：https://www.acwing.com/solution/content/8756/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。




#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 5010;

int n;
PII city[N];
int f[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &city[i].first, &city[i].second);
    sort(city, city + n);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        f[i] = 1;
        for (int j = 0; j < i; j ++ )
            if (city[i].second > city[j].second)
                f[i] = max(f[i], f[j] + 1);
        res = max(res, f[i]);
    }

    printf("%d\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/112802/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。