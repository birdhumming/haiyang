AcWing 2171. EK求最大流    原题链接    中等
作者：    duoduola ,  2020-07-27 16:19:28 ,  阅读 174

7


1
（就是想来理一理思路。小菜鸡第一次写题解(可能也不算是题解)，之前都只是做一做题的。）
（语言可能描述的不到位或者不清楚(感觉有些地方说不太清呀~~~,然后也不太会写题解)，错误的地方请大家指出）

存下图，建立反向边，构建残余网络，在残余网络中不断寻找增广路径，维护残余网络，将其累加至答案中，直到找不到增广路径。
1~n的节点之间的边通过add函数来记录，边的编号从2开始。
在点s之前新增一条编号为1的边，起点是一个新增的点(编号是多少没有用到，所以也没有管它.jpg)，终点为s（这样是为了写bfs的代码时候方便一些，不用先处理以s为顶点的边，直接从编号为1的这条边开始就好）

代码中有注释~~~

代码如下：

#include<iostream>
#include<cstring>
using namespace std;
const int N=1010,M=20010;

//h[i]存下以点i为起点的边的编号（按输入顺序，存下的是最后一条边的编号）
//f[i]存下边i的权值，e[i]存下边i的终点，ne[i]存下和边i同起点的上一条边的编号(可以依次找出同起点的所有边)
//idx用来记录边的编号
//p,d,pre三个数组在bfs寻找增广路径时使用，来记录当前搜到的边的信息，
//p[i]表示当前边的编号，d[i]表示走到这条边的路径中最小的边权值(最大的可行流量)，
//pre[i]表示当前这一条边是从之前的哪一条走过来的(记录的是bfs过程中的相应下标)
//tot用来记录bfs过程中展开的边的数量，下标为tot的位置是增广路径的最后一条边(其终点为t)
//n,m,s,t如题，mark用来标记bfs过程中已经到达了的点，防止重复搜索
int h[N]={0},f[M]={0},e[M]={0},ne[M]={0},idx=2;
int p[N]={0},d[N]={0},pre[N]={0},tot=0,n=0,m=0,s=0,t=0;
bool mark[N]={0};

//存下边的信息，同时要存下反向边，构建残余网络
void add(int& a,int& b,int& c){
    e[idx]=b;f[idx]=c;ne[idx]=h[a];h[a]=idx;idx++;
    e[idx]=a;f[idx]=0;ne[idx]=h[b];h[b]=idx;idx++;
}

//bfs找增广路径，结果记录在p,d,pre三个数组中
bool bfs(){
    int l=0;tot=0;//l是左端点，tot相当于右端点(每次重新置为0)
    memset(mark,0,sizeof(mark));//mark数组赋为false
    while(l<=tot){  //l<=tot,还要继续展开边
        //p[l]表示当前这条边的编号，e[p[l]]表示当前这条边的终点，h[e[p[l]]]表示以这一终点为顶点的一条边
        //通过ne数组不断找到以这一终点为顶点的所有边，for循环中的i就是这些边的编号
        for(int i=h[e[p[l]]];i;i=ne[i]){    //h数组的初始值为0，当i为0时表示以e[p[l]]为起点的边都搜过了
            if(!mark[e[i]]&&f[i]){//如果当前边的终点还没有到达过并且当前这条边的权值大于0，就会展开这一条边
                tot++;//右边界++,并标记上这条边的终点
                mark[e[i]]=1;
                //存下这条边，p[tot]存下编号i，
                //d[tot]存下路径中最小的权值(到达上一条边时最小权值d[l]和当前边i的权值中的最小值)
                //pre[tot]存下当前这一边是从下标l位置的那条边走过来的
                p[tot]=i;d[tot]=min(f[i],d[l]);pre[tot]=l;
                if(e[i]==t)return true;//当前这条边到达了终点，返回true
            }
        }
        l++;// l不要忘记++(因为我就忘了)，继续展开下一条边
    }
    return false;//没有找到增广路径辽~
}
int main(){
    std::ios::sync_with_stdio(false);
    cin>>n>>m>>s>>t;
    e[1]=s;//添加编号为1的边，其终点为s（边的其他信息没有管它，因为没有用到~~
    p[0]=1;d[0]=1e9;//bfs的起点是这条编号为1的边，当前最小权值赋成一个较大的值
    int a=0,b=0,c=0;
    while(m--){//输入边的信息，存下来
        cin>>a>>b>>c;
        add(a,b,c);
    }
    int ans=0;
    while(bfs()){//当前残网络中还可找到增广路径，则累加至ans中，并修改这条路径中正向边和反向边的权值
        ans+=d[tot];
        for(int i=tot;i;i=pre[i]){//从tot位置的边开始，沿着增广路径往回走，走到0位置的边(也就是边1时)停止
            //路径中的每一条边减去d[tot]，其反向边加上d[tot]
            f[p[i]]-=d[tot];f[p[i]^1]+=d[tot];
        }
    }
    cout<<ans<<endl;
    return 0;
}

作者：duoduola
链接：https://www.acwing.com/solution/content/17161/
   。
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010, M = 20010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], pre[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(st, false, sizeof st);
    q[0] = S, st[S] = true, d[S] = INF;
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (!st[ver] && f[i])
            {
                st[ver] = true;
                d[ver] = min(d[t], f[i]);
                pre[ver] = i;
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int EK()
{
    int r = 0;
    while (bfs())
    {
        r += d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
            f[pre[i]] -= d[T], f[pre[i] ^ 1] += d[T];
    }
    return r;
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    printf("%d\n", EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/403258/
   。

AcWing 2172. Dinic/ISAP求最大流 - python3    原题链接    中等
作者：    roon2300 ,  2020-08-11 14:45:43 ,  阅读 103

2


1
C++ 版：

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010, M = 200010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], nh[N];

inline void add(int a, int b, int c){
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

bool bfs(){
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, nh[S] = h[S];
    int hh = 0, tt = 1;
    while (hh < tt){
        int t = q[hh ++];
        for (int i = h[t]; ~i; i = ne[i]){
            int v = e[i];
            if (d[v] == -1 && f[i]){
                d[v] = d[t] + 1;
                nh[v] = h[v];   // 可以在开头全copy
                if (v == T) return true;
                q[tt ++] = v;
            }
        }
    }
    return false;
}

int find(int u, int limit){
    if (u == T) return limit;
    int flow = 0;

    for (int i = nh[u]; ~i && flow < limit; i = ne[i]){   // 1. nh 优化， 2. 增广最大量优化
        nh[u] = i;  // nh当前可行弧优化
        int v = e[i];
        if (d[v] == d[u] + 1 && f[i]){
            int t = find(v, min(f[i], limit - flow));
            if (t)  flow += t, f[i] -= t; //, f[i ^ 1] += t;
            else  d[v] = -1;       // 3. 废点优化
        }
    }
    return flow;
}

int dinic(){
    int res = 0, flow;
    while( bfs() ) while (flow = find(S, INF)) res += flow;
    return res;
}

int main(){
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- ){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, 0);
    }
    printf("%d\n", dinic());
    return 0;
}


python3 版：

N, M, inf = 10010, 200010, float('inf')

h, e, f, ne, idx = [-1] * N, [0] * M, [0] * M, [0] * M, 0

q, d, nh = [0] * N, [-1] * N, [0] * N  # d: dist or level 

def add(a, b, c):
    global idx
    e[idx], f[idx], ne[idx], h[a] = b, c, h[a], idx
    idx += 1

def bfs():
    """ rebuild nh[] and d[] """
    global nh, d
    nh = list(h)        # nh[S] = h[S]
    d = [-1] * N; d[S] = 0

    q[0] = S; hh, tt = 0, 1
    while hh < tt:
        u = q[hh]; hh += 1
        i = h[u]
        while i != -1:
            v = e[i]
            if d[v] == -1 and f[i]:
                d[v] = d[u] + 1     #  nh[v] = h[v]
                if v == T: return True   # T 也是要标d和cur的
                q[tt] = v; tt += 1
            i = ne[i]

    return False

def find(u, limit):
    if u == T: return limit
    flow = 0
    i = nh[u]        # 1. 当前(起始可用)弧优化
    while i != -1 and flow < limit:   # 2. 最大增广量优化
        nh[u] = i    # 当前弧优化。  进阶指南似乎放的位置效率比较低
        v = e[i]
        if d[v] == d[u] + 1 and f[i]:             # 标层级
            t = find(v, min(f[i], limit - flow))  # 避免无限递归
            if t: flow += t; f[i] -= t;  # f[i ^ 1] += t  
            else: d[v] = -1         # 3. 废点优化，本轮bfs里面不再可能是增广路
        i = ne[i]

    return flow

def dinic():
    res = 0
    while bfs():
        flow = find(S, inf)
        while flow:
            res += flow
            flow = find(S, inf)
    return res


n, m, S, T = map(int, input().split())
while m:
    a, b, c = map(int, input().split())
    add(a, b, c); add(b, a, 0)
    m -= 1
print(dinic())

loj #127. 最大流 加强版


// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define maxn 1300
#define maxm 120010
using namespace std;
struct edge {
    int u, v, cap;
} e[maxm];
struct Dinic {
    int tp, s, t, dis[maxn], cur[maxn], que[maxn];
    vector<edge> e;
    vector<int> v[maxn];
    void AddEdge(int x, int y, int flw) {
        e.push_back(edge{ x, y, flw });
        e.push_back(edge{ y, x, 0 });
        v[x].push_back(e.size() - 2);
        // v[y].push_back(e.size()-1);
    }
    int bfs() {
        memset(dis, 0x3f, sizeof dis);
        int l = 1, r = 1;
        que[1] = s;
        dis[s] = 0;
        while (l <= r) {
            int p = que[l++], to;
            for (int i : v[p])
                if (e[i].cap && dis[to = e[i].v] > 1e9)
                    dis[to] = dis[p] + 1, que[++r] = to;
        }
        return dis[t] < 1e9;
    }
    int dfs(int p, int a) {
        if (p == t || !a)
            return a;
        int sf = 0, flw;
        for (int &i = cur[p], to; i < (int)v[p].size(); ++i) {
            edge &E = e[v[p][i]];
            if (dis[to = E.v] == dis[p] + 1 && (flw = dfs(to, min(a, E.cap)))) {
                E.cap -= flw;
                e[v[p][i] ^ 1].cap += flw;
                a -= flw;
                sf += flw;
                if (!a)     // 把此处移到for的判断里会有问题。。。
                    break;
            }
        }
        return sf;
    }
    int dinic(int s, int t, int tp = 1) {
        this->s = s;
        this->t = t;
        this->tp = tp;
        int flw = 0;
        while (bfs()) {
            memset(cur, 0, sizeof cur);
            flw += dfs(s, INT_MAX);
        }
        return flw;
    }
} sol;
int n, m, i, s, t, ans;
int main() {
    scanf("%d%d%d%d", &n, &m, &s, &t);
    for (i = 0; i < m; i++) scanf("%d%d%d", &e[i].u, &e[i].v, &e[i].cap);
    sort(e, e + m, [](edge a, edge b) { return a.cap > b.cap; });
    for (int tp : { 0, 1 })
        for (int p = 1 << 30, i = 0; p; p /= 2) {
            while (i < m && e[i].cap >= p) {
                if (tp)
                    sol.v[e[i].v].push_back(i * 2 + 1);
                else
                    sol.AddEdge(e[i].u, e[i].v, e[i].cap);
                i++;
            }
            ans += sol.dinic(s, t, tp);
        }
    printf("%d\n", ans);
    return 0;
}

关于最后的

    for (int tp : { 0, 1 })
        for (int p = 1 << 30, i = 0; p; p /= 2) {
参考 论如何用dinic ac 最大流 加强版 里面的解释：
1. 先不加反向边跑一遍，然后一次性把反向边都加进去，然后再跑一遍
2. 二进制缩放，只跑大于p的边
看起来应该是针对数据的专门的优化

作者：roon2300
链接：https://www.acwing.com/solution/content/18166/
   。
自己都不知道自己写的是个啥
反正写完就神奇的过了。。
数据配图↓↓


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=10005;
const int M=200005;
const int INF=0x3fffffff;

int n,m,S,T;
int h[N],e[M],ne[M],idx;
int depth[N],flow[M];
int q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    flow[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

int bfs()
{
    memset(depth,0,sizeof depth);
    depth[S]=1,*q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(flow[i]&&!depth[e[i]])
            {
                depth[e[i]]=depth[t]+1;
                q[++tt]=e[i];
            }
    }
    return depth[T];
}

int dfs(int u,int T,int s)
{
    if(u==T)return s;
    int f=0;
    for(int i=h[u];i;i=ne[i])
        if(flow[i]&&depth[e[i]]==depth[u]+1)
        {
            int v=dfs(e[i],T,min(s,flow[i]));
            flow[(i-1^1)+1]+=v;
            flow[i]-=v;
            s-=v,f+=v;
        }
    if(!f)depth[u]=-1;
    return f;
}

int main()
{
    scanf("%d%d%d%d",&n,&m,&S,&T);
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c),add(b,a,0);
    }
    int res=0;
    while(bfs())res+=dfs(S,T,INF);
    printf("%d\n",res);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/401964/
   。


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010, M = 200010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T)  return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;  // 当前弧优化
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    printf("%d\n", dinic());

    return 0;


作者：yxc
链接：https://www.acwing.com/activity/content/code/content/412368/
   。
AcWing 2175. 飞行员配对方案问题    原题链接    困难
作者：    IEE_ ,  2020-08-16 23:25:27 ,  阅读 86

1


建立源点 S 与 1∼m1∼m 的所有飞行员连容量为 1 的边，将剩下的飞行员向汇点 T 连一条边，再将所给搭配连容量为 1 的边，求 S 至 T 的最大流即可

为了方便，将源点 S 设为 00，T 设为 n+1n+1。

此题代码：

signed main() {
  cin >> m >> n;

  memset(h, -1, sizeof h);
  S = 0, T = n + 1;
  for (int i = 1; i <= m; ++i) add(S, i, 1);
  for (int i = m + 1; i <= n; ++i) add(i, T, 1);
  int a, b;
  while (scanf("%d%d", &a, &b), a != -1 && b != -1) add(a, b, 1);

  cout << dinic() << endl;

  for (int i = 0; i < idx; i += 2) {
    if (e[i] > m && e[i] <= n && !f[i]) {
      cout << e[i ^ 1] << ' ' << e[i] << endl;
    }
  }
  return 0;
}

作者：IEE_
链接：https://www.acwing.com/solution/content/18579/
   。


AcWing 2175. 飞行员配对方案问题
作者：    垫底抽风 ,  2020-07-24 18:06:23 ,  阅读 74

2


匈牙利算法求二分图的最大匹配
模板题

#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

bool read(int &a,int &b)
{
    a=b=0;char ch=getchar();
    while(~ch&&ch!='-'&&(ch<48||ch>57))ch=getchar();
    if(ch=='-')return false;
    for(;ch>47&&ch<58;ch=getchar())a=(a<<1)+(a<<3)+(ch^48);
    while(~ch&&(ch<48||ch>57))ch=getchar();
    for(;ch>47&&ch<58;ch=getchar())b=(b<<1)+(b<<3)+(ch^48);
}

const int N=105;
const int M=10005;

int n1,n2,res;
int h[N],e[M],ne[M],idx;
int match[N];
bool st[N];

void add(int a,int b)
{
    e[++idx]=b;
    ne[idx]=h[a];
    h[a]=idx;
}

bool find(int u)
{
    for(int i=h[u];i;i=ne[i])
        if(!st[e[i]])
        {
            st[e[i]]=true;
            if(!match[e[i]]||find(match[e[i]]))
            {
                match[e[i]]=u;
                return true;
            }
        }
    return false;
}

int main()
{
    read(n1,n2);
    for(int a,b;read(a,b);add(a,b));
    for(int i=1;i<=n1;i++)
    {
        memset(st,false,sizeof st);
        if(find(i))res++;
    }
    printf("%d\n",res);
    for(int i=n2;i>n1;i--)
        if(match[i])
            printf("%d %d\n",match[i],i);
    return 0;
}
DinicDinic 求二分图的最大匹配

#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

bool read(int &a,int &b)
{
    a=b=0;char ch=getchar();
    while(~ch&&ch!='-'&&(ch<48||ch>57))ch=getchar();
    if(ch=='-')return false;
    for(;ch>47&&ch<58;ch=getchar())a=(a<<1)+(a<<3)+(ch^48);
    while(~ch&&(ch<48||ch>57))ch=getchar();
    for(;ch>47&&ch<58;ch=getchar())b=(b<<1)+(b<<3)+(ch^48);
    return true;
}

const int N=205;
const int M=20405;
const int INF=0x3fffffff;

int n1,n2,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int main()
{
    read(n1,n2),S=0,T=n2+1;
    for(int a,b;read(a,b);add(a,b,1),add(b,a,0));
    for(int i=1;i<=n1;i++)add(S,i,1),add(i,S,0);
    for(int i=n1+1;i<=n2;i++)add(i,T,1),add(T,i,0);
    int maxflow=0;
    while(bfs())
        for(int flow;flow=find(S,INF);)
            maxflow+=flow;
    printf("%d\n",maxflow);
    for(int i=h[S];i;i=ne[i])
        if(!w[i])
            for(int j=h[e[i]];j;j=ne[j])
                if(e[j]>n1&&!w[j])
                {
                    printf("%d %d\n",e[i],e[j]);
                    break;
                }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/402007/
   。


1


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 5210, INF = 1e8;

int m, n, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = h[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &m, &n);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= m; i ++ ) add(S, i, 1);
    for (int i = m + 1; i <= n; i ++ ) add(i, T, 1);

    int a, b;
    while (cin >> a >> b, a != -1) add(a, b, 1);

    printf("%d\n", dinic());
    for (int i = 0; i < idx; i += 2)
        if (e[i] > m && e[i] <= n && !f[i])
            printf("%d %d\n", e[i ^ 1], e[i]);

    return 0;


作者：yxc
链接：https://www.acwing.com/activity/content/code/content/412418/
   。

AcWing 2179. 圆桌问题    原题链接    困难
作者：    whsstory ,  2020-07-24 20:23:33 ,  阅读 114

3


特殊的二分图匹配问题。

可以拆点后跑二分图最大匹配。复杂度O(∑ri∑ci(∑ri+∑ci))O(∑ri∑ci(∑ri+∑ci)) ,可能会T 。

也可以直接跑最大流：源点S 向单位ii连容量为riri的边，单位ii向餐桌jj连容量为1的边，餐桌jj向汇点T 连容量为cici的边。这显然是个二分图。用Dinic求解最大流，复杂度为O(nm∑ri+∑ci‾‾‾‾‾‾‾‾‾‾‾√)(注意本题中边数为O(nm∑ri+∑ci)(注意本题中边数为nmnm)

//我的Dinic板子肯定没有y总的好，你们可以看看y总的
const ll INF=1ll<<50;
#define MAXN 200011
struct edge
{
    ll v,w,nxt;
}e[MAXN<<1|1];
ll cnt=1,last[MAXN],cur[MAXN];
void add_directed_edge(ll u,ll v,ll w)
{
    e[++cnt].v=v,e[cnt].w=w;
    e[cnt].nxt=last[u],last[u]=cnt;
}
void adde(ll u,ll v,ll w){add_directed_edge(u,v,w),add_directed_edge(v,u,0);}

ll dep[MAXN];
bool bfs(ll s,ll t,ll n)
{
    for(ll i=1;i<=n;++i)dep[i]=0,cur[i]=last[i];
    std::queue<ll>q;
    dep[s]=1,q.push(s);
    while(q.size())
    {
        ll u=q.front();q.pop();
        for(ll i=last[u];i;i=e[i].nxt)
        {
            ll v=e[i].v;
            if(!dep[v]&&e[i].w>0)dep[v]=dep[u]+1,q.push(v);
        }
    }
    return dep[t];
}
ll ex_flow(ll u,ll t,ll flow=INF)
{
    if(u==t)return flow;
    ll f=0;
    for(ll &i=cur[u];i;i=e[i].nxt)
    {
        ll v=e[i].v;
        if(dep[v]==dep[u]+1&&e[i].w>0)
        {
            ll tmp=ex_flow(v,t,min(e[i].w,flow-f));
            e[i].w-=tmp,e[i^1].w+=tmp;
            f+=tmp;
            if(f==flow)return f;
        }
    }
    return f;
}
ll Dinic(ll s,ll t,ll n)
{
    ll ans=0;
    while(bfs(s,t,n))ans+=ex_flow(s,t);
    return ans;
}
ll a[MAXN],b[MAXN];
int main()
{
    ll m=read(),n=read(),s=m+n+1,t=m+n+2,sumr=0;
    for(ll i=1;i<=m;++i)a[i]=read(),sumr+=a[i],adde(s,i,a[i]);
    for(ll i=m+1;i<=m+n;++i)b[i]=read(),adde(i,t,b[i]);
    for(ll i=1;i<=m;++i)
        for(ll j=m+1;j<=m+n;++j)adde(i,j,1);
    if(Dinic(s,t,t)<sumr)return puts("0"),0;
    puts("1");
    for(ll u=1;u<=m;++u)
    {
        for(ll i=last[u];i;i=e[i].nxt)
            if(e[i].v>m&&e[i].v<=m+n&&!e[i].w)printf("%lld ",e[i].v-m);
        puts("");
    }

    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/17003/
   。


#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 430, M = (150 * 270 + N) * 2, INF = 1e8;

int m, n, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &m, &n);
    S = 0, T = m + n + 1;
    memset(h, -1, sizeof h);

    int tot = 0;
    for (int i = 1; i <= m; i ++ )
    {
        int c;
        scanf("%d", &c);
        add(S, i, c);
        tot += c;
    }
    for (int i = 1; i <= n; i ++ )
    {
        int c;
        scanf("%d", &c);
        add(m + i, T, c);
    }
    for (int i = 1; i <= m; i ++ )
        for (int j = 1; j <= n; j ++ )
            add(i, m + j, 1);

    if (dinic() != tot) puts("0");
    else
    {
        puts("1");
        for (int i = 1; i <= m; i ++ )
        {
            for (int j = h[i]; ~j; j = ne[j])
                if (e[j] > m && e[j] <= m + n && !f[j])
                    printf("%d ", e[j] - m);
            puts("");
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/412450/
   。

您们以前都写过？？
只有我一个人是第一次学第一次写是嘛。。。

#include <cstring>
#include <iostream>

using namespace std;

const int N=425,M=81845;
const int INF=0x3ffffff;

int n,m;
int S,T,sum,res;
int h[N],e[M],ne[M],idx;
int depth[N],w[M];
int q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(depth,0,sizeof depth);
    depth[S]=1,*q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!depth[e[i]]&&w[i])
            {
                depth[e[i]]=depth[t]+1;
                q[++tt]=e[i];
                if(e[i]==T)return true;
            }
    }
    return false;
}

int dfs(int u,int s)
{
    if(u==T)return s;
    int f=0;
    for(int i=h[u];i;i=ne[i])
        if(w[i]&&depth[e[i]]==depth[u]+1)
        {
            int v=dfs(e[i],min(s,w[i]));
            w[(i-1^1)+1]+=v;
            w[i]-=v;
            s-=v,f+=v;
        }
    if(!f)depth[u]=-1;
    return f;
}

int main()
{
    scanf("%d%d",&n,&m);
    S=0,T=m+n+1;
    for(int i=1;i<=n;i++)
    {
        int R;
        scanf("%d",&R);
        sum+=R;
        add(S,i,R);
        add(i,S,0);
    }
    for(int i=1;i<=m;i++)
    {
        int C;
        scanf("%d",&C);
        add(i+n,T,C);
        add(T,i+n,0);
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            add(i,j+n,1);
            add(j+n,i,0);
        }
    while(bfs())res+=dfs(S,INF);
    if(res^sum)return putchar(0x30),0;
    putchar(0x31);
    for(int u=1;putchar(10),u<=n;u++)
        for(int i=h[u];i;i=ne[i])
            if(e[i]!=S&&!w[i])
                printf("%d ",e[i]-n);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/402049/
   。

AcWing 2188. 无源汇上下界可行流    原题链接    中等
作者：    whsstory ,  2020-07-25 21:38:39 ,  阅读 209

9


1
更好的阅读体验：My blog

浅谈上下界网络流
参考资料：liu_runda’s blog,red’s blog

PS:左侧可以跳转

无源汇有上下界可行流(循环流)
给一个网络，求一个流满足：每条边ii流量在[low(i),upp(i)][low(i),upp(i)]之间，每个点uu都要满足流量守恒(即∑toi=uf(i)=∑fromi=uf(i)∑toi=uf(i)=∑fromi=uf(i))

[HTML_REMOVED]

可行流算法的核心是将一个不满足流量守恒的初始流调整成满足流量守恒的流. -liu_runda

初始流即一开始将每条边流量设为low(i)low(i)的流。显然这个流不一定满足流量守恒。我们要通过调整（再加上一个附加流）将其变为可行流

记a(u)=∑toi=uf(i)−∑fromi=uf(i)a(u)=∑toi=uf(i)−∑fromi=uf(i),即初始流中，点uu的流入量-流出量。

在附加流中，让点uu的流入量-流出量=−a(u)−a(u),就能保证流量守恒。

当−a(u)<0 (a(u)>0)−a(u)<0 (a(u)>0),需要让uu的流入量增加a(u)a(u).这可以通过新建超级源点SS,并增加S→u,S→u,容量为a(u)a(u)的边做到。
当−a(u)>0 (a(u)<0)−a(u)>0 (a(u)<0)需要让uu的流出量增加a(u)a(u).这可以通过新建超级汇点TT,并增加u→T,u→T,容量为−a(u)−a(u)的边做到。
另外，对于原图中的边ii,还有upp(i)−low(i)upp(i)−low(i)的容量，也要加上。

与S,TS,T相邻的边都满流 加上附加流后每个点都满足流量守恒

因此，跑一下SS到TT的最大流，若与S,TS,T相邻的边都满流，则存在可行流。每条边的具体流量即为low(i)+ilow(i)+i在附加流中的流量（即反边容量）。

ll Dinic(ll s,ll t,ll n){....}
//略去了Dinic板子
ll a[MAXN],low[MAXM],upp[MAXM];
int main()
{
    ll n=read(),m=read(),S=n+1,T=S+1;
    for(ll i=1;i<=m;++i)
    {
        ll u=read(),v=read();low[i]=read(),upp[i]=read();
        a[u]-=low[i],a[v]+=low[i];adde(u,v,upp[i]-low[i]);
    }
    ll sum=0;
    for(ll i=1;i<=n;++i)
        if(a[i]>0)sum+=a[i],adde(S,i,a[i]);
        else if(a[i]<0)adde(i,T,-a[i]);
    ll f=Dinic(S,T,T);
    if(f<sum)return puts("NO")&0;
    puts("YES");
    for(ll i=1;i<=m;++i)printf("%lld\n",e[i<<1|1].w+low[i]);//e[i<<1|1].w表示反边容量，即附加流中的流量
    return 0;
}
有源汇有上下界最大流
在有源汇的网络流图中，源点rSrS、汇点rTrT不满足流量守恒，无法直接跑循环流。

但只要加一条rT→rSrT→rS,下界为0上界为正无穷的边，就能保证流量守恒。跑一下超源SS到TT的最大流，得到可行流，可行流中rT→rSrT→rS的流量即为rS→rTrS→rT的真正流量，记为f1f1.

删掉rT→rSrT→rS的边，再跑一次rS→rTrS→rT的最大流f2f2,答案即为f1+f2f1+f2
My code

有源汇有上下界最小流
基本与前者类似，用f1f1减掉rTrT流向rSrS的最大流f3f3(即回退这些流)即为答案。
My code

作者：whsstory
链接：https://www.acwing.com/solution/content/17067/
   。



#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 210, M = (10200 + N) * 2, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], l[M], ne[M], idx;
int q[N], d[N], cur[N], A[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = d - c, l[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        add(a, b, c, d);
        A[a] -= c, A[b] += c;
    }

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        if (A[i] > 0) add(S, i, 0, A[i]), tot += A[i];
        else if (A[i] < 0) add(i, T, 0, -A[i]);

    if (dinic() != tot) puts("NO");
    else
    {
        puts("YES");
        for (int i = 0; i < m * 2; i += 2)
            printf("%d\n", f[i ^ 1] + l[i]);
    }
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/412492/
   。

写了个玄学dinic。。

#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>

using namespace std;

const int N=210;
const int M=60210;
const int INF=0x3fffffff;

int n,m,S,T;
int sum,flow;
int h[N],e[M],w[M],ne[M],idx;
int up[M],down[M];
int in[N],out[N];
int q[N],hh,tt;
int depth[N];

inline void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(depth,0,sizeof depth);
    depth[S]=1,*q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!depth[e[i]]&&w[i]>0)
            {
                depth[e[i]]=depth[t]+1;
                q[++tt]=e[i];
            }
    }
    return depth[T]>0;
}

int dfs(int u,int s)
{
    if(u==T||s<=0)return s;
    int f=s;
    for(int i=h[u];i;i=ne[i])
        if(depth[e[i]]==depth[u]+1&&w[i]>0)
        {
            int v=dfs(e[i],min(f,w[i]));
            if(v<=0)depth[e[i]]=-2;
            w[(i-1^1)+1]+=v;
            w[i]-=v;
            f-=v;
            if(f<=0)break;
        }
    return s-f;
}

int main()
{
    scanf("%d%d",&n,&m);
    S=0,T=n+1;
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d%d%d",&u,&v,down+i,up+i);
        in[v]+=down[i],out[u]+=down[i];
        add(u,v,up[i]-down[i]);
        add(v,u,0);
    }
    for(int i=1;i<=n;i++)
        if(in[i]>=out[i])
        {
            add(S,i,in[i]-out[i]);
            add(i,S,0);
            sum+=in[i]-out[i];
        }
        else
        {
            add(i,T,out[i]-in[i]);
            add(T,i,0);
        }
    while(bfs())flow+=dfs(S,INF);
    if(flow!=sum)
    {
        puts("NO");
        return 0;
    }
    puts("YES");
    for(int i=1;i<=m;i++)printf("%d\n",down[i]+w[i<<1]);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/402171/
   。


cWing 2189. 有源汇上下界最大流    原题链接    中等
作者：    stoYZMorz ,  2020-08-03 11:46:41 ,  阅读 93

1


算法1
(dinic)
前面的思路大家阔以看一下无源上下界可行流
这里说一下不太好理解的部分
第一次跑完最大流之后求得的是流满下界的流
那么图里还剩许多s到t的自由流。
所以剩下的把st和ed删掉。把与st和ed相连的边也删掉。
然后在剩下的图上跑一次从s到t的最大流即可。
那么最终答案就是流满下界的流+残余的自由流

时间复杂度
参考文献
https://blog.csdn.net/Hanks_o/article/details/77984623

C++ 代码
//代码直接cv y总的了,y总的代码总是很好理解
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 210, M = (N + 10000) * 2, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N], A[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int s, t;
    scanf("%d%d%d%d", &n, &m, &s, &t);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        add(a, b, d - c);
        A[a] -= c, A[b] += c;
    }

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        if (A[i] > 0) add(S, i, A[i]), tot += A[i];
        else if (A[i] < 0) add(i, T, -A[i]);

    add(t, s, INF);
    if (dinic() < tot) puts("No Solution");
    else
    {
        int res = f[idx - 1];
        S = s, T = t;
        f[idx - 1] = f[idx - 2] = 0;
        printf("%d\n", res + dinic());
    }

    return 0;
}

作者：stoYZMorz
链接：https://www.acwing.com/solution/content/17634/
   。



2


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 210, M = (N + 10000) * 2, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N], A[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int s, t;
    scanf("%d%d%d%d", &n, &m, &s, &t);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        add(a, b, d - c);
        A[a] -= c, A[b] += c;
    }

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        if (A[i] > 0) add(S, i, A[i]), tot += A[i];
        else if (A[i] < 0) add(i, T, -A[i]);

    add(t, s, INF);
    if (dinic() < tot) puts("No Solution");
    else
    {
        int res = f[idx - 1];
        S = s, T = t;
        f[idx - 1] = f[idx - 2] = 0;
        printf("%d\n", res + dinic());
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/413441/
   。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=205;
const int M=20405;
const int INF=0x3fffffff;

int n,m,S,T,sum;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],A[N];
int q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    int s,t;
    scanf("%d%d%d%d",&n,&m,&s,&t);
    S=0,T=n+1;
    for(int i=0;i<m;i++)
    {
        int a,b,c,d;
        scanf("%d%d%d%d",&a,&b,&c,&d);
        add(a,b,d-c),add(b,a,0);
        A[a]-=c,A[b]+=c;
    }
    for(int i=1;i<=n;i++)
        if(A[i]>0)add(S,i,A[i]),add(i,S,0),sum+=A[i];
        else if(A[i]<0)add(i,T,-A[i]),add(T,i,0);
    add(t,s,INF),add(s,t,0);
    if(dinic()!=sum)puts("No Solution");
    else
    {
        int flow=w[idx];
        w[idx]=w[idx-1]=0;
        S=s,T=t;
        printf("%d\n",flow+dinic());
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/418575/
   。


'''
转换成有源点，有汇点，流量上下界约束的最小流模型
用Dinic算法求解即可
'''
INF = 0x7fffffffffffffff
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def Dinic(self, rev_edge_w = None):                 # rev_edge_w是反向边边权，默认都是0
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for i, (a, b, w) in enumerate(self.edges):
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            if rev_edge_w is not None:
                f[idx] = rev_edge_w[i]

            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, INF)

        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]

from collections import Counter
n, m, S, T = map(int, input().split())
SS, TT = n+1, n+2
edges = []
L = []
sum1, sum2 = Counter(), Counter()
for _ in range(m):
    a, b, l, u = map(int, input().split())
    edges.append((a, b, u-l))
    L.append(l)
    sum1[b] += l
    sum2[a] += l

# T和S间建立一条虚拟边
edges.append((T, S, INF))
sum1[S] += 0
sum2[T] += 0

for node in range(1, n+1):
    v1 = 0 if node not in sum1 else sum1[node]
    v2 = 0 if node not in sum2 else sum2[node]
    if v1 > v2:
        edges.append((SS, node, v1-v2))
    else:
        edges.append((node, TT, v2-v1))

algo = FortdFulkerson(edges, SS, TT, max_node_num=n+2, max_edge_num=len(edges))
ans = algo.Dinic()

F1 = 0
# 验证满流
flag = True
for a, b, f, w in ans[1]:
    if a == SS and f != w:
        flag = False
        break

    if w == INF:
        F1 = f

if not flag:
    print('No Solution')

else:
    # 再构建第二轮的图，求S到T的最大流，最后叠加结果
    e = []
    rev_w = []
    for a, b, f, w in ans[1]:
        if a >= 1 and a <= n and b >= 1 and b <= n and w != INF and w-f > 0:
            e.append((a, b, w-f))
            rev_w.append(f)     # 反向边的边权值
    algo = FortdFulkerson(e, T, S, max_node_num=n, max_edge_num=len(e))
    ans = algo.Dinic(rev_w)
    F2 = ans[0]
    ans = F1 - F2

    print(ans)



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21155/
   。


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 50010, M = (N + 125003) * 2, INF = 2147483647;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N], A[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int s, t;
    scanf("%d%d%d%d", &n, &m, &s, &t);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        add(a, b, d - c);
        A[a] -= c, A[b] += c;
    }

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        if (A[i] > 0) add(S, i, A[i]), tot += A[i];
        else if (A[i] < 0) add(i, T, -A[i]);

    add(t, s, INF);

    if (dinic() < tot) puts("No Solution");
    else
    {
        int res = f[idx - 1];
        S = t, T = s;
        f[idx - 1] = f[idx - 2] = 0;
        printf("%d\n", res - dinic());
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/413437/
   。

新建超级源点SS,向所有源点连容量为+∞+∞的边即可。汇点同理。问题即转化为普通最大流问题。

ll Dinic(ll s,ll t,ll n)
{
    ll res=0;
    while(bfs(s,t,n))res+=ex_flow(s,t);
    return res;
}
int main()
{
    ll n=read(),m=read(),sc=read(),tc=read(),S=n+1,T=n+2;
    for(ll i=1;i<=sc;++i)adde(S,read(),INF);
    for(ll i=1;i<=tc;++i)adde(read(),T,INF);
    while(m--)
    {
        ll u=read(),v=read(),w=read();
        adde(u,v,w);
    }
    printf("%lld",Dinic(S,T,T));
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/17483/
   。



1


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010, M = (100000 + N) * 2, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int sc, tc;
    scanf("%d%d%d%d", &n, &m, &sc, &tc);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    while (sc -- )
    {
        int x;
        scanf("%d", &x);
        add(S, x, INF);
    }
    while (tc -- )
    {
        int x;
        scanf("%d", &x);
        add(x, T, INF);
    }

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    printf("%d\n", dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/413457/
   。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=10005;
const int M=220005;
const int INF=0x3fffffff;

int n,m,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    int sc,tc;
    scanf("%d%d%d%d",&n,&m,&sc,&tc);
    S=0,T=n+1;
    for(int x;sc--;)
    {
        scanf("%d",&x);
        add(S,x,INF);
        add(x,S,0);
    }
    for(int x;tc--;)
    {
        scanf("%d",&x);
        add(x,T,INF);
        add(T,x,0);
    }
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c),add(b,a,0);
    }
    printf("%d\n",dinic());
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/418593/
   。

AcWing 2236. 伊基的故事 I - 道路重建    原题链接    中等
作者：    皓首不倦 ,  2020-09-22 15:58:19 ,  阅读 23

0




'''
查找流量图的关键边，输出关键边的数量即可
'''


from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 获取关键路径的标号列表，标号从0开始编号
    def getKeyEdges(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)  # 原图中有向边的流量

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                    # 更新原图边的流量
                    if self.edges[idx >> 1][0] == node:
                        orig_flow[idx >> 1] += t
                    else:
                        orig_flow[idx >> 1] -= t

                idx = ne[idx]

            return flow


        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            dfs(self.source_node, 0x7fffffff)

        # 筛选满流的边
        candi_e = []
        for i in range(len(self.edges)):
            if self.edges[i][2] == orig_flow[i]:
                candi_e.append(i)

        s_reachable = set() # S能够到的点
        t_reachable = set() # 能够到T的点

        # 从S和T分别正向和反向搜索能够到的点
        def travel(cur, visit):
            visit[cur] = 1
            s_reachable.add(cur)

            idx = h[cur]
            while idx != -1:
                next_node = e[idx]
                if visit[next_node] == 0 and f[idx] > 0:
                    travel(next_node, visit)

                idx = ne[idx]

        def rev_travle(cur, visit):
            visit[cur] = 1
            t_reachable.add(cur)

            idx = h[cur]
            while idx != -1:
                next_node = e[idx]
                if visit[next_node] == 0 and f[idx] != self.edges[idx>>1][2]:
                    # 方向边没有满流，等价于正向边还有流量可以用，next_node就可以沿着正向边到cur
                    rev_travle(next_node, visit)

                idx = ne[idx]

        travel(self.source_node, [0] * (self.max_node_num + 1))
        rev_travle(self.end_node, [0] * (self.max_node_num + 1))

        ans = []
        for edge_idx in candi_e:
            a, b, _ = self.edges[edge_idx]
            if a in s_reachable and b in t_reachable:
                ans.append(edge_idx)
        return ans


n, m = map(int, input().split())
e = []
for _ in range(m):
    a, b, w = map(int, input().split())
    a, b = a + 1, b + 1
    e.append((a, b, w))

algo = FortdFulkerson(e, 1, n, max_node_num=n, max_edge_num=len(e))
print(len(algo.getKeyEdges()))

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21165/
   。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=505;
const int M=10005;
const int INF=0x3fffffff;

int n,m,S,T,ans;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;
bool vis_s[N],vis_t[N];

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

void dfs(int u,int type,bool vis[])
{
    vis[u]=true;
    for(int i=h[u];i;i=ne[i])
        if(!vis[e[i]]&&w[i^type])
            dfs(e[i],type,vis);
}

int main()
{
    scanf("%d%d",&n,&m);
    S=0,T=n-1;
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c),add(b,a,0);
    }
    while(bfs())while(find(S,INF));
    dfs(S,0,vis_s),dfs(T,1,vis_t);
    for(int i=0;i<n;i++)
        if(vis_s[i])
            for(int j=h[i];j;j=ne[j])
                if(!(j&1)&&vis_t[e[j]])
                    ans++;
    printf("%d\n",ans);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/418613/
   。



1


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 510, M = 10010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
bool vis_s[N], vis_t[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

void dfs(int u, bool st[], int t)
{
    st[u] = true;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = i ^ t, ver = e[i];
        if (f[j] && !st[ver])
            dfs(ver, st, t);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n - 1;
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    dinic();
    dfs(S, vis_s, 0);
    dfs(T, vis_t, 1);

    int res = 0;
    for (int i = 0; i < m * 2; i += 2)
        if (!f[i] && vis_s[e[i ^ 1]] && vis_t[e[i]])
            res ++ ;

    printf("%d\n", res);
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/413522/
   。


AcWing 2277. 秘密挤奶机    原题链接    困难
作者：    皓首不倦 ,  2020-09-22 18:02:20 ,  阅读 25

1



'''
对边权值的上界进行二分搜索，验证上界是否有满足条件的路径方案存在
判断时候将所有边权值大于上界的边删掉，剩下的边每一条边拆成正反
两个方向的权值是1的有向边组成有向图，求有向图中1到N的最大流f
f数值就等价于从1到N的没有公共边的路径条数

需要注意的是原图是无向图，一条边拆出来的两条有向边是不能同时使用的，
但是特殊点在于，如果最大流两条边都使用了，那把这两条边上流过的流量删掉
剩下的流依然是一个最大流，所以任意一个最大流都必然能找到一个没有同时用
两条有向边的最大流与其对应，所以不考虑成对的有向边同时使用这个约束，
并不影响最后答案


'''

from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]

n, m, t = map(int, input().split())
s = set()
edges = []
for _ in range(m):
    a, b, w  = map(int, input().split())
    s.add(w)
    edges.append((a, b, w))

edge_len = list(s)
edge_len.sort()


def valid(max_len) -> bool:
    e = [(a, b, 1) for a, b, w in edges if w <= max_len]
    e.extend([(b, a, 1) for a, b, w in edges if w <= max_len])
    algo = FortdFulkerson(e, 1, n, max_node_num=n, max_edge_num=len(e))
    return algo.getMaxFlow()[0] >= t

l, r = 0, len(edge_len)-1
ans = None
while l <= r:
    mid = l + (r-l) // 2
    if valid(edge_len[mid]):
        ans = edge_len[mid]
        r = mid - 1
    else:
        l = mid + 1

print(ans)

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21175/
   。

    在残留网络中不需要把原图中每条边对应的四条边都建出来
建两条方向相同的边，在残留网络中相当于是建了一条容量为两条边的和的边
所以只用建正向边和反向边即可，不需要建容量为 00 的边

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=205;
const int M=80010;
const int INF=0x3fffffff;

int n,m,t,S,T;
int e[M],w[M],p[M],ne[M],idx=1;
int h[N],d[N],cur[N];
int q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    p[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

bool check(int x)
{
    for(int i=1;i<=idx;i++)
        w[i]=p[i]<=x;
    return dinic()>=t;
}

int main()
{
    scanf("%d %d %d",&n,&m,&t);
    S=1,T=n;
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c),add(b,a,c);
    }
    int l=1,r=1e6+5;
    while(l<r)
    {
        int mid=l+r>>1;
        if(check(mid))r=mid;
        else    l=mid+1;
    }
    printf("%d\n",r);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/423471/
   。
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 210, M = 80010, INF = 1e8;

int n, m, K, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, w[idx] = c, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

bool check(int mid)
{
    for (int i = 0; i < idx; i ++ )
        if (w[i] > mid) f[i] = 0;
        else f[i] = 1;

    return dinic() >= K;
}

int main()
{
    scanf("%d%d%d", &n, &m, &K);
    S = 1, T = n;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    int l = 1, r = 1e6;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    printf("%d\n", r);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/423599/
   。

二分答案 xx，将 ≤x≤x 的边加入，跑一个网络流看是否可行即可。

复杂度 O(n2PlogP)O(n2Plog⁡P)
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 205, M = 40005, INF = 1e9;

int n, m, T, A[M], B[M], L[M], W[M], len;

int q[N], d[N], cur[N];

int head[N], numE;

struct E{
    int next, v, w;
} e[M * 4];

void inline add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
    e[++numE] = (E) { head[v], u, 0 };
    head[v] = numE;
}

bool inline bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = 1, d[1] = 1, cur[1] = head[1];
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (!d[v] && e[i].w) {
                d[v] = d[u] + 1, q[++tt] = v, cur[v] = head[v];
                if (v == n) return true;
            }
        }
    }
    return false;
}

int inline dinic(int u, int flow) {
    if (u == n) return flow;
    int rest = flow;
    for (int i = cur[u]; i && rest; i = e[i].next) {
        int v = e[i].v; cur[u] = i;
        if (d[v] == d[u] + 1 && e[i].w) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, e[i ^ 1].w += k, rest -= k;
        }
    }
    return flow - rest;
}

bool inline check(int x) {
    memset(head, 0, sizeof head);
    numE = 1;
    for (int i = 1; i <= m; i++) 
        if (L[i] <= x) add(A[i], B[i], 1), add(B[i], A[i], 1);
    int ans = 0, res;
    while (bfs())
        while (res = dinic(1, INF)) ans += res;
    return ans >= T;
}

int main() {
    scanf("%d%d%d", &n, &m, &T);
    for (int i = 1; i <= m; i++) scanf("%d%d%d", A + i, B + i, L + i), W[i] = L[i];
    sort(W + 1, W + 1 + m);
    len = unique(W + 1, W + 1 + m) - W - 1;
    int l = 1, r = len;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (check(W[mid])) r = mid;
        else l = mid + 1;
    }
    printf("%d\n", W[r]);
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/426017/
   。

二分 Dinic
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 210, M = 80010, INF = 0x3f3f3f3f;

int h[N], e[M], f[M], w[M], ne[M], idx;
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, w[idx] = c, ne[idx] = h[b], h[b] = idx ++;
}


int n, m, K;
int S, T;

int hs[N], d[N], q[N];

bool bfs()
{
    int hh = 0, tt = -1;
    memset(d, -1, sizeof d);
    d[S] = 0;
    hs[S] = h[S];
    q[ ++ tt] = S;

    while(hh <= tt)
    {
        int u = q[hh ++];

        for(int i = h[u]; ~i; i = ne[i])
        {
            int j = e[i];
            if(d[j] == -1 and f[i])
            {
                d[j] = d[u] + 1;
                hs[j] = h[j];
                if(j == T)  return true;
                q[ ++ tt] = j;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if(u == T)  return limit;

    int flow = 0;
    for(int i = hs[u]; ~i and flow < limit; i = ne[i])
    {
        hs[u] = i;
        int j = e[i];
        if(d[j] == d[u] + 1 and f[i])
        {
            int t = find(j, min(f[i], limit - flow));
            if(!t)  d[j] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int res = 0, flow;
    while(bfs())  while(flow = find(S, INF))  res += flow;
    return res;
}

bool check(int mid)
{
    for(int i = 0; i < idx; i ++)
        f[i] = w[i] <= mid;

    return dinic() >= K;
}

int main()
{
    memset(h, -1, sizeof h);
    scanf("%d%d%d", &n, &m, &K);
    S = 1, T = n;

    while(m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    int l = 1, r = 1e6;
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid))  r = mid;
        else  l = mid + 1;
    }
    printf("%d\n", l);
    return 0;
}

作者：滑稽_ωﾉ
链接：https://www.acwing.com/activity/content/code/content/424371/
   。

AcWing 2187. 星际转移问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-22 22:21:38 ,  阅读 35

0





from typing import List
from collections import deque

INF = 0x7fffffffffffffff
class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def Dinic(self, rev_edge_w = None):                 # rev_edge_w是反向边边权，默认都是0
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for i, (a, b, w) in enumerate(self.edges):
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            if rev_edge_w is not None:
                f[idx] = rev_edge_w[i]

            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, INF)

        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]



class MergeSetExt:
    def __init__(self, max_key_val = 0, trans_key_func=None):
        if trans_key_func is not None and max_key_val > 0:
            # 如果能够提供转换key的回调，并查集内部用线性表存储
            self.trans_key_callback = trans_key_func
            self.m = [-1 for _ in range(max_key_val+1)]
            self.__root2cluster_size = [0 for _ in range(max_key_val+1)]
        else:
            # 如果不能提供转换key的回调，并查集内部用hash表存储
            self.trans_key_callback = None
            self.m = {}
            self.__root2cluster_size = {}
        self.__root_cnt = 0

    def getRoot(self, node):
        buf = []
        root = self.trans_key_callback(node) if self.trans_key_callback else node
        while self.m[root] != root:
            buf.append(root)
            root = self.m[root]
        for key in buf:
            self.m[key] = root

        return root

    def merge(self, a, b):
        orig_a, orig_b = a, b
        if self.trans_key_callback:
            a, b = self.trans_key_callback(a), self.trans_key_callback(b)

        for node in [a, b]:
            if (self.trans_key_callback is None and node not in self.m) or (self.trans_key_callback is not None and self.m[node] == -1):
                self.m[node] = node
                self.__root2cluster_size[node] = 1
                self.__root_cnt += 1

        root1 = self.getRoot(orig_a)
        root2 = self.getRoot(orig_b)
        if root1 != root2:
            self.m[root1] = root2

            self.__root2cluster_size[root2] += self.__root2cluster_size[root1]
            if self.trans_key_callback:
                self.__root2cluster_size[root1] = 0
            else:
                self.__root2cluster_size.pop(root1)
            self.__root_cnt -= 1

    def isInSameSet(self, a, b):
        if a == b:
            return True

        orig_a, orig_b = a, b
        if self.trans_key_callback:
            a, b = self.trans_key_callback(a), self.trans_key_callback(b)

            for node in [a, b]:
                if self.m[node] == -1:
                    return False
        else:
            for node in [orig_a, orig_b]:
                if node not in self.m:
                    return False

        return self.getRoot(orig_a) == self.getRoot(orig_b)


n, m, k = map(int, input().split())
H = [0] * m     # H[i]是编号是i的飞船的容量
P = []          # P[i]是编号是i的飞船的路线中的位置列表
for i in range(m):
    arr = list(map(int, input().split()))
    H[i] = arr[0]
    P.append(arr[2:])

merge_set = MergeSetExt(n+2, lambda x: x)
for p in P:
    last_val = None
    for i, val in enumerate(p):
        if val == 0:
            val = n+1
        elif val == -1:
            p[i] = n+1      # 月球的编号换成n+1, 方便后面建图
            val = n+2

        if last_val is not None:
            merge_set.merge(last_val, val)
        last_val = val

if not merge_set.isInSameSet(n+1, n+2):
    # 地球和月球不可达
    print(0)

else:

    # <i, j>二元组转换成节点编号
    def pos2idx(i, j):
        return 3 + (i * (n+2)) + j

    S, T = 1, 2

    d = 0
    edges = []
    f = []          # f[idx]是编号是idx的边已经用掉的流量

    total_flow = 0
    while True:
        if d == 0:
            edges.append((S, pos2idx(0, 0), k))
            f.append(0)

        else:
            for j in range(0, n+2):
                edges.append((pos2idx(d-1, j), pos2idx(d, j), INF))
                f.append(0)

            edges.append((pos2idx(d, n+1), T, INF))
            f.append(0)

            for i, p in enumerate(P):
                last_pos = p[(d-1) % len(p)]
                cur_pos = p[d % len(p)]
                edges.append((pos2idx(d-1, last_pos), pos2idx(d, cur_pos), H[i]))
                f.append(0)

            e = [(a, b, w-f) for (a, b, w), f in zip(edges, f)]
            max_flow, new_edges = FortdFulkerson(e, S, T, (d+1)*(n+2)+2, len(e)).Dinic(rev_edge_w=f)
            total_flow += max_flow
            if total_flow == k:
                print(d)
                break

            new_f = [flow for _, _, flow, _ in new_edges]
            for i, val in enumerate(f):
                new_f[i] += f[i]

            f = new_f

        d += 1


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21200/
   。

手残打错一个变量名。。调了俩小时。。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=11255;
const int M=54005;
const int INF=0x3fffffff;

int n,m,k,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;
struct Ship
{
    int h,r,id[15];
}ships[22];
int p[15];

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

int find(int x)
{
    if(p[x]!=x)p[x]=find(p[x]);
    return p[x];
}

int id(int d,int i)
{
    return d*(n+2)+i;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    scanf("%d%d%d",&n,&m,&k);
    S=0,T=n+1;
    for(int i=1;i<n+2;i++)p[i]=i;
    for(int i=0;i<m;i++)
    {
        scanf("%d%d",&ships[i].h,&ships[i].r);
        for(int j=0;j<ships[i].r;j++)
        {
            scanf("%d",&ships[i].id[j]);
            if(!~ships[i].id[j])ships[i].id[j]=n+1;
            if(j)p[find(ships[i].id[j-1])]=find(ships[i].id[j]);
        }
    }
    if(find(0)!=find(n+1))puts("0");
    else
    {
        for(int ans=1,flow=0;;ans++)
        {
            for(int i=0;i<m;i++)
            {
                const Ship &s=ships[i];
                int u=(ans-1)%s.r,v=ans%s.r;
                u=id(ans-1,s.id[u]),v=id(ans,s.id[v]);
                add(u,v,s.h),add(v,u,0);
            }
            for(int i=0;i<n+2;i++)
            {
                add(id(ans-1,i),id(ans,i),INF);
                add(id(ans,i),id(ans-1,i),0);
            }
            add(id(ans,n+1),T,INF);
            add(T,id(ans,n+1),INF);
            flow+=dinic();
            if(flow>=k)
            {
                printf("%d\n",ans);
                break;
            }
        }
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/423651/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1101 * 22 + 10, M = (N + 1100 + 13 * 1101) + 10, INF = 1e8;

int n, m, k, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
struct Ship
{
    int h, r, id[30];
}ships[30];
int p[30];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int get(int i, int day)
{
    return day * (n + 2) + i;
}

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d%d", &n, &m, &k);
    S = N - 2, T = N - 1;
    memset(h, -1, sizeof h);
    for (int i = 0; i < 30; i ++ ) p[i] = i;
    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        ships[i] = {a, b};
        for (int j = 0; j < b; j ++ )
        {
            int id;
            scanf("%d", &id);
            if (id == -1) id = n + 1;
            ships[i].id[j] = id;
            if (j)
            {
                int x = ships[i].id[j - 1];
                p[find(x)] = find(id);
            }
        }
    }
    if (find(0) != find(n + 1)) puts("0");
    else
    {
        add(S, get(0, 0), k);
        add(get(n + 1, 0), T, INF);
        int day = 1, res = 0;
        while (true)
        {
            add(get(n + 1, day), T, INF);
            for (int i = 0; i <= n + 1; i ++ )
                add(get(i, day - 1), get(i, day), INF);
            for (int i = 0; i < m; i ++ )
            {
                int r = ships[i].r;
                int a = ships[i].id[(day - 1) % r], b = ships[i].id[day % r];
                add(get(a, day - 1), get(b, day), ships[i].h);
            }
            res += dinic();
            if (res >= k) break;
            day ++ ;
        }

        printf("%d\n", day);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/423677/
   。

又做过，copy！

星际转移问题
隐约的感知到，每个人从地球到月球从图论的角度上来说构成一条路径，每个人又可以抽象成单位 11 的流，所以这题就是网络流？但是由于天数时间轴的影响不能直接建图。所以这题解启示我们建立分层图，即某天的一个位置抽象为为一个图中的节点。

题意中的两种决策乘坐飞船、下船等待可以抽象成两种边（由于具有传递性所以只需连接一步操作的节点）。不过还要注意的是每天地球和月球的边要注意和源点和汇点进行联系，进而达到图题一体的模式。

乘坐飞船走：对于一条飞船上的路径，一天对应位置的节点 ⇒⇒ 后一天对应位置的节点，流量为 H[i]H[i] ，表示通过这种方式最多可以送走 H[i]H[i] 人
下船等待：某位置一天的节点 ⇒⇒ 下一天同一位置的节点，流量无限
源点向每天的地球连边无限，每天月球向汇点连接无限
发现二分复杂度是冗余的，不妨从小到大枚举时间。

考虑存在情况的最坏情况下的时间，一条路径肯定没有环（不然可以不走环），所以一条链最长有 m+2m+2 个点， m+1m+1 条边，可能一个循环才能跑一次，所以每转移一条边 n+2n+2 个时间。所以时间最多 (m+2)∗(n+2)<=330(m+2)∗(n+2)<=330，所以枚举到 330330 就行了。。总复杂度 (N+M+11500∗4950‾‾‾‾‾√)(N+M+11500∗4950)，一看就跑得很快。（这里的复杂度由于边加边边在残余网络上跑，所以貌似是这个复杂度 # 我也不确定）

#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
const int N = 14, M = 21, S = 55, L = 5000, INF = 1e9, LM = 23500;
int n, m, s, t, K, p[M], r[M], h[M][N + 2], q[L], d[L], maxflow, flow;
int head[L], numE = 1;
struct E{
    int next, v, w;
} e[LM];
void add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
}
void addEdge(int u, int v, int w) {
    add(u, v, w); add(v, u, 0);
}

bool bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = s, d[s] = 1;
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (e[i].w && !d[v]) {
                d[v] = d[u] + 1;
                q[++tt] = v;
                if (v == t) return true;
            }
        }
    }
    return false;
}

int dinic(int u, int flow) {
    if (u == t) return flow;
    int rest = flow;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].v;
        if (e[i].w && d[v] == d[u] + 1) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, e[i ^ 1].w += k;
            rest -= k;
        }
    }
    return flow - rest;
}

//  第 i 天，第 j 号飞船
int get(int i, int j) {
    if (j == 0) return 3 + i * (n + 2);
    else if(j == -1) return 4 + i * (n + 2);
    return 4 + i * (n + 2) + j;
}


void build(int i) {
    int cnt = 2 + i * (n + 2);
    int st = cnt + 1, ed = cnt + 2;
    addEdge(s, st, INF), addEdge(ed, t, INF);
    for (int j = 1; j <= n; j++) addEdge(get(i - 1, j), get(i, j), INF);
    for (int j = 0; j < m; j++) {
        int u = h[j][(i - 1) % r[j]], v = h[j][i % r[j]];
        addEdge(get(i - 1, u), get(i, v), p[j]);
    }
}

int main() {
    scanf("%d%d%d", &n, &m, &K);
    s = 1, t = 2;
    // 第 0 天的地球和月亮连边
    addEdge(1, 3, INF), addEdge(4, 2, INF);
    for (int i = 0; i < m; i++) {
        scanf("%d%d", p + i, r + i);
        for (int j = 0; j < r[i]; j++) scanf("%d", &h[i][j]);
    }
    for (int t = 1; t <= 330; t++) {
        build(t);
        while (bfs())
            while(flow = dinic(s, INF)) maxflow += flow;
        if (maxflow >= K) {
            printf("%d\n", t);
            return 0;
        }
    }
    puts("0");
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/426047/
   。
AcWing 2240. 餐饮    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 00:17:45 ,  阅读 24

1





'''
把牛拆成两个点，两个点连接容量是1的边，限制每一头牛只能用一次
'''

from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]


n, f, d = map(int, input().split())
edges = []
for i in range(1, n+1):
    edges.append((i, i+n, 1))

S, T = 2*n + f + d + 1, 2*n + f + d + 2
for i in range(1, f+1):
    edges.append((S, i + 2*n, 1))
for i in range(1, d+1):
    edges.append((i + 2*n + f, T, 1))

for i in range(1, n+1):
    arr = list(map(int, input().split()))
    f_num, d_num = arr[0], arr[1]
    ff = arr[2: f_num+2]
    dd = arr[f_num+2:]

    for f_val in ff:
        edges.append((f_val + 2*n, i, 1))
    for d_val in dd:
        edges.append((i+n, d_val+ 2*n + f, 1))

print(FortdFulkerson(edges, S, T, 2 + 2*n + f + d, len(edges)).getMaxFlow()[0])

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21204/
   。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long ll;

const int INF=0x3fffffff;
const int N=405,M=40605;

int n,S,T;
int h[N],e[M],ne[M],w[M],idx=1;
int d[N],cur[N],q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    int F,D;
    scanf("%d%d%d",&n,&F,&D);
    S=n+n+F+D+1,T=S+1;
    for(int i=1;i<=n;i++)
    {
        add(i,n+i,1);
        add(n+i,i,0);
        int fi,di;
        scanf("%d%d",&fi,&di);
        for(int t;fi--;)
        {
            scanf("%d",&t);
            t+=n+n;
            add(t,i,1);
            add(i,t,0);
        }
        for(int t;di--;)
        {
            scanf("%d",&t);
            t+=n+n+F;
            add(n+i,t,1);
            add(t,n+i,0);
        }
    }
    for(int i=1,j=n+n+1;i<=F;i++,j++)
        add(S,j,1),add(j,S,0);
    for(int i=1,j=n+n+F+1;i<=D;i++,j++)
        add(j,T,1),add(T,j,0);
    printf("%d\n",dinic());
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/418650/
   。

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int N = 105, NP = 4 * N, M = N * N * 2 + 2 * N, INF = 1e9;

int n, F, D, idx, fId[N], dId[N], S, T, f[N], c[N];

int d[NP], q[NP], cur[NP];

int head[NP], numE = 1;

struct E{
    int next, v, w;
} e[M << 1];

void inline add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
    e[++numE] = (E) { head[v], u, 0 };
    head[v] = numE;
}

bool inline bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = S, cur[S] = head[S], d[S] = 1;
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (!d[v] && e[i].w) {
                d[v] = d[u] + 1, q[++tt] = v, cur[v] = head[v];
                if (v == T) return true;
            }
        }
    }
    return false;
}

int dinic(int u, int flow) {
    if (u == T) return flow;
    int rest = flow;
    for (int i = cur[u]; i && rest; i = e[i].next) {
        int v = e[i].v; cur[u] = i;
        if (d[v] == d[u] + 1 && e[i].w) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, rest -= k, e[i ^ 1].w += k;
        }
    }
    return flow - rest;
}

int main() {
    scanf("%d%d%d", &n, &F, &D);
    idx = 2 * n; S = ++idx, T = ++idx;
    for (int i = 1; i <= n; i++) add(i, i + n, 1);
    for (int i = 1; i <= F; i++) fId[i] = ++idx, add(S, fId[i], 1);
    for (int i = 1; i <= D; i++) dId[i] = ++idx, add(dId[i], T, 1);
    for (int i = 1; i <= n; i++) {
        int cf, cd, x; scanf("%d%d", &cf, &cd);
        while (cf--) scanf("%d", &x), add(fId[x], i, 1);
        while (cd--) scanf("%d", &x), add(i + n, dId[x], 1);
    }
    int ans = 0, res;
    while (bfs())
        while (res = dinic(S, INF)) ans += res;
    printf("%d\n", ans);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/426072/
   。

将牛拆点即可。

#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
typedef long long ll;
typedef unsigned un;
//typedef std::string str;
typedef std::pair<ll,ll> pll;
typedef std::pair<int,int> pii;
typedef std::pair<double,double> pd;
ll read(){ll x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}return f*x;}
ll max(ll a,ll b){return a>b?a:b;}
ll min(ll a,ll b){return a<b?a:b;}
void umax(ll& a,ll t){if(t>a)a=t;}
bool umin(ll& a,ll t){if(t<a)return a=t,1;return 0;}
const ll INF=1ll<<30;
#define MAXN 200011
struct edge
{
    int v,w,nxt;
}e[MAXN<<1|1];
int cnt=1,last[MAXN];
void add_directed_edge(int u,int v,int w)
{
    e[++cnt].v=v,e[cnt].w=w;
    e[cnt].nxt=last[u],last[u]=cnt;
}
void adde(int u,int v,int w){ add_directed_edge(u,v,w),add_directed_edge(v,u,0);}

int cur[MAXN],dep[MAXN];
bool bfs(int s,int t,int n)
{
    for(int i=1;i<=n;++i)cur[i]=last[i],dep[i]=0;
    std::queue<int>q;
    q.push(s),dep[s]=1;
    while(q.size())
    {
        int u=q.front();q.pop();
        for(int i=last[u];i;i=e[i].nxt)
        {
            int v=e[i].v;
            if(e[i].w&&!dep[v])dep[v]=dep[u]+1,q.push(v);
        }
    }
    return dep[t]>0;
}
int ex_flow(int u,int t,int flow=INF)
{
    if(u==t)return flow;
    int f=0;
    for(int &i=cur[u];i;i=e[i].nxt)
    {
        int v=e[i].v;
        if(e[i].w&&dep[v]==dep[u]+1)
        {
            int tmp=ex_flow(v,t,min(e[i].w,flow-f));
            e[i].w-=tmp,e[i^1].w+=tmp;
            f+=tmp;
            if(f==flow)return f;
        }
    }
    return f;
}
int Dinic(int s,int t,int n)
{
    int res=0;
    while(bfs(s,t,n))res+=ex_flow(s,t);
    return res;
}
int main()
{
    int n=read(),F=read(),D=read(),S=n+n+F+D+1,T=S+1;
    for(int i=1;i<=n;++i)
    {
        adde(i,n+i,1);
        int LF=read(),LD=read();
        while(LF--)adde(n+n+read(),i,1);
        while(LD--)adde(n+i,n+n+F+read(),1);
    }
    for(int i=1;i<=F;++i)adde(S,n+n+i,1);
    for(int i=1;i<=D;++i)adde(n+n+F+i,T,1);
    printf("%d",Dinic(S,T,T));
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/activity/content/code/content/417793/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 410, M = 40610, INF = 1e8;

int n, F, D, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d%d", &n, &F, &D);
    S = 0, T = n * 2 + F + D + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= F; i ++ ) add(S, n * 2 + i, 1);
    for (int i = 1; i <= D; i ++ ) add(n * 2 + F + i, T, 1);
    for (int i = 1; i <= n; i ++ )
    {
        add(i, n + i, 1);
        int a, b, t;
        scanf("%d%d", &a, &b);
        while (a -- )
        {
            scanf("%d", &t);
            add(n * 2 + t, i, 1);
        }
        while (b -- )
        {
            scanf("%d", &t);
            add(i + n, n * 2 + F + t, 1);
        }
    }
    printf("%d\n", dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/423705/
   。
AcWing 2180. 最长递增子序列问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 13:00:56 ,  阅读 28

1





from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]


n = int(input())
arr = list(map(int, input().split()))


# 问题1
# dp[i]是i位置结尾的最长递增子序列长度
dp = [1] * n
for i in range(1, n):
    for j in range(i):
        if arr[j] <= arr[i]:
            dp[i] = max(1 + dp[j], dp[i])

s = max(dp)
ans1 = s


# 问题2
edges = []
mm = {}
for i, f in enumerate(dp):
    if f not in mm:
        mm[f] = []
    mm[f].append((i+1, arr[i]))

for i in range(1, n+1):
    edges.append((i, i+n, 1))

S, T = 2*n + 1, 2*n + 2

for node, _ in mm[1]:
    edges.append((S, node, 1))

for f in range(1, s):
    for node1, val1 in mm[f]:
        for node2, val2 in mm[f+1]:
            if val1 <= val2 and node1 < node2:
                edges.append((node1+n, node2, 1))

for node, _ in mm[s]:
    edges.append((node+n, T, 1))

ans2 = FortdFulkerson(edges, S, T, 2*n+2, len(edges)).getMaxFlow()[0]


# 问题3
if s == 1:
    ans3 = n
else:
    e = []
    for i, (a, b, w) in enumerate(edges):
        if b == 1 or a == 1 or a == n+n or a == n:
            e.append((a, b, 0x7fffffff))
            continue

        e.append((a, b, w))

    ans3 = FortdFulkerson(e, S, T, 2*n+2, len(e)).getMaxFlow()[0]

print(ans1)
print(ans2)
print(ans3)

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21206/
   。

include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010, M = 251010, INF = 1e8;

int n, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
int g[N], w[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d", &n);
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    int s = 0;
    for (int i = 1; i <= n; i ++ )
    {
        add(i, i + n, 1);
        g[i] = 1;
        for (int j = 1; j < i; j ++ )
            if (w[j] <= w[i])
                g[i] = max(g[i], g[j] + 1);
        for (int j = 1; j < i; j ++ )
            if (w[j] <= w[i] && g[j] + 1 == g[i])
                add(n + j, i, 1);
        s = max(s, g[i]);
        if (g[i] == 1) add(S, i, 1);
    }

    for (int i = 1; i <= n; i ++ )
        if (g[i] == s)
            add(n + i, T, 1);

    printf("%d\n", s);
    if (s == 1) printf("%d\n%d\n", n, n);
    else
    {
        int res = dinic();
        printf("%d\n", res);
        for (int i = 0; i < idx; i += 2)
        {
            int a = e[i ^ 1], b = e[i];
            if (a == S && b == 1) f[i] = INF;
            else if (a == 1 && b == n + 1) f[i] = INF;
            else if (a == n && b == n + n) f[i] = INF;
            else if (a == n + n && b == T) f[i] = INF;
        }
        printf("%d\n", res + dinic());
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/423737/
   。

拆点
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=1005;
const int M=250505;
const int INF=0x3f3f3f3f;

int n,S,T,flow;
int a[N],f[N],res;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;

void addedge(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

void add(int a,int b,int c)
{
    addedge(a,b,c),addedge(b,a,0);
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    scanf("%d",&n);
    if(n==1)return puts("1\n1\n1"),0;
    for(int i=1;i<=n;i++)scanf("%d",a+i);
    for(int i=2;i<=n;res=max(res,f[i++]))
        for(int j=1;j<i;j++)
            if(a[i]>=a[j]&&f[i]<=f[j])
                f[i]=f[j]+1;
    printf("%d\n",res+1);
    S=0,T=n+n+1;
    for(int i=1;i<=n;i++)
    {
        add(i,i+n,1);
        if(!f[i])add(S,i,1);
        if(f[i]==res)add(i+n,T,1);
    }
    for(int i=2;i<=n;i++)
        for(int j=1;j<i;j++)
            if(a[i]>=a[j]&&f[i]==f[j]+1)
                add(j+n,i,1);
    flow=dinic();
    printf("%d\n",flow);
    add(S,1,INF),add(1,n+1,INF);
    if(f[n]==res)add(n<<1,T,INF),add(n,n<<1,INF);
    printf("%d\n",flow+dinic());
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/423699/
   。

做过 * 3

最长不下降子序列问题
第一问
设 f[i]f[i] 以 ii 结尾的最长不下降子序列，dp即可。

第二问
用分层图的思想，把 f[i]f[i] 按照值划分成 ss 个不同的值。

由于每个点只能在一个序列的原则，拆点限制，把 ii 拆成一个入点和一个出点，入点向出点连流量为 11 的边

由起点向每一个 f[i]=1f[i]=1 的点连 11 的流量。

由每一个 f[i]=sf[i]=s 的点向终点连 11 的流量。

将能够转移的 i,ji,j （即 i<j,f[i]+1=f[j]i<j,f[i]+1=f[j] ）连一条边

每一条从起点到终点的路径都是一个长度为 ss 的最长不下降子序列。

这样去除最多的序列等价于找到最多的从 s,ts,t 互不干扰的路径，这里流量为 11，最大流和它们是等价的。

第三问
与第二问不同的就是两个可以反复使用，所以把 1,n1,n 所在内部入点出点的边流量设为无限，并且如果它们与起点终点连过边，流量也设为无限。这样既设计为除了 1,n1,n，剩下点只能经过一次，和题目等价。 有个小技巧，改变流量可以直接加流量，跑最大流不用重新跑一遍，加一条边可以在上次的残余网络上跑。

并且要注意一个特例就是 n=1n=1 的情况，这时候不能起点向 11 连边，否则就输出 INFINF 了。

#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
const int N = 505, L = N * 2, M = N * (N - 1) + N * 2, INF = 1e9;
int n, S, s, t, a[N], f[N], d[L], q[L], maxflow, flow;
int head[L], numE = 1;
struct E{
    int next, v, w;
} e[M];
void add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
} 
void addEdge(int u, int v, int w) {
    add(u, v, w), add(v, u, 0);
}
bool bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = s, d[s] = 1;
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (!d[v] && e[i].w) {
                d[v] = d[u] + 1;
                q[++tt] = v;
                if (v == t) return true;
            }
        }
    }
    return false;
} 
int dinic(int u, int flow) {
    if (u == t) return flow;
    int rest = flow;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].v;
        if (d[v] == d[u] + 1 && e[i].w) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, e[i ^ 1].w += k;
            rest -= k;
        }
    }
    return flow - rest;
}
int main() {
    scanf("%d", &n);
    s = 2 * n + 1, t = 2 * n + 2;
    for (int i = 1; i <= n; i++) scanf("%d", a + i);
    for (int i = 1; i <= n; i++) {
        f[i] = 1;
        for (int j = 1; j < i; j++) 
            if (a[j] <= a[i]) f[i] = max(f[i], f[j] + 1);
        S = max(S, f[i]);
    }
    printf("%d\n", S);
    for (int i = 1; i <= n; i++) {
        addEdge(i, i + n, 1);
        if (f[i] == 1) addEdge(s, i, 1);
        if (f[i] == S) addEdge(i + n, t, 1);
        for (int j = 1; j < i; j++)
            if (a[j] <= a[i] && f[j] + 1 == f[i]) addEdge(j + n, i, 1);
    }
    while (bfs())
        while (flow = dinic(s, INF)) maxflow += flow;
    printf("%d\n", maxflow);

    if (S != 1) addEdge(s, 1, INF), addEdge(1, 1 + n, INF);
    if (f[n] == S) addEdge(n * 2, t, INF), addEdge(n, n * 2, INF);
    while (bfs())
        while (flow = dinic(s, INF)) maxflow += flow;
    printf("%d\n", maxflow);
} 

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/426056/
   。

Dinic 拆点
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010, M = 251010, INF = 0x3f3f3f3f;

int h[N], e[M], f[M], ne[M], idx;
void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

int n, S, T;
int g[N], w[N];

int hs[N], d[N], q[N];

bool bfs()
{
    memset(d, -1, sizeof d);
    d[S] = 0;
    hs[S] = h[S];
    int hh = 0, tt = -1;
    q[ ++ tt] = S;

    while(hh <= tt)
    {
        int u = q[hh ++];

        for(int i = h[u]; ~i; i = ne[i])
        {
            int j = e[i];
            if(d[j] == -1 and f[i])
            {
                d[j] = d[u] + 1;
                hs[j] = h[j];
                if(j == T)  return true;
                q[ ++ tt] = j;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if(u == T)  return limit;

    int flow = 0;
    for(int i = hs[u]; ~i and flow < limit; i = ne[i])
    {
        hs[u] = i;
        int j = e[i];
        if(d[j] == d[u] + 1 and f[i])
        {
            int t = find(j, min(f[i], limit - flow));
            if(!t)  d[j] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int res = 0, flow;
    while(bfs())  while(flow = find(S, INF))  res += flow;
    return res;
}

int main()
{
    memset(h, -1, sizeof h);

    scanf("%d", &n);
    S = 0, T = n * 2 + 1;

    int s = 0;
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d", &w[i]);
        g[i] = 1;
        for(int j = 1; j < i; j ++)
            if(w[j] <= w[i])  g[i] = max(g[i], g[j] + 1);
        s = max(s, g[i]);

        add(i, n + i, 1);
        for(int j = 1; j < i; j ++)
            if(w[j] <= w[i] and g[j] + 1 == g[i])  add(n + j, i, 1);
        if(g[i] == 1)  add(S, i, 1);
    }
    for(int i = 1; i <= n; i ++)
        if(g[i] == s)  add(n + i, T, 1);

    printf("%d\n", s);
    if(s == 1)  return 0 * printf("%d\n%d\n", n, n);

    int res = dinic();
    printf("%d\n", res);
    for(int i = 0; i < idx; i += 2)
    {
        int a = e[i ^ 1], b = e[i];
        if(a == S and b == 1)  f[i] = INF;
        if(a == 1 and b == n + 1)  f[i] = INF;
        if(a == n and b == n + n)  f[i] = INF;
        if(a == n + n and b == T)  f[i] = INF;
    }
    printf("%d\n", res + dinic());
    return 0;
}

作者：滑稽_ωﾉ
链接：https://www.acwing.com/activity/content/code/content/425157/
   。

AcWing 2278. 企鹅游行    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 15:43:41 ,  阅读 15

1






from typing import List
from collections import deque

import sys


class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow


t = int(input())
for _ in range(t):
    s = input().split()
    n = int(s[0])
    dis = float(s[1])

    pos = []
    edges = []
    S = 2 * n + 1
    total = 0
    for i in range(n):
        s = sys.stdin.readline().strip()
        x, y, nn, mm = map(int, s.split())
        pos.append((x, y, nn, mm))
        edges.append((S, i + 1, nn))
        edges.append((i + 1, i + 1 + n, mm))
        total += nn

    for i in range(n):
        x1, y1, _, mm1 = pos[i]
        for j in range(i):
            x2, y2, _, mm2 = pos[j]
            if (x1 - x2) ** 2 + (y1 - y2) ** 2 <= dis ** 2:
                edges.append((i + 1 + n, j + 1, mm1))
                edges.append((j + 1 + n, i + 1, mm2))

    flag = False
    for T in range(1, n + 1):
        flow = FortdFulkerson(edges, S, T, 2 * n + 1, len(edges)).getMaxFlow()

        if flow == total:
            print(T - 1, end=' ')
            flag = True

    if not flag:
        print(-1)
    else:
        print()

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21229/
   。

    #include <iostream>
#include <cstring>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 210, M = 20410, INF = 1e8;
const double eps = 1e-8;

int n, S, T;
double D;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
PII p[N];

bool check(PII a, PII b)
{
    double dx = a.x - b.x, dy = a.y - b.y;
    return dx * dx + dy * dy < D * D + eps;
}

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int cases;
    scanf("%d", &cases);
    while (cases -- )
    {
        memset(h, -1, sizeof h);
        idx = 0;
        scanf("%d%lf", &n, &D);
        S = 0;

        int tot = 0;
        for (int i = 1; i <= n; i ++ )
        {
            int x, y, a, b;
            scanf("%d%d%d%d", &x, &y, &a, &b);
            p[i] = {x, y};
            add(S, i, a);
            add(i, n + i, b);
            tot += a;
        }

        for (int i = 1; i <= n; i ++ )
            for (int j = i + 1; j <= n; j ++ )
                if (check(p[i], p[j]))
                {
                    add(n + i, j, INF);
                    add(n + j, i, INF);
                }

        int cnt = 0;
        for (int i = 1; i <= n; i ++ )
        {
            T = i;
            for (int j = 0; j < idx; j += 2)
            {
                f[j] += f[j ^ 1];
                f[j ^ 1] = 0;
            }
            if (dinic() == tot)
            {
                printf("%d ", i - 1);
                cnt ++ ;
            }
        }
        if (!cnt) puts("-1");
        else puts("");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/424507/
   。

Dinic 拆点
#include<cstdio>
#include<cstring>
#include<algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 210, M = 20410, INF = 0x3f3f3f3f;
const double eps = 1e-8;

int h[N], e[M], f[M], ne[M], idx;
void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

int n, S, T;

int q[N], d[N], hs[N];

bool bfs()
{
    memset(d, -1, sizeof d);
    int hh = 0, tt = -1;

    hs[S] = h[S];
    d[S] = 0;
    q[ ++ tt] = S;

    while(hh <= tt)
    {
        int u = q[hh ++];

        for(int i = h[u]; ~i; i = ne[i])
        {
            int j = e[i];
            if(d[j] == -1 and f[i])
            {
                d[j] = d[u] + 1;
                hs[j] = h[j];
                if(j == T)  return true;
                q[ ++ tt] = j;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if(u == T)  return limit;

    int flow = 0;
    for(int i = hs[u]; ~i and flow < limit; i = ne[i])
    {
        hs[u] = i;
        int j = e[i];
        if(d[j] == d[u] + 1 and f[i])
        {
            int t = find(j, min(f[i], limit - flow));
            if(!t)  d[j] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int res = 0, flow;
    while(bfs())  while(flow = find(S, INF))  res += flow;
    return res;
}

PII p[N];
double D;

bool check(int i, int j)
{
    double dx = p[i].x - p[j].x, dy = p[i].y - p[j].y;
    return dx * dx + dy * dy < D * D + eps;
}

int main()
{
    int _;
    scanf("%d", &_);
    while(_ --)
    {
        memset(h, -1, sizeof h);
        idx = 0;

        scanf("%d%lf", &n, &D);
        S = 0, T = n * 2 + 1;

        int m = 0;
        for(int i = 1; i <= n; i ++)
        {
            int x, y, a, b;
            scanf("%d%d%d%d", &x, &y, &a, &b);
            p[i] = {x, y};
            add(S, i, a);
            add(i, i + n, b);
            m += a;
        }
        for(int i = 1; i <= n; i ++)
            for(int j = i + 1; j <= n; j ++)
                if(check(i, j))
                {
                    add(i + n, j, INF);
                    add(j + n, i, INF);
                }

        vector<int> res;
        for(T = 1; T <= n; T ++)
        {
            for(int i = 0; i < idx; i += 2)
            {
                f[i] += f[i ^ 1];
                f[i ^ 1] = 0;
            }
            if(dinic() >= m)  res.push_back(T - 1);
        }
        if(!res.size())  puts("-1");
        else
        {
            for(int i : res)  printf("%d ", i);
            puts("");
        }
    }
    return 0;
}

作者：滑稽_ωﾉ
链接：https://www.acwing.com/activity/content/code/content/425193/
   。


#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=205;
const int M=20605;
const int INF=0x3f3f3f3f;

int n,S,T;
double D;
int x[N],y[N],s[N],t[N];
int h[N],e[M],w[M],ne[M],idx;
int d[N],cur[N],q[N],hh,tt;

void addedge(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

void add(int a,int b,int c)
{
    addedge(a,b,c),addedge(b,a,0);
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    int task;
    for(scanf("%d",&task);task--;)
    {
        scanf("%d%lf",&n,&D);
        bool flag=true;
        int sum=0;
        for(int i=0;i<n;i++)
        {
            scanf("%d%d%d%d",x+i,y+i,s+i,t+i);
            sum+=s[i];
        }
        for(S=n+n+1,T=0;T<n;T++)
        {
            memset(h,0,sizeof h),idx=1;
            for(int i=1;i<n;i++)
                for(int j=0;j<i;j++)
                    if(hypot(x[i]-x[j],y[i]-y[j])<=D)
                        add(i+n,j,INF),add(j+n,i,INF);
            for(int i=0;i<n;i++)
            {
                if(s[i])add(S,i,s[i]);
                add(i,i+n,t[i]);
            }
            if(dinic()==sum)printf("%d ",T),flag=false;
        }
        puts(flag?"-1":"");
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/444717/
   。

这复杂度也太玄学了。。

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int N = 205, M = N * N * 2 + 2 * N, INF = 1e9;

int n, S, T;

double D;

int d[N], q[N], cur[N], X[N], Y[N];

int head[N], numE;

struct E{
    int next, v, w;
} e[M << 1];

void inline add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
    e[++numE] = (E) { head[v], u, 0 };
    head[v] = numE;
}

bool inline bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = S, cur[S] = head[S], d[S] = 1;
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (!d[v] && e[i].w) {
                d[v] = d[u] + 1, q[++tt] = v, cur[v] = head[v];
                if (v == T) return true;
            }
        }
    }
    return false;
}

int dinic(int u, int flow) {
    if (u == T) return flow;
    int rest = flow;
    for (int i = cur[u]; i && rest; i = e[i].next) {
        int v = e[i].v; cur[u] = i;
        if (d[v] == d[u] + 1 && e[i].w) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, rest -= k, e[i ^ 1].w += k;
        }
    }
    return flow - rest;
}

void inline clear() {
    memset(head, 0, sizeof head);
    numE = 1;
}

int main() {
    int CASE; scanf("%d", &CASE);
    while (CASE--) {
        clear();
        scanf("%d%lf", &n, &D);
        S = 2 * n + 1;
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            int a, b;
            scanf("%d%d%d%d", X + i, Y + i, &a, &b);
            add(S, i, a), add(i, i + n, b);
            sum += a;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = i + 1; j <= n; j++) {
                if ((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]) <= D * D) {
                    add(i + n, j, INF), add(j + n, i, INF);
                }
            }
        }

        int cnt = 0;
        for (int i = 1; i <= n; i++) {
            T = i;
            for (int j = 2; j <= numE; j += 2) 
                e[j].w += e[j + 1].w, e[j + 1].w = 0;
            int ans = 0, res;
            while (bfs())
                while (res = dinic(S, INF)) ans += res;
            if (ans == sum) {
                printf("%d ", i - 1);
                ++cnt;
            }
        }
        if (!cnt) puts("-1");
        else puts("");
    }
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/427696/
   。
#include<cstdio>
#include<cstring>
#include<map>
#include<vector>
#include<cmath>
#include<cstdlib>
#include<stack>
#include<queue>
#include <iomanip>
#include<iostream>
#include<algorithm>
using namespace std ;
const int N=500 ;
const int M=100000 ;
const int inf=1<<30 ;
struct node
{
    int u ,v,c,next;
}edge[M] ;

struct node1
{
    int n,m ;
    double x,y;
}e[M] ;

int head[N],dis[N],gap[N],cur[N],pre[N] ;
int top , s,t,sum,n,nv;
double d ;

double Dis(int i,int j)  
{  
    return sqrt(1.0*(e[i].x-e[j].x)*(e[i].x-e[j].x)+(e[i].y-e[j].y)*(e[i].y-e[j].y));  
}  

void add(int u ,int v,int c)     
{    
    edge[top].u=u;    
    edge[top].v=v;    
    edge[top].c=c;    
    edge[top].next=head[u];    
    head[u]=top++;    
    edge[top].u=v;    
    edge[top].v=u;    
    edge[top].c=0;    
    edge[top].next=head[v];    
    head[v]=top++;    
}    

int sap()    
{    
    memset(dis,0,sizeof(dis));    
    memset(gap,0,sizeof(gap));    
    int u,v,minflow=inf,flow=0;    
    for(int i = 0 ; i <=nv ; i++)  cur[i]=head[i] ;    
    u=pre[s]=s;    
    gap[s]=nv;    
    while(dis[s] <= nv )    
    {    
            loop :    
               for(int &j=cur[u] ; j!=-1 ; j=edge[j].next)                   
               {    
                     v=edge[j].v ;    
                     if(edge[j].c > 0 && dis[u] == dis[v] +1 )    
                     {    
                              minflow = min(minflow ,edge[j].c) ;    
                              pre[v]=u;    
                              u=v ;    
                          if(v==t)    
                          {      
                                for( u =pre[v] ; v!=s ;v=u,u=pre[u])    
                                      {    
                                            edge[cur[u]].c -= minflow ;     
                                            edge[cur[u]^1].c += minflow ;    
                                      }     
                                flow += minflow ;    
                                minflow = inf ;    
                          }    
                         goto loop ;    
                     }    
               }    
           int mindis=nv ;    
           for(int i = head[u] ; i!=-1 ; i=edge[i].next)    
           {    
                  v=edge[i].v ;    
                  if(edge[i].c > 0 && dis[v] < mindis)    
                  {    
                       mindis = dis[v] ;    
                       cur[u]=i ;           
                 }    
           }    
          if(--gap[dis[u]]==0) break ;    
          gap[ dis[u] = mindis +1 ]++  ;    
          u=pre[u] ;    
    }    
    return flow ;    
}    



void make(int mid)
{
    memset(head,-1,sizeof(head)) ;
    top = 0 ;
    s=0,t=2*n+1 ,nv=t+1 ;
    for(int i = 1 ; i <= n ; i++)
     {
          add(s,i,e[i].n) ;  //源点连冰块 
         if(i==mid)  //聚集地之间流量没有来限制 
            add(i,i+n,inf) ; 
         else add(i,i+n,e[i].m) ;//限制企鹅数量 
     } 
    for(int i = 1 ; i <= n ;i++ )
      for(int j = i+1; j <= n ; j++)
       {
           if( Dis(i,j) <= d ) //i,j冰块可以互相到达 
             {
               add(i+n,j,inf) ,add(j+n,i,inf)   ;//互相可以跳上去 
            }
       }

} 

int main()
{
    int tt ,f[200];
    scanf("%d",&tt) ;
    while(tt--)
    {
          scanf("%d%lf",&n,&d) ;
          sum = 0;
          for(int i = 1 ; i <= n ; i++)
          {
              scanf("%lf%lf%d%d",&e[i].x,&e[i].y,&e[i].n,&e[i].m) ;
              sum += e[i].n ;
          }
          int k = 0 ;
          for(int i = 1 ; i <= n ; i++)
          {
                make(i) ;
                add(i+n,t,inf) ;  //聚集地到汇点连边 
              if(sap()==sum)   //i冰块可以作为聚集地 
              {
                   f[k++]=i-1 ;
              }
          }
         if(k==0)
            printf("-1\n") ;
          else
          {
                printf("%d",f[0]) ;
                for(int  i = 1 ; i < k ; i++)
                   printf(" %d",f[i]) ;
                 puts("") ;  
          }  

    }
    return 0 ;
} 

作者：真-蒻-王善珑
链接：https://www.acwing.com/activity/content/code/content/423558/
   。
Pig
wc掉线了，于是颓题解

顾客为什么有钥匙啊

大体思路显然是，建源点SS向顾客连容量为需求的边，猪圈向汇点TT连容量为+∞+∞的边，然后顾客与猪圈以某种方式连边，最后的最大流即为答案。

对于顾客与猪圈连边，一种错误的方法是，对每个顾客建一个虚点PP,每个他能开的猪圈向PP连容量为+∞+∞的无向边，然后顾客向这个虚点连边。这样是样例也过不去的，错误的原因是，第一个顾客有1,2的钥匙，第二个顾客有1，3的钥匙，并不意味着3的猪一定能换到2上。

考虑对于当前的顾客ii，求出他可以支配的猪圈集合SiSi，即可以在之前通过某些方法让他能任意选择的猪圈。首先他直接有钥匙的猪圈显然属于SiSi.其次，∀j<i,,∀x,y∈Aj,x∈Si∀j<i,,∀x,y∈Aj,x∈Si,必然有y∈Siy∈Si(即若Si∪Aj≠∅Si∪Aj≠∅,令Si=Si∩AjSi=Si∩Aj.令ii向SiSi中每个点连边即可。可以std::bitset维护。

时间复杂度理论上界O(n2mω+nmnm‾‾‾√))O(n2mω+nmnm)),但完全跑不到。在poj上0ms。。。

std::bitset<1011>s[111];
int main()
{
    int n2=read(),n1=read(),S=n1+n2+1,T=S+1,tot=T;
    for(int i=1;i<=n2;++i)adde(n1+i,T,read());
    for(int i=1;i<=n1;++i)
    {
        int l=read();
        while(l--)s[i][read()]=1;
        std::bitset<1011>pos=s[i];
        for(int j=i-1;j;--j)
            if((pos&s[j]).any())pos|=s[j];
        for(int j=1;j<=n2;++j)
            if(pos[j])adde(i,n1+j,INF);
        adde(S,i,read());
    }
    printf("%lld",Dinic(S,T,tot));
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/17624/
   。

AcWing 2237. 猪    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 17:11:08 ,  阅读 19

0






from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow




m, n = map(int, input().split())
X = list(map(int, input().split()))

S, T = n+1, n+2

edges = []
visit = [[] for i in range(m)]      # visit[idx]记录idx号猪舍被那些顾客打开过
for i in range(1, n+1):
    arr = list(map(int, input().split()))
    buy_cnt = arr[-1]
    for house_idx in arr[1:-1]:
        house_idx -= 1

        if len(visit[house_idx]) == 0:
            edges.append((S, i, X[house_idx]))
        else:
            for cus_idx in visit[house_idx]:
                edges.append((cus_idx, i, 0x7fffffff))

        visit[house_idx].append(i)
    edges.append((i, T, buy_cnt))

print(FortdFulkerson(edges, S, T, n+2, len(edges)).getMaxFlow())

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21236/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 100200 * 2 + 10, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
int w[1010], belong[1010];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs())
    {
        r += find(S, INF);
        flow = find(S, INF);
        if (flow) puts("!");
        r += flow;
    }
    return r;
}

int main()
{
    scanf("%d%d", &m, &n);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= m; i ++ ) scanf("%d", &w[i]);
    for (int i = 1; i <= n; i ++ )
    {
        int a, b;
        scanf("%d", &a);
        while (a -- )
        {
            int t;
            scanf("%d", &t);
            if (!belong[t]) add(S, i, w[t]);
            else add(belong[t], i, INF);
            belong[t] = i;
        }
        scanf("%d", &b);
        add(i, T, b);
    }

    printf("%d\n", dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/424544/
   。

舔包建图
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=105;
const int M=200205;
const int INF=0x3f3f3f3f;

int n,m,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;
int c[1005],last[1005];

void addedge(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

void add(int a,int b,int c)
{
    addedge(a,b,c),addedge(b,a,0);
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    scanf("%d%d",&m,&n),S=0,T=n+1;
    for(int i=1;i<=m;i++)scanf("%d",c+i);
    for(int i=1,A,id;i<=n;i++)
    {
        for(scanf("%d",&A);A--;)
        {
            scanf("%d",&id);
            if(last[id])add(last[id],i,INF);
            else    add(S,i,c[id]);
            last[id]=i;
        }
        scanf("%d",&A);
        add(i,T,A);
    }
    printf("%d\n",dinic());
    return 0;
}
瞎写的另一种建图方式
#include <cstring>

const int INF=0x3fffffff;
const int N=1105;
const int M=202205;

int n,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;
char st[105][126],p[126];

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    int n1,n2;
    scanf("%d%d",&n2,&n1);
    S=n1+n2+1,T=n=S+1;
    for(int i=1,x;i<=n2;++i)
    {
        scanf("%d",&x);
        add(n1+i,T,x);
        add(T,n1+i,x);
    }
    for(int i=1;i<=n1;i++)
    {
        int A,x;
        for(scanf("%d",&A);A--;)
        {
            scanf("%d",&x);
            st[i][x>>3]|=1<<(x&7);
        }
        memcpy(p,st[i],sizeof p);
        for(int j=i-1;j;j--)
        {
            bool judge=false;
            for(int k=1;k<=n2;k++)
                if((p[k>>3]>>(k&7)&1)&&(st[j][k>>3]>>(k&7)&1))
                {
                    judge=true;
                    break;
                }
            if(judge)
                for(int k=1;k<=n2;k++)
                    if(st[j][k>>3]>>(k&7)&1)
                        p[k>>3]|=1<<(k&7);
        }
        for(int j=1;j<=n2;j++)
            if(p[j>>3]>>(j&7)&1)
            {
                add(i,n1+j,INF);
                add(n1+j,i,0);
            }
        scanf("%d",&x);
        add(S,i,x),add(i,S,0);
    }
    printf("%d\n",dinic());
    return 0;
}


作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/418545/
   。

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int M = 1005, N = 105, INF = 1e9;

int m, n, cnt[M], A[N], K[N][M], B[N], S, T, last[M];

int head[N], numE = 1;

int d[N], q[N], cur[N];

struct E{
    int next, v, w;
} e[(N * M) << 1];

void inline add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
    e[++numE] = (E) { head[v], u, 0 };
    head[v] = numE;
}

bool inline bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = S, cur[S] = head[S], d[S] = 1;
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (!d[v] && e[i].w) {
                d[v] = d[u] + 1, q[++tt] = v, cur[v] = head[v];
                if (v == T) return true;
            }
        }
    }
    return false;
}

int dinic(int u, int flow) {
    if (u == T) return flow;
    int rest = flow;
    for (int i = cur[u]; i && rest; i = e[i].next) {
        int v = e[i].v; cur[u] = i;
        if (d[v] == d[u] + 1 && e[i].w) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, rest -= k, e[i ^ 1].w += k;
        }
    }
    return flow - rest;
}

int main() {
    scanf("%d%d", &m, &n);
    S = n + 1, T = n + 2;
    for (int i = 1; i <= m; i++) scanf("%d", cnt + i);
    for (int i = 1; i <= n; i++) {
        scanf("%d", A + i);
        for (int j = 1; j <= A[i]; j++) {
            scanf("%d", &K[i][j]);
            if (!last[K[i][j]]) add(S, i, cnt[K[i][j]]);
            else add(last[K[i][j]], i, INF);
            last[K[i][j]] = i;
        }
        scanf("%d", B + i);
        add(i, T, B[i]);
    }
    int ans = 0, res;
    while (bfs())
        while (res = dinic(S, INF)) ans += res;
    printf("%d\n", ans);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/428160/
   。

AcWing 2173. Dinic/ISAP求最小割    原题链接    中等
作者：    皓首不倦 ,  2020-09-23 18:52:58 ,  阅读 16

0




'''
求最小割和求最大流是等价的，直接用Dinic求最大流即可
'''

from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]

n, m, start, end = map(int, input().split())
link = {}
for _ in range(m):
    a, b, w = map(int, input().split())

    if (a, b) not in link:
        link[(a, b)] = w
    else:
        #print(f'overlap {a} {b}')
        link[(a, b)] += w

edges = [(a, b, w) for (a, b), w in link.items()]
algo = FortdFulkerson(edges, start, end, max_node_num=n, max_edge_num=m)
print(algo.getMaxFlow()[0])

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21240/
   。

基本概念
1.1 流网络，不考虑反向边
1.2 可行流，不考虑反向边
1.2.1 两个条件：容量限制、流量守恒
1.2.2 可行流的流量指从源点流出的流量 - 流入源点的流量
1.2.3 最大流是指最大可行流
1.3 残留网络，考虑反向边，残留网络的可行流f’ + 原图的可行流f = 原题的另一个可行流
(1) |f’ + f| = |f’| + |f|
(2) |f’| 可能是负数
1.4 增广路径
1.5 割
1.5.1 割的定义
1.5.2 割的容量，不考虑反向边，“最小割”是指容量最小的割。
1.5.3 割的流量，考虑反向边，f(S, T) <= c(S, T)
1.5.4 对于任意可行流f，任意割[S, T]，|f| = f(S, T)
1.5.5 对于任意可行流f，任意割[S, T]，|f| <= c(S, T)
1.5.6 最大流最小割定理
(1) 可以流f是最大流
(2) 可行流f的残留网络中不存在增广路
(3) 存在某个割[S, T]，|f| = c(S, T)
1.6. 算法
1.6.1 EK O(nm^2)
1.6.2 Dinic O(n^2m)
1.7 应用
1.7.1 二分图
(1) 二分图匹配
(2) 二分图多重匹配
1.7.2 上下界网络流
(1) 无源汇上下界可行流
(2) 有源汇上下界最大流
(3) 有源汇上下界最小流
1.7.3 多源汇最大流
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010, M = 200010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    printf("%d\n", dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/424558/
   。
最大流最小割定理
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=10005;
const int M=200005;
const int INF=0x3fffffff;

int n,m,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    scanf("%d%d%d%d",&n,&m,&S,&T);
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c),add(b,a,0);
    }
    printf("%d\n",dinic());
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/423681/
   。

AcWing 2279. 网络战争    原题链接    困难
作者：    whsstory ,  2020-08-09 09:49:46 ,  阅读 106

3


网络战争
注：如果Latex挂掉了请告知我，或者用typora/vscode打开

求一个平均权值最小的割集。

考虑分数规划。存在一个平均值不大于xx的割集等价于：
∃C,∑e∈Cw(e)|C|≤x
∃C,∑e∈Cw(e)|C|≤x
⇒∃C,∑e∈C(w(e)−x)≤0
⇒∃C,∑e∈C(w(e)−x)≤0
故 存在一个平均值不大于xx的割集⇔⇔将边权全部减少xx后，最小割权值不超过0.二分答案+最大流 即可。

注意图中会出现负权边，没法直接最大流，但最小割中必然包含所有负权边，提前选上即可。

浮点数最大流真毒瘤啊

struct one{int u,v,w;}e2[MAXM];
int n,m,S,T;
bool check(double k)
{
    cnt=1;
    for(int i=1;i<=n;++i)last[i]=0;
    double sum=0;
    for(int i=1;i<=m;++i)
        if(e2[i].w<=k)sum+=e2[i].w-k;
        else adde(e2[i].u,e2[i].v,e2[i].w-k),adde(e2[i].v,e2[i].u,e2[i].w-k);
    return Dinic(S,T,n)+sum<=0;
}
int main()
{
    n=read(),m=read(),S=read(),T=read();
    for(int i=1;i<=m;++i)e2[i].u=read(),e2[i].v=read(),e2[i].w=read();
    double l=0,r=1e7;
    while(r-l>2e-3)
    {
        double mid=(l+r)/2;
        if(check(mid))r=mid;
        else l=mid;
    }
    printf("%.2lf",l);
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/17983/
   。

AcWing 2279. 网络战争    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 20:45:42 ,  阅读 22

1


1




EPSILON = 1e-7
from typing import List
from collections import deque

import sys
class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow


n, m, S, T = map(int, input().split())
e = []
max_w = -0x7fffffff
for _ in range(m):
    a, b, w = map(int, input().split())
    e.append((a, b, w))
    max_w = max(w, max_w)

l, r = 0, max_w
ans = None
while abs(l - r) > EPSILON:
    mid = l + (r - l) / 2

    total = 0
    edges = []
    for a, b, w in e:
        if w <= mid:
            total -= mid - w
        else:
            edges.append((a, b, w-mid))
            edges.append((b, a, w-mid))

    max_flow = FortdFulkerson(edges, S, T, n, len(edges)).getMaxFlow()
    if max_flow + total < 0:
        ans = r
        r = mid
    else:
        l = mid

print('{:.2f}'.format(ans))

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21254/
   。

2


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 810, INF = 1e8;
const double eps = 1e-8;

int n, m, S, T;
int h[N], e[M], w[M], ne[M], idx;
double f[M];
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, w[idx] = c, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i] > 0)
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

double find(int u, double limit)
{
    if (u == T) return limit;
    double flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i] > 0)
        {
            double t = find(ver, min(f[i], limit - flow));
            if (t < eps) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

double dinic(double mid)
{
    double res = 0;
    for (int i = 0; i < idx; i += 2)
        if (w[i] <= mid)
        {
            res += w[i] - mid;
            f[i] = f[i ^ 1] = 0;
        }
        else f[i] = f[i ^ 1] = w[i] - mid;

    double r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r + res;
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    double l = 0, r = 1e7;
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (dinic(mid) < 0) r = mid;
        else l = mid;
    }

    printf("%.2lf\n", r);
  

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/424638/
   。
AcWing 2280. 最优标号    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 23:15:10 ,  阅读 35

3





from typing import List
from collections import deque

import sys
class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow



n, m = map(int, input().split())
e = []

for i in range(m):
    a, b = map(int, input().split())
    e.append((a, b, 1))
    e.append((b, a, 1))

k = int(input())
label = {}
for i in range(k):
    a, b = map(int, input().split())
    label[a] = b

S, T = n+1, n+2
ans = 0
for bit in range(32):

    ee = []
    for node, val in label.items():
        if val & (1 << bit):
           ee.append((node, T, 0x7fffffff))
           ee.append((T, node, 0x7fffffff))
        else:
            ee.append((node, S, 0x7fffffff))
            ee.append((S, node, 0x7fffffff))

    edges = e + ee
    max_flow = FortdFulkerson(edges, S, T, n+2, len(edges)).getMaxFlow()
    ans += (1 << bit) * max_flow

print(ans)


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21265/
   。
#include <iostream>
#include <cstring>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef long long LL;
typedef pair<int, int> PII;

const int N = 510, M = (3000 + N * 2) * 2, INF = 1e8;

int n, m, k, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
int p[N];
PII edges[3010];

void add(int a, int b, int c1, int c2)
{
    e[idx] = b, f[idx] = c1, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = c2, ne[idx] = h[b], h[b] = idx ++ ;
}

void build(int k)
{
    memset(h, -1, sizeof h);
    idx = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].x, b = edges[i].y;
        add(a, b, 1, 1);
    }
    for (int i = 1; i <= n; i ++ )
        if (p[i] >= 0)
        {
            if (p[i] >> k & 1) add(i, T, INF, 0);
            else add(S, i, INF, 0);
        }
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

LL dinic(int k)
{
    build(k);
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + 1;
    for (int i = 0; i < m; i ++ ) scanf("%d%d", &edges[i].x, &edges[i].y);
    scanf("%d", &k);
    memset(p, -1, sizeof p);
    while (k -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        p[a] = b;
    }

    LL res = 0;
    for (int i = 0; i <= 30; i ++ ) res += dinic(i) << i;
    printf("%lld\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/424690/
   。
AcWing 961. 最大获利    原题链接    中等
作者：    whsstory ,  2020-08-10 10:48:47 ,  阅读 83

4


最大获利
若选择用户ii，则ai,biai,bi都必须选择，最大化点权和。这便是最大权闭合图的模型。

最大权闭合图的解法是，新建源点SS,向正权点连容量为点权的边；新建汇点TT,负权点向TT连容量为点权的相反数的边。图中原有的边容量改为正无穷。正权点点权和减去最小割即为答案。

正确性证明：选择用户i⇒i⇒ ai,biai,bi必须选择，即必须割掉ai,biai,bi连向TT的边；放弃用户i⇒i⇒割掉SS连向ii的边。

int main()
{
    int n=read(),m=read(),S=n+m+1,T=S+1,sum=0;
    for(int i=1;i<=n;++i)adde(m+i,T,read());
    for(int i=1;i<=m;++i)
    {
        int a=read(),b=read(),val=read();
        sum+=val;
        adde(i,m+a,INF),adde(i,m+b,INF);
        adde(S,i,val);
    }
    printf("%lld",sum-Dinic(S,T,T));
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/17985/
   。
AcWing 961. 最大获利 最大密度子图建图解法    原题链接    中等
作者：    皓首不倦 ,  2020-09-25 12:46:35 ,  阅读 21

1



'''
转成无向图最大密度子图问题求解，比最大权值和闭合子图模型快一些
'''

from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow


n, m = map(int, input().split())
S, T = n+1, n+2
U = 9999
edges = []
for node in range(1, n+1):
    edges.append((S, node, U))
    edges.append((node, S, U))

d = [0] * (n+1)

cost = list(map(int, input().split()))
for _ in range(m):
    a, b, w = map(int, input().split())
    edges.append((a, b, w))
    edges.append((b, a, w))

    d[a] += w
    d[b] += w

for node in range(1, n+1):
    edges.append((node, T, U-d[node]+2*cost[node-1]))
    edges.append((T, node, U-d[node]+2*cost[node - 1]))

ans = (n*U - FortdFulkerson(edges, S, T, n+2, len(edges)).getMaxFlow()) / 2
print(int(ans))



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21358/
   。



2


最大权闭合图
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 55010, M = (50000 * 3 + 5000) * 2 + 10, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + m + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ )
    {
        int p;
        scanf("%d", &p);
        add(m + i, T, p);
    }

    int tot = 0;
    for (int i = 1; i <= m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(S, i, c);
        add(i, m + a, INF);
        add(i, m + b, INF);
        tot += c;
    }

    printf("%d\n", tot - dinic());

    return 0;
}
最大密度子图
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 5010, M = (50000 + N * 2) * 2 + 10, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
int dg[N], p[N];

void add(int a, int b, int c1, int c2)
{
    e[idx] = b, f[idx] = c1, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = c2, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &p[i]), p[i] *= -1;
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c, c);
        dg[a] += c, dg[b] += c;
    }
    int U = 0;
    for (int i = 1; i <= n; i ++ ) U = max(U, 2 * p[i] + dg[i]);
    for (int i = 1; i <= n; i ++ )
    {
        add(S, i, U, 0);
        add(i, T, U - 2 * p[i] - dg[i], 0);
    }

    printf("%d\n", (U * n - dinic()) / 2);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/435267/
   。
AcWing 2324. 生活的艰辛    原题链接    困难
作者：    TCO ,  2020-08-20 11:40:16 ,  阅读 64

1


1
浮点数好毒瘤啊
这个题调了好多次精度才过。。
做法就是一顿推公式。记住一个结论就是： 对于一张原图，新加S,T两点。给原图的每个点都add(S,i,V,0),add(i,T,2g-di+V,0)//g是二分的密度，di代表这个点的度数。V是为了防止负数出现
对于原图的边add(u,v,1,1)
然后有：C[S,T]=Vn + 2g|V’|-2|E’| //这里V是上面的含义，V’是选中的点，E’是子图的边数，那么对于每一个二分的g,我们去check是否满足C[S,T]-Vn<0，若满足就说明g可行。
至于详细的推导嘛。。。看y总的视频讲解以及胡伯涛那篇论文《最小割在信息学奥赛中的应用》


#include<bits/stdc++.h>
using namespace std;

const int N=10010,M=200010;
int q[N],d[N],cur[N],dg[N];
double f[M],sum;
int e[M],ne[M],idx,h[N],n,m,S,T,VV;

struct E{
    int a,b;
}edge[10010];

void add(int a,int b,double c,double d)
{
    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;
    e[idx]=a,f[idx]=d,ne[idx]=h[b],h[b]=idx++;
}
bool bfs()
{

    memset(d,-1,sizeof d); 
    q[0]=S,cur[S]=h[S],d[S]=0;
    int hh=0,tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];~i;i=ne[i])
        {
            int ver=e[i];
            if(d[ver]==-1&&f[i])
            {
                d[ver]=d[t]+1;
                cur[ver]=h[ver];
                if(ver==T) return true;
                q[++tt]=ver;
            }
        }
    }
    return false;
}
double find(int u,double limit)
{
    if(u==T ) return limit;
    double flow=0;
    for(int i=cur[u];~i&&flow<limit;i=ne[i])
    {
        int ver=e[i];
        cur[u]=i;
        if(d[ver]==d[u]+1&&f[i]>0)
        {
            double t=find(ver,min(f[i],limit-flow));
            if(t<1e-8) d[ver]=-1;
            f[i]-=t,f[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

bool dinic(double mid)
{
    memset(h,-1,sizeof h);
    idx=0;
    for(int i=1;i<=m;i++)
    {
        int a=edge[i].a,b=edge[i].b;
        add(a,b,1,1);
    }
    for(int i=1;i<=n;i++) add(S,i,VV,0),add(i,T,VV+2*mid-dg[i],0);
    double r=0,flow;
    while(bfs()  ) while(flow=find(S,0x3f3f3f3f)) r+=flow;
    return 0<sum-r;
}
bool st[N];
vector<int> ans;
void dfs(int u)
{
   // printf("now fuck %d\n",u);
   if(u!=S) ans.push_back(u);
   st[u]=true;
    for(int i=h[u];~i;i=ne[i])
    {
        if(!st[e[i]]&&f[i]>0) dfs(e[i]);
    }
}
int main()
{
    cin>>n>>m;
    VV=m+10;
    sum=n*VV;
    S=n+2,T=n+4;
    for(int i=1;i<=m;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        edge[i]={a,b};
        dg[a]++;
        dg[b]++;
    }
    double l=0,r=m;
    while(r-l>1e-8)
    {
        double mid=(l+r)/2;
        if(dinic(mid)) l=mid;
        else r=mid;
    }
    dinic(l);dfs(S);
    //printf("%.6lf\n",l);
    if(ans.size()==0)
    {
        cout<<1<<endl<<1;
    }
    else {

        printf("%d\n",ans.size());
        for(int i=1;i<=n;i++) if(st[i]) printf("%d\n",i);
    }
    return 0;
}

作者：TCO
链接：https://www.acwing.com/solution/content/18827/
   。
AcWing 2324. 生活的艰辛    原题链接    困难
作者：    皓首不倦 ,  2020-09-24 23:35:54 ,  阅读 39

0


.png)

.png)

.png)


'''
01 分数规划二分搜索边数平均值的上界，利用最小割的容量验证
平均值上界是否是有效值
'''


from typing import List
from collections import deque


EPSILON = 1e-4

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 获取最小割的划分方案，返回最小割容量以及两个列表，第一个列表为和源点在一个集合中的所有点，第二个列表是和汇点在同一个集合中的所有点
    def getMinCut(self):
        e = [-1] * (self.max_edge_num * 2 + 1)          # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)          # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)         # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        min_cut_cap = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            min_cut_cap += dfs(self.source_node, 0x7fffffff)

        visit = [0] * (self.max_node_num + 1)
        def travel(cur):
            visit[cur] = 1

            idx = h[cur]
            while idx != -1:
                next_node = e[idx]
                if visit[next_node] == 0 and f[idx] > 0:
                    travel(next_node)

                idx = ne[idx]

        travel(self.source_node)
        s_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 1]
        t_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 0]

        return min_cut_cap, s_nodes, t_nodes


n, m = map(int, input().split())
U = 99999
S, T = n+1, n+2

e = []
d = [0] * (n+1)
for node in range(1, n+1):
    e.append((S, node, U))
    e.append((node, S, U))

for i in range(m):
    a, b = map(int, input().split())
    d[a] += 1
    d[b] += 1
    e.append((a, b, 1))
    e.append((b, a, 1))

# 二分搜索可能的平均边数的上界
ans = None
l, r = 0, m
while abs(l- r) > EPSILON:
    mid = l + (r-l) / 2

    e1 = [(node, T, 2*mid - d[node] + U) for node in range(1, n + 1)]
    e2 = [(T, node, 2*mid - d[node] + U) for node in range(1, n + 1)]
    edges = e + e1 + e2

    min_cut_cap, s_nodes, _ = FortdFulkerson(edges, S, T, n+2, len(edges)).getMinCut()
    val = n * U - min_cut_cap
    #print(l, r, min_cut_cap, val, s_nodes)

    if val > 0:
        l = mid
        ans = s_nodes
    else:
        r = mid

if ans is not None:
    print(len(ans)-1)
    for node in ans:
        if node == S:
            continue
        print(node)

else:
    print(1)
    print(1)

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21338/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = (1000 + N * 2) * 2, INF = 1e8;

int n, m, S, T;
int h[N], e[M], ne[M], idx;
double f[M];
int q[N], d[N], cur[N];
int dg[N];

struct Edge
{
    int a, b;
}edges[M];

int ans;
bool st[N];

void add(int a, int b, double c1, double c2)
{
    e[idx] = b, f[idx] = c1, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = c2, ne[idx] = h[b], h[b] = idx ++ ;
}

void build(double g)
{
    memset(h, -1, sizeof h);
    idx = 0;
    for (int i = 0; i < m; i ++ ) add(edges[i].a, edges[i].b, 1, 1);
    for (int i = 1; i <= n; i ++ )
    {
        add(S, i, m, 0);
        add(i, T, m + g * 2 - dg[i], 0);
    }
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i] > 0)
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

double find(int u, double limit)
{
    if (u == T) return limit;
    double flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i] > 0)
        {
            double t = find(ver, min(f[i], limit - flow));
            if (t <= 0) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

double dinic(double g)
{
    build(g);
    double r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

void dfs(int u)
{
    st[u] = true;
    if (u != S) ans ++ ;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int ver = e[i];
        if (!st[ver] && f[i] > 0)
            dfs(ver);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + 1;

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        dg[a] ++, dg[b] ++ ;
        edges[i] = {a, b};
    }

    double l = 0, r = m;
    while (r - l > 1e-8)
    {
        double mid = (l + r) / 2;
        double t = dinic(mid);
        if (m * n - t > 0) l = mid;
        else r = mid;
    }

    dinic(l);
    dfs(S);

    if (!ans) puts("1\n1");
    else
    {
        printf("%d\n", ans);
        for (int i = 1; i <= n; i ++ )
            if (st[i])
                printf("%d\n", i);
    }
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/435370/
   。
AcWing 2325. 有向图破坏    原题链接    困难
作者：    皓首不倦 ,  2020-09-25 15:55:51 ,  阅读 25

1





'''
转成二分图的最小点权值和覆盖点集问题求解
'''


from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 获取最小割的划分方案，返回最小割容量以及两个列表，第一个列表为和源点在一个集合中的所有点，第二个列表是和汇点在同一个集合中的所有点
    def getMinCut(self):
        e = [-1] * (self.max_edge_num * 2 + 1)          # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)          # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)         # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        min_cut_cap = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            min_cut_cap += dfs(self.source_node, 0x7fffffff)

        visit = [0] * (self.max_node_num + 1)
        def travel(cur):
            visit[cur] = 1

            idx = h[cur]
            while idx != -1:
                next_node = e[idx]
                if visit[next_node] == 0 and f[idx] > 0:
                    travel(next_node)

                idx = ne[idx]

        travel(self.source_node)
        s_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 1]
        t_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 0]

        return min_cut_cap, s_nodes, t_nodes


n, m = map(int, input().split())
w_pos = [0] + list(map(int, input().split()))
w_neg = [0] + list(map(int, input().split()))

# part1 点范围为1 - n part2点范围为n+1 - 2n


edges = []
S, T = 2*n+1, 2*n+2
for node in range(1, n+1):
    edges.append((S, node, w_neg[node]))
    edges.append((node+n, T, w_pos[node]))

for _ in range(m):
    a, b = map(int, input().split())
    edges.append( (a, b+n, 0x7fffffff) )

min_cut_cap, ss, tt = FortdFulkerson(edges, S, T, 2*n+2, len(edges)).getMinCut()
print(min_cut_cap)


pos_nodes = []
neg_nodes = []
for node in ss:
    if node >= n+1 and node <= 2*n:
        pos_nodes.append(node-n)

for node in tt:
    if node >= 1 and node <= n:
        neg_nodes.append(node)

print(len(pos_nodes) + len(neg_nodes))
for node in pos_nodes:
    print(f'{node} +')
for node in neg_nodes:
    print(f'{node} -')


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21371/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 210, M = 5200 * 2 + 10, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

void dfs(int u)
{
    st[u] = true;
    for (int i = h[u]; ~i; i = ne[i])
        if (f[i] && !st[e[i]])
            dfs(e[i]);
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ )
    {
        int w;
        scanf("%d",  &w);
        add(S, i, w);
    }
    for (int i = 1; i <= n; i ++ )
    {
        int w;
        scanf("%d", &w);
        add(n + i, T, w);
    }

    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(b, n + a, INF);
    }

    printf("%d\n", dinic());
    dfs(S);

    int cnt = 0;
    for (int i = 0; i < idx; i += 2)
    {
        int a = e[i ^ 1], b = e[i];
        if (st[a] && !st[b]) cnt ++ ;
    }

    printf("%d\n", cnt);
    for (int i = 0; i < idx; i += 2)
    {
        int a = e[i ^ 1], b = e[i];
        if (st[a] && !st[b])
        {
            if (a == S) printf("%d +\n", b);
        }
    }
    for (int i = 0; i < idx; i += 2)
    {
        int a = e[i ^ 1], b = e[i];
        if (st[a] && !st[b])
        {
            if (b == T) printf("%d -\n", a - n);
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/446906/
   。
AcWing 2326. 王者之剑    原题链接    困难
作者：    皓首不倦 ,  2020-09-25 19:40:00 ,  阅读 24

0


'''
方格涂色为黑白相间，相邻的黑色和白色格子之间连无向边构成二分图，
本质是要求二分图上最大权值和的独立子集，等价于求二分图最小权值和
的覆盖子集，然后用总权值减去最小覆盖子集的点权值和就是答案
'''



from collections import deque
class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow




m, n = map(int, input().split())
S, T = m * n + 1, m * n + 2

edges = []
total_w = 0

visit = set()

last_flag = 1
for i in range(m):
    grid = list(map(int, input().split()))
    flag = 1 - last_flag
    for j in range(n):
        total_w += grid[j]

        node = i * n + j + 1
        if flag == 0:
            edges.append((S, node, grid[j]))

            for ii, jj in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j-1)]:
                if ii < m and ii >= 0 and jj < n and jj >= 0:
                    ne = ii * n + jj + 1
                    if (node, ne) not in visit:
                        visit.add((node, ne))
                        edges.append((node, ne, 0x7fffffff))
        else:
            edges.append((node, T, grid[j]))

        flag = 1 - flag

    last_flag = 1 - last_flag

ans = total_w - FortdFulkerson(edges, S, T, m*n+2, len(edges)).getMaxFlow()
print(ans)




作者：皓首不倦
链接：https://www.acwing.com/solution/content/21382/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010, M = 60010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

int get(int x, int y)
{
    return (x - 1) * m + y;
}

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n * m + 1;
    memset(h, -1, sizeof h);

    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            int w;
            scanf("%d", &w);
            if (i + j & 1)
            {
                add(S, get(i, j), w);
                for (int k = 0; k < 4; k ++ )
                {
                    int x = i + dx[k], y = j + dy[k];
                    if (x >= 1 && x <= n && y >= 1 && y <= m)
                        add(get(i, j), get(x, y), INF);
                }
            }
            else
                add(get(i, j), T, w);
            tot += w;
        }

    printf("%d\n", tot - dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/446979/
   。
AcWing 381. 有线电视网络    原题链接    简单
作者：    皓首不倦 ,  2020-09-25 23:54:13 ,  阅读 27

0


没搞懂输入数据格式搞成这么奇怪的格式是为什么，代码浪费时间去处理这种奇怪的输入格式，没看出来有什么意义



'''
每一个点拆成出点和入点
枚举源点S和汇点T，S入点和出点间连边权无穷大的有向边，T入点和出点之间连边权无穷大的有向边
其他点的入点和出点之间连接边权是1的有向边
原图中已经有的无向边转成两条有向边，有向边起点对应的点的出节点向有向边终点的入节点连接边权
是1的有向边，求取S到T的最小割，割边一定都是除了源点和汇点之间的其他点的入点和出点之间的边
割边的数量就是最小割数值，也就是最少要删除多少条入点和出点之间的边，才能让S到T不连通
也就等价于是删除多少个S T以外的点，能够让S T不连通，枚举 S 和 T 找需要删除的点的最小个数
就是最后的答案

'''



from typing import List
from collections import deque
import sys


class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow




while True:

    try:
        s = input()
        if s == '':
            continue
        ss = s.split()
        n, m = int(ss[0]), int(ss[1])
    except:
        break

    e = []
    for num_s in ss[2:]:
        a, b = map(int, num_s[1:-1].split(','))
        a, b = a + 1, b + 1
        e.append((a, b))

    while len(e) < m:
        s = input()
        ss = s.split()
        for num_s in ss:
            a, b = map(int, num_s[1:-1].split(','))
            a, b = a + 1, b + 1
            e.append((a, b))


    ans = n
    for S in range(1, n+1):
        for T in range(1, n+1):
            if S == T:
                continue

            edges = []
            for node in range(1, n+1):
                if node != S and node != T:
                    edges.append((node, node+n, 1))
                else:
                    edges.append((node, node+n, 0x7fffffff))

            for a, b in e:
                edges.append((a+n, b, 0x7fffffff))
                edges.append((b+n, a, 0x7fffffff))

            ans = min(ans, FortdFulkerson(edges, S, T, 2*n, len(edges)).getMaxFlow())

    print(ans)


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21395/
   。
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 5210, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    while (cin >> n >> m)
    {
        memset(h, -1, sizeof h);
        idx = 0;
        for (int i = 0; i < n; i ++ ) add(i, n + i, 1);
        while (m -- )
        {
            int a, b;
            scanf(" (%d,%d)", &a, &b);
            add(n + a, b, INF);
            add(n + b, a, INF);
        }
        int res = n;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < i; j ++ )
            {
                S = n + i, T = j;
                for (int k = 0; k < idx; k += 2)
                {
                    f[k] += f[k ^ 1];
                    f[k ^ 1] = 0;
                }
                res = min(res, dinic());
            }
        printf("%d\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/447889/
   。

AcWing 2176. 太空飞行计划问题 最大权闭合子图模型应用    原题链接    困难
作者：    皓首不倦 ,  2020-09-26 11:21:27 ,  阅读 19

0



'''
转换为最大权闭合子图问题求解
所有试验是正权点，所有器材是负权点，正权点对一些负权点有依赖，负权点没有对外依赖
因此最后选择的方案一定是一个闭合点集
直接用最大权闭合子图模型求解即可
'''


from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 获取最小割的划分方案，返回最小割容量以及两个列表，第一个列表为和源点在一个集合中的所有点，第二个列表是和汇点在同一个集合中的所有点
    def getMinCut(self):
        e = [-1] * (self.max_edge_num * 2 + 1)          # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)          # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)         # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        min_cut_cap = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            min_cut_cap += dfs(self.source_node, 0x7fffffff)

        visit = [0] * (self.max_node_num + 1)
        def travel(cur):
            visit[cur] = 1

            idx = h[cur]
            while idx != -1:
                next_node = e[idx]
                if visit[next_node] == 0 and f[idx] > 0:
                    travel(next_node)

                idx = ne[idx]

        travel(self.source_node)
        s_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 1]
        t_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 0]

        return min_cut_cap, s_nodes, t_nodes


m, n = map(int, input().split())
S, T = m+n+1, m+n+2
edges = []

pos_node_sum = 0
for i in range(1, m+1):
    arr = list(map(int, input().split()))
    edges.append((S, i, arr[0]))
    pos_node_sum += arr[0]
    for node in arr[1:]:
        edges.append((i, node+m, 0x7fffffff))

arr = list(map(int, input().split()))
for i, val in enumerate(arr):
    edges.append((i+1+m, T, val))

min_cut_cap, s_nodes, _ = FortdFulkerson(edges, S, T, m+n+2, len(edges)).getMinCut()
max_profit = pos_node_sum - min_cut_cap


pos_nodes = []
neg_nodes = []
for node in s_nodes:
    if node >= 1 and node <= m:
        pos_nodes.append(node)
    elif node >= m+1 and node <= m+n:
        neg_nodes.append(node - m)

for node in pos_nodes:
    print(node, end=' ')
print()

for node in neg_nodes:
    print(node, end=' ')
print()
print(max_profit)



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21410/
   。

#include <iostream>
#include <cstring>
#include <sstream>
#include <algorithm>

using namespace std;

const int N = 110, M = 5210, INF = 1e8;

int m, n, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

void dfs(int u)
{
    st[u] = true;
    for (int i = h[u]; ~i; i = ne[i])
        if (!st[e[i]] && f[i])
            dfs(e[i]);
}

int main()
{
    scanf("%d%d", &m, &n);
    S = 0, T = m + n + 1;
    memset(h, -1, sizeof h);
    getchar();  // 过滤掉第一行最后的回程

    int tot = 0;
    for (int i = 1; i <= m; i ++ )
    {
        int w, id;
        string line;
        getline(cin, line);
        stringstream ssin(line);
        ssin >> w;
        add(S, i, w);
        while (ssin >> id) add(i, m + id, INF);
        tot += w;
    }
    for (int i = 1; i <= n; i ++ )
    {
        int p;
        cin >> p;
        add(m + i, T, p);
    }

    int res = dinic();
    dfs(S);

    for (int i = 1; i <= m; i ++ )
        if (st[i]) printf("%d ", i);
    puts("");
    for (int i = m + 1; i <= m + n; i ++ )
        if (st[i]) printf("%d ", i - m);
    puts("");
    printf("%d\n", tot - res);
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/447945/
   。

AcWing 2199. 骑士共存问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-26 14:36:31 ,  阅读 19

0



'''
抽象成一个二分图放棋子问题，能放如果一个位置能够放棋子，其相邻8个位置就不能再放棋子，这个位置和
相邻的8个位置之间连二分图的边，可以明显看出边只可能在颜色不同的两个端点之间，因此模型就是一个
二分图找最大权独立点集中的点权和，每一个点的权值为1，用最大流算法求解即可
'''


from typing import List
from collections import deque

import sys


class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow




n, m = map(int, input().split())
grid = [[0] * (n+1) for _ in range(n+1)]
total_nodes = n*n


for _ in range(m):
    s = sys.stdin.readline().strip()
    a, b = map(int, s.split())
    grid[a][b] = 1
    total_nodes -= 1


def node2idx(i, j):
    return 1 + (i-1) * n + (j-1)


start_flag = 1
S, T = n *n + 1, n*n + 2
edges = []
for i in range(1, n+1):
    start_flag = 1 - start_flag
    flag = start_flag
    for j in range(1, n+1):

        if grid[i][j] == 1:
            flag = 1 - flag
            continue

        node = node2idx(i, j)

        if flag == 0:
            edges.append((S, node, 1))

            for ii, jj in [(i-1, j-2), (i+1, j-2), (i-1, j+2), (i+1, j+2), (i-2, j-1), (i+2, j-1), (i-2, j+1), (i+2, j+1)]:
                if ii >= 1 and ii <= n and jj >= 1 and jj <= n:
                    if grid[ii][jj] == 1:
                        continue

                    new_node = node2idx(ii, jj)
                    edges.append((node, new_node, 0x7fffffff))
        else:
            edges.append((node, T, 1))

        flag = 1 - flag

print(total_nodes - FortdFulkerson(edges, S, T, n*n+2, len(edges)).getMaxFlow())




作者：皓首不倦
链接：https://www.acwing.com/solution/content/21415/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 40010, M = 400010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
bool g[210][210];

int get(int x, int y)
{
    return (x - 1) * n + y;
}

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n * n + 1;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int x, y;
        scanf("%d%d", &x, &y);
        g[x][y] = true;
    }

    int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};
    int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
        {
            if (g[i][j]) continue;
            if (i + j & 1)
            {
                add(S, get(i, j), 1);
                for (int k = 0; k < 8; k ++ )
                {
                    int x = i + dx[k], y = j + dy[k];
                    if (x >= 1 && x <= n && y >= 1 && y <= n && !g[x][y])
                        add(get(i, j), get(x, y), INF);
                }
            }
            else add(get(i, j), T, 1);
            tot ++ ;
        }

    printf("%d\n", tot - dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/448005/
   。

AcWing 2174. 费用流    原题链接    中等
作者：    皓首不倦 ,  2020-09-26 21:03:48 ,  阅读 32

1



'''
费用流算法实现，增广路查找用SPFA实现
'''


from collections import deque

class SPFA:

    # start_node 为起始点，edges是边的三元组(节点1， 节点2， 边权重) is_directed表示是否是有向图
    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))


    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1

        # 进行V次迭代，第V次检查是否是无解情况
        iter_times = 0
        while iter_times < self.max_node_num:
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            iter_times += 1

            if iter_times == self.max_node_num:
                if update_flag:
                    return False

            if not update_flag:
                break

        return True


class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num


    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if not algo.getMinPathLen(pre, f) if min_cost else algo.getMaxPathLen(pre, f):
                break

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]


n, m, S, T = map(int, input().split())
edges = []
for _ in range(m):
    a, b, w, c = map(int, input().split())
    edges.append((a, b, w, c))

ans = FortdFulkerson(edges, S, T, n, len(edges)).getCostFlow()[:-1]
print(ans[0], ans[1])



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21432/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 5010, M = 100010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, 0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }

    return incf[T] > 0;
}

void EK(int& flow, int& cost)
{
    flow = cost = 0;
    while (spfa())
    {
        int t = incf[T];
        flow += t, cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        add(a, b, c, d);
    }

    int flow, cost;
    EK(flow, cost);
    printf("%d %d\n", flow, cost);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/457817/
   。
cWing 2192. 运输问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-26 22:23:29 ,  阅读 24

1





'''
抽象成费用流模型求解，求最大费用最大流和最小费用最大流的费用
'''


from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]


n, m = map(int, input().split())
S, T = n + m + 1, n + m + 2

arr = list(map(int, input().split()))
edges = []
for i, val in enumerate(arr):
    edges.append((S, i+1, arr[i], 0))

arr = list(map(int, input().split()))
for i, val in enumerate(arr):
    edges.append((i+1+n, T, arr[i], 0))

for i in range(1, n+1):
    arr = list(map(int, input().split()))
    for j in range(1, m+1):
        cost = arr[j-1]
        edges.append((i, j + n, 0x7fffffff, cost))

algo = FortdFulkerson(edges, S, T, m+n+2, len(edges))
print(algo.getCostFlow()[1])

algo = FortdFulkerson(edges, S, T, m+n+2, len(edges))
print(algo.getCostFlow(min_cost=False)[1])




作者：皓首不倦
链接：https://www.acwing.com/solution/content/21439/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 160, M = 5150 * 2 + 10, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, 0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(incf[t], f[i]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    scanf("%d%d", &m, &n);
    S = 0, T = m + n + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= m; i ++ )
    {
        int a;
        scanf("%d", &a);
        add(S, i, a, 0);
    }
    for (int i = 1; i <= n; i ++ )
    {
        int b;
        scanf("%d", &b);
        add(m + i, T, b, 0);
    }
    for (int i = 1; i <= m; i ++ )
        for (int j = 1; j <= n; j ++ )
        {
            int c;
            scanf("%d", &c);
            add(i, m + j, INF, c);
        }

    printf("%d\n", EK());

    for (int i = 0; i < idx; i += 2)
    {
        f[i] += f[i ^ 1], f[i ^ 1] = 0;
        w[i] = -w[i], w[i ^ 1] = -w[i ^ 1];
    }
    printf("%d\n", -EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/457863/
   。
AcWing 2194. 负载平衡问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-26 23:40:35 ,  阅读 15

0







from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]




n = int(input())
arr = []
while len(arr) < n:
    s = input()
    arr.extend(list(map(int, s.split())))

mean = sum(arr) // len(arr)

S, T = n+1, n+2
edges = []
for i, val in enumerate(arr):
    node = i+1
    if val >= mean:
        edges.append((S, node, val-mean, 0))
    else:
        edges.append((node, T, mean-val, 0))

    left = node - 1 if node != 1 else n
    right = node + 1 if node != n else 1

    edges.append((node, left, 0x7fffffff, 1))
    edges.append((node, right, 0x7fffffff, 1))

print(FordFulkerson(edges, S, T, n+2, len(edges)).getCostFlow()[1])




作者：皓首不倦
链接：https://www.acwing.com/solution/content/21447/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 610, INF = 1e8;

int n, S, T;
int s[N];
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, 0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    scanf("%d", &n);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
    {
        scanf("%d", &s[i]);
        tot += s[i];
        add(i, i < n ? i + 1 : 1, INF, 1);
        add(i, i > 1 ? i - 1 : n, INF, 1);
    }

    tot /= n;
    for (int i = 1; i <= n; i ++ )
        if (tot < s[i])
            add(S, i, s[i] - tot, 0);
        else if (tot > s[i])
            add(i, T, tot - s[i], 0);

    printf("%d\n", EK());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/457906/
   。
AcWing 2193. 分配问题 最大流方式求二分图最大匹配的最小费用和最大费用    原题链接    困难
作者：    皓首不倦 ,  2020-09-27 16:05:20 ,  阅读 20

0



'''
用最大流算法求二分图的最大花费最大匹配和最小花费最大匹配
工作和员工分别当做二分图中的Par1和Part2, 两个部分之间
节点的边的容量是1，费用是员工做工作的收益值，按照二分图
匹配对应的最大流模型建图即可
'''

from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1

        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]




n = int(input())
edges = []
for i in range(1, n+1):
    arr = list(map(int, input().split()))
    for j in range(1, n+1):
        edges.append((i, j+n, 1, arr[j-1]))

S, T = 2*n+1, 2*n+2
for node in range(1, n+1):
    edges.append((S, node, 1, 0))
for node in range(n+1, 2*n+1):
    edges.append((node, T, 1, 0))

algo = FordFulkerson(edges, S, T, 2*n+2, len(edges))
print(algo.getCostFlow()[1])
print(algo.getCostFlow(min_cost=False)[1])



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21473/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 5210, INF = 1e8;

int n, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, 0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    scanf("%d", &n);
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ )
    {
        add(S, i, 1, 0);
        add(n + i, T, 1, 0);
    }
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
        {
            int c;
            scanf("%d", &c);
            add(i, n + j, 1, c);
        }

    printf("%d\n", EK());

    for (int i = 0; i < idx; i += 2)
    {
        f[i] += f[i ^ 1], f[i ^ 1] = 0;
        w[i] = -w[i], w[i ^ 1] = -w[i ^ 1];
    }
    printf("%d\n", -EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/457930/
   。
AcWing 2191. 数字梯形问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-27 20:11:05 ,  阅读 21

0







from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]



m, n = map(int, input().split())
total_nodes = (m + m + (n-1)) * n // 2
S, T = total_nodes*2 + 1, total_nodes*2 + 2

grid = []
for i in range(n):
    grid.append(list(map(int, input().split())))


def pos2idx(i, j):
    return (m+m+(i-1))*i // 2 + (j+1)



# 第一问
edges = []
# 内部边
for node in range(1, total_nodes+1):
    edges.append((node, node+total_nodes, 1, 0))

# 源点到第一层节点的边
for j in range(m):
    node = pos2idx(0, j)
    edges.append((S, node, 1, grid[0][j]))

# 每一层和下一层的边
for i in range(n-1):
    for j in range(len(grid[i])):
        node = pos2idx(i, j) + total_nodes

        new_node = pos2idx(i+1, j)
        edges.append((node, new_node, 1, grid[i+1][j]))

        new_node = pos2idx(i+1, j+1)
        edges.append((node, new_node, 1, grid[i+1][j+1]))

# 最后一层和汇点之间的边
for j in range(len(grid[n-1])):
    node = pos2idx(n-1, j) + total_nodes
    edges.append((node, T, 0x7fffffff, 0))

ans = FordFulkerson(edges, S, T, 2*total_nodes+2, len(edges)).getCostFlow(min_cost=False)
print(ans[1])



# 第二问
edges = []
# 内部边
for node in range(1, total_nodes+1):
    edges.append((node, node+total_nodes, 0x7fffffff, 0))

# 源点到第一层节点的边
for j in range(m):
    node = pos2idx(0, j)
    edges.append((S, node, 1, grid[0][j]))

# 每一层和下一层的边
for i in range(n-1):
    for j in range(len(grid[i])):
        node = pos2idx(i, j) + total_nodes

        new_node = pos2idx(i+1, j)
        edges.append((node, new_node, 1, grid[i+1][j]))

        new_node = pos2idx(i+1, j+1)
        edges.append((node, new_node, 1, grid[i+1][j+1]))

# 最后一层和汇点之间的边
for j in range(len(grid[n-1])):
    node = pos2idx(n-1, j) + total_nodes
    edges.append((node, T, 0x7fffffff, 0))

ans = FordFulkerson(edges, S, T, 2*total_nodes+2, len(edges)).getCostFlow(min_cost=False)
print(ans[1])


# 第三问
edges = []
# 内部边
for node in range(1, total_nodes+1):
    edges.append((node, node+total_nodes, 0x7fffffff, 0))

# 源点到第一层节点的边
for j in range(m):
    node = pos2idx(0, j)
    edges.append((S, node, 1, grid[0][j]))

# 每一层和下一层的边
for i in range(n-1):
    for j in range(len(grid[i])):
        node = pos2idx(i, j) + total_nodes

        new_node = pos2idx(i+1, j)
        edges.append((node, new_node, 0x7fffffff, grid[i+1][j]))

        new_node = pos2idx(i+1, j+1)
        edges.append((node, new_node, 0x7fffffff, grid[i+1][j+1]))

# 最后一层和汇点之间的边
for j in range(len(grid[n-1])):
    node = pos2idx(n-1, j) + total_nodes
    edges.append((node, T, 0x7fffffff, 0))

ans = FordFulkerson(edges, S, T, 2*total_nodes+2, len(edges)).getCostFlow(min_cost=False)
print(ans[1])



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21482/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1200, M = 4000, INF = 1e8;

int m, n, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];
int id[40][40], cost[40][40];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, -0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] < d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    int cnt = 0;
    scanf("%d%d", &m, &n);
    S = ++ cnt;
    T = ++ cnt;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m + i - 1; j ++ )
        {
            scanf("%d", &cost[i][j]);
            id[i][j] = ++ cnt;
        }

    // 规则1
    memset(h, -1, sizeof h), idx = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m + i - 1; j ++ )
        {
            add(id[i][j] * 2, id[i][j] * 2 + 1, 1, cost[i][j]);
            if (i == 1) add(S, id[i][j] * 2, 1, 0);
            if (i == n) add(id[i][j] * 2 + 1, T, 1, 0);
            if (i < n)
            {
                add(id[i][j] * 2 + 1, id[i + 1][j] * 2, 1, 0);
                add(id[i][j] * 2 + 1, id[i + 1][j + 1] * 2, 1, 0);
            }
        }
    printf("%d\n", EK());

    // 规则2
    memset(h, -1, sizeof h), idx = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m + i - 1; j ++ )
        {
            add(id[i][j] * 2, id[i][j] * 2 + 1, INF, cost[i][j]);
            if (i == 1) add(S, id[i][j] * 2, 1, 0);
            if (i == n) add(id[i][j] * 2 + 1, T, INF, 0);
            if (i < n)
            {
                add(id[i][j] * 2 + 1, id[i + 1][j] * 2, 1, 0);
                add(id[i][j] * 2 + 1, id[i + 1][j + 1] * 2, 1, 0);
            }
        }
    printf("%d\n", EK());

    // 规则3
    memset(h, -1, sizeof h), idx = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m + i - 1; j ++ )
        {
            add(id[i][j] * 2, id[i][j] * 2 + 1, INF, cost[i][j]);
            if (i == 1) add(S, id[i][j] * 2, 1, 0);
            if (i == n) add(id[i][j] * 2 + 1, T, INF, 0);
            if (i < n)
            {
                add(id[i][j] * 2 + 1, id[i + 1][j] * 2, INF, 0);
                add(id[i][j] * 2 + 1, id[i + 1][j + 1] * 2, INF, 0);
            }
        }
    printf("%d\n", EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/457967/
   。
AcWing 382. K取方格数    原题链接    困难
作者：    皓首不倦 ,  2020-09-27 22:44:10 ,  阅读 22

0





from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]


n, k = map(int, input().split())
grid = []
for i in range(n):
    grid.append(list(map(int, input().split())))

def pos2idx(i, j):
    return i*n + j + 1

edges = []
S, T = n*n*2 + 1, n*n*2 + 2
edges.append((S, 1, k, 0))


for i in range(n):
    for j in range(n):
        node = pos2idx(i, j)
        # 内部边
        edges.append((node, node+n*n, 1, grid[i][j]))
        edges.append((node, node+n*n, 0x7fffffff, 0))


        for ii, jj in [(i+1, j), (i, j+1)]:
            if ii < n and jj < n:
                new_node = pos2idx(ii, jj)
                edges.append((node+n*n, new_node, 0x7fffffff, 0))

node = pos2idx(n-1,n-1)
edges.append((node+n*n, T, 0x7fffffff, 0))

ans = FordFulkerson(edges, S, T, n*n*2+2, len(edges)).getCostFlow(min_cost=False)
print(ans[1])




作者：皓首不倦
链接：https://www.acwing.com/solution/content/21495/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 5010, M = 20010, INF = 1e8;

int n, k, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

int get(int x, int y, int t)
{
    return (x * n + y) * 2 + t;
}

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, -0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] < d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(incf[t], f[i]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    scanf("%d%d", &n, &k);
    S = 2 * n * n, T = S + 1;
    memset(h, -1, sizeof h);
    add(S, get(0, 0, 0), k, 0);
    add(get(n - 1, n - 1, 1), T, k, 0);
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
        {
            int c;
            scanf("%d", &c);
            add(get(i, j, 0), get(i, j, 1), 1, c);
            add(get(i, j, 0), get(i, j, 1), INF, 0);
            if (i + 1 < n) add(get(i, j, 1), get(i + 1, j, 0), INF, 0);
            if (j + 1 < n) add(get(i, j, 1), get(i, j + 1, 0), INF, 0);
        }

    printf("%d\n", EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/458914/
   。

AcWing 2195. 深海机器人问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-28 11:16:09 ,  阅读 19

0



'''
所有机器人出发点当做源点，所有机器人的目的地当做汇点，整个模型是多源多汇最大费用最
大流模型，边的两个端点之间需要构造两条边，一条边容量是1，费用是边的费用，一条边容量
是正无穷，费用是0，用于约束每一条边的费用只被一个流量使用一次
'''

from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]

a, b = map(int, input().split())
p, q = map(int, input().split())
p, q = p+1, q+1
S, T = p*q + 1, p*q + 2

def pos2idx(i, j):
    return i * q + j + 1

edges = []
for i in range(p):
    arr = list(map(int, input().split()))
    for j in range(q-1):
        node, new_node = pos2idx(i, j), pos2idx(i, j+1)
        edges.append((node, new_node, 1, arr[j]))
        edges.append((node, new_node, 0x7fffffff, 0))

for i in range(q):
    arr = list(map(int, input().split()))
    for j in range(p-1):
        node, new_node = pos2idx(j, i), pos2idx(j+1, i)
        edges.append((node, new_node, 1, arr[j]))
        edges.append((node, new_node, 0x7fffffff, 0))

for _ in range(a):
    w, i, j= map(int, input().split())
    edges.append((S, pos2idx(i, j), w, 0))

for _ in range(b):
    w, i, j = map(int, input().split())
    edges.append((pos2idx(i, j), T, w, 0))

print(FordFulkerson(edges, S, T, p*q+2, len(edges)).getCostFlow(min_cost=False)[1])



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21509/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 260, M = 2000, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

int get(int x, int y)
{
    return x * (m + 1) + y;
}

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, -0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] < d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    int A, B;
    scanf("%d%d%d%d", &A, &B, &n, &m);
    S = (n + 1) * (m + 1), T = S + 1;
    memset(h, -1, sizeof h);
    for (int i = 0; i <= n; i ++ )
        for (int j = 0; j < m; j ++ )
        {
            int c;
            scanf("%d", &c);
            add(get(i, j), get(i, j + 1), 1, c);
            add(get(i, j), get(i, j + 1), INF, 0);
        }
    for (int i = 0; i <= m; i ++ )
        for (int j = 0; j < n; j ++ )
        {
            int c;
            scanf("%d", &c);
            add(get(j, i), get(j + 1, i), 1, c);
            add(get(j, i), get(j + 1, i), INF, 0);
        }
    while (A -- )
    {
        int k, x, y;
        scanf("%d%d%d", &k, &x, &y);
        add(S, get(x, y), k, 0);
    }
    while (B -- )
    {
        int r, x, y;
        scanf("%d%d%d", &r, &x, &y);
        add(get(x, y), T, r, 0);
    }

    printf("%d\n", EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/458952/
   。

AcWing 2184. 餐巾计划问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-28 13:47:53 ,  阅读 20

0





from collections import deque
class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]

N, p, m, f, n, s = map(int, input().split())
r = [0] * (N+1)
for i in range(N):
    r[i+1] = int(input())

S, T = N+N+1, N+N+2
edges = []
for node in range(1, N+1):
    edges.append((S, node, 0x7fffffff, p))
    if node-m >= 1:
        edges.append((node-m+N, node, 0x7fffffff, f))
    if node-n >= 1:
        edges.append((node-n+N, node, 0x7fffffff, s))

    edges.append((node, T, r[node], 0))

    if node + 1 <= N:
        edges.append((node+N, node+1+N, 0x7fffffff, 0))
    edges.append((S, node+N, r[node], 0))

print(FordFulkerson(edges, S, T, 2*N+2, len(edges)).getCostFlow()[1])



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21514/
   。
