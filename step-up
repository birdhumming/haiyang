AcWing 2171. EK求最大流    原题链接    中等
作者：    duoduola ,  2020-07-27 16:19:28 ,  阅读 174

7


1
（就是想来理一理思路。小菜鸡第一次写题解(可能也不算是题解)，之前都只是做一做题的。）
（语言可能描述的不到位或者不清楚(感觉有些地方说不太清呀~~~,然后也不太会写题解)，错误的地方请大家指出）

存下图，建立反向边，构建残余网络，在残余网络中不断寻找增广路径，维护残余网络，将其累加至答案中，直到找不到增广路径。
1~n的节点之间的边通过add函数来记录，边的编号从2开始。
在点s之前新增一条编号为1的边，起点是一个新增的点(编号是多少没有用到，所以也没有管它.jpg)，终点为s（这样是为了写bfs的代码时候方便一些，不用先处理以s为顶点的边，直接从编号为1的这条边开始就好）

代码中有注释~~~

代码如下：

#include<iostream>
#include<cstring>
using namespace std;
const int N=1010,M=20010;

//h[i]存下以点i为起点的边的编号（按输入顺序，存下的是最后一条边的编号）
//f[i]存下边i的权值，e[i]存下边i的终点，ne[i]存下和边i同起点的上一条边的编号(可以依次找出同起点的所有边)
//idx用来记录边的编号
//p,d,pre三个数组在bfs寻找增广路径时使用，来记录当前搜到的边的信息，
//p[i]表示当前边的编号，d[i]表示走到这条边的路径中最小的边权值(最大的可行流量)，
//pre[i]表示当前这一条边是从之前的哪一条走过来的(记录的是bfs过程中的相应下标)
//tot用来记录bfs过程中展开的边的数量，下标为tot的位置是增广路径的最后一条边(其终点为t)
//n,m,s,t如题，mark用来标记bfs过程中已经到达了的点，防止重复搜索
int h[N]={0},f[M]={0},e[M]={0},ne[M]={0},idx=2;
int p[N]={0},d[N]={0},pre[N]={0},tot=0,n=0,m=0,s=0,t=0;
bool mark[N]={0};

//存下边的信息，同时要存下反向边，构建残余网络
void add(int& a,int& b,int& c){
    e[idx]=b;f[idx]=c;ne[idx]=h[a];h[a]=idx;idx++;
    e[idx]=a;f[idx]=0;ne[idx]=h[b];h[b]=idx;idx++;
}

//bfs找增广路径，结果记录在p,d,pre三个数组中
bool bfs(){
    int l=0;tot=0;//l是左端点，tot相当于右端点(每次重新置为0)
    memset(mark,0,sizeof(mark));//mark数组赋为false
    while(l<=tot){  //l<=tot,还要继续展开边
        //p[l]表示当前这条边的编号，e[p[l]]表示当前这条边的终点，h[e[p[l]]]表示以这一终点为顶点的一条边
        //通过ne数组不断找到以这一终点为顶点的所有边，for循环中的i就是这些边的编号
        for(int i=h[e[p[l]]];i;i=ne[i]){    //h数组的初始值为0，当i为0时表示以e[p[l]]为起点的边都搜过了
            if(!mark[e[i]]&&f[i]){//如果当前边的终点还没有到达过并且当前这条边的权值大于0，就会展开这一条边
                tot++;//右边界++,并标记上这条边的终点
                mark[e[i]]=1;
                //存下这条边，p[tot]存下编号i，
                //d[tot]存下路径中最小的权值(到达上一条边时最小权值d[l]和当前边i的权值中的最小值)
                //pre[tot]存下当前这一边是从下标l位置的那条边走过来的
                p[tot]=i;d[tot]=min(f[i],d[l]);pre[tot]=l;
                if(e[i]==t)return true;//当前这条边到达了终点，返回true
            }
        }
        l++;// l不要忘记++(因为我就忘了)，继续展开下一条边
    }
    return false;//没有找到增广路径辽~
}
int main(){
    std::ios::sync_with_stdio(false);
    cin>>n>>m>>s>>t;
    e[1]=s;//添加编号为1的边，其终点为s（边的其他信息没有管它，因为没有用到~~
    p[0]=1;d[0]=1e9;//bfs的起点是这条编号为1的边，当前最小权值赋成一个较大的值
    int a=0,b=0,c=0;
    while(m--){//输入边的信息，存下来
        cin>>a>>b>>c;
        add(a,b,c);
    }
    int ans=0;
    while(bfs()){//当前残网络中还可找到增广路径，则累加至ans中，并修改这条路径中正向边和反向边的权值
        ans+=d[tot];
        for(int i=tot;i;i=pre[i]){//从tot位置的边开始，沿着增广路径往回走，走到0位置的边(也就是边1时)停止
            //路径中的每一条边减去d[tot]，其反向边加上d[tot]
            f[p[i]]-=d[tot];f[p[i]^1]+=d[tot];
        }
    }
    cout<<ans<<endl;
    return 0;
}

作者：duoduola
链接：https://www.acwing.com/solution/content/17161/
   。
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010, M = 20010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], pre[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(st, false, sizeof st);
    q[0] = S, st[S] = true, d[S] = INF;
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (!st[ver] && f[i])
            {
                st[ver] = true;
                d[ver] = min(d[t], f[i]);
                pre[ver] = i;
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int EK()
{
    int r = 0;
    while (bfs())
    {
        r += d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
            f[pre[i]] -= d[T], f[pre[i] ^ 1] += d[T];
    }
    return r;
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    printf("%d\n", EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/403258/
   。

AcWing 2172. Dinic/ISAP求最大流 - python3    原题链接    中等
作者：    roon2300 ,  2020-08-11 14:45:43 ,  阅读 103

2


1
C++ 版：

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010, M = 200010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], nh[N];

inline void add(int a, int b, int c){
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

bool bfs(){
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, nh[S] = h[S];
    int hh = 0, tt = 1;
    while (hh < tt){
        int t = q[hh ++];
        for (int i = h[t]; ~i; i = ne[i]){
            int v = e[i];
            if (d[v] == -1 && f[i]){
                d[v] = d[t] + 1;
                nh[v] = h[v];   // 可以在开头全copy
                if (v == T) return true;
                q[tt ++] = v;
            }
        }
    }
    return false;
}

int find(int u, int limit){
    if (u == T) return limit;
    int flow = 0;

    for (int i = nh[u]; ~i && flow < limit; i = ne[i]){   // 1. nh 优化， 2. 增广最大量优化
        nh[u] = i;  // nh当前可行弧优化
        int v = e[i];
        if (d[v] == d[u] + 1 && f[i]){
            int t = find(v, min(f[i], limit - flow));
            if (t)  flow += t, f[i] -= t; //, f[i ^ 1] += t;
            else  d[v] = -1;       // 3. 废点优化
        }
    }
    return flow;
}

int dinic(){
    int res = 0, flow;
    while( bfs() ) while (flow = find(S, INF)) res += flow;
    return res;
}

int main(){
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- ){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, 0);
    }
    printf("%d\n", dinic());
    return 0;
}


python3 版：

N, M, inf = 10010, 200010, float('inf')

h, e, f, ne, idx = [-1] * N, [0] * M, [0] * M, [0] * M, 0

q, d, nh = [0] * N, [-1] * N, [0] * N  # d: dist or level 

def add(a, b, c):
    global idx
    e[idx], f[idx], ne[idx], h[a] = b, c, h[a], idx
    idx += 1

def bfs():
    """ rebuild nh[] and d[] """
    global nh, d
    nh = list(h)        # nh[S] = h[S]
    d = [-1] * N; d[S] = 0

    q[0] = S; hh, tt = 0, 1
    while hh < tt:
        u = q[hh]; hh += 1
        i = h[u]
        while i != -1:
            v = e[i]
            if d[v] == -1 and f[i]:
                d[v] = d[u] + 1     #  nh[v] = h[v]
                if v == T: return True   # T 也是要标d和cur的
                q[tt] = v; tt += 1
            i = ne[i]

    return False

def find(u, limit):
    if u == T: return limit
    flow = 0
    i = nh[u]        # 1. 当前(起始可用)弧优化
    while i != -1 and flow < limit:   # 2. 最大增广量优化
        nh[u] = i    # 当前弧优化。  进阶指南似乎放的位置效率比较低
        v = e[i]
        if d[v] == d[u] + 1 and f[i]:             # 标层级
            t = find(v, min(f[i], limit - flow))  # 避免无限递归
            if t: flow += t; f[i] -= t;  # f[i ^ 1] += t  
            else: d[v] = -1         # 3. 废点优化，本轮bfs里面不再可能是增广路
        i = ne[i]

    return flow

def dinic():
    res = 0
    while bfs():
        flow = find(S, inf)
        while flow:
            res += flow
            flow = find(S, inf)
    return res


n, m, S, T = map(int, input().split())
while m:
    a, b, c = map(int, input().split())
    add(a, b, c); add(b, a, 0)
    m -= 1
print(dinic())

loj #127. 最大流 加强版


// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define maxn 1300
#define maxm 120010
using namespace std;
struct edge {
    int u, v, cap;
} e[maxm];
struct Dinic {
    int tp, s, t, dis[maxn], cur[maxn], que[maxn];
    vector<edge> e;
    vector<int> v[maxn];
    void AddEdge(int x, int y, int flw) {
        e.push_back(edge{ x, y, flw });
        e.push_back(edge{ y, x, 0 });
        v[x].push_back(e.size() - 2);
        // v[y].push_back(e.size()-1);
    }
    int bfs() {
        memset(dis, 0x3f, sizeof dis);
        int l = 1, r = 1;
        que[1] = s;
        dis[s] = 0;
        while (l <= r) {
            int p = que[l++], to;
            for (int i : v[p])
                if (e[i].cap && dis[to = e[i].v] > 1e9)
                    dis[to] = dis[p] + 1, que[++r] = to;
        }
        return dis[t] < 1e9;
    }
    int dfs(int p, int a) {
        if (p == t || !a)
            return a;
        int sf = 0, flw;
        for (int &i = cur[p], to; i < (int)v[p].size(); ++i) {
            edge &E = e[v[p][i]];
            if (dis[to = E.v] == dis[p] + 1 && (flw = dfs(to, min(a, E.cap)))) {
                E.cap -= flw;
                e[v[p][i] ^ 1].cap += flw;
                a -= flw;
                sf += flw;
                if (!a)     // 把此处移到for的判断里会有问题。。。
                    break;
            }
        }
        return sf;
    }
    int dinic(int s, int t, int tp = 1) {
        this->s = s;
        this->t = t;
        this->tp = tp;
        int flw = 0;
        while (bfs()) {
            memset(cur, 0, sizeof cur);
            flw += dfs(s, INT_MAX);
        }
        return flw;
    }
} sol;
int n, m, i, s, t, ans;
int main() {
    scanf("%d%d%d%d", &n, &m, &s, &t);
    for (i = 0; i < m; i++) scanf("%d%d%d", &e[i].u, &e[i].v, &e[i].cap);
    sort(e, e + m, [](edge a, edge b) { return a.cap > b.cap; });
    for (int tp : { 0, 1 })
        for (int p = 1 << 30, i = 0; p; p /= 2) {
            while (i < m && e[i].cap >= p) {
                if (tp)
                    sol.v[e[i].v].push_back(i * 2 + 1);
                else
                    sol.AddEdge(e[i].u, e[i].v, e[i].cap);
                i++;
            }
            ans += sol.dinic(s, t, tp);
        }
    printf("%d\n", ans);
    return 0;
}

关于最后的

    for (int tp : { 0, 1 })
        for (int p = 1 << 30, i = 0; p; p /= 2) {
参考 论如何用dinic ac 最大流 加强版 里面的解释：
1. 先不加反向边跑一遍，然后一次性把反向边都加进去，然后再跑一遍
2. 二进制缩放，只跑大于p的边
看起来应该是针对数据的专门的优化

作者：roon2300
链接：https://www.acwing.com/solution/content/18166/
   。
自己都不知道自己写的是个啥
反正写完就神奇的过了。。
数据配图↓↓


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=10005;
const int M=200005;
const int INF=0x3fffffff;

int n,m,S,T;
int h[N],e[M],ne[M],idx;
int depth[N],flow[M];
int q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    flow[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

int bfs()
{
    memset(depth,0,sizeof depth);
    depth[S]=1,*q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(flow[i]&&!depth[e[i]])
            {
                depth[e[i]]=depth[t]+1;
                q[++tt]=e[i];
            }
    }
    return depth[T];
}

int dfs(int u,int T,int s)
{
    if(u==T)return s;
    int f=0;
    for(int i=h[u];i;i=ne[i])
        if(flow[i]&&depth[e[i]]==depth[u]+1)
        {
            int v=dfs(e[i],T,min(s,flow[i]));
            flow[(i-1^1)+1]+=v;
            flow[i]-=v;
            s-=v,f+=v;
        }
    if(!f)depth[u]=-1;
    return f;
}

int main()
{
    scanf("%d%d%d%d",&n,&m,&S,&T);
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c),add(b,a,0);
    }
    int res=0;
    while(bfs())res+=dfs(S,T,INF);
    printf("%d\n",res);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/401964/
   。


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010, M = 200010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T)  return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;  // 当前弧优化
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    printf("%d\n", dinic());

    return 0;


作者：yxc
链接：https://www.acwing.com/activity/content/code/content/412368/
   。
AcWing 2175. 飞行员配对方案问题    原题链接    困难
作者：    IEE_ ,  2020-08-16 23:25:27 ,  阅读 86

1


建立源点 S 与 1∼m1∼m 的所有飞行员连容量为 1 的边，将剩下的飞行员向汇点 T 连一条边，再将所给搭配连容量为 1 的边，求 S 至 T 的最大流即可

为了方便，将源点 S 设为 00，T 设为 n+1n+1。

此题代码：

signed main() {
  cin >> m >> n;

  memset(h, -1, sizeof h);
  S = 0, T = n + 1;
  for (int i = 1; i <= m; ++i) add(S, i, 1);
  for (int i = m + 1; i <= n; ++i) add(i, T, 1);
  int a, b;
  while (scanf("%d%d", &a, &b), a != -1 && b != -1) add(a, b, 1);

  cout << dinic() << endl;

  for (int i = 0; i < idx; i += 2) {
    if (e[i] > m && e[i] <= n && !f[i]) {
      cout << e[i ^ 1] << ' ' << e[i] << endl;
    }
  }
  return 0;
}

作者：IEE_
链接：https://www.acwing.com/solution/content/18579/
   。


AcWing 2175. 飞行员配对方案问题
作者：    垫底抽风 ,  2020-07-24 18:06:23 ,  阅读 74

2


匈牙利算法求二分图的最大匹配
模板题

#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

bool read(int &a,int &b)
{
    a=b=0;char ch=getchar();
    while(~ch&&ch!='-'&&(ch<48||ch>57))ch=getchar();
    if(ch=='-')return false;
    for(;ch>47&&ch<58;ch=getchar())a=(a<<1)+(a<<3)+(ch^48);
    while(~ch&&(ch<48||ch>57))ch=getchar();
    for(;ch>47&&ch<58;ch=getchar())b=(b<<1)+(b<<3)+(ch^48);
}

const int N=105;
const int M=10005;

int n1,n2,res;
int h[N],e[M],ne[M],idx;
int match[N];
bool st[N];

void add(int a,int b)
{
    e[++idx]=b;
    ne[idx]=h[a];
    h[a]=idx;
}

bool find(int u)
{
    for(int i=h[u];i;i=ne[i])
        if(!st[e[i]])
        {
            st[e[i]]=true;
            if(!match[e[i]]||find(match[e[i]]))
            {
                match[e[i]]=u;
                return true;
            }
        }
    return false;
}

int main()
{
    read(n1,n2);
    for(int a,b;read(a,b);add(a,b));
    for(int i=1;i<=n1;i++)
    {
        memset(st,false,sizeof st);
        if(find(i))res++;
    }
    printf("%d\n",res);
    for(int i=n2;i>n1;i--)
        if(match[i])
            printf("%d %d\n",match[i],i);
    return 0;
}
DinicDinic 求二分图的最大匹配

#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

bool read(int &a,int &b)
{
    a=b=0;char ch=getchar();
    while(~ch&&ch!='-'&&(ch<48||ch>57))ch=getchar();
    if(ch=='-')return false;
    for(;ch>47&&ch<58;ch=getchar())a=(a<<1)+(a<<3)+(ch^48);
    while(~ch&&(ch<48||ch>57))ch=getchar();
    for(;ch>47&&ch<58;ch=getchar())b=(b<<1)+(b<<3)+(ch^48);
    return true;
}

const int N=205;
const int M=20405;
const int INF=0x3fffffff;

int n1,n2,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int main()
{
    read(n1,n2),S=0,T=n2+1;
    for(int a,b;read(a,b);add(a,b,1),add(b,a,0));
    for(int i=1;i<=n1;i++)add(S,i,1),add(i,S,0);
    for(int i=n1+1;i<=n2;i++)add(i,T,1),add(T,i,0);
    int maxflow=0;
    while(bfs())
        for(int flow;flow=find(S,INF);)
            maxflow+=flow;
    printf("%d\n",maxflow);
    for(int i=h[S];i;i=ne[i])
        if(!w[i])
            for(int j=h[e[i]];j;j=ne[j])
                if(e[j]>n1&&!w[j])
                {
                    printf("%d %d\n",e[i],e[j]);
                    break;
                }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/402007/
   。


1


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 5210, INF = 1e8;

int m, n, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = h[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &m, &n);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= m; i ++ ) add(S, i, 1);
    for (int i = m + 1; i <= n; i ++ ) add(i, T, 1);

    int a, b;
    while (cin >> a >> b, a != -1) add(a, b, 1);

    printf("%d\n", dinic());
    for (int i = 0; i < idx; i += 2)
        if (e[i] > m && e[i] <= n && !f[i])
            printf("%d %d\n", e[i ^ 1], e[i]);

    return 0;


作者：yxc
链接：https://www.acwing.com/activity/content/code/content/412418/
   。

AcWing 2179. 圆桌问题    原题链接    困难
作者：    whsstory ,  2020-07-24 20:23:33 ,  阅读 114

3


特殊的二分图匹配问题。

可以拆点后跑二分图最大匹配。复杂度O(∑ri∑ci(∑ri+∑ci))O(∑ri∑ci(∑ri+∑ci)) ,可能会T 。

也可以直接跑最大流：源点S 向单位ii连容量为riri的边，单位ii向餐桌jj连容量为1的边，餐桌jj向汇点T 连容量为cici的边。这显然是个二分图。用Dinic求解最大流，复杂度为O(nm∑ri+∑ci‾‾‾‾‾‾‾‾‾‾‾√)(注意本题中边数为O(nm∑ri+∑ci)(注意本题中边数为nmnm)

//我的Dinic板子肯定没有y总的好，你们可以看看y总的
const ll INF=1ll<<50;
#define MAXN 200011
struct edge
{
    ll v,w,nxt;
}e[MAXN<<1|1];
ll cnt=1,last[MAXN],cur[MAXN];
void add_directed_edge(ll u,ll v,ll w)
{
    e[++cnt].v=v,e[cnt].w=w;
    e[cnt].nxt=last[u],last[u]=cnt;
}
void adde(ll u,ll v,ll w){add_directed_edge(u,v,w),add_directed_edge(v,u,0);}

ll dep[MAXN];
bool bfs(ll s,ll t,ll n)
{
    for(ll i=1;i<=n;++i)dep[i]=0,cur[i]=last[i];
    std::queue<ll>q;
    dep[s]=1,q.push(s);
    while(q.size())
    {
        ll u=q.front();q.pop();
        for(ll i=last[u];i;i=e[i].nxt)
        {
            ll v=e[i].v;
            if(!dep[v]&&e[i].w>0)dep[v]=dep[u]+1,q.push(v);
        }
    }
    return dep[t];
}
ll ex_flow(ll u,ll t,ll flow=INF)
{
    if(u==t)return flow;
    ll f=0;
    for(ll &i=cur[u];i;i=e[i].nxt)
    {
        ll v=e[i].v;
        if(dep[v]==dep[u]+1&&e[i].w>0)
        {
            ll tmp=ex_flow(v,t,min(e[i].w,flow-f));
            e[i].w-=tmp,e[i^1].w+=tmp;
            f+=tmp;
            if(f==flow)return f;
        }
    }
    return f;
}
ll Dinic(ll s,ll t,ll n)
{
    ll ans=0;
    while(bfs(s,t,n))ans+=ex_flow(s,t);
    return ans;
}
ll a[MAXN],b[MAXN];
int main()
{
    ll m=read(),n=read(),s=m+n+1,t=m+n+2,sumr=0;
    for(ll i=1;i<=m;++i)a[i]=read(),sumr+=a[i],adde(s,i,a[i]);
    for(ll i=m+1;i<=m+n;++i)b[i]=read(),adde(i,t,b[i]);
    for(ll i=1;i<=m;++i)
        for(ll j=m+1;j<=m+n;++j)adde(i,j,1);
    if(Dinic(s,t,t)<sumr)return puts("0"),0;
    puts("1");
    for(ll u=1;u<=m;++u)
    {
        for(ll i=last[u];i;i=e[i].nxt)
            if(e[i].v>m&&e[i].v<=m+n&&!e[i].w)printf("%lld ",e[i].v-m);
        puts("");
    }

    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/17003/
   。


#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 430, M = (150 * 270 + N) * 2, INF = 1e8;

int m, n, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &m, &n);
    S = 0, T = m + n + 1;
    memset(h, -1, sizeof h);

    int tot = 0;
    for (int i = 1; i <= m; i ++ )
    {
        int c;
        scanf("%d", &c);
        add(S, i, c);
        tot += c;
    }
    for (int i = 1; i <= n; i ++ )
    {
        int c;
        scanf("%d", &c);
        add(m + i, T, c);
    }
    for (int i = 1; i <= m; i ++ )
        for (int j = 1; j <= n; j ++ )
            add(i, m + j, 1);

    if (dinic() != tot) puts("0");
    else
    {
        puts("1");
        for (int i = 1; i <= m; i ++ )
        {
            for (int j = h[i]; ~j; j = ne[j])
                if (e[j] > m && e[j] <= m + n && !f[j])
                    printf("%d ", e[j] - m);
            puts("");
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/412450/
   。

您们以前都写过？？
只有我一个人是第一次学第一次写是嘛。。。

#include <cstring>
#include <iostream>

using namespace std;

const int N=425,M=81845;
const int INF=0x3ffffff;

int n,m;
int S,T,sum,res;
int h[N],e[M],ne[M],idx;
int depth[N],w[M];
int q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(depth,0,sizeof depth);
    depth[S]=1,*q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!depth[e[i]]&&w[i])
            {
                depth[e[i]]=depth[t]+1;
                q[++tt]=e[i];
                if(e[i]==T)return true;
            }
    }
    return false;
}

int dfs(int u,int s)
{
    if(u==T)return s;
    int f=0;
    for(int i=h[u];i;i=ne[i])
        if(w[i]&&depth[e[i]]==depth[u]+1)
        {
            int v=dfs(e[i],min(s,w[i]));
            w[(i-1^1)+1]+=v;
            w[i]-=v;
            s-=v,f+=v;
        }
    if(!f)depth[u]=-1;
    return f;
}

int main()
{
    scanf("%d%d",&n,&m);
    S=0,T=m+n+1;
    for(int i=1;i<=n;i++)
    {
        int R;
        scanf("%d",&R);
        sum+=R;
        add(S,i,R);
        add(i,S,0);
    }
    for(int i=1;i<=m;i++)
    {
        int C;
        scanf("%d",&C);
        add(i+n,T,C);
        add(T,i+n,0);
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            add(i,j+n,1);
            add(j+n,i,0);
        }
    while(bfs())res+=dfs(S,INF);
    if(res^sum)return putchar(0x30),0;
    putchar(0x31);
    for(int u=1;putchar(10),u<=n;u++)
        for(int i=h[u];i;i=ne[i])
            if(e[i]!=S&&!w[i])
                printf("%d ",e[i]-n);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/402049/
   。

AcWing 2188. 无源汇上下界可行流    原题链接    中等
作者：    whsstory ,  2020-07-25 21:38:39 ,  阅读 209

9


1
更好的阅读体验：My blog

浅谈上下界网络流
参考资料：liu_runda’s blog,red’s blog

PS:左侧可以跳转

无源汇有上下界可行流(循环流)
给一个网络，求一个流满足：每条边ii流量在[low(i),upp(i)][low(i),upp(i)]之间，每个点uu都要满足流量守恒(即∑toi=uf(i)=∑fromi=uf(i)∑toi=uf(i)=∑fromi=uf(i))

[HTML_REMOVED]

可行流算法的核心是将一个不满足流量守恒的初始流调整成满足流量守恒的流. -liu_runda

初始流即一开始将每条边流量设为low(i)low(i)的流。显然这个流不一定满足流量守恒。我们要通过调整（再加上一个附加流）将其变为可行流

记a(u)=∑toi=uf(i)−∑fromi=uf(i)a(u)=∑toi=uf(i)−∑fromi=uf(i),即初始流中，点uu的流入量-流出量。

在附加流中，让点uu的流入量-流出量=−a(u)−a(u),就能保证流量守恒。

当−a(u)<0 (a(u)>0)−a(u)<0 (a(u)>0),需要让uu的流入量增加a(u)a(u).这可以通过新建超级源点SS,并增加S→u,S→u,容量为a(u)a(u)的边做到。
当−a(u)>0 (a(u)<0)−a(u)>0 (a(u)<0)需要让uu的流出量增加a(u)a(u).这可以通过新建超级汇点TT,并增加u→T,u→T,容量为−a(u)−a(u)的边做到。
另外，对于原图中的边ii,还有upp(i)−low(i)upp(i)−low(i)的容量，也要加上。

与S,TS,T相邻的边都满流 加上附加流后每个点都满足流量守恒

因此，跑一下SS到TT的最大流，若与S,TS,T相邻的边都满流，则存在可行流。每条边的具体流量即为low(i)+ilow(i)+i在附加流中的流量（即反边容量）。

ll Dinic(ll s,ll t,ll n){....}
//略去了Dinic板子
ll a[MAXN],low[MAXM],upp[MAXM];
int main()
{
    ll n=read(),m=read(),S=n+1,T=S+1;
    for(ll i=1;i<=m;++i)
    {
        ll u=read(),v=read();low[i]=read(),upp[i]=read();
        a[u]-=low[i],a[v]+=low[i];adde(u,v,upp[i]-low[i]);
    }
    ll sum=0;
    for(ll i=1;i<=n;++i)
        if(a[i]>0)sum+=a[i],adde(S,i,a[i]);
        else if(a[i]<0)adde(i,T,-a[i]);
    ll f=Dinic(S,T,T);
    if(f<sum)return puts("NO")&0;
    puts("YES");
    for(ll i=1;i<=m;++i)printf("%lld\n",e[i<<1|1].w+low[i]);//e[i<<1|1].w表示反边容量，即附加流中的流量
    return 0;
}
有源汇有上下界最大流
在有源汇的网络流图中，源点rSrS、汇点rTrT不满足流量守恒，无法直接跑循环流。

但只要加一条rT→rSrT→rS,下界为0上界为正无穷的边，就能保证流量守恒。跑一下超源SS到TT的最大流，得到可行流，可行流中rT→rSrT→rS的流量即为rS→rTrS→rT的真正流量，记为f1f1.

删掉rT→rSrT→rS的边，再跑一次rS→rTrS→rT的最大流f2f2,答案即为f1+f2f1+f2
My code

有源汇有上下界最小流
基本与前者类似，用f1f1减掉rTrT流向rSrS的最大流f3f3(即回退这些流)即为答案。
My code

作者：whsstory
链接：https://www.acwing.com/solution/content/17067/
   。



#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 210, M = (10200 + N) * 2, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], l[M], ne[M], idx;
int q[N], d[N], cur[N], A[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = d - c, l[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        add(a, b, c, d);
        A[a] -= c, A[b] += c;
    }

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        if (A[i] > 0) add(S, i, 0, A[i]), tot += A[i];
        else if (A[i] < 0) add(i, T, 0, -A[i]);

    if (dinic() != tot) puts("NO");
    else
    {
        puts("YES");
        for (int i = 0; i < m * 2; i += 2)
            printf("%d\n", f[i ^ 1] + l[i]);
    }
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/412492/
   。

写了个玄学dinic。。

#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>

using namespace std;

const int N=210;
const int M=60210;
const int INF=0x3fffffff;

int n,m,S,T;
int sum,flow;
int h[N],e[M],w[M],ne[M],idx;
int up[M],down[M];
int in[N],out[N];
int q[N],hh,tt;
int depth[N];

inline void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(depth,0,sizeof depth);
    depth[S]=1,*q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!depth[e[i]]&&w[i]>0)
            {
                depth[e[i]]=depth[t]+1;
                q[++tt]=e[i];
            }
    }
    return depth[T]>0;
}

int dfs(int u,int s)
{
    if(u==T||s<=0)return s;
    int f=s;
    for(int i=h[u];i;i=ne[i])
        if(depth[e[i]]==depth[u]+1&&w[i]>0)
        {
            int v=dfs(e[i],min(f,w[i]));
            if(v<=0)depth[e[i]]=-2;
            w[(i-1^1)+1]+=v;
            w[i]-=v;
            f-=v;
            if(f<=0)break;
        }
    return s-f;
}

int main()
{
    scanf("%d%d",&n,&m);
    S=0,T=n+1;
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d%d%d",&u,&v,down+i,up+i);
        in[v]+=down[i],out[u]+=down[i];
        add(u,v,up[i]-down[i]);
        add(v,u,0);
    }
    for(int i=1;i<=n;i++)
        if(in[i]>=out[i])
        {
            add(S,i,in[i]-out[i]);
            add(i,S,0);
            sum+=in[i]-out[i];
        }
        else
        {
            add(i,T,out[i]-in[i]);
            add(T,i,0);
        }
    while(bfs())flow+=dfs(S,INF);
    if(flow!=sum)
    {
        puts("NO");
        return 0;
    }
    puts("YES");
    for(int i=1;i<=m;i++)printf("%d\n",down[i]+w[i<<1]);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/402171/
   。


cWing 2189. 有源汇上下界最大流    原题链接    中等
作者：    stoYZMorz ,  2020-08-03 11:46:41 ,  阅读 93

1


算法1
(dinic)
前面的思路大家阔以看一下无源上下界可行流
这里说一下不太好理解的部分
第一次跑完最大流之后求得的是流满下界的流
那么图里还剩许多s到t的自由流。
所以剩下的把st和ed删掉。把与st和ed相连的边也删掉。
然后在剩下的图上跑一次从s到t的最大流即可。
那么最终答案就是流满下界的流+残余的自由流

时间复杂度
参考文献
https://blog.csdn.net/Hanks_o/article/details/77984623

C++ 代码
//代码直接cv y总的了,y总的代码总是很好理解
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 210, M = (N + 10000) * 2, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N], A[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int s, t;
    scanf("%d%d%d%d", &n, &m, &s, &t);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        add(a, b, d - c);
        A[a] -= c, A[b] += c;
    }

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        if (A[i] > 0) add(S, i, A[i]), tot += A[i];
        else if (A[i] < 0) add(i, T, -A[i]);

    add(t, s, INF);
    if (dinic() < tot) puts("No Solution");
    else
    {
        int res = f[idx - 1];
        S = s, T = t;
        f[idx - 1] = f[idx - 2] = 0;
        printf("%d\n", res + dinic());
    }

    return 0;
}

作者：stoYZMorz
链接：https://www.acwing.com/solution/content/17634/
   。



2


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 210, M = (N + 10000) * 2, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N], A[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int s, t;
    scanf("%d%d%d%d", &n, &m, &s, &t);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        add(a, b, d - c);
        A[a] -= c, A[b] += c;
    }

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        if (A[i] > 0) add(S, i, A[i]), tot += A[i];
        else if (A[i] < 0) add(i, T, -A[i]);

    add(t, s, INF);
    if (dinic() < tot) puts("No Solution");
    else
    {
        int res = f[idx - 1];
        S = s, T = t;
        f[idx - 1] = f[idx - 2] = 0;
        printf("%d\n", res + dinic());
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/413441/
   。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=205;
const int M=20405;
const int INF=0x3fffffff;

int n,m,S,T,sum;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],A[N];
int q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    int s,t;
    scanf("%d%d%d%d",&n,&m,&s,&t);
    S=0,T=n+1;
    for(int i=0;i<m;i++)
    {
        int a,b,c,d;
        scanf("%d%d%d%d",&a,&b,&c,&d);
        add(a,b,d-c),add(b,a,0);
        A[a]-=c,A[b]+=c;
    }
    for(int i=1;i<=n;i++)
        if(A[i]>0)add(S,i,A[i]),add(i,S,0),sum+=A[i];
        else if(A[i]<0)add(i,T,-A[i]),add(T,i,0);
    add(t,s,INF),add(s,t,0);
    if(dinic()!=sum)puts("No Solution");
    else
    {
        int flow=w[idx];
        w[idx]=w[idx-1]=0;
        S=s,T=t;
        printf("%d\n",flow+dinic());
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/418575/
   。


'''
转换成有源点，有汇点，流量上下界约束的最小流模型
用Dinic算法求解即可
'''
INF = 0x7fffffffffffffff
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def Dinic(self, rev_edge_w = None):                 # rev_edge_w是反向边边权，默认都是0
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for i, (a, b, w) in enumerate(self.edges):
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            if rev_edge_w is not None:
                f[idx] = rev_edge_w[i]

            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, INF)

        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]

from collections import Counter
n, m, S, T = map(int, input().split())
SS, TT = n+1, n+2
edges = []
L = []
sum1, sum2 = Counter(), Counter()
for _ in range(m):
    a, b, l, u = map(int, input().split())
    edges.append((a, b, u-l))
    L.append(l)
    sum1[b] += l
    sum2[a] += l

# T和S间建立一条虚拟边
edges.append((T, S, INF))
sum1[S] += 0
sum2[T] += 0

for node in range(1, n+1):
    v1 = 0 if node not in sum1 else sum1[node]
    v2 = 0 if node not in sum2 else sum2[node]
    if v1 > v2:
        edges.append((SS, node, v1-v2))
    else:
        edges.append((node, TT, v2-v1))

algo = FortdFulkerson(edges, SS, TT, max_node_num=n+2, max_edge_num=len(edges))
ans = algo.Dinic()

F1 = 0
# 验证满流
flag = True
for a, b, f, w in ans[1]:
    if a == SS and f != w:
        flag = False
        break

    if w == INF:
        F1 = f

if not flag:
    print('No Solution')

else:
    # 再构建第二轮的图，求S到T的最大流，最后叠加结果
    e = []
    rev_w = []
    for a, b, f, w in ans[1]:
        if a >= 1 and a <= n and b >= 1 and b <= n and w != INF and w-f > 0:
            e.append((a, b, w-f))
            rev_w.append(f)     # 反向边的边权值
    algo = FortdFulkerson(e, T, S, max_node_num=n, max_edge_num=len(e))
    ans = algo.Dinic(rev_w)
    F2 = ans[0]
    ans = F1 - F2

    print(ans)



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21155/
   。


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 50010, M = (N + 125003) * 2, INF = 2147483647;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N], A[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int s, t;
    scanf("%d%d%d%d", &n, &m, &s, &t);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        add(a, b, d - c);
        A[a] -= c, A[b] += c;
    }

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        if (A[i] > 0) add(S, i, A[i]), tot += A[i];
        else if (A[i] < 0) add(i, T, -A[i]);

    add(t, s, INF);

    if (dinic() < tot) puts("No Solution");
    else
    {
        int res = f[idx - 1];
        S = t, T = s;
        f[idx - 1] = f[idx - 2] = 0;
        printf("%d\n", res - dinic());
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/413437/
   。

新建超级源点SS,向所有源点连容量为+∞+∞的边即可。汇点同理。问题即转化为普通最大流问题。

ll Dinic(ll s,ll t,ll n)
{
    ll res=0;
    while(bfs(s,t,n))res+=ex_flow(s,t);
    return res;
}
int main()
{
    ll n=read(),m=read(),sc=read(),tc=read(),S=n+1,T=n+2;
    for(ll i=1;i<=sc;++i)adde(S,read(),INF);
    for(ll i=1;i<=tc;++i)adde(read(),T,INF);
    while(m--)
    {
        ll u=read(),v=read(),w=read();
        adde(u,v,w);
    }
    printf("%lld",Dinic(S,T,T));
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/17483/
   。



1


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010, M = (100000 + N) * 2, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int sc, tc;
    scanf("%d%d%d%d", &n, &m, &sc, &tc);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    while (sc -- )
    {
        int x;
        scanf("%d", &x);
        add(S, x, INF);
    }
    while (tc -- )
    {
        int x;
        scanf("%d", &x);
        add(x, T, INF);
    }

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    printf("%d\n", dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/413457/
   。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=10005;
const int M=220005;
const int INF=0x3fffffff;

int n,m,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    int sc,tc;
    scanf("%d%d%d%d",&n,&m,&sc,&tc);
    S=0,T=n+1;
    for(int x;sc--;)
    {
        scanf("%d",&x);
        add(S,x,INF);
        add(x,S,0);
    }
    for(int x;tc--;)
    {
        scanf("%d",&x);
        add(x,T,INF);
        add(T,x,0);
    }
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c),add(b,a,0);
    }
    printf("%d\n",dinic());
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/418593/
   。

AcWing 2236. 伊基的故事 I - 道路重建    原题链接    中等
作者：    皓首不倦 ,  2020-09-22 15:58:19 ,  阅读 23

0




'''
查找流量图的关键边，输出关键边的数量即可
'''


from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 获取关键路径的标号列表，标号从0开始编号
    def getKeyEdges(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)  # 原图中有向边的流量

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                    # 更新原图边的流量
                    if self.edges[idx >> 1][0] == node:
                        orig_flow[idx >> 1] += t
                    else:
                        orig_flow[idx >> 1] -= t

                idx = ne[idx]

            return flow


        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            dfs(self.source_node, 0x7fffffff)

        # 筛选满流的边
        candi_e = []
        for i in range(len(self.edges)):
            if self.edges[i][2] == orig_flow[i]:
                candi_e.append(i)

        s_reachable = set() # S能够到的点
        t_reachable = set() # 能够到T的点

        # 从S和T分别正向和反向搜索能够到的点
        def travel(cur, visit):
            visit[cur] = 1
            s_reachable.add(cur)

            idx = h[cur]
            while idx != -1:
                next_node = e[idx]
                if visit[next_node] == 0 and f[idx] > 0:
                    travel(next_node, visit)

                idx = ne[idx]

        def rev_travle(cur, visit):
            visit[cur] = 1
            t_reachable.add(cur)

            idx = h[cur]
            while idx != -1:
                next_node = e[idx]
                if visit[next_node] == 0 and f[idx] != self.edges[idx>>1][2]:
                    # 方向边没有满流，等价于正向边还有流量可以用，next_node就可以沿着正向边到cur
                    rev_travle(next_node, visit)

                idx = ne[idx]

        travel(self.source_node, [0] * (self.max_node_num + 1))
        rev_travle(self.end_node, [0] * (self.max_node_num + 1))

        ans = []
        for edge_idx in candi_e:
            a, b, _ = self.edges[edge_idx]
            if a in s_reachable and b in t_reachable:
                ans.append(edge_idx)
        return ans


n, m = map(int, input().split())
e = []
for _ in range(m):
    a, b, w = map(int, input().split())
    a, b = a + 1, b + 1
    e.append((a, b, w))

algo = FortdFulkerson(e, 1, n, max_node_num=n, max_edge_num=len(e))
print(len(algo.getKeyEdges()))

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21165/
   。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=505;
const int M=10005;
const int INF=0x3fffffff;

int n,m,S,T,ans;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;
bool vis_s[N],vis_t[N];

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

void dfs(int u,int type,bool vis[])
{
    vis[u]=true;
    for(int i=h[u];i;i=ne[i])
        if(!vis[e[i]]&&w[i^type])
            dfs(e[i],type,vis);
}

int main()
{
    scanf("%d%d",&n,&m);
    S=0,T=n-1;
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c),add(b,a,0);
    }
    while(bfs())while(find(S,INF));
    dfs(S,0,vis_s),dfs(T,1,vis_t);
    for(int i=0;i<n;i++)
        if(vis_s[i])
            for(int j=h[i];j;j=ne[j])
                if(!(j&1)&&vis_t[e[j]])
                    ans++;
    printf("%d\n",ans);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/418613/
   。



1


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 510, M = 10010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
bool vis_s[N], vis_t[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

void dfs(int u, bool st[], int t)
{
    st[u] = true;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = i ^ t, ver = e[i];
        if (f[j] && !st[ver])
            dfs(ver, st, t);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n - 1;
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    dinic();
    dfs(S, vis_s, 0);
    dfs(T, vis_t, 1);

    int res = 0;
    for (int i = 0; i < m * 2; i += 2)
        if (!f[i] && vis_s[e[i ^ 1]] && vis_t[e[i]])
            res ++ ;

    printf("%d\n", res);
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/413522/
   。


AcWing 2277. 秘密挤奶机    原题链接    困难
作者：    皓首不倦 ,  2020-09-22 18:02:20 ,  阅读 25

1



'''
对边权值的上界进行二分搜索，验证上界是否有满足条件的路径方案存在
判断时候将所有边权值大于上界的边删掉，剩下的边每一条边拆成正反
两个方向的权值是1的有向边组成有向图，求有向图中1到N的最大流f
f数值就等价于从1到N的没有公共边的路径条数

需要注意的是原图是无向图，一条边拆出来的两条有向边是不能同时使用的，
但是特殊点在于，如果最大流两条边都使用了，那把这两条边上流过的流量删掉
剩下的流依然是一个最大流，所以任意一个最大流都必然能找到一个没有同时用
两条有向边的最大流与其对应，所以不考虑成对的有向边同时使用这个约束，
并不影响最后答案


'''

from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]

n, m, t = map(int, input().split())
s = set()
edges = []
for _ in range(m):
    a, b, w  = map(int, input().split())
    s.add(w)
    edges.append((a, b, w))

edge_len = list(s)
edge_len.sort()


def valid(max_len) -> bool:
    e = [(a, b, 1) for a, b, w in edges if w <= max_len]
    e.extend([(b, a, 1) for a, b, w in edges if w <= max_len])
    algo = FortdFulkerson(e, 1, n, max_node_num=n, max_edge_num=len(e))
    return algo.getMaxFlow()[0] >= t

l, r = 0, len(edge_len)-1
ans = None
while l <= r:
    mid = l + (r-l) // 2
    if valid(edge_len[mid]):
        ans = edge_len[mid]
        r = mid - 1
    else:
        l = mid + 1

print(ans)

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21175/
   。

    在残留网络中不需要把原图中每条边对应的四条边都建出来
建两条方向相同的边，在残留网络中相当于是建了一条容量为两条边的和的边
所以只用建正向边和反向边即可，不需要建容量为 00 的边

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=205;
const int M=80010;
const int INF=0x3fffffff;

int n,m,t,S,T;
int e[M],w[M],p[M],ne[M],idx=1;
int h[N],d[N],cur[N];
int q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    p[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

bool check(int x)
{
    for(int i=1;i<=idx;i++)
        w[i]=p[i]<=x;
    return dinic()>=t;
}

int main()
{
    scanf("%d %d %d",&n,&m,&t);
    S=1,T=n;
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c),add(b,a,c);
    }
    int l=1,r=1e6+5;
    while(l<r)
    {
        int mid=l+r>>1;
        if(check(mid))r=mid;
        else    l=mid+1;
    }
    printf("%d\n",r);
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/423471/
   。
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 210, M = 80010, INF = 1e8;

int n, m, K, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, w[idx] = c, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

bool check(int mid)
{
    for (int i = 0; i < idx; i ++ )
        if (w[i] > mid) f[i] = 0;
        else f[i] = 1;

    return dinic() >= K;
}

int main()
{
    scanf("%d%d%d", &n, &m, &K);
    S = 1, T = n;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    int l = 1, r = 1e6;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    printf("%d\n", r);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/423599/
   。

二分答案 xx，将 ≤x≤x 的边加入，跑一个网络流看是否可行即可。

复杂度 O(n2PlogP)O(n2Plog⁡P)
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 205, M = 40005, INF = 1e9;

int n, m, T, A[M], B[M], L[M], W[M], len;

int q[N], d[N], cur[N];

int head[N], numE;

struct E{
    int next, v, w;
} e[M * 4];

void inline add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
    e[++numE] = (E) { head[v], u, 0 };
    head[v] = numE;
}

bool inline bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = 1, d[1] = 1, cur[1] = head[1];
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (!d[v] && e[i].w) {
                d[v] = d[u] + 1, q[++tt] = v, cur[v] = head[v];
                if (v == n) return true;
            }
        }
    }
    return false;
}

int inline dinic(int u, int flow) {
    if (u == n) return flow;
    int rest = flow;
    for (int i = cur[u]; i && rest; i = e[i].next) {
        int v = e[i].v; cur[u] = i;
        if (d[v] == d[u] + 1 && e[i].w) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, e[i ^ 1].w += k, rest -= k;
        }
    }
    return flow - rest;
}

bool inline check(int x) {
    memset(head, 0, sizeof head);
    numE = 1;
    for (int i = 1; i <= m; i++) 
        if (L[i] <= x) add(A[i], B[i], 1), add(B[i], A[i], 1);
    int ans = 0, res;
    while (bfs())
        while (res = dinic(1, INF)) ans += res;
    return ans >= T;
}

int main() {
    scanf("%d%d%d", &n, &m, &T);
    for (int i = 1; i <= m; i++) scanf("%d%d%d", A + i, B + i, L + i), W[i] = L[i];
    sort(W + 1, W + 1 + m);
    len = unique(W + 1, W + 1 + m) - W - 1;
    int l = 1, r = len;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (check(W[mid])) r = mid;
        else l = mid + 1;
    }
    printf("%d\n", W[r]);
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/426017/
   。

二分 Dinic
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 210, M = 80010, INF = 0x3f3f3f3f;

int h[N], e[M], f[M], w[M], ne[M], idx;
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, w[idx] = c, ne[idx] = h[b], h[b] = idx ++;
}


int n, m, K;
int S, T;

int hs[N], d[N], q[N];

bool bfs()
{
    int hh = 0, tt = -1;
    memset(d, -1, sizeof d);
    d[S] = 0;
    hs[S] = h[S];
    q[ ++ tt] = S;

    while(hh <= tt)
    {
        int u = q[hh ++];

        for(int i = h[u]; ~i; i = ne[i])
        {
            int j = e[i];
            if(d[j] == -1 and f[i])
            {
                d[j] = d[u] + 1;
                hs[j] = h[j];
                if(j == T)  return true;
                q[ ++ tt] = j;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if(u == T)  return limit;

    int flow = 0;
    for(int i = hs[u]; ~i and flow < limit; i = ne[i])
    {
        hs[u] = i;
        int j = e[i];
        if(d[j] == d[u] + 1 and f[i])
        {
            int t = find(j, min(f[i], limit - flow));
            if(!t)  d[j] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int res = 0, flow;
    while(bfs())  while(flow = find(S, INF))  res += flow;
    return res;
}

bool check(int mid)
{
    for(int i = 0; i < idx; i ++)
        f[i] = w[i] <= mid;

    return dinic() >= K;
}

int main()
{
    memset(h, -1, sizeof h);
    scanf("%d%d%d", &n, &m, &K);
    S = 1, T = n;

    while(m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    int l = 1, r = 1e6;
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid))  r = mid;
        else  l = mid + 1;
    }
    printf("%d\n", l);
    return 0;
}

作者：滑稽_ωﾉ
链接：https://www.acwing.com/activity/content/code/content/424371/
   。

AcWing 2187. 星际转移问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-22 22:21:38 ,  阅读 35

0





from typing import List
from collections import deque

INF = 0x7fffffffffffffff
class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def Dinic(self, rev_edge_w = None):                 # rev_edge_w是反向边边权，默认都是0
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for i, (a, b, w) in enumerate(self.edges):
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            if rev_edge_w is not None:
                f[idx] = rev_edge_w[i]

            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, INF)

        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]



class MergeSetExt:
    def __init__(self, max_key_val = 0, trans_key_func=None):
        if trans_key_func is not None and max_key_val > 0:
            # 如果能够提供转换key的回调，并查集内部用线性表存储
            self.trans_key_callback = trans_key_func
            self.m = [-1 for _ in range(max_key_val+1)]
            self.__root2cluster_size = [0 for _ in range(max_key_val+1)]
        else:
            # 如果不能提供转换key的回调，并查集内部用hash表存储
            self.trans_key_callback = None
            self.m = {}
            self.__root2cluster_size = {}
        self.__root_cnt = 0

    def getRoot(self, node):
        buf = []
        root = self.trans_key_callback(node) if self.trans_key_callback else node
        while self.m[root] != root:
            buf.append(root)
            root = self.m[root]
        for key in buf:
            self.m[key] = root

        return root

    def merge(self, a, b):
        orig_a, orig_b = a, b
        if self.trans_key_callback:
            a, b = self.trans_key_callback(a), self.trans_key_callback(b)

        for node in [a, b]:
            if (self.trans_key_callback is None and node not in self.m) or (self.trans_key_callback is not None and self.m[node] == -1):
                self.m[node] = node
                self.__root2cluster_size[node] = 1
                self.__root_cnt += 1

        root1 = self.getRoot(orig_a)
        root2 = self.getRoot(orig_b)
        if root1 != root2:
            self.m[root1] = root2

            self.__root2cluster_size[root2] += self.__root2cluster_size[root1]
            if self.trans_key_callback:
                self.__root2cluster_size[root1] = 0
            else:
                self.__root2cluster_size.pop(root1)
            self.__root_cnt -= 1

    def isInSameSet(self, a, b):
        if a == b:
            return True

        orig_a, orig_b = a, b
        if self.trans_key_callback:
            a, b = self.trans_key_callback(a), self.trans_key_callback(b)

            for node in [a, b]:
                if self.m[node] == -1:
                    return False
        else:
            for node in [orig_a, orig_b]:
                if node not in self.m:
                    return False

        return self.getRoot(orig_a) == self.getRoot(orig_b)


n, m, k = map(int, input().split())
H = [0] * m     # H[i]是编号是i的飞船的容量
P = []          # P[i]是编号是i的飞船的路线中的位置列表
for i in range(m):
    arr = list(map(int, input().split()))
    H[i] = arr[0]
    P.append(arr[2:])

merge_set = MergeSetExt(n+2, lambda x: x)
for p in P:
    last_val = None
    for i, val in enumerate(p):
        if val == 0:
            val = n+1
        elif val == -1:
            p[i] = n+1      # 月球的编号换成n+1, 方便后面建图
            val = n+2

        if last_val is not None:
            merge_set.merge(last_val, val)
        last_val = val

if not merge_set.isInSameSet(n+1, n+2):
    # 地球和月球不可达
    print(0)

else:

    # <i, j>二元组转换成节点编号
    def pos2idx(i, j):
        return 3 + (i * (n+2)) + j

    S, T = 1, 2

    d = 0
    edges = []
    f = []          # f[idx]是编号是idx的边已经用掉的流量

    total_flow = 0
    while True:
        if d == 0:
            edges.append((S, pos2idx(0, 0), k))
            f.append(0)

        else:
            for j in range(0, n+2):
                edges.append((pos2idx(d-1, j), pos2idx(d, j), INF))
                f.append(0)

            edges.append((pos2idx(d, n+1), T, INF))
            f.append(0)

            for i, p in enumerate(P):
                last_pos = p[(d-1) % len(p)]
                cur_pos = p[d % len(p)]
                edges.append((pos2idx(d-1, last_pos), pos2idx(d, cur_pos), H[i]))
                f.append(0)

            e = [(a, b, w-f) for (a, b, w), f in zip(edges, f)]
            max_flow, new_edges = FortdFulkerson(e, S, T, (d+1)*(n+2)+2, len(e)).Dinic(rev_edge_w=f)
            total_flow += max_flow
            if total_flow == k:
                print(d)
                break

            new_f = [flow for _, _, flow, _ in new_edges]
            for i, val in enumerate(f):
                new_f[i] += f[i]

            f = new_f

        d += 1


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21200/
   。

手残打错一个变量名。。调了俩小时。。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=11255;
const int M=54005;
const int INF=0x3fffffff;

int n,m,k,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;
struct Ship
{
    int h,r,id[15];
}ships[22];
int p[15];

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

int find(int x)
{
    if(p[x]!=x)p[x]=find(p[x]);
    return p[x];
}

int id(int d,int i)
{
    return d*(n+2)+i;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    scanf("%d%d%d",&n,&m,&k);
    S=0,T=n+1;
    for(int i=1;i<n+2;i++)p[i]=i;
    for(int i=0;i<m;i++)
    {
        scanf("%d%d",&ships[i].h,&ships[i].r);
        for(int j=0;j<ships[i].r;j++)
        {
            scanf("%d",&ships[i].id[j]);
            if(!~ships[i].id[j])ships[i].id[j]=n+1;
            if(j)p[find(ships[i].id[j-1])]=find(ships[i].id[j]);
        }
    }
    if(find(0)!=find(n+1))puts("0");
    else
    {
        for(int ans=1,flow=0;;ans++)
        {
            for(int i=0;i<m;i++)
            {
                const Ship &s=ships[i];
                int u=(ans-1)%s.r,v=ans%s.r;
                u=id(ans-1,s.id[u]),v=id(ans,s.id[v]);
                add(u,v,s.h),add(v,u,0);
            }
            for(int i=0;i<n+2;i++)
            {
                add(id(ans-1,i),id(ans,i),INF);
                add(id(ans,i),id(ans-1,i),0);
            }
            add(id(ans,n+1),T,INF);
            add(T,id(ans,n+1),INF);
            flow+=dinic();
            if(flow>=k)
            {
                printf("%d\n",ans);
                break;
            }
        }
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/423651/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1101 * 22 + 10, M = (N + 1100 + 13 * 1101) + 10, INF = 1e8;

int n, m, k, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
struct Ship
{
    int h, r, id[30];
}ships[30];
int p[30];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int get(int i, int day)
{
    return day * (n + 2) + i;
}

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d%d", &n, &m, &k);
    S = N - 2, T = N - 1;
    memset(h, -1, sizeof h);
    for (int i = 0; i < 30; i ++ ) p[i] = i;
    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        ships[i] = {a, b};
        for (int j = 0; j < b; j ++ )
        {
            int id;
            scanf("%d", &id);
            if (id == -1) id = n + 1;
            ships[i].id[j] = id;
            if (j)
            {
                int x = ships[i].id[j - 1];
                p[find(x)] = find(id);
            }
        }
    }
    if (find(0) != find(n + 1)) puts("0");
    else
    {
        add(S, get(0, 0), k);
        add(get(n + 1, 0), T, INF);
        int day = 1, res = 0;
        while (true)
        {
            add(get(n + 1, day), T, INF);
            for (int i = 0; i <= n + 1; i ++ )
                add(get(i, day - 1), get(i, day), INF);
            for (int i = 0; i < m; i ++ )
            {
                int r = ships[i].r;
                int a = ships[i].id[(day - 1) % r], b = ships[i].id[day % r];
                add(get(a, day - 1), get(b, day), ships[i].h);
            }
            res += dinic();
            if (res >= k) break;
            day ++ ;
        }

        printf("%d\n", day);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/423677/
   。

又做过，copy！

星际转移问题
隐约的感知到，每个人从地球到月球从图论的角度上来说构成一条路径，每个人又可以抽象成单位 11 的流，所以这题就是网络流？但是由于天数时间轴的影响不能直接建图。所以这题解启示我们建立分层图，即某天的一个位置抽象为为一个图中的节点。

题意中的两种决策乘坐飞船、下船等待可以抽象成两种边（由于具有传递性所以只需连接一步操作的节点）。不过还要注意的是每天地球和月球的边要注意和源点和汇点进行联系，进而达到图题一体的模式。

乘坐飞船走：对于一条飞船上的路径，一天对应位置的节点 ⇒⇒ 后一天对应位置的节点，流量为 H[i]H[i] ，表示通过这种方式最多可以送走 H[i]H[i] 人
下船等待：某位置一天的节点 ⇒⇒ 下一天同一位置的节点，流量无限
源点向每天的地球连边无限，每天月球向汇点连接无限
发现二分复杂度是冗余的，不妨从小到大枚举时间。

考虑存在情况的最坏情况下的时间，一条路径肯定没有环（不然可以不走环），所以一条链最长有 m+2m+2 个点， m+1m+1 条边，可能一个循环才能跑一次，所以每转移一条边 n+2n+2 个时间。所以时间最多 (m+2)∗(n+2)<=330(m+2)∗(n+2)<=330，所以枚举到 330330 就行了。。总复杂度 (N+M+11500∗4950‾‾‾‾‾√)(N+M+11500∗4950)，一看就跑得很快。（这里的复杂度由于边加边边在残余网络上跑，所以貌似是这个复杂度 # 我也不确定）

#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
const int N = 14, M = 21, S = 55, L = 5000, INF = 1e9, LM = 23500;
int n, m, s, t, K, p[M], r[M], h[M][N + 2], q[L], d[L], maxflow, flow;
int head[L], numE = 1;
struct E{
    int next, v, w;
} e[LM];
void add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
}
void addEdge(int u, int v, int w) {
    add(u, v, w); add(v, u, 0);
}

bool bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = s, d[s] = 1;
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (e[i].w && !d[v]) {
                d[v] = d[u] + 1;
                q[++tt] = v;
                if (v == t) return true;
            }
        }
    }
    return false;
}

int dinic(int u, int flow) {
    if (u == t) return flow;
    int rest = flow;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].v;
        if (e[i].w && d[v] == d[u] + 1) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, e[i ^ 1].w += k;
            rest -= k;
        }
    }
    return flow - rest;
}

//  第 i 天，第 j 号飞船
int get(int i, int j) {
    if (j == 0) return 3 + i * (n + 2);
    else if(j == -1) return 4 + i * (n + 2);
    return 4 + i * (n + 2) + j;
}


void build(int i) {
    int cnt = 2 + i * (n + 2);
    int st = cnt + 1, ed = cnt + 2;
    addEdge(s, st, INF), addEdge(ed, t, INF);
    for (int j = 1; j <= n; j++) addEdge(get(i - 1, j), get(i, j), INF);
    for (int j = 0; j < m; j++) {
        int u = h[j][(i - 1) % r[j]], v = h[j][i % r[j]];
        addEdge(get(i - 1, u), get(i, v), p[j]);
    }
}

int main() {
    scanf("%d%d%d", &n, &m, &K);
    s = 1, t = 2;
    // 第 0 天的地球和月亮连边
    addEdge(1, 3, INF), addEdge(4, 2, INF);
    for (int i = 0; i < m; i++) {
        scanf("%d%d", p + i, r + i);
        for (int j = 0; j < r[i]; j++) scanf("%d", &h[i][j]);
    }
    for (int t = 1; t <= 330; t++) {
        build(t);
        while (bfs())
            while(flow = dinic(s, INF)) maxflow += flow;
        if (maxflow >= K) {
            printf("%d\n", t);
            return 0;
        }
    }
    puts("0");
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/426047/
   。
AcWing 2240. 餐饮    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 00:17:45 ,  阅读 24

1





'''
把牛拆成两个点，两个点连接容量是1的边，限制每一头牛只能用一次
'''

from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]


n, f, d = map(int, input().split())
edges = []
for i in range(1, n+1):
    edges.append((i, i+n, 1))

S, T = 2*n + f + d + 1, 2*n + f + d + 2
for i in range(1, f+1):
    edges.append((S, i + 2*n, 1))
for i in range(1, d+1):
    edges.append((i + 2*n + f, T, 1))

for i in range(1, n+1):
    arr = list(map(int, input().split()))
    f_num, d_num = arr[0], arr[1]
    ff = arr[2: f_num+2]
    dd = arr[f_num+2:]

    for f_val in ff:
        edges.append((f_val + 2*n, i, 1))
    for d_val in dd:
        edges.append((i+n, d_val+ 2*n + f, 1))

print(FortdFulkerson(edges, S, T, 2 + 2*n + f + d, len(edges)).getMaxFlow()[0])

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21204/
   。

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long ll;

const int INF=0x3fffffff;
const int N=405,M=40605;

int n,S,T;
int h[N],e[M],ne[M],w[M],idx=1;
int d[N],cur[N],q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    int F,D;
    scanf("%d%d%d",&n,&F,&D);
    S=n+n+F+D+1,T=S+1;
    for(int i=1;i<=n;i++)
    {
        add(i,n+i,1);
        add(n+i,i,0);
        int fi,di;
        scanf("%d%d",&fi,&di);
        for(int t;fi--;)
        {
            scanf("%d",&t);
            t+=n+n;
            add(t,i,1);
            add(i,t,0);
        }
        for(int t;di--;)
        {
            scanf("%d",&t);
            t+=n+n+F;
            add(n+i,t,1);
            add(t,n+i,0);
        }
    }
    for(int i=1,j=n+n+1;i<=F;i++,j++)
        add(S,j,1),add(j,S,0);
    for(int i=1,j=n+n+F+1;i<=D;i++,j++)
        add(j,T,1),add(T,j,0);
    printf("%d\n",dinic());
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/418650/
   。

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int N = 105, NP = 4 * N, M = N * N * 2 + 2 * N, INF = 1e9;

int n, F, D, idx, fId[N], dId[N], S, T, f[N], c[N];

int d[NP], q[NP], cur[NP];

int head[NP], numE = 1;

struct E{
    int next, v, w;
} e[M << 1];

void inline add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
    e[++numE] = (E) { head[v], u, 0 };
    head[v] = numE;
}

bool inline bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = S, cur[S] = head[S], d[S] = 1;
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (!d[v] && e[i].w) {
                d[v] = d[u] + 1, q[++tt] = v, cur[v] = head[v];
                if (v == T) return true;
            }
        }
    }
    return false;
}

int dinic(int u, int flow) {
    if (u == T) return flow;
    int rest = flow;
    for (int i = cur[u]; i && rest; i = e[i].next) {
        int v = e[i].v; cur[u] = i;
        if (d[v] == d[u] + 1 && e[i].w) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, rest -= k, e[i ^ 1].w += k;
        }
    }
    return flow - rest;
}

int main() {
    scanf("%d%d%d", &n, &F, &D);
    idx = 2 * n; S = ++idx, T = ++idx;
    for (int i = 1; i <= n; i++) add(i, i + n, 1);
    for (int i = 1; i <= F; i++) fId[i] = ++idx, add(S, fId[i], 1);
    for (int i = 1; i <= D; i++) dId[i] = ++idx, add(dId[i], T, 1);
    for (int i = 1; i <= n; i++) {
        int cf, cd, x; scanf("%d%d", &cf, &cd);
        while (cf--) scanf("%d", &x), add(fId[x], i, 1);
        while (cd--) scanf("%d", &x), add(i + n, dId[x], 1);
    }
    int ans = 0, res;
    while (bfs())
        while (res = dinic(S, INF)) ans += res;
    printf("%d\n", ans);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/426072/
   。

将牛拆点即可。

#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
typedef long long ll;
typedef unsigned un;
//typedef std::string str;
typedef std::pair<ll,ll> pll;
typedef std::pair<int,int> pii;
typedef std::pair<double,double> pd;
ll read(){ll x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}return f*x;}
ll max(ll a,ll b){return a>b?a:b;}
ll min(ll a,ll b){return a<b?a:b;}
void umax(ll& a,ll t){if(t>a)a=t;}
bool umin(ll& a,ll t){if(t<a)return a=t,1;return 0;}
const ll INF=1ll<<30;
#define MAXN 200011
struct edge
{
    int v,w,nxt;
}e[MAXN<<1|1];
int cnt=1,last[MAXN];
void add_directed_edge(int u,int v,int w)
{
    e[++cnt].v=v,e[cnt].w=w;
    e[cnt].nxt=last[u],last[u]=cnt;
}
void adde(int u,int v,int w){ add_directed_edge(u,v,w),add_directed_edge(v,u,0);}

int cur[MAXN],dep[MAXN];
bool bfs(int s,int t,int n)
{
    for(int i=1;i<=n;++i)cur[i]=last[i],dep[i]=0;
    std::queue<int>q;
    q.push(s),dep[s]=1;
    while(q.size())
    {
        int u=q.front();q.pop();
        for(int i=last[u];i;i=e[i].nxt)
        {
            int v=e[i].v;
            if(e[i].w&&!dep[v])dep[v]=dep[u]+1,q.push(v);
        }
    }
    return dep[t]>0;
}
int ex_flow(int u,int t,int flow=INF)
{
    if(u==t)return flow;
    int f=0;
    for(int &i=cur[u];i;i=e[i].nxt)
    {
        int v=e[i].v;
        if(e[i].w&&dep[v]==dep[u]+1)
        {
            int tmp=ex_flow(v,t,min(e[i].w,flow-f));
            e[i].w-=tmp,e[i^1].w+=tmp;
            f+=tmp;
            if(f==flow)return f;
        }
    }
    return f;
}
int Dinic(int s,int t,int n)
{
    int res=0;
    while(bfs(s,t,n))res+=ex_flow(s,t);
    return res;
}
int main()
{
    int n=read(),F=read(),D=read(),S=n+n+F+D+1,T=S+1;
    for(int i=1;i<=n;++i)
    {
        adde(i,n+i,1);
        int LF=read(),LD=read();
        while(LF--)adde(n+n+read(),i,1);
        while(LD--)adde(n+i,n+n+F+read(),1);
    }
    for(int i=1;i<=F;++i)adde(S,n+n+i,1);
    for(int i=1;i<=D;++i)adde(n+n+F+i,T,1);
    printf("%d",Dinic(S,T,T));
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/activity/content/code/content/417793/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 410, M = 40610, INF = 1e8;

int n, F, D, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d%d", &n, &F, &D);
    S = 0, T = n * 2 + F + D + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= F; i ++ ) add(S, n * 2 + i, 1);
    for (int i = 1; i <= D; i ++ ) add(n * 2 + F + i, T, 1);
    for (int i = 1; i <= n; i ++ )
    {
        add(i, n + i, 1);
        int a, b, t;
        scanf("%d%d", &a, &b);
        while (a -- )
        {
            scanf("%d", &t);
            add(n * 2 + t, i, 1);
        }
        while (b -- )
        {
            scanf("%d", &t);
            add(i + n, n * 2 + F + t, 1);
        }
    }
    printf("%d\n", dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/423705/
   。
AcWing 2180. 最长递增子序列问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 13:00:56 ,  阅读 28

1





from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]


n = int(input())
arr = list(map(int, input().split()))


# 问题1
# dp[i]是i位置结尾的最长递增子序列长度
dp = [1] * n
for i in range(1, n):
    for j in range(i):
        if arr[j] <= arr[i]:
            dp[i] = max(1 + dp[j], dp[i])

s = max(dp)
ans1 = s


# 问题2
edges = []
mm = {}
for i, f in enumerate(dp):
    if f not in mm:
        mm[f] = []
    mm[f].append((i+1, arr[i]))

for i in range(1, n+1):
    edges.append((i, i+n, 1))

S, T = 2*n + 1, 2*n + 2

for node, _ in mm[1]:
    edges.append((S, node, 1))

for f in range(1, s):
    for node1, val1 in mm[f]:
        for node2, val2 in mm[f+1]:
            if val1 <= val2 and node1 < node2:
                edges.append((node1+n, node2, 1))

for node, _ in mm[s]:
    edges.append((node+n, T, 1))

ans2 = FortdFulkerson(edges, S, T, 2*n+2, len(edges)).getMaxFlow()[0]


# 问题3
if s == 1:
    ans3 = n
else:
    e = []
    for i, (a, b, w) in enumerate(edges):
        if b == 1 or a == 1 or a == n+n or a == n:
            e.append((a, b, 0x7fffffff))
            continue

        e.append((a, b, w))

    ans3 = FortdFulkerson(e, S, T, 2*n+2, len(e)).getMaxFlow()[0]

print(ans1)
print(ans2)
print(ans3)

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21206/
   。

include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010, M = 251010, INF = 1e8;

int n, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
int g[N], w[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d", &n);
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    int s = 0;
    for (int i = 1; i <= n; i ++ )
    {
        add(i, i + n, 1);
        g[i] = 1;
        for (int j = 1; j < i; j ++ )
            if (w[j] <= w[i])
                g[i] = max(g[i], g[j] + 1);
        for (int j = 1; j < i; j ++ )
            if (w[j] <= w[i] && g[j] + 1 == g[i])
                add(n + j, i, 1);
        s = max(s, g[i]);
        if (g[i] == 1) add(S, i, 1);
    }

    for (int i = 1; i <= n; i ++ )
        if (g[i] == s)
            add(n + i, T, 1);

    printf("%d\n", s);
    if (s == 1) printf("%d\n%d\n", n, n);
    else
    {
        int res = dinic();
        printf("%d\n", res);
        for (int i = 0; i < idx; i += 2)
        {
            int a = e[i ^ 1], b = e[i];
            if (a == S && b == 1) f[i] = INF;
            else if (a == 1 && b == n + 1) f[i] = INF;
            else if (a == n && b == n + n) f[i] = INF;
            else if (a == n + n && b == T) f[i] = INF;
        }
        printf("%d\n", res + dinic());
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/423737/
   。

拆点
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=1005;
const int M=250505;
const int INF=0x3f3f3f3f;

int n,S,T,flow;
int a[N],f[N],res;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;

void addedge(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

void add(int a,int b,int c)
{
    addedge(a,b,c),addedge(b,a,0);
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    scanf("%d",&n);
    if(n==1)return puts("1\n1\n1"),0;
    for(int i=1;i<=n;i++)scanf("%d",a+i);
    for(int i=2;i<=n;res=max(res,f[i++]))
        for(int j=1;j<i;j++)
            if(a[i]>=a[j]&&f[i]<=f[j])
                f[i]=f[j]+1;
    printf("%d\n",res+1);
    S=0,T=n+n+1;
    for(int i=1;i<=n;i++)
    {
        add(i,i+n,1);
        if(!f[i])add(S,i,1);
        if(f[i]==res)add(i+n,T,1);
    }
    for(int i=2;i<=n;i++)
        for(int j=1;j<i;j++)
            if(a[i]>=a[j]&&f[i]==f[j]+1)
                add(j+n,i,1);
    flow=dinic();
    printf("%d\n",flow);
    add(S,1,INF),add(1,n+1,INF);
    if(f[n]==res)add(n<<1,T,INF),add(n,n<<1,INF);
    printf("%d\n",flow+dinic());
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/423699/
   。

做过 * 3

最长不下降子序列问题
第一问
设 f[i]f[i] 以 ii 结尾的最长不下降子序列，dp即可。

第二问
用分层图的思想，把 f[i]f[i] 按照值划分成 ss 个不同的值。

由于每个点只能在一个序列的原则，拆点限制，把 ii 拆成一个入点和一个出点，入点向出点连流量为 11 的边

由起点向每一个 f[i]=1f[i]=1 的点连 11 的流量。

由每一个 f[i]=sf[i]=s 的点向终点连 11 的流量。

将能够转移的 i,ji,j （即 i<j,f[i]+1=f[j]i<j,f[i]+1=f[j] ）连一条边

每一条从起点到终点的路径都是一个长度为 ss 的最长不下降子序列。

这样去除最多的序列等价于找到最多的从 s,ts,t 互不干扰的路径，这里流量为 11，最大流和它们是等价的。

第三问
与第二问不同的就是两个可以反复使用，所以把 1,n1,n 所在内部入点出点的边流量设为无限，并且如果它们与起点终点连过边，流量也设为无限。这样既设计为除了 1,n1,n，剩下点只能经过一次，和题目等价。 有个小技巧，改变流量可以直接加流量，跑最大流不用重新跑一遍，加一条边可以在上次的残余网络上跑。

并且要注意一个特例就是 n=1n=1 的情况，这时候不能起点向 11 连边，否则就输出 INFINF 了。

#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
const int N = 505, L = N * 2, M = N * (N - 1) + N * 2, INF = 1e9;
int n, S, s, t, a[N], f[N], d[L], q[L], maxflow, flow;
int head[L], numE = 1;
struct E{
    int next, v, w;
} e[M];
void add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
} 
void addEdge(int u, int v, int w) {
    add(u, v, w), add(v, u, 0);
}
bool bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = s, d[s] = 1;
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (!d[v] && e[i].w) {
                d[v] = d[u] + 1;
                q[++tt] = v;
                if (v == t) return true;
            }
        }
    }
    return false;
} 
int dinic(int u, int flow) {
    if (u == t) return flow;
    int rest = flow;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].v;
        if (d[v] == d[u] + 1 && e[i].w) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, e[i ^ 1].w += k;
            rest -= k;
        }
    }
    return flow - rest;
}
int main() {
    scanf("%d", &n);
    s = 2 * n + 1, t = 2 * n + 2;
    for (int i = 1; i <= n; i++) scanf("%d", a + i);
    for (int i = 1; i <= n; i++) {
        f[i] = 1;
        for (int j = 1; j < i; j++) 
            if (a[j] <= a[i]) f[i] = max(f[i], f[j] + 1);
        S = max(S, f[i]);
    }
    printf("%d\n", S);
    for (int i = 1; i <= n; i++) {
        addEdge(i, i + n, 1);
        if (f[i] == 1) addEdge(s, i, 1);
        if (f[i] == S) addEdge(i + n, t, 1);
        for (int j = 1; j < i; j++)
            if (a[j] <= a[i] && f[j] + 1 == f[i]) addEdge(j + n, i, 1);
    }
    while (bfs())
        while (flow = dinic(s, INF)) maxflow += flow;
    printf("%d\n", maxflow);

    if (S != 1) addEdge(s, 1, INF), addEdge(1, 1 + n, INF);
    if (f[n] == S) addEdge(n * 2, t, INF), addEdge(n, n * 2, INF);
    while (bfs())
        while (flow = dinic(s, INF)) maxflow += flow;
    printf("%d\n", maxflow);
} 

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/426056/
   。

Dinic 拆点
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010, M = 251010, INF = 0x3f3f3f3f;

int h[N], e[M], f[M], ne[M], idx;
void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

int n, S, T;
int g[N], w[N];

int hs[N], d[N], q[N];

bool bfs()
{
    memset(d, -1, sizeof d);
    d[S] = 0;
    hs[S] = h[S];
    int hh = 0, tt = -1;
    q[ ++ tt] = S;

    while(hh <= tt)
    {
        int u = q[hh ++];

        for(int i = h[u]; ~i; i = ne[i])
        {
            int j = e[i];
            if(d[j] == -1 and f[i])
            {
                d[j] = d[u] + 1;
                hs[j] = h[j];
                if(j == T)  return true;
                q[ ++ tt] = j;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if(u == T)  return limit;

    int flow = 0;
    for(int i = hs[u]; ~i and flow < limit; i = ne[i])
    {
        hs[u] = i;
        int j = e[i];
        if(d[j] == d[u] + 1 and f[i])
        {
            int t = find(j, min(f[i], limit - flow));
            if(!t)  d[j] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int res = 0, flow;
    while(bfs())  while(flow = find(S, INF))  res += flow;
    return res;
}

int main()
{
    memset(h, -1, sizeof h);

    scanf("%d", &n);
    S = 0, T = n * 2 + 1;

    int s = 0;
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d", &w[i]);
        g[i] = 1;
        for(int j = 1; j < i; j ++)
            if(w[j] <= w[i])  g[i] = max(g[i], g[j] + 1);
        s = max(s, g[i]);

        add(i, n + i, 1);
        for(int j = 1; j < i; j ++)
            if(w[j] <= w[i] and g[j] + 1 == g[i])  add(n + j, i, 1);
        if(g[i] == 1)  add(S, i, 1);
    }
    for(int i = 1; i <= n; i ++)
        if(g[i] == s)  add(n + i, T, 1);

    printf("%d\n", s);
    if(s == 1)  return 0 * printf("%d\n%d\n", n, n);

    int res = dinic();
    printf("%d\n", res);
    for(int i = 0; i < idx; i += 2)
    {
        int a = e[i ^ 1], b = e[i];
        if(a == S and b == 1)  f[i] = INF;
        if(a == 1 and b == n + 1)  f[i] = INF;
        if(a == n and b == n + n)  f[i] = INF;
        if(a == n + n and b == T)  f[i] = INF;
    }
    printf("%d\n", res + dinic());
    return 0;
}

作者：滑稽_ωﾉ
链接：https://www.acwing.com/activity/content/code/content/425157/
   。

AcWing 2278. 企鹅游行    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 15:43:41 ,  阅读 15

1






from typing import List
from collections import deque

import sys


class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow


t = int(input())
for _ in range(t):
    s = input().split()
    n = int(s[0])
    dis = float(s[1])

    pos = []
    edges = []
    S = 2 * n + 1
    total = 0
    for i in range(n):
        s = sys.stdin.readline().strip()
        x, y, nn, mm = map(int, s.split())
        pos.append((x, y, nn, mm))
        edges.append((S, i + 1, nn))
        edges.append((i + 1, i + 1 + n, mm))
        total += nn

    for i in range(n):
        x1, y1, _, mm1 = pos[i]
        for j in range(i):
            x2, y2, _, mm2 = pos[j]
            if (x1 - x2) ** 2 + (y1 - y2) ** 2 <= dis ** 2:
                edges.append((i + 1 + n, j + 1, mm1))
                edges.append((j + 1 + n, i + 1, mm2))

    flag = False
    for T in range(1, n + 1):
        flow = FortdFulkerson(edges, S, T, 2 * n + 1, len(edges)).getMaxFlow()

        if flow == total:
            print(T - 1, end=' ')
            flag = True

    if not flag:
        print(-1)
    else:
        print()

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21229/
   。

    #include <iostream>
#include <cstring>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 210, M = 20410, INF = 1e8;
const double eps = 1e-8;

int n, S, T;
double D;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
PII p[N];

bool check(PII a, PII b)
{
    double dx = a.x - b.x, dy = a.y - b.y;
    return dx * dx + dy * dy < D * D + eps;
}

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    int cases;
    scanf("%d", &cases);
    while (cases -- )
    {
        memset(h, -1, sizeof h);
        idx = 0;
        scanf("%d%lf", &n, &D);
        S = 0;

        int tot = 0;
        for (int i = 1; i <= n; i ++ )
        {
            int x, y, a, b;
            scanf("%d%d%d%d", &x, &y, &a, &b);
            p[i] = {x, y};
            add(S, i, a);
            add(i, n + i, b);
            tot += a;
        }

        for (int i = 1; i <= n; i ++ )
            for (int j = i + 1; j <= n; j ++ )
                if (check(p[i], p[j]))
                {
                    add(n + i, j, INF);
                    add(n + j, i, INF);
                }

        int cnt = 0;
        for (int i = 1; i <= n; i ++ )
        {
            T = i;
            for (int j = 0; j < idx; j += 2)
            {
                f[j] += f[j ^ 1];
                f[j ^ 1] = 0;
            }
            if (dinic() == tot)
            {
                printf("%d ", i - 1);
                cnt ++ ;
            }
        }
        if (!cnt) puts("-1");
        else puts("");
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/424507/
   。

Dinic 拆点
#include<cstdio>
#include<cstring>
#include<algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 210, M = 20410, INF = 0x3f3f3f3f;
const double eps = 1e-8;

int h[N], e[M], f[M], ne[M], idx;
void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++;
}

int n, S, T;

int q[N], d[N], hs[N];

bool bfs()
{
    memset(d, -1, sizeof d);
    int hh = 0, tt = -1;

    hs[S] = h[S];
    d[S] = 0;
    q[ ++ tt] = S;

    while(hh <= tt)
    {
        int u = q[hh ++];

        for(int i = h[u]; ~i; i = ne[i])
        {
            int j = e[i];
            if(d[j] == -1 and f[i])
            {
                d[j] = d[u] + 1;
                hs[j] = h[j];
                if(j == T)  return true;
                q[ ++ tt] = j;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if(u == T)  return limit;

    int flow = 0;
    for(int i = hs[u]; ~i and flow < limit; i = ne[i])
    {
        hs[u] = i;
        int j = e[i];
        if(d[j] == d[u] + 1 and f[i])
        {
            int t = find(j, min(f[i], limit - flow));
            if(!t)  d[j] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int res = 0, flow;
    while(bfs())  while(flow = find(S, INF))  res += flow;
    return res;
}

PII p[N];
double D;

bool check(int i, int j)
{
    double dx = p[i].x - p[j].x, dy = p[i].y - p[j].y;
    return dx * dx + dy * dy < D * D + eps;
}

int main()
{
    int _;
    scanf("%d", &_);
    while(_ --)
    {
        memset(h, -1, sizeof h);
        idx = 0;

        scanf("%d%lf", &n, &D);
        S = 0, T = n * 2 + 1;

        int m = 0;
        for(int i = 1; i <= n; i ++)
        {
            int x, y, a, b;
            scanf("%d%d%d%d", &x, &y, &a, &b);
            p[i] = {x, y};
            add(S, i, a);
            add(i, i + n, b);
            m += a;
        }
        for(int i = 1; i <= n; i ++)
            for(int j = i + 1; j <= n; j ++)
                if(check(i, j))
                {
                    add(i + n, j, INF);
                    add(j + n, i, INF);
                }

        vector<int> res;
        for(T = 1; T <= n; T ++)
        {
            for(int i = 0; i < idx; i += 2)
            {
                f[i] += f[i ^ 1];
                f[i ^ 1] = 0;
            }
            if(dinic() >= m)  res.push_back(T - 1);
        }
        if(!res.size())  puts("-1");
        else
        {
            for(int i : res)  printf("%d ", i);
            puts("");
        }
    }
    return 0;
}

作者：滑稽_ωﾉ
链接：https://www.acwing.com/activity/content/code/content/425193/
   。


#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=205;
const int M=20605;
const int INF=0x3f3f3f3f;

int n,S,T;
double D;
int x[N],y[N],s[N],t[N];
int h[N],e[M],w[M],ne[M],idx;
int d[N],cur[N],q[N],hh,tt;

void addedge(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

void add(int a,int b,int c)
{
    addedge(a,b,c),addedge(b,a,0);
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    int task;
    for(scanf("%d",&task);task--;)
    {
        scanf("%d%lf",&n,&D);
        bool flag=true;
        int sum=0;
        for(int i=0;i<n;i++)
        {
            scanf("%d%d%d%d",x+i,y+i,s+i,t+i);
            sum+=s[i];
        }
        for(S=n+n+1,T=0;T<n;T++)
        {
            memset(h,0,sizeof h),idx=1;
            for(int i=1;i<n;i++)
                for(int j=0;j<i;j++)
                    if(hypot(x[i]-x[j],y[i]-y[j])<=D)
                        add(i+n,j,INF),add(j+n,i,INF);
            for(int i=0;i<n;i++)
            {
                if(s[i])add(S,i,s[i]);
                add(i,i+n,t[i]);
            }
            if(dinic()==sum)printf("%d ",T),flag=false;
        }
        puts(flag?"-1":"");
    }
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/444717/
   。

这复杂度也太玄学了。。

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int N = 205, M = N * N * 2 + 2 * N, INF = 1e9;

int n, S, T;

double D;

int d[N], q[N], cur[N], X[N], Y[N];

int head[N], numE;

struct E{
    int next, v, w;
} e[M << 1];

void inline add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
    e[++numE] = (E) { head[v], u, 0 };
    head[v] = numE;
}

bool inline bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = S, cur[S] = head[S], d[S] = 1;
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (!d[v] && e[i].w) {
                d[v] = d[u] + 1, q[++tt] = v, cur[v] = head[v];
                if (v == T) return true;
            }
        }
    }
    return false;
}

int dinic(int u, int flow) {
    if (u == T) return flow;
    int rest = flow;
    for (int i = cur[u]; i && rest; i = e[i].next) {
        int v = e[i].v; cur[u] = i;
        if (d[v] == d[u] + 1 && e[i].w) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, rest -= k, e[i ^ 1].w += k;
        }
    }
    return flow - rest;
}

void inline clear() {
    memset(head, 0, sizeof head);
    numE = 1;
}

int main() {
    int CASE; scanf("%d", &CASE);
    while (CASE--) {
        clear();
        scanf("%d%lf", &n, &D);
        S = 2 * n + 1;
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            int a, b;
            scanf("%d%d%d%d", X + i, Y + i, &a, &b);
            add(S, i, a), add(i, i + n, b);
            sum += a;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = i + 1; j <= n; j++) {
                if ((X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]) <= D * D) {
                    add(i + n, j, INF), add(j + n, i, INF);
                }
            }
        }

        int cnt = 0;
        for (int i = 1; i <= n; i++) {
            T = i;
            for (int j = 2; j <= numE; j += 2) 
                e[j].w += e[j + 1].w, e[j + 1].w = 0;
            int ans = 0, res;
            while (bfs())
                while (res = dinic(S, INF)) ans += res;
            if (ans == sum) {
                printf("%d ", i - 1);
                ++cnt;
            }
        }
        if (!cnt) puts("-1");
        else puts("");
    }
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/427696/
   。
#include<cstdio>
#include<cstring>
#include<map>
#include<vector>
#include<cmath>
#include<cstdlib>
#include<stack>
#include<queue>
#include <iomanip>
#include<iostream>
#include<algorithm>
using namespace std ;
const int N=500 ;
const int M=100000 ;
const int inf=1<<30 ;
struct node
{
    int u ,v,c,next;
}edge[M] ;

struct node1
{
    int n,m ;
    double x,y;
}e[M] ;

int head[N],dis[N],gap[N],cur[N],pre[N] ;
int top , s,t,sum,n,nv;
double d ;

double Dis(int i,int j)  
{  
    return sqrt(1.0*(e[i].x-e[j].x)*(e[i].x-e[j].x)+(e[i].y-e[j].y)*(e[i].y-e[j].y));  
}  

void add(int u ,int v,int c)     
{    
    edge[top].u=u;    
    edge[top].v=v;    
    edge[top].c=c;    
    edge[top].next=head[u];    
    head[u]=top++;    
    edge[top].u=v;    
    edge[top].v=u;    
    edge[top].c=0;    
    edge[top].next=head[v];    
    head[v]=top++;    
}    

int sap()    
{    
    memset(dis,0,sizeof(dis));    
    memset(gap,0,sizeof(gap));    
    int u,v,minflow=inf,flow=0;    
    for(int i = 0 ; i <=nv ; i++)  cur[i]=head[i] ;    
    u=pre[s]=s;    
    gap[s]=nv;    
    while(dis[s] <= nv )    
    {    
            loop :    
               for(int &j=cur[u] ; j!=-1 ; j=edge[j].next)                   
               {    
                     v=edge[j].v ;    
                     if(edge[j].c > 0 && dis[u] == dis[v] +1 )    
                     {    
                              minflow = min(minflow ,edge[j].c) ;    
                              pre[v]=u;    
                              u=v ;    
                          if(v==t)    
                          {      
                                for( u =pre[v] ; v!=s ;v=u,u=pre[u])    
                                      {    
                                            edge[cur[u]].c -= minflow ;     
                                            edge[cur[u]^1].c += minflow ;    
                                      }     
                                flow += minflow ;    
                                minflow = inf ;    
                          }    
                         goto loop ;    
                     }    
               }    
           int mindis=nv ;    
           for(int i = head[u] ; i!=-1 ; i=edge[i].next)    
           {    
                  v=edge[i].v ;    
                  if(edge[i].c > 0 && dis[v] < mindis)    
                  {    
                       mindis = dis[v] ;    
                       cur[u]=i ;           
                 }    
           }    
          if(--gap[dis[u]]==0) break ;    
          gap[ dis[u] = mindis +1 ]++  ;    
          u=pre[u] ;    
    }    
    return flow ;    
}    



void make(int mid)
{
    memset(head,-1,sizeof(head)) ;
    top = 0 ;
    s=0,t=2*n+1 ,nv=t+1 ;
    for(int i = 1 ; i <= n ; i++)
     {
          add(s,i,e[i].n) ;  //源点连冰块 
         if(i==mid)  //聚集地之间流量没有来限制 
            add(i,i+n,inf) ; 
         else add(i,i+n,e[i].m) ;//限制企鹅数量 
     } 
    for(int i = 1 ; i <= n ;i++ )
      for(int j = i+1; j <= n ; j++)
       {
           if( Dis(i,j) <= d ) //i,j冰块可以互相到达 
             {
               add(i+n,j,inf) ,add(j+n,i,inf)   ;//互相可以跳上去 
            }
       }

} 

int main()
{
    int tt ,f[200];
    scanf("%d",&tt) ;
    while(tt--)
    {
          scanf("%d%lf",&n,&d) ;
          sum = 0;
          for(int i = 1 ; i <= n ; i++)
          {
              scanf("%lf%lf%d%d",&e[i].x,&e[i].y,&e[i].n,&e[i].m) ;
              sum += e[i].n ;
          }
          int k = 0 ;
          for(int i = 1 ; i <= n ; i++)
          {
                make(i) ;
                add(i+n,t,inf) ;  //聚集地到汇点连边 
              if(sap()==sum)   //i冰块可以作为聚集地 
              {
                   f[k++]=i-1 ;
              }
          }
         if(k==0)
            printf("-1\n") ;
          else
          {
                printf("%d",f[0]) ;
                for(int  i = 1 ; i < k ; i++)
                   printf(" %d",f[i]) ;
                 puts("") ;  
          }  

    }
    return 0 ;
} 

作者：真-蒻-王善珑
链接：https://www.acwing.com/activity/content/code/content/423558/
   。
Pig
wc掉线了，于是颓题解

顾客为什么有钥匙啊

大体思路显然是，建源点SS向顾客连容量为需求的边，猪圈向汇点TT连容量为+∞+∞的边，然后顾客与猪圈以某种方式连边，最后的最大流即为答案。

对于顾客与猪圈连边，一种错误的方法是，对每个顾客建一个虚点PP,每个他能开的猪圈向PP连容量为+∞+∞的无向边，然后顾客向这个虚点连边。这样是样例也过不去的，错误的原因是，第一个顾客有1,2的钥匙，第二个顾客有1，3的钥匙，并不意味着3的猪一定能换到2上。

考虑对于当前的顾客ii，求出他可以支配的猪圈集合SiSi，即可以在之前通过某些方法让他能任意选择的猪圈。首先他直接有钥匙的猪圈显然属于SiSi.其次，∀j<i,,∀x,y∈Aj,x∈Si∀j<i,,∀x,y∈Aj,x∈Si,必然有y∈Siy∈Si(即若Si∪Aj≠∅Si∪Aj≠∅,令Si=Si∩AjSi=Si∩Aj.令ii向SiSi中每个点连边即可。可以std::bitset维护。

时间复杂度理论上界O(n2mω+nmnm‾‾‾√))O(n2mω+nmnm)),但完全跑不到。在poj上0ms。。。

std::bitset<1011>s[111];
int main()
{
    int n2=read(),n1=read(),S=n1+n2+1,T=S+1,tot=T;
    for(int i=1;i<=n2;++i)adde(n1+i,T,read());
    for(int i=1;i<=n1;++i)
    {
        int l=read();
        while(l--)s[i][read()]=1;
        std::bitset<1011>pos=s[i];
        for(int j=i-1;j;--j)
            if((pos&s[j]).any())pos|=s[j];
        for(int j=1;j<=n2;++j)
            if(pos[j])adde(i,n1+j,INF);
        adde(S,i,read());
    }
    printf("%lld",Dinic(S,T,tot));
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/17624/
   。

AcWing 2237. 猪    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 17:11:08 ,  阅读 19

0






from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow




m, n = map(int, input().split())
X = list(map(int, input().split()))

S, T = n+1, n+2

edges = []
visit = [[] for i in range(m)]      # visit[idx]记录idx号猪舍被那些顾客打开过
for i in range(1, n+1):
    arr = list(map(int, input().split()))
    buy_cnt = arr[-1]
    for house_idx in arr[1:-1]:
        house_idx -= 1

        if len(visit[house_idx]) == 0:
            edges.append((S, i, X[house_idx]))
        else:
            for cus_idx in visit[house_idx]:
                edges.append((cus_idx, i, 0x7fffffff))

        visit[house_idx].append(i)
    edges.append((i, T, buy_cnt))

print(FortdFulkerson(edges, S, T, n+2, len(edges)).getMaxFlow())

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21236/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 100200 * 2 + 10, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
int w[1010], belong[1010];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs())
    {
        r += find(S, INF);
        flow = find(S, INF);
        if (flow) puts("!");
        r += flow;
    }
    return r;
}

int main()
{
    scanf("%d%d", &m, &n);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= m; i ++ ) scanf("%d", &w[i]);
    for (int i = 1; i <= n; i ++ )
    {
        int a, b;
        scanf("%d", &a);
        while (a -- )
        {
            int t;
            scanf("%d", &t);
            if (!belong[t]) add(S, i, w[t]);
            else add(belong[t], i, INF);
            belong[t] = i;
        }
        scanf("%d", &b);
        add(i, T, b);
    }

    printf("%d\n", dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/424544/
   。

舔包建图
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=105;
const int M=200205;
const int INF=0x3f3f3f3f;

int n,m,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;
int c[1005],last[1005];

void addedge(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

void add(int a,int b,int c)
{
    addedge(a,b,c),addedge(b,a,0);
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    scanf("%d%d",&m,&n),S=0,T=n+1;
    for(int i=1;i<=m;i++)scanf("%d",c+i);
    for(int i=1,A,id;i<=n;i++)
    {
        for(scanf("%d",&A);A--;)
        {
            scanf("%d",&id);
            if(last[id])add(last[id],i,INF);
            else    add(S,i,c[id]);
            last[id]=i;
        }
        scanf("%d",&A);
        add(i,T,A);
    }
    printf("%d\n",dinic());
    return 0;
}
瞎写的另一种建图方式
#include <cstring>

const int INF=0x3fffffff;
const int N=1105;
const int M=202205;

int n,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;
char st[105][126],p[126];

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    int n1,n2;
    scanf("%d%d",&n2,&n1);
    S=n1+n2+1,T=n=S+1;
    for(int i=1,x;i<=n2;++i)
    {
        scanf("%d",&x);
        add(n1+i,T,x);
        add(T,n1+i,x);
    }
    for(int i=1;i<=n1;i++)
    {
        int A,x;
        for(scanf("%d",&A);A--;)
        {
            scanf("%d",&x);
            st[i][x>>3]|=1<<(x&7);
        }
        memcpy(p,st[i],sizeof p);
        for(int j=i-1;j;j--)
        {
            bool judge=false;
            for(int k=1;k<=n2;k++)
                if((p[k>>3]>>(k&7)&1)&&(st[j][k>>3]>>(k&7)&1))
                {
                    judge=true;
                    break;
                }
            if(judge)
                for(int k=1;k<=n2;k++)
                    if(st[j][k>>3]>>(k&7)&1)
                        p[k>>3]|=1<<(k&7);
        }
        for(int j=1;j<=n2;j++)
            if(p[j>>3]>>(j&7)&1)
            {
                add(i,n1+j,INF);
                add(n1+j,i,0);
            }
        scanf("%d",&x);
        add(S,i,x),add(i,S,0);
    }
    printf("%d\n",dinic());
    return 0;
}


作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/418545/
   。

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int M = 1005, N = 105, INF = 1e9;

int m, n, cnt[M], A[N], K[N][M], B[N], S, T, last[M];

int head[N], numE = 1;

int d[N], q[N], cur[N];

struct E{
    int next, v, w;
} e[(N * M) << 1];

void inline add(int u, int v, int w) {
    e[++numE] = (E) { head[u], v, w };
    head[u] = numE;
    e[++numE] = (E) { head[v], u, 0 };
    head[v] = numE;
}

bool inline bfs() {
    memset(d, 0, sizeof d);
    int hh = 0, tt = 0;
    q[0] = S, cur[S] = head[S], d[S] = 1;
    while (hh <= tt) {
        int u = q[hh++];
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (!d[v] && e[i].w) {
                d[v] = d[u] + 1, q[++tt] = v, cur[v] = head[v];
                if (v == T) return true;
            }
        }
    }
    return false;
}

int dinic(int u, int flow) {
    if (u == T) return flow;
    int rest = flow;
    for (int i = cur[u]; i && rest; i = e[i].next) {
        int v = e[i].v; cur[u] = i;
        if (d[v] == d[u] + 1 && e[i].w) {
            int k = dinic(v, min(rest, e[i].w));
            if (!k) d[v] = 0;
            e[i].w -= k, rest -= k, e[i ^ 1].w += k;
        }
    }
    return flow - rest;
}

int main() {
    scanf("%d%d", &m, &n);
    S = n + 1, T = n + 2;
    for (int i = 1; i <= m; i++) scanf("%d", cnt + i);
    for (int i = 1; i <= n; i++) {
        scanf("%d", A + i);
        for (int j = 1; j <= A[i]; j++) {
            scanf("%d", &K[i][j]);
            if (!last[K[i][j]]) add(S, i, cnt[K[i][j]]);
            else add(last[K[i][j]], i, INF);
            last[K[i][j]] = i;
        }
        scanf("%d", B + i);
        add(i, T, B[i]);
    }
    int ans = 0, res;
    while (bfs())
        while (res = dinic(S, INF)) ans += res;
    printf("%d\n", ans);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/activity/content/code/content/428160/
   。

AcWing 2173. Dinic/ISAP求最小割    原题链接    中等
作者：    皓首不倦 ,  2020-09-23 18:52:58 ,  阅读 16

0




'''
求最小割和求最大流是等价的，直接用Dinic求最大流即可
'''

from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    #返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num*2 + 1)            # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num*2 + 1)            # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num*2 + 1)           # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度
        orig_flow = [0] * (self.max_edge_num + 1)       # 原图中有向边的流量

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False


        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]     # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node]+1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx^1], flow = f[idx]-t, f[idx^1]+t, flow+t

                    # 更新原图边的流量
                    if self.edges[idx>>1][0] == node:
                        orig_flow[idx>>1] += t
                    else:
                        orig_flow[idx>>1] -= t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2]) for i in range(len(self.edges))]

n, m, start, end = map(int, input().split())
link = {}
for _ in range(m):
    a, b, w = map(int, input().split())

    if (a, b) not in link:
        link[(a, b)] = w
    else:
        #print(f'overlap {a} {b}')
        link[(a, b)] += w

edges = [(a, b, w) for (a, b), w in link.items()]
algo = FortdFulkerson(edges, start, end, max_node_num=n, max_edge_num=m)
print(algo.getMaxFlow()[0])

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21240/
   。

基本概念
1.1 流网络，不考虑反向边
1.2 可行流，不考虑反向边
1.2.1 两个条件：容量限制、流量守恒
1.2.2 可行流的流量指从源点流出的流量 - 流入源点的流量
1.2.3 最大流是指最大可行流
1.3 残留网络，考虑反向边，残留网络的可行流f’ + 原图的可行流f = 原题的另一个可行流
(1) |f’ + f| = |f’| + |f|
(2) |f’| 可能是负数
1.4 增广路径
1.5 割
1.5.1 割的定义
1.5.2 割的容量，不考虑反向边，“最小割”是指容量最小的割。
1.5.3 割的流量，考虑反向边，f(S, T) <= c(S, T)
1.5.4 对于任意可行流f，任意割[S, T]，|f| = f(S, T)
1.5.5 对于任意可行流f，任意割[S, T]，|f| <= c(S, T)
1.5.6 最大流最小割定理
(1) 可以流f是最大流
(2) 可行流f的残留网络中不存在增广路
(3) 存在某个割[S, T]，|f| = c(S, T)
1.6. 算法
1.6.1 EK O(nm^2)
1.6.2 Dinic O(n^2m)
1.7 应用
1.7.1 二分图
(1) 二分图匹配
(2) 二分图多重匹配
1.7.2 上下界网络流
(1) 无源汇上下界可行流
(2) 有源汇上下界最大流
(3) 有源汇上下界最小流
1.7.3 多源汇最大流
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010, M = 200010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    printf("%d\n", dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/424558/
   。
最大流最小割定理
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=10005;
const int M=200005;
const int INF=0x3fffffff;

int n,m,S,T;
int h[N],e[M],w[M],ne[M],idx=1;
int d[N],cur[N],q[N],hh,tt;

void add(int a,int b,int c)
{
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

bool bfs()
{
    memset(d,0,sizeof d);
    d[S]=1,cur[S]=h[S];
    *q=S,hh=tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];i;i=ne[i])
            if(!d[e[i]]&&w[i])
            {
                d[e[i]]=d[t]+1;
                cur[e[i]]=h[e[i]];
                if(e[i]==T)return true;
                q[++tt]=e[i];
            }
    }
    return false;
}

int find(int u,int limit)
{
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u];i&&flow<limit;i=ne[i])
    {
        cur[u]=i;
        if(d[e[i]]==d[u]+1&&w[i])
        {
            int t=find(e[i],min(w[i],limit-flow));
            if(!t)d[e[i]]=0;
            w[i]-=t,w[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

int dinic()
{
    int maxflow=0,flow;
    while(bfs())while(flow=find(S,INF))maxflow+=flow;
    return maxflow;
}

int main()
{
    scanf("%d%d%d%d",&n,&m,&S,&T);
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c),add(b,a,0);
    }
    printf("%d\n",dinic());
    return 0;
}

作者：垫底抽风
链接：https://www.acwing.com/activity/content/code/content/423681/
   。

AcWing 2279. 网络战争    原题链接    困难
作者：    whsstory ,  2020-08-09 09:49:46 ,  阅读 106

3


网络战争
注：如果Latex挂掉了请告知我，或者用typora/vscode打开

求一个平均权值最小的割集。

考虑分数规划。存在一个平均值不大于xx的割集等价于：
∃C,∑e∈Cw(e)|C|≤x
∃C,∑e∈Cw(e)|C|≤x
⇒∃C,∑e∈C(w(e)−x)≤0
⇒∃C,∑e∈C(w(e)−x)≤0
故 存在一个平均值不大于xx的割集⇔⇔将边权全部减少xx后，最小割权值不超过0.二分答案+最大流 即可。

注意图中会出现负权边，没法直接最大流，但最小割中必然包含所有负权边，提前选上即可。

浮点数最大流真毒瘤啊

struct one{int u,v,w;}e2[MAXM];
int n,m,S,T;
bool check(double k)
{
    cnt=1;
    for(int i=1;i<=n;++i)last[i]=0;
    double sum=0;
    for(int i=1;i<=m;++i)
        if(e2[i].w<=k)sum+=e2[i].w-k;
        else adde(e2[i].u,e2[i].v,e2[i].w-k),adde(e2[i].v,e2[i].u,e2[i].w-k);
    return Dinic(S,T,n)+sum<=0;
}
int main()
{
    n=read(),m=read(),S=read(),T=read();
    for(int i=1;i<=m;++i)e2[i].u=read(),e2[i].v=read(),e2[i].w=read();
    double l=0,r=1e7;
    while(r-l>2e-3)
    {
        double mid=(l+r)/2;
        if(check(mid))r=mid;
        else l=mid;
    }
    printf("%.2lf",l);
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/17983/
   。

AcWing 2279. 网络战争    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 20:45:42 ,  阅读 22

1


1




EPSILON = 1e-7
from typing import List
from collections import deque

import sys
class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow


n, m, S, T = map(int, input().split())
e = []
max_w = -0x7fffffff
for _ in range(m):
    a, b, w = map(int, input().split())
    e.append((a, b, w))
    max_w = max(w, max_w)

l, r = 0, max_w
ans = None
while abs(l - r) > EPSILON:
    mid = l + (r - l) / 2

    total = 0
    edges = []
    for a, b, w in e:
        if w <= mid:
            total -= mid - w
        else:
            edges.append((a, b, w-mid))
            edges.append((b, a, w-mid))

    max_flow = FortdFulkerson(edges, S, T, n, len(edges)).getMaxFlow()
    if max_flow + total < 0:
        ans = r
        r = mid
    else:
        l = mid

print('{:.2f}'.format(ans))

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21254/
   。

2


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 810, INF = 1e8;
const double eps = 1e-8;

int n, m, S, T;
int h[N], e[M], w[M], ne[M], idx;
double f[M];
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, w[idx] = c, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i] > 0)
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

double find(int u, double limit)
{
    if (u == T) return limit;
    double flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i] > 0)
        {
            double t = find(ver, min(f[i], limit - flow));
            if (t < eps) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

double dinic(double mid)
{
    double res = 0;
    for (int i = 0; i < idx; i += 2)
        if (w[i] <= mid)
        {
            res += w[i] - mid;
            f[i] = f[i ^ 1] = 0;
        }
        else f[i] = f[i ^ 1] = w[i] - mid;

    double r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r + res;
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    double l = 0, r = 1e7;
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (dinic(mid) < 0) r = mid;
        else l = mid;
    }

    printf("%.2lf\n", r);
  

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/424638/
   。
AcWing 2280. 最优标号    原题链接    困难
作者：    皓首不倦 ,  2020-09-23 23:15:10 ,  阅读 35

3





from typing import List
from collections import deque

import sys
class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow



n, m = map(int, input().split())
e = []

for i in range(m):
    a, b = map(int, input().split())
    e.append((a, b, 1))
    e.append((b, a, 1))

k = int(input())
label = {}
for i in range(k):
    a, b = map(int, input().split())
    label[a] = b

S, T = n+1, n+2
ans = 0
for bit in range(32):

    ee = []
    for node, val in label.items():
        if val & (1 << bit):
           ee.append((node, T, 0x7fffffff))
           ee.append((T, node, 0x7fffffff))
        else:
            ee.append((node, S, 0x7fffffff))
            ee.append((S, node, 0x7fffffff))

    edges = e + ee
    max_flow = FortdFulkerson(edges, S, T, n+2, len(edges)).getMaxFlow()
    ans += (1 << bit) * max_flow

print(ans)


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21265/
   。
#include <iostream>
#include <cstring>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef long long LL;
typedef pair<int, int> PII;

const int N = 510, M = (3000 + N * 2) * 2, INF = 1e8;

int n, m, k, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
int p[N];
PII edges[3010];

void add(int a, int b, int c1, int c2)
{
    e[idx] = b, f[idx] = c1, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = c2, ne[idx] = h[b], h[b] = idx ++ ;
}

void build(int k)
{
    memset(h, -1, sizeof h);
    idx = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].x, b = edges[i].y;
        add(a, b, 1, 1);
    }
    for (int i = 1; i <= n; i ++ )
        if (p[i] >= 0)
        {
            if (p[i] >> k & 1) add(i, T, INF, 0);
            else add(S, i, INF, 0);
        }
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

LL dinic(int k)
{
    build(k);
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + 1;
    for (int i = 0; i < m; i ++ ) scanf("%d%d", &edges[i].x, &edges[i].y);
    scanf("%d", &k);
    memset(p, -1, sizeof p);
    while (k -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        p[a] = b;
    }

    LL res = 0;
    for (int i = 0; i <= 30; i ++ ) res += dinic(i) << i;
    printf("%lld\n", res);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/424690/
   。
AcWing 961. 最大获利    原题链接    中等
作者：    whsstory ,  2020-08-10 10:48:47 ,  阅读 83

4


最大获利
若选择用户ii，则ai,biai,bi都必须选择，最大化点权和。这便是最大权闭合图的模型。

最大权闭合图的解法是，新建源点SS,向正权点连容量为点权的边；新建汇点TT,负权点向TT连容量为点权的相反数的边。图中原有的边容量改为正无穷。正权点点权和减去最小割即为答案。

正确性证明：选择用户i⇒i⇒ ai,biai,bi必须选择，即必须割掉ai,biai,bi连向TT的边；放弃用户i⇒i⇒割掉SS连向ii的边。

int main()
{
    int n=read(),m=read(),S=n+m+1,T=S+1,sum=0;
    for(int i=1;i<=n;++i)adde(m+i,T,read());
    for(int i=1;i<=m;++i)
    {
        int a=read(),b=read(),val=read();
        sum+=val;
        adde(i,m+a,INF),adde(i,m+b,INF);
        adde(S,i,val);
    }
    printf("%lld",sum-Dinic(S,T,T));
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/17985/
   。
AcWing 961. 最大获利 最大密度子图建图解法    原题链接    中等
作者：    皓首不倦 ,  2020-09-25 12:46:35 ,  阅读 21

1



'''
转成无向图最大密度子图问题求解，比最大权值和闭合子图模型快一些
'''

from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow


n, m = map(int, input().split())
S, T = n+1, n+2
U = 9999
edges = []
for node in range(1, n+1):
    edges.append((S, node, U))
    edges.append((node, S, U))

d = [0] * (n+1)

cost = list(map(int, input().split()))
for _ in range(m):
    a, b, w = map(int, input().split())
    edges.append((a, b, w))
    edges.append((b, a, w))

    d[a] += w
    d[b] += w

for node in range(1, n+1):
    edges.append((node, T, U-d[node]+2*cost[node-1]))
    edges.append((T, node, U-d[node]+2*cost[node - 1]))

ans = (n*U - FortdFulkerson(edges, S, T, n+2, len(edges)).getMaxFlow()) / 2
print(int(ans))



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21358/
   。



2


最大权闭合图
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 55010, M = (50000 * 3 + 5000) * 2 + 10, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + m + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ )
    {
        int p;
        scanf("%d", &p);
        add(m + i, T, p);
    }

    int tot = 0;
    for (int i = 1; i <= m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(S, i, c);
        add(i, m + a, INF);
        add(i, m + b, INF);
        tot += c;
    }

    printf("%d\n", tot - dinic());

    return 0;
}
最大密度子图
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 5010, M = (50000 + N * 2) * 2 + 10, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
int dg[N], p[N];

void add(int a, int b, int c1, int c2)
{
    e[idx] = b, f[idx] = c1, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = c2, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &p[i]), p[i] *= -1;
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c, c);
        dg[a] += c, dg[b] += c;
    }
    int U = 0;
    for (int i = 1; i <= n; i ++ ) U = max(U, 2 * p[i] + dg[i]);
    for (int i = 1; i <= n; i ++ )
    {
        add(S, i, U, 0);
        add(i, T, U - 2 * p[i] - dg[i], 0);
    }

    printf("%d\n", (U * n - dinic()) / 2);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/435267/
   。
AcWing 2324. 生活的艰辛    原题链接    困难
作者：    TCO ,  2020-08-20 11:40:16 ,  阅读 64

1


1
浮点数好毒瘤啊
这个题调了好多次精度才过。。
做法就是一顿推公式。记住一个结论就是： 对于一张原图，新加S,T两点。给原图的每个点都add(S,i,V,0),add(i,T,2g-di+V,0)//g是二分的密度，di代表这个点的度数。V是为了防止负数出现
对于原图的边add(u,v,1,1)
然后有：C[S,T]=Vn + 2g|V’|-2|E’| //这里V是上面的含义，V’是选中的点，E’是子图的边数，那么对于每一个二分的g,我们去check是否满足C[S,T]-Vn<0，若满足就说明g可行。
至于详细的推导嘛。。。看y总的视频讲解以及胡伯涛那篇论文《最小割在信息学奥赛中的应用》


#include<bits/stdc++.h>
using namespace std;

const int N=10010,M=200010;
int q[N],d[N],cur[N],dg[N];
double f[M],sum;
int e[M],ne[M],idx,h[N],n,m,S,T,VV;

struct E{
    int a,b;
}edge[10010];

void add(int a,int b,double c,double d)
{
    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;
    e[idx]=a,f[idx]=d,ne[idx]=h[b],h[b]=idx++;
}
bool bfs()
{

    memset(d,-1,sizeof d); 
    q[0]=S,cur[S]=h[S],d[S]=0;
    int hh=0,tt=0;
    while(hh<=tt)
    {
        int t=q[hh++];
        for(int i=h[t];~i;i=ne[i])
        {
            int ver=e[i];
            if(d[ver]==-1&&f[i])
            {
                d[ver]=d[t]+1;
                cur[ver]=h[ver];
                if(ver==T) return true;
                q[++tt]=ver;
            }
        }
    }
    return false;
}
double find(int u,double limit)
{
    if(u==T ) return limit;
    double flow=0;
    for(int i=cur[u];~i&&flow<limit;i=ne[i])
    {
        int ver=e[i];
        cur[u]=i;
        if(d[ver]==d[u]+1&&f[i]>0)
        {
            double t=find(ver,min(f[i],limit-flow));
            if(t<1e-8) d[ver]=-1;
            f[i]-=t,f[i^1]+=t,flow+=t;
        }
    }
    return flow;
}

bool dinic(double mid)
{
    memset(h,-1,sizeof h);
    idx=0;
    for(int i=1;i<=m;i++)
    {
        int a=edge[i].a,b=edge[i].b;
        add(a,b,1,1);
    }
    for(int i=1;i<=n;i++) add(S,i,VV,0),add(i,T,VV+2*mid-dg[i],0);
    double r=0,flow;
    while(bfs()  ) while(flow=find(S,0x3f3f3f3f)) r+=flow;
    return 0<sum-r;
}
bool st[N];
vector<int> ans;
void dfs(int u)
{
   // printf("now fuck %d\n",u);
   if(u!=S) ans.push_back(u);
   st[u]=true;
    for(int i=h[u];~i;i=ne[i])
    {
        if(!st[e[i]]&&f[i]>0) dfs(e[i]);
    }
}
int main()
{
    cin>>n>>m;
    VV=m+10;
    sum=n*VV;
    S=n+2,T=n+4;
    for(int i=1;i<=m;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        edge[i]={a,b};
        dg[a]++;
        dg[b]++;
    }
    double l=0,r=m;
    while(r-l>1e-8)
    {
        double mid=(l+r)/2;
        if(dinic(mid)) l=mid;
        else r=mid;
    }
    dinic(l);dfs(S);
    //printf("%.6lf\n",l);
    if(ans.size()==0)
    {
        cout<<1<<endl<<1;
    }
    else {

        printf("%d\n",ans.size());
        for(int i=1;i<=n;i++) if(st[i]) printf("%d\n",i);
    }
    return 0;
}

作者：TCO
链接：https://www.acwing.com/solution/content/18827/
   。
AcWing 2324. 生活的艰辛    原题链接    困难
作者：    皓首不倦 ,  2020-09-24 23:35:54 ,  阅读 39

0


.png)

.png)

.png)


'''
01 分数规划二分搜索边数平均值的上界，利用最小割的容量验证
平均值上界是否是有效值
'''


from typing import List
from collections import deque


EPSILON = 1e-4

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 获取最小割的划分方案，返回最小割容量以及两个列表，第一个列表为和源点在一个集合中的所有点，第二个列表是和汇点在同一个集合中的所有点
    def getMinCut(self):
        e = [-1] * (self.max_edge_num * 2 + 1)          # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)          # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)         # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        min_cut_cap = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            min_cut_cap += dfs(self.source_node, 0x7fffffff)

        visit = [0] * (self.max_node_num + 1)
        def travel(cur):
            visit[cur] = 1

            idx = h[cur]
            while idx != -1:
                next_node = e[idx]
                if visit[next_node] == 0 and f[idx] > 0:
                    travel(next_node)

                idx = ne[idx]

        travel(self.source_node)
        s_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 1]
        t_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 0]

        return min_cut_cap, s_nodes, t_nodes


n, m = map(int, input().split())
U = 99999
S, T = n+1, n+2

e = []
d = [0] * (n+1)
for node in range(1, n+1):
    e.append((S, node, U))
    e.append((node, S, U))

for i in range(m):
    a, b = map(int, input().split())
    d[a] += 1
    d[b] += 1
    e.append((a, b, 1))
    e.append((b, a, 1))

# 二分搜索可能的平均边数的上界
ans = None
l, r = 0, m
while abs(l- r) > EPSILON:
    mid = l + (r-l) / 2

    e1 = [(node, T, 2*mid - d[node] + U) for node in range(1, n + 1)]
    e2 = [(T, node, 2*mid - d[node] + U) for node in range(1, n + 1)]
    edges = e + e1 + e2

    min_cut_cap, s_nodes, _ = FortdFulkerson(edges, S, T, n+2, len(edges)).getMinCut()
    val = n * U - min_cut_cap
    #print(l, r, min_cut_cap, val, s_nodes)

    if val > 0:
        l = mid
        ans = s_nodes
    else:
        r = mid

if ans is not None:
    print(len(ans)-1)
    for node in ans:
        if node == S:
            continue
        print(node)

else:
    print(1)
    print(1)

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21338/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = (1000 + N * 2) * 2, INF = 1e8;

int n, m, S, T;
int h[N], e[M], ne[M], idx;
double f[M];
int q[N], d[N], cur[N];
int dg[N];

struct Edge
{
    int a, b;
}edges[M];

int ans;
bool st[N];

void add(int a, int b, double c1, double c2)
{
    e[idx] = b, f[idx] = c1, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = c2, ne[idx] = h[b], h[b] = idx ++ ;
}

void build(double g)
{
    memset(h, -1, sizeof h);
    idx = 0;
    for (int i = 0; i < m; i ++ ) add(edges[i].a, edges[i].b, 1, 1);
    for (int i = 1; i <= n; i ++ )
    {
        add(S, i, m, 0);
        add(i, T, m + g * 2 - dg[i], 0);
    }
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i] > 0)
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

double find(int u, double limit)
{
    if (u == T) return limit;
    double flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i] > 0)
        {
            double t = find(ver, min(f[i], limit - flow));
            if (t <= 0) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

double dinic(double g)
{
    build(g);
    double r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

void dfs(int u)
{
    st[u] = true;
    if (u != S) ans ++ ;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int ver = e[i];
        if (!st[ver] && f[i] > 0)
            dfs(ver);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + 1;

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        dg[a] ++, dg[b] ++ ;
        edges[i] = {a, b};
    }

    double l = 0, r = m;
    while (r - l > 1e-8)
    {
        double mid = (l + r) / 2;
        double t = dinic(mid);
        if (m * n - t > 0) l = mid;
        else r = mid;
    }

    dinic(l);
    dfs(S);

    if (!ans) puts("1\n1");
    else
    {
        printf("%d\n", ans);
        for (int i = 1; i <= n; i ++ )
            if (st[i])
                printf("%d\n", i);
    }
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/435370/
   。
AcWing 2325. 有向图破坏    原题链接    困难
作者：    皓首不倦 ,  2020-09-25 15:55:51 ,  阅读 25

1





'''
转成二分图的最小点权值和覆盖点集问题求解
'''


from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 获取最小割的划分方案，返回最小割容量以及两个列表，第一个列表为和源点在一个集合中的所有点，第二个列表是和汇点在同一个集合中的所有点
    def getMinCut(self):
        e = [-1] * (self.max_edge_num * 2 + 1)          # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)          # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)         # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        min_cut_cap = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            min_cut_cap += dfs(self.source_node, 0x7fffffff)

        visit = [0] * (self.max_node_num + 1)
        def travel(cur):
            visit[cur] = 1

            idx = h[cur]
            while idx != -1:
                next_node = e[idx]
                if visit[next_node] == 0 and f[idx] > 0:
                    travel(next_node)

                idx = ne[idx]

        travel(self.source_node)
        s_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 1]
        t_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 0]

        return min_cut_cap, s_nodes, t_nodes


n, m = map(int, input().split())
w_pos = [0] + list(map(int, input().split()))
w_neg = [0] + list(map(int, input().split()))

# part1 点范围为1 - n part2点范围为n+1 - 2n


edges = []
S, T = 2*n+1, 2*n+2
for node in range(1, n+1):
    edges.append((S, node, w_neg[node]))
    edges.append((node+n, T, w_pos[node]))

for _ in range(m):
    a, b = map(int, input().split())
    edges.append( (a, b+n, 0x7fffffff) )

min_cut_cap, ss, tt = FortdFulkerson(edges, S, T, 2*n+2, len(edges)).getMinCut()
print(min_cut_cap)


pos_nodes = []
neg_nodes = []
for node in ss:
    if node >= n+1 and node <= 2*n:
        pos_nodes.append(node-n)

for node in tt:
    if node >= 1 and node <= n:
        neg_nodes.append(node)

print(len(pos_nodes) + len(neg_nodes))
for node in pos_nodes:
    print(f'{node} +')
for node in neg_nodes:
    print(f'{node} -')


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21371/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 210, M = 5200 * 2 + 10, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

void dfs(int u)
{
    st[u] = true;
    for (int i = h[u]; ~i; i = ne[i])
        if (f[i] && !st[e[i]])
            dfs(e[i]);
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ )
    {
        int w;
        scanf("%d",  &w);
        add(S, i, w);
    }
    for (int i = 1; i <= n; i ++ )
    {
        int w;
        scanf("%d", &w);
        add(n + i, T, w);
    }

    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(b, n + a, INF);
    }

    printf("%d\n", dinic());
    dfs(S);

    int cnt = 0;
    for (int i = 0; i < idx; i += 2)
    {
        int a = e[i ^ 1], b = e[i];
        if (st[a] && !st[b]) cnt ++ ;
    }

    printf("%d\n", cnt);
    for (int i = 0; i < idx; i += 2)
    {
        int a = e[i ^ 1], b = e[i];
        if (st[a] && !st[b])
        {
            if (a == S) printf("%d +\n", b);
        }
    }
    for (int i = 0; i < idx; i += 2)
    {
        int a = e[i ^ 1], b = e[i];
        if (st[a] && !st[b])
        {
            if (b == T) printf("%d -\n", a - n);
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/446906/
   。
AcWing 2326. 王者之剑    原题链接    困难
作者：    皓首不倦 ,  2020-09-25 19:40:00 ,  阅读 24

0


'''
方格涂色为黑白相间，相邻的黑色和白色格子之间连无向边构成二分图，
本质是要求二分图上最大权值和的独立子集，等价于求二分图最小权值和
的覆盖子集，然后用总权值减去最小覆盖子集的点权值和就是答案
'''



from collections import deque
class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow




m, n = map(int, input().split())
S, T = m * n + 1, m * n + 2

edges = []
total_w = 0

visit = set()

last_flag = 1
for i in range(m):
    grid = list(map(int, input().split()))
    flag = 1 - last_flag
    for j in range(n):
        total_w += grid[j]

        node = i * n + j + 1
        if flag == 0:
            edges.append((S, node, grid[j]))

            for ii, jj in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j-1)]:
                if ii < m and ii >= 0 and jj < n and jj >= 0:
                    ne = ii * n + jj + 1
                    if (node, ne) not in visit:
                        visit.add((node, ne))
                        edges.append((node, ne, 0x7fffffff))
        else:
            edges.append((node, T, grid[j]))

        flag = 1 - flag

    last_flag = 1 - last_flag

ans = total_w - FortdFulkerson(edges, S, T, m*n+2, len(edges)).getMaxFlow()
print(ans)




作者：皓首不倦
链接：https://www.acwing.com/solution/content/21382/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010, M = 60010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

int get(int x, int y)
{
    return (x - 1) * m + y;
}

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n * m + 1;
    memset(h, -1, sizeof h);

    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            int w;
            scanf("%d", &w);
            if (i + j & 1)
            {
                add(S, get(i, j), w);
                for (int k = 0; k < 4; k ++ )
                {
                    int x = i + dx[k], y = j + dy[k];
                    if (x >= 1 && x <= n && y >= 1 && y <= m)
                        add(get(i, j), get(x, y), INF);
                }
            }
            else
                add(get(i, j), T, w);
            tot += w;
        }

    printf("%d\n", tot - dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/446979/
   。
AcWing 381. 有线电视网络    原题链接    简单
作者：    皓首不倦 ,  2020-09-25 23:54:13 ,  阅读 27

0


没搞懂输入数据格式搞成这么奇怪的格式是为什么，代码浪费时间去处理这种奇怪的输入格式，没看出来有什么意义



'''
每一个点拆成出点和入点
枚举源点S和汇点T，S入点和出点间连边权无穷大的有向边，T入点和出点之间连边权无穷大的有向边
其他点的入点和出点之间连接边权是1的有向边
原图中已经有的无向边转成两条有向边，有向边起点对应的点的出节点向有向边终点的入节点连接边权
是1的有向边，求取S到T的最小割，割边一定都是除了源点和汇点之间的其他点的入点和出点之间的边
割边的数量就是最小割数值，也就是最少要删除多少条入点和出点之间的边，才能让S到T不连通
也就等价于是删除多少个S T以外的点，能够让S T不连通，枚举 S 和 T 找需要删除的点的最小个数
就是最后的答案

'''



from typing import List
from collections import deque
import sys


class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow




while True:

    try:
        s = input()
        if s == '':
            continue
        ss = s.split()
        n, m = int(ss[0]), int(ss[1])
    except:
        break

    e = []
    for num_s in ss[2:]:
        a, b = map(int, num_s[1:-1].split(','))
        a, b = a + 1, b + 1
        e.append((a, b))

    while len(e) < m:
        s = input()
        ss = s.split()
        for num_s in ss:
            a, b = map(int, num_s[1:-1].split(','))
            a, b = a + 1, b + 1
            e.append((a, b))


    ans = n
    for S in range(1, n+1):
        for T in range(1, n+1):
            if S == T:
                continue

            edges = []
            for node in range(1, n+1):
                if node != S and node != T:
                    edges.append((node, node+n, 1))
                else:
                    edges.append((node, node+n, 0x7fffffff))

            for a, b in e:
                edges.append((a+n, b, 0x7fffffff))
                edges.append((b+n, a, 0x7fffffff))

            ans = min(ans, FortdFulkerson(edges, S, T, 2*n, len(edges)).getMaxFlow())

    print(ans)


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21395/
   。
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 5210, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    while (cin >> n >> m)
    {
        memset(h, -1, sizeof h);
        idx = 0;
        for (int i = 0; i < n; i ++ ) add(i, n + i, 1);
        while (m -- )
        {
            int a, b;
            scanf(" (%d,%d)", &a, &b);
            add(n + a, b, INF);
            add(n + b, a, INF);
        }
        int res = n;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < i; j ++ )
            {
                S = n + i, T = j;
                for (int k = 0; k < idx; k += 2)
                {
                    f[k] += f[k ^ 1];
                    f[k ^ 1] = 0;
                }
                res = min(res, dinic());
            }
        printf("%d\n", res);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/447889/
   。

AcWing 2176. 太空飞行计划问题 最大权闭合子图模型应用    原题链接    困难
作者：    皓首不倦 ,  2020-09-26 11:21:27 ,  阅读 19

0



'''
转换为最大权闭合子图问题求解
所有试验是正权点，所有器材是负权点，正权点对一些负权点有依赖，负权点没有对外依赖
因此最后选择的方案一定是一个闭合点集
直接用最大权闭合子图模型求解即可
'''


from typing import List
from collections import deque

class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 获取最小割的划分方案，返回最小割容量以及两个列表，第一个列表为和源点在一个集合中的所有点，第二个列表是和汇点在同一个集合中的所有点
    def getMinCut(self):
        e = [-1] * (self.max_edge_num * 2 + 1)          # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)          # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)         # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)              # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)            # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)            # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        min_cut_cap = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            min_cut_cap += dfs(self.source_node, 0x7fffffff)

        visit = [0] * (self.max_node_num + 1)
        def travel(cur):
            visit[cur] = 1

            idx = h[cur]
            while idx != -1:
                next_node = e[idx]
                if visit[next_node] == 0 and f[idx] > 0:
                    travel(next_node)

                idx = ne[idx]

        travel(self.source_node)
        s_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 1]
        t_nodes = [node for node in range(1, self.max_node_num+1) if visit[node] == 0]

        return min_cut_cap, s_nodes, t_nodes


m, n = map(int, input().split())
S, T = m+n+1, m+n+2
edges = []

pos_node_sum = 0
for i in range(1, m+1):
    arr = list(map(int, input().split()))
    edges.append((S, i, arr[0]))
    pos_node_sum += arr[0]
    for node in arr[1:]:
        edges.append((i, node+m, 0x7fffffff))

arr = list(map(int, input().split()))
for i, val in enumerate(arr):
    edges.append((i+1+m, T, val))

min_cut_cap, s_nodes, _ = FortdFulkerson(edges, S, T, m+n+2, len(edges)).getMinCut()
max_profit = pos_node_sum - min_cut_cap


pos_nodes = []
neg_nodes = []
for node in s_nodes:
    if node >= 1 and node <= m:
        pos_nodes.append(node)
    elif node >= m+1 and node <= m+n:
        neg_nodes.append(node - m)

for node in pos_nodes:
    print(node, end=' ')
print()

for node in neg_nodes:
    print(node, end=' ')
print()
print(max_profit)



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21410/
   。

#include <iostream>
#include <cstring>
#include <sstream>
#include <algorithm>

using namespace std;

const int N = 110, M = 5210, INF = 1e8;

int m, n, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

void dfs(int u)
{
    st[u] = true;
    for (int i = h[u]; ~i; i = ne[i])
        if (!st[e[i]] && f[i])
            dfs(e[i]);
}

int main()
{
    scanf("%d%d", &m, &n);
    S = 0, T = m + n + 1;
    memset(h, -1, sizeof h);
    getchar();  // 过滤掉第一行最后的回程

    int tot = 0;
    for (int i = 1; i <= m; i ++ )
    {
        int w, id;
        string line;
        getline(cin, line);
        stringstream ssin(line);
        ssin >> w;
        add(S, i, w);
        while (ssin >> id) add(i, m + id, INF);
        tot += w;
    }
    for (int i = 1; i <= n; i ++ )
    {
        int p;
        cin >> p;
        add(m + i, T, p);
    }

    int res = dinic();
    dfs(S);

    for (int i = 1; i <= m; i ++ )
        if (st[i]) printf("%d ", i);
    puts("");
    for (int i = m + 1; i <= m + n; i ++ )
        if (st[i]) printf("%d ", i - m);
    puts("");
    printf("%d\n", tot - res);
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/447945/
   。

AcWing 2199. 骑士共存问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-26 14:36:31 ,  阅读 19

0



'''
抽象成一个二分图放棋子问题，能放如果一个位置能够放棋子，其相邻8个位置就不能再放棋子，这个位置和
相邻的8个位置之间连二分图的边，可以明显看出边只可能在颜色不同的两个端点之间，因此模型就是一个
二分图找最大权独立点集中的点权和，每一个点的权值为1，用最大流算法求解即可
'''


from typing import List
from collections import deque

import sys


class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1), (form2, to2, weight2), ......]
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 返回整个图的最大流和每条边的流量以及容量，(max_flow, [(from1, to1, flow1, weight1), (from1, to1, flow1, weight1), ......])
    def getMaxFlow(self):
        e = [-1] * (self.max_edge_num * 2 + 1)  # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)  # f[idx]表示编号为idx的残量图边的流量
        ne = [-1] * (self.max_edge_num * 2 + 1)  # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)  # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        dis = [-1] * (self.max_node_num + 1)  # dis[a]表示点a到源点的距离，用于记录分层图信息
        cur = [-1] * (self.max_node_num + 1)  # cur[a]表示节点a在dfs搜索中第一次开始搜索的边的下标，也称当前弧，用于优化dfs速度

        idx = 0
        for a, b, w in self.edges:
            e[idx], f[idx], ne[idx], h[a] = b, w, h[a], idx
            idx += 1
            e[idx], f[idx], ne[idx], h[b] = a, 0, h[b], idx
            idx += 1

        # bfs搜索有没有增广路
        def bfs() -> bool:
            for i in range(self.max_node_num + 1):
                dis[i] = -1

            que = deque()
            que.append(self.source_node)
            dis[self.source_node] = 0
            cur[self.source_node] = h[self.source_node]

            while len(que) > 0:
                cur_node = que.popleft()
                idx = h[cur_node]
                while idx != -1:
                    next_node = e[idx]
                    if dis[next_node] == -1 and f[idx] > 0:
                        dis[next_node] = dis[cur_node] + 1
                        cur[next_node] = h[next_node]
                        if next_node == self.end_node:
                            return True

                        que.append(next_node)

                    idx = ne[idx]

            return False

        # dfs查找增广路, 返回当前残量图上node节点能流入汇点的不超过limit的最大流量有多事少
        def dfs(node, limit) -> int:
            if node == self.end_node:
                return limit

            flow = 0
            idx = cur[node]  # 从节点的当前弧开始搜索下一个点
            while idx != -1 and flow < limit:
                # 当前弧优化，记录每一个节点最后走的一条边，只要limit还没有减成0，已经搜过的边的终点
                # 能够汇入汇点的流量就已经全部用完了，另外一条路径到同一个点时候没必要重复搜索已经不会
                # 再提供流量贡献的邻接点
                cur[node] = idx

                next_node = e[idx]
                if dis[next_node] == dis[node] + 1 and f[idx] > 0:
                    t = dfs(next_node, min(f[idx], limit - flow))
                    if t == 0:
                        # 已经无法提供流量的废点闪删除掉，不再参与搜索
                        dis[next_node] = -1

                    # 更新残量图边的流量
                    f[idx], f[idx ^ 1], flow = f[idx] - t, f[idx ^ 1] + t, flow + t

                idx = ne[idx]

            return flow

        max_flow = 0
        while bfs():
            # 只要还有增广路，就dfs把增广路都找到，把增广路上的流量加到可行流上
            max_flow += dfs(self.source_node, 0x7fffffff)
        return max_flow




n, m = map(int, input().split())
grid = [[0] * (n+1) for _ in range(n+1)]
total_nodes = n*n


for _ in range(m):
    s = sys.stdin.readline().strip()
    a, b = map(int, s.split())
    grid[a][b] = 1
    total_nodes -= 1


def node2idx(i, j):
    return 1 + (i-1) * n + (j-1)


start_flag = 1
S, T = n *n + 1, n*n + 2
edges = []
for i in range(1, n+1):
    start_flag = 1 - start_flag
    flag = start_flag
    for j in range(1, n+1):

        if grid[i][j] == 1:
            flag = 1 - flag
            continue

        node = node2idx(i, j)

        if flag == 0:
            edges.append((S, node, 1))

            for ii, jj in [(i-1, j-2), (i+1, j-2), (i-1, j+2), (i+1, j+2), (i-2, j-1), (i+2, j-1), (i-2, j+1), (i+2, j+1)]:
                if ii >= 1 and ii <= n and jj >= 1 and jj <= n:
                    if grid[ii][jj] == 1:
                        continue

                    new_node = node2idx(ii, jj)
                    edges.append((node, new_node, 0x7fffffff))
        else:
            edges.append((node, T, 1))

        flag = 1 - flag

print(total_nodes - FortdFulkerson(edges, S, T, n*n+2, len(edges)).getMaxFlow())




作者：皓首不倦
链接：https://www.acwing.com/solution/content/21415/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 40010, M = 400010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
bool g[210][210];

int get(int x, int y)
{
    return (x - 1) * n + y;
}

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n * n + 1;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int x, y;
        scanf("%d%d", &x, &y);
        g[x][y] = true;
    }

    int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};
    int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
        {
            if (g[i][j]) continue;
            if (i + j & 1)
            {
                add(S, get(i, j), 1);
                for (int k = 0; k < 8; k ++ )
                {
                    int x = i + dx[k], y = j + dy[k];
                    if (x >= 1 && x <= n && y >= 1 && y <= n && !g[x][y])
                        add(get(i, j), get(x, y), INF);
                }
            }
            else add(get(i, j), T, 1);
            tot ++ ;
        }

    printf("%d\n", tot - dinic());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/448005/
   。

AcWing 2174. 费用流    原题链接    中等
作者：    皓首不倦 ,  2020-09-26 21:03:48 ,  阅读 32

1



'''
费用流算法实现，增广路查找用SPFA实现
'''


from collections import deque

class SPFA:

    # start_node 为起始点，edges是边的三元组(节点1， 节点2， 边权重) is_directed表示是否是有向图
    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))


    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1

        # 进行V次迭代，第V次检查是否是无解情况
        iter_times = 0
        while iter_times < self.max_node_num:
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            iter_times += 1

            if iter_times == self.max_node_num:
                if update_flag:
                    return False

            if not update_flag:
                break

        return True


class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num


    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if not algo.getMinPathLen(pre, f) if min_cost else algo.getMaxPathLen(pre, f):
                break

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]


n, m, S, T = map(int, input().split())
edges = []
for _ in range(m):
    a, b, w, c = map(int, input().split())
    edges.append((a, b, w, c))

ans = FortdFulkerson(edges, S, T, n, len(edges)).getCostFlow()[:-1]
print(ans[0], ans[1])



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21432/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 5010, M = 100010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, 0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }

    return incf[T] > 0;
}

void EK(int& flow, int& cost)
{
    flow = cost = 0;
    while (spfa())
    {
        int t = incf[T];
        flow += t, cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &S, &T);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        add(a, b, c, d);
    }

    int flow, cost;
    EK(flow, cost);
    printf("%d %d\n", flow, cost);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/457817/
   。
cWing 2192. 运输问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-26 22:23:29 ,  阅读 24

1





'''
抽象成费用流模型求解，求最大费用最大流和最小费用最大流的费用
'''


from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FortdFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]


n, m = map(int, input().split())
S, T = n + m + 1, n + m + 2

arr = list(map(int, input().split()))
edges = []
for i, val in enumerate(arr):
    edges.append((S, i+1, arr[i], 0))

arr = list(map(int, input().split()))
for i, val in enumerate(arr):
    edges.append((i+1+n, T, arr[i], 0))

for i in range(1, n+1):
    arr = list(map(int, input().split()))
    for j in range(1, m+1):
        cost = arr[j-1]
        edges.append((i, j + n, 0x7fffffff, cost))

algo = FortdFulkerson(edges, S, T, m+n+2, len(edges))
print(algo.getCostFlow()[1])

algo = FortdFulkerson(edges, S, T, m+n+2, len(edges))
print(algo.getCostFlow(min_cost=False)[1])




作者：皓首不倦
链接：https://www.acwing.com/solution/content/21439/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 160, M = 5150 * 2 + 10, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, 0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(incf[t], f[i]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    scanf("%d%d", &m, &n);
    S = 0, T = m + n + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= m; i ++ )
    {
        int a;
        scanf("%d", &a);
        add(S, i, a, 0);
    }
    for (int i = 1; i <= n; i ++ )
    {
        int b;
        scanf("%d", &b);
        add(m + i, T, b, 0);
    }
    for (int i = 1; i <= m; i ++ )
        for (int j = 1; j <= n; j ++ )
        {
            int c;
            scanf("%d", &c);
            add(i, m + j, INF, c);
        }

    printf("%d\n", EK());

    for (int i = 0; i < idx; i += 2)
    {
        f[i] += f[i ^ 1], f[i ^ 1] = 0;
        w[i] = -w[i], w[i ^ 1] = -w[i ^ 1];
    }
    printf("%d\n", -EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/457863/
   。
AcWing 2194. 负载平衡问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-26 23:40:35 ,  阅读 15

0







from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]




n = int(input())
arr = []
while len(arr) < n:
    s = input()
    arr.extend(list(map(int, s.split())))

mean = sum(arr) // len(arr)

S, T = n+1, n+2
edges = []
for i, val in enumerate(arr):
    node = i+1
    if val >= mean:
        edges.append((S, node, val-mean, 0))
    else:
        edges.append((node, T, mean-val, 0))

    left = node - 1 if node != 1 else n
    right = node + 1 if node != n else 1

    edges.append((node, left, 0x7fffffff, 1))
    edges.append((node, right, 0x7fffffff, 1))

print(FordFulkerson(edges, S, T, n+2, len(edges)).getCostFlow()[1])




作者：皓首不倦
链接：https://www.acwing.com/solution/content/21447/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 610, INF = 1e8;

int n, S, T;
int s[N];
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, 0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    scanf("%d", &n);
    S = 0, T = n + 1;
    memset(h, -1, sizeof h);

    int tot = 0;
    for (int i = 1; i <= n; i ++ )
    {
        scanf("%d", &s[i]);
        tot += s[i];
        add(i, i < n ? i + 1 : 1, INF, 1);
        add(i, i > 1 ? i - 1 : n, INF, 1);
    }

    tot /= n;
    for (int i = 1; i <= n; i ++ )
        if (tot < s[i])
            add(S, i, s[i] - tot, 0);
        else if (tot > s[i])
            add(i, T, tot - s[i], 0);

    printf("%d\n", EK());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/457906/
   。
AcWing 2193. 分配问题 最大流方式求二分图最大匹配的最小费用和最大费用    原题链接    困难
作者：    皓首不倦 ,  2020-09-27 16:05:20 ,  阅读 20

0



'''
用最大流算法求二分图的最大花费最大匹配和最小花费最大匹配
工作和员工分别当做二分图中的Par1和Part2, 两个部分之间
节点的边的容量是1，费用是员工做工作的收益值，按照二分图
匹配对应的最大流模型建图即可
'''

from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1

        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]




n = int(input())
edges = []
for i in range(1, n+1):
    arr = list(map(int, input().split()))
    for j in range(1, n+1):
        edges.append((i, j+n, 1, arr[j-1]))

S, T = 2*n+1, 2*n+2
for node in range(1, n+1):
    edges.append((S, node, 1, 0))
for node in range(n+1, 2*n+1):
    edges.append((node, T, 1, 0))

algo = FordFulkerson(edges, S, T, 2*n+2, len(edges))
print(algo.getCostFlow()[1])
print(algo.getCostFlow(min_cost=False)[1])



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21473/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 5210, INF = 1e8;

int n, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, 0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    scanf("%d", &n);
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ )
    {
        add(S, i, 1, 0);
        add(n + i, T, 1, 0);
    }
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
        {
            int c;
            scanf("%d", &c);
            add(i, n + j, 1, c);
        }

    printf("%d\n", EK());

    for (int i = 0; i < idx; i += 2)
    {
        f[i] += f[i ^ 1], f[i ^ 1] = 0;
        w[i] = -w[i], w[i ^ 1] = -w[i ^ 1];
    }
    printf("%d\n", -EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/457930/
   。
AcWing 2191. 数字梯形问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-27 20:11:05 ,  阅读 21

0







from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]



m, n = map(int, input().split())
total_nodes = (m + m + (n-1)) * n // 2
S, T = total_nodes*2 + 1, total_nodes*2 + 2

grid = []
for i in range(n):
    grid.append(list(map(int, input().split())))


def pos2idx(i, j):
    return (m+m+(i-1))*i // 2 + (j+1)



# 第一问
edges = []
# 内部边
for node in range(1, total_nodes+1):
    edges.append((node, node+total_nodes, 1, 0))

# 源点到第一层节点的边
for j in range(m):
    node = pos2idx(0, j)
    edges.append((S, node, 1, grid[0][j]))

# 每一层和下一层的边
for i in range(n-1):
    for j in range(len(grid[i])):
        node = pos2idx(i, j) + total_nodes

        new_node = pos2idx(i+1, j)
        edges.append((node, new_node, 1, grid[i+1][j]))

        new_node = pos2idx(i+1, j+1)
        edges.append((node, new_node, 1, grid[i+1][j+1]))

# 最后一层和汇点之间的边
for j in range(len(grid[n-1])):
    node = pos2idx(n-1, j) + total_nodes
    edges.append((node, T, 0x7fffffff, 0))

ans = FordFulkerson(edges, S, T, 2*total_nodes+2, len(edges)).getCostFlow(min_cost=False)
print(ans[1])



# 第二问
edges = []
# 内部边
for node in range(1, total_nodes+1):
    edges.append((node, node+total_nodes, 0x7fffffff, 0))

# 源点到第一层节点的边
for j in range(m):
    node = pos2idx(0, j)
    edges.append((S, node, 1, grid[0][j]))

# 每一层和下一层的边
for i in range(n-1):
    for j in range(len(grid[i])):
        node = pos2idx(i, j) + total_nodes

        new_node = pos2idx(i+1, j)
        edges.append((node, new_node, 1, grid[i+1][j]))

        new_node = pos2idx(i+1, j+1)
        edges.append((node, new_node, 1, grid[i+1][j+1]))

# 最后一层和汇点之间的边
for j in range(len(grid[n-1])):
    node = pos2idx(n-1, j) + total_nodes
    edges.append((node, T, 0x7fffffff, 0))

ans = FordFulkerson(edges, S, T, 2*total_nodes+2, len(edges)).getCostFlow(min_cost=False)
print(ans[1])


# 第三问
edges = []
# 内部边
for node in range(1, total_nodes+1):
    edges.append((node, node+total_nodes, 0x7fffffff, 0))

# 源点到第一层节点的边
for j in range(m):
    node = pos2idx(0, j)
    edges.append((S, node, 1, grid[0][j]))

# 每一层和下一层的边
for i in range(n-1):
    for j in range(len(grid[i])):
        node = pos2idx(i, j) + total_nodes

        new_node = pos2idx(i+1, j)
        edges.append((node, new_node, 0x7fffffff, grid[i+1][j]))

        new_node = pos2idx(i+1, j+1)
        edges.append((node, new_node, 0x7fffffff, grid[i+1][j+1]))

# 最后一层和汇点之间的边
for j in range(len(grid[n-1])):
    node = pos2idx(n-1, j) + total_nodes
    edges.append((node, T, 0x7fffffff, 0))

ans = FordFulkerson(edges, S, T, 2*total_nodes+2, len(edges)).getCostFlow(min_cost=False)
print(ans[1])



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21482/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1200, M = 4000, INF = 1e8;

int m, n, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];
int id[40][40], cost[40][40];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, -0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] < d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    int cnt = 0;
    scanf("%d%d", &m, &n);
    S = ++ cnt;
    T = ++ cnt;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m + i - 1; j ++ )
        {
            scanf("%d", &cost[i][j]);
            id[i][j] = ++ cnt;
        }

    // 规则1
    memset(h, -1, sizeof h), idx = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m + i - 1; j ++ )
        {
            add(id[i][j] * 2, id[i][j] * 2 + 1, 1, cost[i][j]);
            if (i == 1) add(S, id[i][j] * 2, 1, 0);
            if (i == n) add(id[i][j] * 2 + 1, T, 1, 0);
            if (i < n)
            {
                add(id[i][j] * 2 + 1, id[i + 1][j] * 2, 1, 0);
                add(id[i][j] * 2 + 1, id[i + 1][j + 1] * 2, 1, 0);
            }
        }
    printf("%d\n", EK());

    // 规则2
    memset(h, -1, sizeof h), idx = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m + i - 1; j ++ )
        {
            add(id[i][j] * 2, id[i][j] * 2 + 1, INF, cost[i][j]);
            if (i == 1) add(S, id[i][j] * 2, 1, 0);
            if (i == n) add(id[i][j] * 2 + 1, T, INF, 0);
            if (i < n)
            {
                add(id[i][j] * 2 + 1, id[i + 1][j] * 2, 1, 0);
                add(id[i][j] * 2 + 1, id[i + 1][j + 1] * 2, 1, 0);
            }
        }
    printf("%d\n", EK());

    // 规则3
    memset(h, -1, sizeof h), idx = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m + i - 1; j ++ )
        {
            add(id[i][j] * 2, id[i][j] * 2 + 1, INF, cost[i][j]);
            if (i == 1) add(S, id[i][j] * 2, 1, 0);
            if (i == n) add(id[i][j] * 2 + 1, T, INF, 0);
            if (i < n)
            {
                add(id[i][j] * 2 + 1, id[i + 1][j] * 2, INF, 0);
                add(id[i][j] * 2 + 1, id[i + 1][j + 1] * 2, INF, 0);
            }
        }
    printf("%d\n", EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/457967/
   。
AcWing 382. K取方格数    原题链接    困难
作者：    皓首不倦 ,  2020-09-27 22:44:10 ,  阅读 22

0





from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]


n, k = map(int, input().split())
grid = []
for i in range(n):
    grid.append(list(map(int, input().split())))

def pos2idx(i, j):
    return i*n + j + 1

edges = []
S, T = n*n*2 + 1, n*n*2 + 2
edges.append((S, 1, k, 0))


for i in range(n):
    for j in range(n):
        node = pos2idx(i, j)
        # 内部边
        edges.append((node, node+n*n, 1, grid[i][j]))
        edges.append((node, node+n*n, 0x7fffffff, 0))


        for ii, jj in [(i+1, j), (i, j+1)]:
            if ii < n and jj < n:
                new_node = pos2idx(ii, jj)
                edges.append((node+n*n, new_node, 0x7fffffff, 0))

node = pos2idx(n-1,n-1)
edges.append((node+n*n, T, 0x7fffffff, 0))

ans = FordFulkerson(edges, S, T, n*n*2+2, len(edges)).getCostFlow(min_cost=False)
print(ans[1])




作者：皓首不倦
链接：https://www.acwing.com/solution/content/21495/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 5010, M = 20010, INF = 1e8;

int n, k, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

int get(int x, int y, int t)
{
    return (x * n + y) * 2 + t;
}

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, -0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] < d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(incf[t], f[i]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    scanf("%d%d", &n, &k);
    S = 2 * n * n, T = S + 1;
    memset(h, -1, sizeof h);
    add(S, get(0, 0, 0), k, 0);
    add(get(n - 1, n - 1, 1), T, k, 0);
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
        {
            int c;
            scanf("%d", &c);
            add(get(i, j, 0), get(i, j, 1), 1, c);
            add(get(i, j, 0), get(i, j, 1), INF, 0);
            if (i + 1 < n) add(get(i, j, 1), get(i + 1, j, 0), INF, 0);
            if (j + 1 < n) add(get(i, j, 1), get(i, j + 1, 0), INF, 0);
        }

    printf("%d\n", EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/458914/
   。

AcWing 2195. 深海机器人问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-28 11:16:09 ,  阅读 19

0



'''
所有机器人出发点当做源点，所有机器人的目的地当做汇点，整个模型是多源多汇最大费用最
大流模型，边的两个端点之间需要构造两条边，一条边容量是1，费用是边的费用，一条边容量
是正无穷，费用是0，用于约束每一条边的费用只被一个流量使用一次
'''

from collections import deque

class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]

a, b = map(int, input().split())
p, q = map(int, input().split())
p, q = p+1, q+1
S, T = p*q + 1, p*q + 2

def pos2idx(i, j):
    return i * q + j + 1

edges = []
for i in range(p):
    arr = list(map(int, input().split()))
    for j in range(q-1):
        node, new_node = pos2idx(i, j), pos2idx(i, j+1)
        edges.append((node, new_node, 1, arr[j]))
        edges.append((node, new_node, 0x7fffffff, 0))

for i in range(q):
    arr = list(map(int, input().split()))
    for j in range(p-1):
        node, new_node = pos2idx(j, i), pos2idx(j+1, i)
        edges.append((node, new_node, 1, arr[j]))
        edges.append((node, new_node, 0x7fffffff, 0))

for _ in range(a):
    w, i, j= map(int, input().split())
    edges.append((S, pos2idx(i, j), w, 0))

for _ in range(b):
    w, i, j = map(int, input().split())
    edges.append((pos2idx(i, j), T, w, 0))

print(FordFulkerson(edges, S, T, p*q+2, len(edges)).getCostFlow(min_cost=False)[1])



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21509/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 260, M = 2000, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

int get(int x, int y)
{
    return x * (m + 1) + y;
}

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, -0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] < d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    int A, B;
    scanf("%d%d%d%d", &A, &B, &n, &m);
    S = (n + 1) * (m + 1), T = S + 1;
    memset(h, -1, sizeof h);
    for (int i = 0; i <= n; i ++ )
        for (int j = 0; j < m; j ++ )
        {
            int c;
            scanf("%d", &c);
            add(get(i, j), get(i, j + 1), 1, c);
            add(get(i, j), get(i, j + 1), INF, 0);
        }
    for (int i = 0; i <= m; i ++ )
        for (int j = 0; j < n; j ++ )
        {
            int c;
            scanf("%d", &c);
            add(get(j, i), get(j + 1, i), 1, c);
            add(get(j, i), get(j + 1, i), INF, 0);
        }
    while (A -- )
    {
        int k, x, y;
        scanf("%d%d%d", &k, &x, &y);
        add(S, get(x, y), k, 0);
    }
    while (B -- )
    {
        int r, x, y;
        scanf("%d%d%d", &r, &x, &y);
        add(get(x, y), T, r, 0);
    }

    printf("%d\n", EK());

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/458952/
   。

AcWing 2184. 餐巾计划问题    原题链接    困难
作者：    皓首不倦 ,  2020-09-28 13:47:53 ,  阅读 20

0





from collections import deque
class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]

N, p, m, f, n, s = map(int, input().split())
r = [0] * (N+1)
for i in range(N):
    r[i+1] = int(input())

S, T = N+N+1, N+N+2
edges = []
for node in range(1, N+1):
    edges.append((S, node, 0x7fffffff, p))
    if node-m >= 1:
        edges.append((node-m+N, node, 0x7fffffff, f))
    if node-n >= 1:
        edges.append((node-n+N, node, 0x7fffffff, s))

    edges.append((node, T, r[node], 0))

    if node + 1 <= N:
        edges.append((node+N, node+1+N, 0x7fffffff, 0))
    edges.append((S, node+N, r[node], 0))

print(FordFulkerson(edges, S, T, 2*N+2, len(edges)).getCostFlow()[1])



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21514/


   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1610, M = 10000, INF = 1e8;

int n, p, x, xp, y, yp, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, 0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    scanf("%d%d%d%d%d%d", &n, &p, &x, &xp, &y, &yp);
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ )
    {
        int r;
        scanf("%d", &r);
        add(S, i, r, 0);
        add(n + i, T, r, 0);
        add(S, n + i, INF, p);
        if (i < n) add(i, i + 1, INF, 0);
        if (i + x <= n) add(i, n + i + x, INF, xp);
        if (i + y <= n) add(i, n + i + y, INF, yp);
    }
    printf("%d\n", EK());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/459012/
   。

AcWing 969. 志愿者招募    原题链接    困难
作者：    皓首不倦 ,  2020-09-28 16:16:41 ,  阅读 31

0





from collections import deque
class SPFA:

    # 包含节点为1, 2, 3, 4, ..... max_node_num
    def __init__(self, start_node, edges, max_node_num):
        self.edges = edges[::]
        self.start_node = start_node
        self.max_node_num = max_node_num
        self.link = {}
        for a, b, w, idx in edges:
            if a not in self.link:
                self.link[a] = []
            self.link[a].append((b, w, idx))

    # 获取最短路径长度的列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMinPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=True)

    # 获取最长路径长度列表[(节点1，长度1), (节点2, 长度2) .....]
    def getMaxPathLen(self, pre, f):
        return self.getInfo(pre, f, min_path=False)

    # min_path表示求的是最短路径还是最长路径
    def getInfo(self, pre, f, min_path = True):
        link = self.link
        dis = [0x7fffffff] * (self.max_node_num+1) if min_path else [-0x7fffffff] * (self.max_node_num+1)
        dis[self.start_node] = 0

        updated_nodes = deque()
        updated_nodes.append(self.start_node)
        in_que = [0] * (self.max_node_num + 1)
        in_que[self.start_node] = 1


        for _ in range(self.max_node_num-1):
            update_flag = False

            # 利用上一轮迭代距离变小的点进行松弛操作
            node_num = len(updated_nodes)
            for _ in range(node_num):
                a = updated_nodes.popleft()
                in_que[a] = 0
                if a not in link:
                    continue

                for b, w, edge_idx in link[a]:
                    if f[edge_idx] == 0:
                        continue

                    if dis[a] == 0x7fffffff:
                        if w == -0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = 0x7fffffff

                    elif dis[a] == -0x7fffffff:
                        if w == 0x7fffffff:
                            new_dis = 0
                        else:
                            new_dis = -0x7fffffff
                    else:
                        new_dis = dis[a] + w


                    if (min_path == True and new_dis < dis[b]) or (min_path == False and new_dis > dis[b]):
                        dis[b] = new_dis
                        pre[b] = (a, edge_idx)
                        update_flag = True

                        if in_que[b] == 0:
                            in_que[b] = 1
                            updated_nodes.append(b)

            if not update_flag:
                break

        return None


class FordFulkerson:
    # 输入图中所有边列表[(from1, to1, weight1, cost1), (form2, to2, weight2, cost1), ......]
    # weight是边的容量，cost是边的费用
    # 边可以有重边和自环边
    # souece_node 和 end_node 分别为源点和汇点
    # 所有节点从1开始连续编号, max_node_num是最大节点数，max_edge_nums是最大边数
    def __init__(self, edges, source_node, end_node, max_node_num, max_edge_num):
        self.edges = edges[::]
        self.source_node = source_node
        self.end_node = end_node
        self.max_edge_num = max_edge_num
        self.max_node_num = max_node_num

    # 费用流计算函数，min_cost为True时候获取最小费用最大流，反之获取最大费用最大流
    # 返回(最大流数值，费用值，[(from1, to1, flow1, capacity1, cost1), (from2, to2, flow2, capacity2, cost2) ......])
    # 流量方案以类表方式返回，五元组依次是边起点，边终点，边上走过的流量，原边容量，原边费用
    def getCostFlow(self, min_cost = True):
        e = [-1] * (self.max_edge_num * 2 + 1)      # e[idx]表示编号为idx残量图边的终点, idx//2 就是残量图边对应的原图边的编号
        f = [-1] * (self.max_edge_num * 2 + 1)      # f[idx]表示编号为idx的残量图边的流量
        c = [-1] * (self.max_edge_num * 2 + 1)      # c[idx]表示编号为idx的残量图的边的费用值
        ne = [-1] * (self.max_edge_num * 2 + 1)     # ne[idx]表示根编号为idx的边同一个起点的下一条边的编号
        h = [-1] * (self.max_node_num + 1)          # h[a]表示节点a为起点的所有边的链表头对应的边的编号
        orig_flow = [0] * (self.max_edge_num + 1)   # 原图中有向边的流量

        # 构建残量图
        idx = 0
        for a, b, w, cost in self.edges:
            e[idx], f[idx], c[idx], ne[idx], h[a] = b, w, cost, h[a], idx
            idx += 1
            e[idx], f[idx], c[idx], ne[idx], h[b] = a, 0, -cost, h[b], idx
            idx += 1

        max_flow_val, cost_val = 0, 0
        e1 = [(a, b, c, idx * 2) for idx, (a, b, _, c) in enumerate(self.edges)]
        e2 = [(b, a, -c, idx * 2 + 1) for idx, (a, b, _, c) in enumerate(self.edges)]
        e = e1 + e2
        algo = SPFA(self.source_node, e, self.max_node_num)

        while True:
            pre = [(None, None)] * (self.max_node_num + 1)
            if min_cost:
                algo.getMinPathLen(pre, f)
            else:
                algo.getMaxPathLen(pre, f)

            if pre[self.end_node][0] is None:
                break

            min_w = 0x7fffffff
            path_len = 0
            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    min_w = min(min_w, f[edge_idx])
                    path_len += c[edge_idx]
                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

            max_flow_val += min_w
            cost_val += path_len * min_w  # 累加费用

            cur, edge_idx, next = self.end_node, 0, None
            while cur is not None:
                if next:
                    f[edge_idx], f[edge_idx ^ 1] = f[edge_idx] - min_w, f[edge_idx ^ 1] + min_w

                    # 更新原图边的流量
                    if idx & 1:
                        orig_flow[edge_idx >> 1] -= min_w
                    else:
                        orig_flow[edge_idx >> 1] += min_w

                cur, edge_idx, next = pre[cur][0], pre[cur][1], cur

        return max_flow_val, cost_val, [(self.edges[i][0], self.edges[i][1], orig_flow[i], self.edges[i][2], self.edges[i][3]) for i in range(len(self.edges))]


N, M = map(int, input().split())
lower_bound = [0] + list(map(int, input().split()))

e = [] # (每条边是(起点，终点，容量下界，容量上界, 费用))
for node in range(1, N+1):
    e.append((node, node+1, lower_bound[node], 0x7fffffff, 0))

for i in range(M):
    a, b, c = map(int, input().split())
    e.append((b+1, a, 0, 0x7fffffff, c))

sub = [0] * (N+2)
for a, b, l, u, c in e:
    sub[a] -= l
    sub[b] += l

S, T = N+2, N+3

edges = [(a, b, u-l, c) for a, b, l, u, c in e]
for node in range(1, N+2):
    if sub[node] > 0:
        edges.append((S, node, sub[node], 0))
    elif sub[node] < 0:
        edges.append((node, T, -sub[node], 0))

print(FordFulkerson(edges, S, T, N+3, len(edges)).getCostFlow()[1])


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21524/
   。

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010, M = 24010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int q[N], d[N], pre[N], incf[N];
bool st[N];

void add(int a, int b, int c, int d)
{
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
}

bool spfa()
{
    int hh = 0, tt = 1;
    memset(d, 0x3f, sizeof d);
    memset(incf, 0, sizeof incf);
    q[0] = S, d[S] = 0, incf[S] = INF;
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (f[i] && d[ver] > d[t] + w[i])
            {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver])
                {
                    q[tt ++ ] = ver;
                    if (tt == N) tt = 0;
                    st[ver] = true;
                }
            }
        }
    }
    return incf[T] > 0;
}

int EK()
{
    int cost = 0;
    while (spfa())
    {
        int t = incf[T];
        cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1])
        {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
    return cost;
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + 2;
    memset(h, -1, sizeof h);
    int last = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int cur;
        scanf("%d", &cur);
        if (last > cur) add(S, i, last - cur, 0);
        else if (last < cur) add(i, T, cur - last, 0);
        add(i, i + 1, INF - cur, 0);
        last = cur;
    }
    add(S, n + 1, last, 0);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(b + 1, a, INF, c);
    }

    printf("%d\n", EK());
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/459075/
   。

文化课 + 竞赛双废物又来水题解了。

首先，对于题干中的人，很像网络流中的流量，但是他有一个每天人数的下限，我从网上借鉴（chaoxi）到了两种思路：

把下界限制转化为一条边的流量下界，这样就是最小费用上下界最大流。
加入几个新值，其条件正好为 ≥0≥0，将其当做一条流量，这样不等式就变成了等式，我们可以利用流量守恒，用点的流满 ⇔⇔ 等式成立，这样就变成了一个最小费用最大流，去掉了上下界的影响。
其实这两种思路本质好像是一致的…

思路一
即 yy 总视频的解法，考虑到人的工作时间是一段区间，不妨差分考虑，先让 ii 的人无条件免费顺延到 i+1i+1 的边，然后在 SS 和 TT 人为规定加入/去除即可，这样一类工作者只会设计常数的点边，复杂度正常。

那么建立网络 GG：

对于一天 ii，让 ii 点向 i+1i+1 点连边。流量下界是 AiAi、上界是正无穷，费用是 00，这条边的流量意味着第 ii 天的工作人数，
对于一类志愿者 jj，让 Tj+1Tj+1 向 SjSj 连一条容量无界限，费用是 CiCi 的边，这条边可以自由活动，意味着自由安排是志愿者。
这样，每个志愿者相当于在流网络的一单位的流量流过了一个环，这个问题变成了最小费用无源汇上下界可行流，我们都知道可行流的可行判定经过转化就是跑到最大流，所以转化完后用最小费用最大流就行了。

时间复杂度
O(n2m)O(n2m) 复杂度真棒

Code
这题 Acwing 咋这么卡常啊

#include <iostream>
#include <cstdio>
#include <cstring>
#define rint register int
typedef long long LL;

using namespace std;

const int N = 1005, M = (N * 2 + 10000) * 2, INF = 0x3f3f3f3f;

int n, m, a[N], incf[N], d[N], q[N], pre[N]; 
int head[N], numE = 1, S, T;
bool vis[N];
LL ans;
struct E{
    int next, v, w, c;
} e[M];

void inline add(int u, int v, int w, int c) {
    e[++numE] = (E) { head[u], v, w, c };
    head[u] = numE;
    e[++numE] = (E) { head[v], u, 0, -c };
    head[v] = numE;
}

bool inline spfa() {
    memset(d, 0x3f, sizeof d);
    rint hh = 0, tt = 1;
    d[S] = 0, q[0] = S, incf[S] = INF;
    while (hh != tt) {
        rint u = q[hh++]; vis[u] = false;
        if (hh == N) hh = 0;
        for (rint i = head[u]; i; i = e[i].next) {
            rint v = e[i].v;
            if (d[u] + e[i].c < d[v] && e[i].w) {
                d[v] = d[u] + e[i].c, pre[v] = i, incf[v] = min(incf[u], e[i].w);
                if (!vis[v]) {
                    vis[v] = true, q[tt++] = v;
                    if (tt == N) tt = 0;
                }
            }
        }
    }
    return d[T] != INF;
}

void inline update() {
    int x = T;
    while (x != S) {
        int i = pre[x];
        e[i].w -= incf[T], e[i ^ 1].w += incf[T]; 
        x = e[i ^ 1].v;
    }
    ans += (LL)d[T] * incf[T];
}

int main() {
    scanf("%d%d", &n, &m); 
    S = n + 2, T = n + 3;
    for (rint i = 1, A; i <= n; i++) {
        scanf("%d", &A);
        add(i, i + 1, INF, 0);
        a[i] -= A, a[i + 1] += A;
    }
    for (rint i = 1, s, t, c; i <= m; i++) {
        scanf("%d%d%d", &s, &t, &c);
        add(t + 1, s, INF, c);
    }
    for (rint i = 1; i <= n + 1; i++) {
        if (a[i] > 0) add(S, i, a[i], 0);
        else if (a[i] < 0) add(i, T, -a[i], 0);
    }
    while (spfa()) update();
    printf("%lld\n", ans);
    return 0;
}
思路二
设一些新的变量：

Bi(Bi≥0)Bi(Bi≥0)，表示第 ii 天实际招了 Ai+BiAi+Bi 人。

Di(Di≥0)Di(Di≥0)，表示实际上第 ii 类志愿者招了 DiDi 类人

这样我们就可以列出 nn 个等式，对于第 ii 个等式（针对第 ii 天的匹配情况）

Ai+Bi=∑Sj≤i≤TjDj
Ai+Bi=∑Sj≤i≤TjDj
但是为了让每个变量在流网络中、在每个等式中都相等，所以我们得让每个变量至多出现在两个式子中，（如果出现在一个式子，就可以将其到源汇点的费用改了，这样就是费用对应上了，如果两个式子，可以从本该连向汇点的边直接连向本该从源点出的边，这样费用对应。这里本人实力还是非常菜，很可能讲了一些玄学的东西，求大佬们轻喷。）

由于每个 jj 影响的 ii 是连续的一段，所以我们可以将式子前后加入两个 0=00=0，然后将式子差分（这是一步等价变换）这样每个 Dj,BiDj,Bi 都恰好会出现在两个式子之中。

对于第 ii 个等式而言，差分后的式子：

−Ai−1−Bi−1+Ai+Bi=−∑i−1=TjDj+∑i=SjDj
−Ai−1−Bi−1+Ai+Bi=−∑i−1=TjDj+∑i=SjDj
我们把式子移项，让每一项都是正的：
Ai+Bi+∑i−1=TjDj=Ai−1+Bi−1+∑i=SjDj
Ai+Bi+∑i−1=TjDj=Ai−1+Bi−1+∑i=SjDj
这样，我们可以把等式看作一个点的流量守恒等式，等式左右两侧分别是流入该点/流出改点的流量，我们建立流网络：

对于常量 AA，在左侧则连一条自虚拟源点出发，到 ii 点，流量为 AiAi，无费用的边，右侧连到汇点，即对称的。
对于变量 BB，从 BiBi 所在右侧等式的点向 BiBi 所在左侧的点，即 ii 连向 i−1i−1，这条边流量无限，意味着自由选择的 BB，而这条边 + 流量守恒保证了 BiBi 在两个式子中不变
对于变量 DD 同理，即 SjSj 连向 Tj+1Tj+1，流量无限，费用为 CjCj 的边。
这样，在流网络跑到的最大流 = 从 SS 出发所有容量（满足常量的强行限制） ⇔⇔ 差分等式成立 ⇔⇔ 原始等式成立 ⇔⇔ 一个满足条件的方案

所以，原问题最小费用 ⇔⇔ 最小费用最大流

时间复杂度
O(n2m)O(n2m)
Code
#include <iostream>
#include <cstdio>
#include <cstring>
#define rint register int
typedef long long LL;

using namespace std;

const int N = 1005, M = (N * 3 + 10000) * 2, INF = 0x3f3f3f3f;

int n, m, a[N], incf[N], d[N], q[N], pre[N]; 
int head[N], numE = 1, S, T;
bool vis[N];
LL ans;
struct E{
    int next, v, w, c;
} e[M];

void inline add(int u, int v, int w, int c) {
    e[++numE] = (E) { head[u], v, w, c };
    head[u] = numE;
    e[++numE] = (E) { head[v], u, 0, -c };
    head[v] = numE;
}

bool inline spfa() {
    memset(d, 0x3f, sizeof d);
    rint hh = 0, tt = 1;
    d[S] = 0, q[0] = S, incf[S] = INF;
    while (hh != tt) {
        rint u = q[hh++]; vis[u] = false;
        if (hh == N) hh = 0;
        for (rint i = head[u]; i; i = e[i].next) {
            rint v = e[i].v;
            if (d[u] + e[i].c < d[v] && e[i].w) {
                d[v] = d[u] + e[i].c, pre[v] = i, incf[v] = min(incf[u], e[i].w);
                if (!vis[v]) {
                    vis[v] = true;
                    q[tt++] = v;
                    if (tt == N) tt = 0;
                }
            }
        }
    }
    return d[T] != INF;
}

void inline update() {
    int x = T;
    while (x != S) {
        int i = pre[x];
        e[i].w -= incf[T], e[i ^ 1].w += incf[T]; 
        x = e[i ^ 1].v;
    }
    ans += (LL)d[T] * incf[T];
}

int main() {
    scanf("%d%d", &n, &m); 
    S = n + 2, T = n + 3;
    for (rint i = 1, A; i <= n; i++) {
        scanf("%d", &A);
        add(S, i, A, 0), add(i + 1, T, A, 0);
        add(i + 1, i, INF, 0);
    }
    for (rint i = 1, s, t, c; i <= m; i++) {
        scanf("%d%d%d", &s, &t, &c);
        add(s, t + 1, INF, c);
    }
    while (spfa()) update();
    printf("%lld\n", ans);
    return 0;
}

作者：墨染空
链接：https://www.acwing.com/solution/content/14362/
   。

#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

const int N = 2000010, M = 2000010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], ts, stk[N], top;
int id[N], cnt;
bool ins[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ ts;
    stk[ ++ top] = u, ins[u] = true;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        } else if (ins[j]) low[u] = min(low[u], dfn[j]);
    }

    if (low[u] == dfn[u])
    {
        int y;
        cnt ++ ;
        do
        {
            y = stk[top -- ], ins[y] = false, id[y] = cnt;
        } while (y != u);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);

    while (m -- )
    {
        int i, a, j, b;
        scanf("%d%d%d%d", &i, &a, &j, &b);
        i --, j -- ;
        add(2 * i + !a, 2 * j + b);
        add(2 * j + !b, 2 * i + a);
    }

    for (int i = 0; i < n * 2; i ++ )
        if (!dfn[i])
            tarjan(i);

    for (int i = 0; i < n; i ++ )
        if (id[i * 2] == id[i * 2 + 1])
        {
            puts("IMPOSSIBLE");
            return 0;
        }

    puts("POSSIBLE");
    for (int i = 0; i < n; i ++ )
        if (id[i * 2] < id[i * 2 + 1]) printf("0 ");
        else printf("1 ");

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/468121/
   。

AcWing 371. 牧师约翰最忙碌的一天    原题链接    中等
作者：    whsstory ,  2020-01-12 22:34:37 ,  阅读 198

1


这题有点难度.
先假设这些婚礼都能办成,若推出矛盾则不能办成.
每个婚礼不是在开始时办就是在结束时办.所以把每个婚礼ii拆成两个点i,n+ii,n+i分别表示在开始时办和在结束时办.
如果某两个婚礼的时间有交集,那么他们会互相限制.我们可以枚举这两个婚礼,记为i,ji,j.
比如说,ii需要的时间和jj有重合,那么如果ii办,jj就不能办.而j,j+nj,j+n中又必须有一个办,也就是说, 如果ii办,j+nj+n必须办(同理可得其逆否命题如果jj办,i+ni+n必须办).

因此,这些限制关系和这n+nn+n个点构成了一个2-SAT模型.
跑一遍tarjan,如果存在矛盾(即i,i+ni,i+n在同一个强连通分量中)则不是所有婚礼都能办成.
接下来考虑如何输出一种方案.
tarjan算法求出的SCC编号满足拓扑序.
因此,直接比较scc[i],scc[n+i]scc[i],scc[n+i]即可得到该在ii办还是该在n+in+i办.
综上,问题在O(n2)O(n2)的时间内解决.

实现的时候有时间转化等细节需要注意.

/**********/
#define MAXN 2011
#define MAXM 1000011
struct Edge
{
    ll v,nxt;
}e[MAXM<<2|1];
ll cnt=0,last[MAXN];
void adde(ll u,ll v)
{
    e[++cnt].v=v;
    e[cnt].nxt=last[u],last[u]=cnt;
}

ll s[MAXN],t[MAXN],d[MAXN];
bool invaild(ll s1,ll t1,ll s2,ll t2)
{
    return t1>s2&&t2>s1;
}

ll dfn[MAXN],low[MAXN],cur=0,scc[MAXN],scnt;
ll stack[MAXN],top=0;
bool ins[MAXN];
void tarjan(ll u)
{
    dfn[u]=low[u]=++cur;
    stack[++top]=u;ins[u]=1;
    for(ll i=last[u];i;i=e[i].nxt)
    {
        ll v=e[i].v;
        if(!dfn[v])
        {
            tarjan(v);
            umin(low[u],low[v]);
        }
        else if(ins[v])umin(low[u],dfn[v]);
    }
    if(dfn[u]==low[u])
    {
        ++scnt;
        while(stack[top]!=u)
        {
            scc[stack[top]]=scnt;
            ins[stack[top]]=0;
            --top;
        }
        scc[stack[top--]]=scnt;
        ins[u]=0;
    }
}
int main()
{
    ll n=read();
    for(ll i=1;i<=n;++i)
    {
        s[i]=read()*60+read();
        t[i]=read()*60+read();
        d[i]=read();
    }
    for(ll i=1;i<=n;++i)
        for(ll j=1;j<=n;++j)
            if(i!=j)
            {
                if(invaild(s[i],s[i]+d[i],s[j],s[j]+d[j]))adde(i,j+n),adde(j,i+n);
                if(invaild(t[i]-d[i],t[i],s[j],s[j]+d[j]))adde(i+n,j+n),adde(j,i);
                if(invaild(s[i],s[i]+d[i],t[j]-d[j],t[j]))adde(i,j),adde(j+n,i+n);
                if(invaild(t[i]-d[i],t[i],t[j]-d[j],t[j]))adde(i+n,j),adde(j+n,i);
            }
    for(ll i=1;i<=n+n;++i)
        if(!dfn[i])tarjan(i);
    for(ll i=1;i<=n;++i)
        if(scc[i]==scc[i+n])
        {
            puts("NO");
            return 0;
        }
    puts("YES");
    for(ll i=1;i<=n;++i)
    {
        ll x=scc[i]>scc[i+n];
        if(!x)printf("%02d:%02d %02d:%02d\n",s[i]/60,s[i]%60,(s[i]+d[i])/60,(s[i]+d[i])%60);
        else printf("%02d:%02d %02d:%02d\n",(t[i]-d[i])/60,(t[i]-d[i])%60,t[i]/60,t[i]%60);
    }
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/7529/
   。

'''
当做一个2-SAT问题看待，
每一对情侣看做一个变量x(i) x(i)要么取0，要么取1，取1表示选择开始的区间做仪式，取0表示选择结束的区间
做仪式, x(i)不论取0还是取1, 情侣对应的开始区间和结束区间都会被选择一个，所以一组合法的x序列就对应了
一种合法的选择方式，是否合法需要验证是否会出现区间覆盖的矛盾

把所有x(i) 和 ~x(i)表示的区间都算出来，暴力枚举一遍所有发生了覆盖的区间，如果 A B发生覆盖
那么 A and B 不能成立，等价于 ~(A and B) = 1 要成立，等价于  ~A or ~B 成立，因此添加
一个2-SAT需要满足的命题 ~A or ~B, 构造一个约束

利用2-SAT模型计算x序列的合法解即可

'''




from typing import List, Tuple
import sys
sys.setrecursionlimit(999999)

class TWO_SAT:
    # max_node_num表示xi有多少个，所有命题应该是x(1), x(2), ...... x(max_node_num序列)
    # edges为边序列, i -> j 边表示 x(i) or x(j) 成立 (也表示x(j) or x(i)成立，两个是等价的)
    # 若i是负的，代表 非x(i)
    def __init__(self, edges, max_node_num):
        self.max_node_num = max_node_num
        self.edges = edges

    # 返回一组x向量的取值，[0, x(1), x(2), x(3), ...... x(max_node_num)]
    # 返回None代表无解
    def getSolution(self):
        e = []
        n = self.max_node_num
        for a, b in self.edges:
            aa = -a if a < 0 else a+n
            bb = -b+n if b < 0 else b
            e.append((aa, bb))

            aa = -a+n if a < 0 else a
            bb = -b if b < 0 else b+n
            e.append((bb, aa))

        max_node_num = 2*self.max_node_num

        link = [[] for _ in range(max_node_num + 1)]
        dfn = [0x7fffffff] * (max_node_num + 1)
        low = [0x7fffffff] * (max_node_num + 1)
        node2sccid = [0] * (max_node_num + 1)

        global_time = [0]
        for a, b in self.edges:
            aa = -a if a < 0 else a+n
            bb = -b+n if b < 0 else b
            link[aa].append(bb)

            aa = -a+n if a < 0 else a
            bb = -b if b < 0 else b+n
            link[bb].append(aa)

        stack = [0] * (max_node_num+1)
        stack_size = [0]

        visit = [0] * (max_node_num + 1)

        scc_id_cnt = [1]
        def dfs(cur):
            global_time[0] += 1
            dfn[cur], low[cur] = global_time[0], global_time[0]
            stack[stack_size[0]] = cur
            stack_size[0] += 1

            pos = stack_size[0] - 1

            for next in link[cur]:
                if visit[next] == 1:
                    continue

                if dfn[next] == 0x7fffffff:
                    dfs(next)
                    low[cur] = min(low[cur], low[next])
                else:
                    low[cur] = min(low[cur], dfn[next])

            if low[cur] == dfn[cur]:
                # dfn 和 low 相等时候，一直退栈退到cur出栈为止
                for node in stack[pos:stack_size[0]]:
                    node2sccid[node] = scc_id_cnt[0]
                    visit[node] = 1
                scc_id_cnt[0] += 1

                stack_size[0] = pos

        for node in range(1, max_node_num + 1):
            if len(link[node]) == 0:
                continue

            if dfn[node] == 0x7fffffff:
                dfs(node)

        x = [0] * (n+1)
        for node in range(1, n+1):
            if node2sccid[node] == node2sccid[node+n] and node2sccid[node] != 0:
                return None

            if node2sccid[node] < node2sccid[node+n]:
                x[node] = 1

        return x

def minute_val(s):
    a, b = map(int, s.split(':'))
    return a * 60 + b

def minute_val2str(val):
    return '{:02d}:{:02d}'.format(val // 60 , val % 60)


def is_overlap(s1, t1, s2, t2):
    return max(s1, s2) < min(t1, t2)

n = int(input())
ss = sys.stdin.readlines()

node2str = {}
node2pair = {}
edges = []
for i, s in enumerate(ss):
    node = i + 1

    part = s.split()
    start, end = map(minute_val, part[:2])
    period = int(part[2])

    node2str[node] = minute_val2str(start) + ' ' + minute_val2str(start + period)
    node2str[-node] = minute_val2str(end-period) + ' ' + minute_val2str(end)

    node2pair[node] = (start, start + period)
    node2pair[-node] = (end-period, end)


for a in range(-n, n+1):
    if a == 0:
        continue

    s1, t1 = node2pair[a]
    for b in range(a+1, n+1):
        if b == 0:
            continue

        s2, t2 = node2pair[b]
        if is_overlap(s1, t1, s2, t2):
            edges.append((-a, -b))

algo = TWO_SAT(edges, n)
ans = algo.getSolution()

if ans is not None:
    print('YES')
    for node in range(1, n+1):
        if ans[node] == 1:
            print(node2str[node])
        else:
            print(node2str[-node])
else:
    print('NO')

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21584/
   。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2010, M = 4000010;

int n;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], ts, stk[N], top;
int id[N], cnt;
bool ins[N];

struct Wedding
{
    int s, t, d;
}w[N];

bool is_overlap(int a, int b, int c, int d)
{
    return d > a && b > c;
}

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ ts;
    stk[ ++ top] = u, ins[u] = true;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        } else if (ins[j]) low[u] = min(low[u], dfn[j]);
    }
    if (dfn[u] == low[u])
    {
        int y;
        cnt ++ ;
        do
        {
            y = stk[top -- ], ins[y] = false, id[y] = cnt;
        }while (y != u);
    }
}

int main()
{
    scanf("%d", &n);
    memset(h, -1, sizeof h);
    for (int i = 0; i < n; i ++ )
    {
        int s0, s1, t0, t1, d;
        scanf("%d:%d %d:%d %d", &s0, &s1, &t0, &t1, &d);
        w[i] = {s0 * 60 + s1, t0 * 60 + t1, d};
    }

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < i; j ++ )
        {
            auto a = w[i], b = w[j];
            if (is_overlap(a.s, a.s + a.d, b.s, b.s + b.d)) add(i, j + n), add(j, i + n);
            if (is_overlap(a.s, a.s + a.d, b.t - b.d, b.t)) add(i, j), add(j + n, i + n);
            if (is_overlap(a.t - a.d, a.t, b.s, b.s + b.d)) add(i + n, j + n), add(j, i);
            if (is_overlap(a.t - a.d, a.t, b.t - b.d, b.t)) add(i + n, j), add(j + n, i);
        }

    for (int i = 0; i < n * 2; i ++ )
        if (!dfn[i])
            tarjan(i);

    for (int i = 0; i < n; i ++ )
        if (id[i] == id[i + n])
        {
            puts("NO");
            return 0;
        }

    puts("YES");
    for (int i = 0; i < n; i ++ )
    {
        auto a = w[i];
        int s = a.s, t = a.t, d = a.d;
        if (id[i] < id[i + n])
            printf("%02d:%02d %02d:%02d\n", s / 60, s % 60, (s + d) / 60, (s + d) % 60);
        else
            printf("%02d:%02d %02d:%02d\n", (t - d) / 60, (t - d) % 60, t / 60, t % 60);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/468153/
   。
AcWing 1032. 游戏    原题链接    困难
作者：    whsstory ,  2020-09-04 20:01:11 ,  阅读 61

3


NOI2017D2T1 游戏
有 nn 个变量，其中 dd 个变量有三种可能的取值，其余变量有两种可能的取值。

另有 mm 条限制关系，形如：若 xx 的值是 aa 那么 yy 的值必须是 bb

求一组可能的解，或说明无解。

n≤5×104,m≤105,d≤8n≤5×104,m≤105,d≤8

my sol
其实将题意化简到上面这样就很显然了。如果没有 d≤8d≤8 的限制，那么原问题是NP的。

但事实上大多数点都只有两种取值。

考虑 2d2d 枚举这 dd 个点的取值，一种是强制不取第三个值，另一种是取且仅取第三个值。之后就变成了 2SAT 问题，tarjan 求解即可。

复杂度 (2d×(n+m))O(2d×(n+m)) 在loj上最长点仅16ms，loj永远滴神！

PS:在2SAT中，若要强制 xx 只能取 xx 而不取 x′x′ ,令 x′x′ 向 xx 连边即可。

#define MAXN 200011
struct edge{int v,nxt;}e[MAXN<<1|1];
int cnt=0,last[MAXN];
void adde(int u,int v){e[++cnt].v=v,e[cnt].nxt=last[u],last[u]=cnt;}

int dfn[MAXN],low[MAXN],top=0,s[MAXN],scc[MAXN], cur=0,scnt=0;
bool ins[MAXN];
void tarjan(int u)
{
    dfn[u]=low[u]=++cur;
    s[++top]=u,ins[u]=1;
    for(int i=last[u];i;i=e[i].nxt)
    {
        int v=e[i].v;
        if(!dfn[v])tarjan(v),umin(low[u],low[v]);
        else if(ins[v])umin(low[u],dfn[v]);
    }
    if(dfn[u]==low[u])
    {
        ++scnt;
        while(s[top]!=u)scc[s[top]]=scnt,ins[s[top]]=0,--top;
        scc[s[top]]=scnt,ins[s[top]]=0,--top;
        // printf("SCC[%d]=%d\n",u,scnt);
    }
}
char a[MAXN];
struct tuple{int u,x,v,y;}ed[MAXN];
void clear(int n)
{
    cnt=cur=scnt=0;
    for(int i=1;i<=n+n;++i)last[i]=dfn[i]=low[i]=scc[i]=0;
}
void make_graph(int n,int m)
{
    for(int i=1;i<=m;++i)
    {
        int u=ed[i].u,x=ed[i].x,v=ed[i].v,y=ed[i].y;
        if(x==(a[u]-'a'))continue;
        if(y==(a[v]-'a')){adde(u+n*(x==(a[u]-'a'+1)%3),u+n*(x==(a[u]-'a'+2)%3));continue;}
        adde(u+n*(x==(a[u]-'a'+1)%3),v+n*(y==(a[v]-'a'+1)%3));
        adde(v+n*(y==(a[v]-'a'+2)%3),u+n*(x==(a[u]-'a'+2)%3));
    }
}
int pos[MAXN];
int main()
{
    // freopen("game2.in","r",stdin);
    int n=read(),d=read();d=0;
    scanf("%s",a+1);
    for(int i=1;i<=n;++i)
        if(a[i]=='x')pos[++d]=i;
    int m=read();
    for(int i=1;i<=m;++i)
    {
        ed[i].u=read(),ed[i].x=getchar()-'A';
        ed[i].v=read(),ed[i].y=getchar()-'A';
    }
    for(int s=0;s<(1<<d);++s)
    {
        clear(n);
        for(int i=1;i<=d;++i)
            if(s&(1<<(i-1)))a[pos[i]]='a',adde(n+pos[i],pos[i]);
            else a[pos[i]]='c';
        make_graph(n,m);
        for(int i=1;i<=n+n;++i)
            if(!dfn[i])tarjan(i);
        bool fail=0;
        for(int i=1;i<=n;++i)
            if(scc[i]==scc[n+i])fail=1;
        if(fail)continue;
        for(int i=1;i<=n;++i)
            if(scc[i]<scc[n+i])putchar((a[i]-'a'+2)%3+'A');
            else putchar((a[i]-'a'+1)%3+'A');
        return 0;
    }
    puts("-1");
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/20020/
   。


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 200010;

int n, d, m;
char s[N];
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], ts, stk[N], top;
int id[N], cnt;
bool ins[N];
int pos[10];

struct Op
{
    int x, y;
    char a, b;
}op[M];

int get(int x, char b, int t)
{
    char a = s[x] - 'a';
    b -= 'A';
    if (((a + 1) % 3 != b) ^ t) return x + n;
    return x;
}

char put(int x, int t)
{
    int y = s[x] - 'a';
    return 'A' + ((y + t) % 3);
}

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ ts;
    stk[ ++ top] = u, ins[u] = true;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        } else if (ins[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        int y;
        cnt ++ ;
        do
        {
            y = stk[top -- ], ins[y] = false, id[y] = cnt;
        } while (y != u);
    }
}


bool work()
{
    memset(h, -1, sizeof h);
    memset(dfn, 0, sizeof dfn);
    idx = ts = cnt = 0;

    for (int i = 0; i < m; i ++ )
    {
        int x = op[i].x - 1, y = op[i].y - 1;
        char a = op[i].a, b = op[i].b;
        if (s[x] != a + 32)
        {
            if (s[y] != b + 32) add(get(x, a, 0), get(y, b, 0)), add(get(y, b, 1), get(x, a, 1));
            else add(get(x, a, 0), get(x, a, 1));
        }
    }

    for (int i = 0; i < n * 2; i ++ )
        if (!dfn[i])
            tarjan(i);

    for (int i = 0; i < n; i ++ )
        if (id[i] == id[i + n])
            return false;

    for (int i = 0; i < n; i ++ )
        if (id[i] < id[i + n]) putchar(put(i, 1));
        else putchar(put(i, 2));

    return true;
}

int main()
{
    scanf("%d%d", &n, &d);
    scanf("%s", s);
    for (int i = 0, j = 0; i < n; i ++ )
        if (s[i] == 'x')
            pos[j ++ ] = i;

    scanf("%d", &m);
    for (int i = 0; i < m; i ++ )
        scanf("%d %c %d %c", &op[i].x, &op[i].a, &op[i].y, &op[i].b);

    for (int k = 0; k < 1 << d; k ++ )
    {
        for (int i = 0; i < d; i ++ )
            if (k >> i & 1) s[pos[i]] = 'a';
            else s[pos[i]] = 'b';

        if (work()) return 0;
    }

    puts("-1");
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/468216/
   。


AcWing 2417. 指挥网络    原题链接    中等
作者：    皓首不倦 ,  2020-09-30 16:18:58 ,  阅读 9

0




'''
朱刘算法计算有向图的最小树形子图
'''

from typing import List, Tuple
import sys
import math

class Tarjan:
    # 求有向图的强连通分量, 单个强连通分量用点列表表示，返回强连通分量的列表
    # 所有节点编号是1, 2, 3, ..... max_node_num
    @staticmethod
    def getStrongConnectedComponent(edges: List[Tuple], max_node_num):
        link = [[] for _ in range(max_node_num + 1)]
        dfn = [0x7fffffff] * (max_node_num + 1)
        low = [0x7fffffff] * (max_node_num + 1)

        global_time = [0]
        for a, b in edges:
            link[a].append(b)

        stack = []
        strong_connect_comp = []

        visit = [0] * (max_node_num + 1)

        def dfs(cur):
            global_time[0] += 1
            dfn[cur], low[cur] = global_time[0], global_time[0]
            stack.append(cur)
            pos = len(stack) - 1

            for next in link[cur]:
                if visit[next] == 1:
                    continue

                if dfn[next] == 0x7fffffff:
                    dfs(next)
                    low[cur] = min(low[cur], low[next])
                else:
                    low[cur] = min(low[cur], dfn[next])

            if low[cur] == dfn[cur]:
                # dfn 和 low 相等时候，一直退栈退到cur出栈为止
                strong_connect_comp.append(stack[pos:])
                while len(stack) > pos:
                    visit[stack.pop(-1)] = 1

        for node in range(1, max_node_num + 1):
            if len(link[node]) == 0:
                continue

            if dfn[node] == 0x7fffffff:
                dfs(node)

        # 处理没有边的点
        for node in range(1, max_node_num + 1):
            if visit[node] == 0:
                strong_connect_comp.append([node])

        return strong_connect_comp


class Zhuliu:
    # max_node_num为节点数量，所有节点从1到max_node_num顺序连续编号
    def __init__(self, edges, max_node_num, root_node):
        self.edges = edges
        self.max_node_num = max_node_num
        self.root_node = root_node

    # 返回最小树形子图的边权和，无解返回None
    def getMinTreeSubGraph(self):

        n = self.max_node_num
        link = {node: {} for node in range(1,n+1)}
        for a, b, w in self.edges:
            # 自环边和指向根的边没有意义，直接过滤掉
            if a == b or b == self.root_node:
                continue

            link[a][b] = w


        # 验证从起点到所有点是不是连通的，不连通无解
        visit = [0] * (n + 1)
        def dfs(cur):
            visit[cur] = 1

            for next in link[cur].keys():
                if visit[next] == 0:
                    dfs(next)

        dfs(self.root_node)
        if sum(visit) != n:
            return None

        # 不断找环缩点，直到没有环为止
        total_dis = 0
        cur_node_num = n
        dis = [0x7fffffff] * (n + 1)        # 每个节点的前驱到这个节点的边权
        pre = [0] * (n + 1)                 # 每个节点的前驱
        scc_id = [0] * (n+1)                # 每个节点属于的强连通分量编号
        cur_root = self.root_node

        while True:
            for node in range(1, cur_node_num+1):
                dis[node] = 0x7fffffff
                pre[node] = None
                scc_id[node] = None


            for node1 in link:
                for node2, w in link[node1].items():
                    if w < dis[node2]:
                        dis[node2] = w
                        pre[node2] = node1

            e = [(pre[node], node) for node in range(1, cur_node_num+1) if node != cur_root]
            scc_list = Tarjan.getStrongConnectedComponent(e, cur_node_num)
            if len(scc_list) == cur_node_num:
                # 强连通分量个数是节点个数，说明选的入边中没有环，直接累加边权结束运算
                for node in range(1, cur_node_num+1):
                    if node == cur_root:
                        continue

                    total_dis += link[pre[node]][node]
                break

            else:
                for i, scc in enumerate(scc_list):

                    for node in scc:
                        scc_id[node] = i+1

                for node in range(1, cur_node_num+1):
                    if node == cur_root:
                        continue
                    if scc_id[pre[node]] == scc_id[node]:
                        total_dis += link[pre[node]][node]  # 累加环上的边的权值

                new_node_num = len(scc_list)
                new_link = {node: {} for node in range(1,new_node_num+1)}
                for node1 in link:
                    n1 = scc_id[node1]
                    for node2 in link[node1]:
                        n2 = scc_id[node2]

                        if n1 == n2:
                            continue    # 环上的边删掉

                        if n2 == scc_id[cur_root]:
                            continue

                        if n2 == scc_id[pre[node2]]:
                            # 终点在环上的边, 终点和指向终点的点就应该在一个连通分量里面
                            if n2 in new_link[n1]:
                                new_link[n1][n2] = min(link[node1][node2] - link[pre[node2]][node2], new_link[n1][n2])
                            else:
                                new_link[n1][n2] = link[node1][node2] - link[pre[node2]][node2]
                        else:
                            if n2 in new_link[n1]:
                                new_link[n1][n2] = min(new_link[n1][n2], link[node1][node2])
                            else:
                                new_link[n1][n2] = link[node1][node2]

                link, cur_node_num, cur_root = new_link, new_node_num, scc_id[cur_root]

        return total_dis



while True:
    try:
        n, m = map(int, input().split())
    except:
        break

    pos = [(0, 0)]
    for _ in range(n):
        s = sys.stdin.readline()
        a, b = map(int, s.split())
        pos.append((a, b))


    def get_dis(a, b):
        x = pos[a][0] - pos[b][0]
        y = pos[a][1] - pos[b][1]
        return math.sqrt(x**2 + y**2)

    edges = []
    for _ in range(m):
        s = sys.stdin.readline()
        a, b = map(int, s.split())
        edges.append((a, b, get_dis(a, b)))

    ans = Zhuliu(edges, n, 1).getMinTreeSubGraph()
    print('{:.2f}'.format(ans) if ans is not None else 'poor snoopy')


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21614/
   。

#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>

#define x first
#define y second

using namespace std;

typedef pair<double, double> PDD;

const int N = 110;
const double INF = 1e8;

int n, m;
PDD q[N];
bool g[N][N];
double d[N][N], bd[N][N];
int pre[N], bpre[N];
int dfn[N], low[N], ts, stk[N], top;
int id[N], cnt;
bool st[N], ins[N];

void dfs(int u)
{
    st[u] = true;
    for (int i = 1; i <= n; i ++ )
        if (g[u][i] && !st[i])
            dfs(i);
}

bool check_con()
{
    memset(st, 0, sizeof st);
    dfs(1);
    for (int i = 1; i <= n; i ++ )
        if (!st[i])
            return false;
    return true;
}

double get_dist(int a, int b)
{
    double dx = q[a].x - q[b].x;
    double dy = q[a].y - q[b].y;
    return sqrt(dx * dx + dy * dy);
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ ts;
    stk[ ++ top] = u, ins[u] = true;

    int j = pre[u];
    if (!dfn[j])
    {
        tarjan(j);
        low[u] = min(low[u], low[j]);
    } else if (ins[j]) low[u] = min(low[u], dfn[j]);

    if (low[u] == dfn[u])
    {
        int y;
        ++ cnt;
        do
        {
            y = stk[top -- ], ins[y] = false, id[y] = cnt;
        } while (y != u);
    }
}

double work()
{
    double res = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (g[i][j]) d[i][j] = get_dist(i, j);
            else d[i][j] = INF;

    while (true)
    {
        for (int i = 1; i <= n; i ++ )
        {
            pre[i] = i;
            for (int j = 1; j <= n; j ++ )
                if (d[pre[i]][i] > d[j][i])
                    pre[i] = j;
        }

        memset(dfn, 0, sizeof dfn);
        ts = cnt = 0;
        for (int i = 1; i <= n; i ++ )
            if (!dfn[i])
                tarjan(i);

        if (cnt == n)
        {
            for (int i = 2; i <= n; i ++ ) res += d[pre[i]][i];
            break;
        }

        for (int i = 2; i <= n; i ++ )
            if (id[pre[i]] == id[i])
                res += d[pre[i]][i];

        for (int i = 1; i <= cnt; i ++ )
            for (int j = 1; j <= cnt; j ++ )
                bd[i][j] = INF;

        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                if (d[i][j] < INF && id[i] != id[j])
                {
                    int a = id[i], b = id[j];
                    if (id[pre[j]] == id[j]) bd[a][b] = min(bd[a][b], d[i][j] - d[pre[j]][j]);
                    else bd[a][b] = min(bd[a][b], d[i][j]);
                }

        n = cnt;
        memcpy(d, bd, sizeof d);
    }

    return res;
}

int main()
{
    while (~scanf("%d%d", &n, &m))
    {
        for (int i = 1; i <= n; i ++ ) scanf("%lf%lf", &q[i].x, &q[i].y);

        memset(g, 0, sizeof g);
        while (m -- )
        {
            int a, b;
            scanf("%d%d", &a, &b);
            if (a != b && b != 1) g[a][b] = true;
        }

        if (!check_con()) puts("poor snoopy");
        else printf("%.2lf\n", work());
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/468952/
   。
AcWing 2419. prufer序列    原题链接    中等
作者：    皓首不倦 ,  2020-10-01 11:26:16 ,  阅读 10

0




# 树编码为prufer序列
# 所有节点编号从1到max_node_num
class PruferEncoder:
    def __init__(self, edges, max_node_num, is_directed = False):
        self.is_directed = is_directed
        self.max_node_num = max_node_num

        self.link = [[] for _ in range(max_node_num+1)]
        self.valid = [1] * (max_node_num + 1)
        self.__d = [0] * (max_node_num + 1)

        for a, b in edges:
            if is_directed:
                self.link[b].append(a)
                self.__d[a] += 1
            else:
                self.link[a].append(b)
                self.link[b].append(a)
                self.__d[a] += 1
                self.__d[b] += 1

    def __remove_node(self, node):
        for other in self.link[node]:
            self.__d[other] -= 1
        self.valid[node] = 0

    def encode(self):
        ans = []
        for i in range(1, self.max_node_num+1):
            if len(ans) == self.max_node_num - 2:
                break

            if (self.is_directed == True and self.__d[i] == 0) or (self.is_directed == False and self.__d[i] == 1):
                for node in self.link[i]:
                    if self.valid[node]:
                        ans.append(node)
                        break

                self.__remove_node(i)

                while ((self.is_directed == True and self.__d[ans[-1]] == 0) or (self.is_directed == False and self.__d[ans[-1]] == 1)) and ans[-1] < i and len(ans) < self.max_node_num - 2:
                    for node in self.link[ans[-1]]:
                        if self.valid[node]:
                            ans.append(node)
                            break
                    self.__remove_node(ans[-2])

        return ans


# prufer序列解码为边列表，不区分是有向图的编码序列还是无向图的编码序列，都能正确解码
# 所有节点编号从1到max_node_num
from queue import PriorityQueue
class PruferDecoder():
    def __init__(self, encode_list, max_node_num):
        self.data = encode_list[::]
        self.max_node_num = max_node_num

    def decode(self):
        d = [0] * (self.max_node_num+1)
        for node in self.data:
            d[node] += 1
        d[self.max_node_num] = 1

        min_heap = PriorityQueue()
        for node in range(1, self.max_node_num+1):
            if d[node] == 0:
                min_heap.put(node)
        ans = []
        for node in self.data:
            ans.append((node, min_heap.get()))
            d[node] -= 1
            if d[node] == 0:
                min_heap.put(node)

        ans.append((self.max_node_num, min_heap.get()))
        return ans

n, t = map(int, input().split())
if t == 1:
    edges = []
    arr = list(map(int, input().split()))
    for i, node in enumerate(arr):
        edges.append((node, i+1))

    ans = PruferEncoder(edges, n, is_directed=True).encode()
    for val in ans:
        print(val, end=' ')
    print()

else:
    arr = list(map(int, input().split()))
    edges = PruferDecoder(arr, n).decode()
    ans = [0] * (n-1)
    for a, b in edges:
        ans[b-1] = a
    for val in ans:
        print(val, end=' ')
    print()


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21667/
   。
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;
int f[N], d[N], p[N];

void tree2prufer()
{
    for (int i = 1; i < n; i ++ )
    {
        scanf("%d", &f[i]);
        d[f[i]] ++ ;
    }

    for (int i = 0, j = 1; i < n - 2; j ++ )
    {
        while (d[j]) j ++ ;
        p[i ++ ] = f[j];
        while (i < n - 2 && -- d[p[i - 1]] == 0 && p[i - 1] < j) p[i ++ ] = f[p[i - 1]];
    }

    for (int i = 0; i < n - 2; i ++ ) printf("%d ", p[i]);
}

void prufer2tree()
{
    for (int i = 1; i <= n - 2; i ++ )
    {
        scanf("%d", &p[i]);
        d[p[i]] ++ ;
    }
    p[n - 1] = n;

    for (int i = 1, j = 1; i < n; i ++, j ++ )
    {
        while (d[j]) j ++ ;
        f[j] = p[i];
        while (i < n - 1 && -- d[p[i]] == 0 && p[i] < j) f[p[i]] = p[i + 1], i ++ ;
    }

    for (int i = 1; i <= n - 1; i ++ ) printf("%d ", f[i]);
}

int main()
{
    scanf("%d%d", &n, &m);
    if (m == 1) tree2prufer();
    else prufer2tree();

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/468998/
   。
AcWing 2418. 光之大陆    原题链接    中等
作者：    whsstory ,  2020-09-06 19:06:26 ,  阅读 61

3


题意：有标号点仙人掌计数（每个点至多在一个环中）

n≤300n≤300 ,任意模数。

解： nn 个点的点仙人掌是由若干个不相交的环（可以是点)构成的。考虑将 nn 个点划分成若干个不相交的环的方案数（先不将这些环连接起来）（点有标号）

这个可以dp：记 f(i,j)f(i,j) 表示 ii 个点划分为 jj 个不相交的环的方案数。枚举点 ii 所在的环的大小 kk 可得：
f(i,j)=∑kf(i−k,j−1)×Ck−1i−1×g(k)
f(i,j)=∑kf(i−k,j−1)×Ci−1k−1×g(k)

其中 g(k)g(k) 表示 kk 个点的不同环的数量（朝向不同算不同，因为朝向不同在最后连接时会造成不同的方案）

那么 g(k)=(k−1)!×k/2=k!/2g(k)=(k−1)!×k/2=k!/2 .含义是： kk 个点的圆排列是 (k−1)!(k−1)! 个，朝向有 kk 种，但是顺逆时针的连接是等价的，所以要除以2. 特别的，由于2个点的环无意义，令 g(2)=0g(2)=0

这部分的复杂度是 (n3)O(n3)

现在考虑将 kk 个不相交的环连接的方案数。考虑prufer那套理论，长度为 LL 的prufer序列唯一确定了 L+1L+1 条边，所以恰 kk 个环 (k>1)(k>1) 的点仙人掌数量就是 f(n,k)×nk−2f(n,k)×nk−2 （prufer序列每个位置有 nn 种填法，还需确定 k−1k−1 条边）

对于 k=1k=1 ，此时本质不同的环才算不同，有 (n−1)!/2(n−1)!/2 个。

总复杂度 (n3)O(n3) .建议递推组合数，因为当模数小于 nn 时用阶乘求会出故障。

一道清新的prufer+计数dp的好题。

#define MAXN 311
ll mod;
ll f[MAXN][MAXN],C[MAXN][MAXN],g[MAXN];
int main()
{
    int n=read();
    mod=read();
    C[0][0]=1;
    for(int i=1;i<=n;++i)
    {
        C[i][0]=1;
        for(int j=1;j<=i;++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
    }
    g[1]=1,g[3]=3;
    for(int i=4;i<=n;++i)g[i]=g[i-1]*i%mod;
    f[0][0]=1;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=i;++j)
            for(int k=1;k<=i;++k)
                f[i][j]=(f[i][j]+f[i-k][j-1]*C[i-1][k-1]%mod*g[k])%mod;
    ll ans=g[n-1],pru=1;
    for(int i=2;i<=n;++i)
    {
        ans=(ans+f[n][i]*pru)%mod;pru=pru*n%mod;
    }
    printf("%lld",ans);
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/20187/
   。


2


做完这题就感觉计数特别玄学，问题出在网上所有题解都认为旋转算不同方案，需要 ×k×k。但我觉得不需要，因为映射的时候已经选择了对应的编号，想了 3 天，发现这一点网上的题解的理解好像都是错的。。

遂发题解。

或者说，我们做题的都是自己构造了一个自己认为正确的“广义” Prufer 序列，但并没有考虑具体映射关系，编号和缩点后编号的是否映射到位，所以计数不可避免的出现一些重复、缺漏的部分，但是阴差阳错的就对了。。

这题就是求 nn 个点的区分编号、联通点仙人掌图数量。

我们可以考虑把 nn 分成若干简单环，然后考虑把他们连起来的方案数。

考虑把每个简单环缩点，设缩点后有 jj 个点，设 c[x]c[x] 为 xx 缩点后属于的编号。

那么对于 jj 个缩点的图，有多少种生成树个数呢？

考虑 Prufer 编码，稍稍做一点改动，考虑每次选择的点是 nn 个，需要连 j−1j−1 条边，所以是 nj−2nj−2。这样为什么是正确的呢？考虑构造一个类似的映射方式，在标准 Prufer 编码映射上的改动：

在有关度数的所有操作，把 xx 当作 c[x]c[x] 进行相关操作
在有关生成 Prufer 序列，连接父亲儿子边这些操作，用原始编号。
这样的话我们发现映射的时候，如果当作一个以 nn 为根的有根树，对于一条边而言，映射出了这条边父亲的缩点前的具体编号与儿子缩点后的具体编号（这个可以考虑 Prufer 映射的过程，连边在这种特殊的映射中 (x,y)(x,y)， yy 实际上是缩点后的编号），所以对于每条边，我们还要计数选择这条边儿子连接的具体是 yy 这个缩的点连接的是这个环中具体的哪个点（选择一个接口），即除了 nn 所在的那个环，其他的都要从中选一个点作为接口 。并且，我们发现 Prufer 编码没有确定最后一条边，即父亲为 nn 缩点后所在的的那条边的父亲的具体编号（原始的 Prufer 编码缩点后的节点是根不需要连父亲边，但考虑到我们特殊的 Prufer，最后只能保证从 nn 号节点连边，没有选择 nn 号节点缩点后的点对应着缩点前的哪个点，所以 nn 对应的环也要从中选一个），设每个缩点的环大小是 szsz，答案应该是 nj−2×∏sznj−2×∏sz
后面 szsz 的乘积，我们可以在把分成环的时候把贡献送进去。

所以 fi,jfi,j 实际上是把 ii 个点的仙人掌缩点后分成 jj 个点，再从每个环里面选出一个点作为接口连接父亲边，的方案数。

所以这个 ×k×k 实际上并不是网上流传的朝向本质不同，而是广义 Prufer 计数留下的历史遗漏问题，缩点后编号和原始编号映射没有映射全，需要额外增加计数导致的。

答案就是 ∑ni=1fn,i×ni−2∑i=1nfn,i×ni−2。

考虑求解 fi,jfi,j，可以类比 AcWing 307. 连通图 的方式，枚举基准点 ii 的联通块大小 kk。

fi,j=∑k=1ifi−k,j−1×Ck−1i−1×gk×k
fi,j=∑k=1ifi−k,j−1×Ci−1k−1×gk×k
这个 gigi 表示大小为 ii 的环的方案数：

gi={0, i=2 (i−1)!2,otherwisegi={0, i=2 (i−1)!2,otherwise
不存在大小为 22 的环，i=1i=1 默认是一个点，在这个题里环旋转、翻转本质相同。

注意 i=1i=1 的时候特判，贡献即 (n−1)!2(n−1)!2
这个东西在预处理组合数后可以 O(n3)O(n3) 做，这题就做完了。

#include <iostream>
#include <cstdio>

using namespace std;

const int N = 205;

typedef long long LL;

int n, P, f[N][N], fact[N], C[N][N];

int main() {
    scanf("%d%d", &n, &P);
    f[0][0] = C[0][0] = 1;
    fact[1] = 1, fact[3] = 3;
    for (int i = 4; i <= n; i++) fact[i] = fact[i - 1] * i % P;
    for (int i = 1; i <= n; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++) 
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            for (int k = 1; k <= i; k++) {
                f[i][j] = (f[i][j] + (LL)f[i - k][j - 1] * C[i - 1][k - 1] % P * fact[k]) % P;
            }
        }
    }
    int ans = fact[n - 1], s = 1;
    for (int i = 2; i <= n; i++, s = s * n % P) ans = (ans + (LL)f[n][i] * s) % P;
    printf("%d\n", ans);
    return 0;

作者：墨染空
链接：https://www.acwing.com/solution/content/20527/
   。
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 210;

int n, m;
int C[N][N], g[N], f[N][N];

void init()
{
    for (int i = 0; i <= n; i ++ )
        for (int j = 0; j <= i; j ++ )
            if (!j) C[i][j] = 1;
            else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % m;

    g[1] = 1, g[3] = 3;
    for (int i = 4; i <= n; i ++ ) g[i] = g[i - 1] * i % m;
}

int main()
{
    cin >> n >> m;
    init();

    f[0][0] = 1;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= i; j ++ )
            for (int k = 1; k <= i - j + 1; k ++ )
                f[i][j] = (f[i][j] + f[i - k][j - 1] * (LL)C[i - 1][k - 1] * g[k]) % m;

    LL res = g[n - 1], p = 1;
    for (int k = 2; k <= n; k ++ )
    {
        res += f[n][k] * p;
        p = p * n % m;
    }

    cout << res % m << endl;

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/469048/
   。
AcWing 2437. Splay    原题链接    中等
作者：    皓首不倦 ,  2020-10-01 22:16:42 ,  阅读 12

0




#include <string.h>
#include <stdio.h>
#include <algorithm>
using namespace std;

#define MAX_NODE_NUM       100005

struct Node {
    int child[2];       // 左右子节点编号
    int parent;         // 父节点编号
    int val;            // 节点数值
    int size;           // 子树大小
    int flag;           // 懒标记
} pool[MAX_NODE_NUM];


class SplayTree {
private:
    int __root;           // 根节点编号
    int __pool_pos;       // 对象池最后一个分配位置

public:
    SplayTree(int node_num) {
        __root = 0;
        __pool_pos = 1;
        memset(pool, 0, sizeof(Node) * (node_num+1));
    }

    // 翻转懒标记
    void rev_flag(int idx) {
        pool[idx].flag ^= 1;
    }

    int get_left_child(int idx) {
        return pool[idx].child[0];
    }

    int get_right_child(int idx) {
        return pool[idx].child[1];
    }

    int get_root() {
        return __root;
    }

    // 搬移函数，将编号为x的节点通过旋转搬移到k号节点的下面
    void move(int x, int k) {
        __move(x, k);
    }

    // 插入数值是val的节点
    void insert(int val) {
        int u = __root, p = 0;
        while (u != 0) {
            p = u;
            u = pool[u].child[val > pool[u].val];
        }

        u = __pool_pos++;
        if (p != 0) {
            pool[p].child[val > pool[p].val] = u;
        }

        pool[u].parent = p;
        pool[u].val = val;

        __move(u, 0);
    }

    // 获取第k大的节点编号，返回0表示无解
    int get_kth_idx(int k) {
        int u = __root;
        while (u) {
            __push_down(u);

            if (pool[pool[u].child[0]].size >= k) {
                u = pool[u].child[0];
            } else if (pool[pool[u].child[0]].size + 1 == k) {
                return u;
            } else {
                k -= pool[pool[u].child[0]].size + 1;
                u = pool[u].child[1];
            }
        }

        return 0;
    }

    void get_mid_travel_list(int* ans) {
        int pos = 0;
        __get_mid_travel_list(__root, pos, ans);
    }

private:
    // 信息上传函数(即根据子节点信息更新序号是idx的节点的信息)
    void __push_up(int idx) {
        Node& node = pool[idx];
        node.size = 1 + pool[node.child[0]].size + pool[node.child[1]].size;
    }

    /******* 此处 __flag_oper  __push_down_child_flag 两个函数的逻辑需要根据不同的问题场景进行修改 **********/

    // 懒标记对应的操作，默认什么操作也没有，具体使用时候在此处添加操作
    void __flag_oper(int idx) {
        swap(pool[idx].child[0], pool[idx].child[1]);
    }

    // 修改子节点的标记函数，默认就是将标记下传，不同问题可能有不同处理方式，这里把逻辑提出来
    void __push_down_child_flag(int idx) {
        pool[pool[idx].child[0]].flag ^= 1;
        pool[pool[idx].child[1]].flag ^= 1;
    }

    /******* 此处 __flag_oper  __push_down_child_flag 两个函数的逻辑需要根据不同的问题场景进行修改 **********/

    // 懒标记下移操作
    void __push_down(int idx) {
        if (pool[idx].flag) {
            __flag_oper(idx);
            __push_down_child_flag(idx);
            pool[idx].flag = 0;
        }
    }

    // 统一的左旋和右旋函数，将编号为x对应的节点网上一层旋转
    void __rotate(int x) {
        int y = pool[x].parent, z = pool[y].parent;
        int k1 = pool[y].child[1] == x, k2 = pool[z].child[1] == y;
        pool[z].child[k2] = x;
        pool[x].parent = z;
        pool[y].child[k1] = pool[x].child[k1^1];
        pool[pool[x].child[k1^1]].parent = y;
        pool[x].child[k1^1] = y;
        pool[y].parent = x;

        __push_up(y);
        __push_up(x);
    }

    // 搬移函数，将编号为x的节点通过旋转搬移到k号节点的下面
    // k = 0 表示将x节点搬移到根节点位置
    void __move(int x, int k) {
        while (pool[x].parent != k) {
            int y = pool[x].parent, z = pool[y].parent;
            if (z != k) {
                if ( (pool[y].child[1] == x) != (pool[z].child[1] == y) ) {
                    __rotate(x);
                } else {
                    __rotate(y);
                }
            }
            __rotate(x);
        }

        if (k == 0) {
            __root = x;
        }
    }

    void __get_mid_travel_list(int cur, int& pos, int* ans) {
        if (cur == 0) {
            return;
        }

        __push_down(cur);

        __get_mid_travel_list(pool[cur].child[0], pos, ans);
        ans[pos++] = pool[cur].val;
        __get_mid_travel_list(pool[cur].child[1], pos, ans);
    }
};

int mid_arr[MAX_NODE_NUM];

int main(void) {
    //freopen("/Users/grh/Programming/CLionProjects/Test/data.txt", "r", stdin);

    int n, m;;
    int l, r;
    scanf("%d %d", &n, &m);

    SplayTree tree(n+2);
    for (int i = 0; i <= n+1; i++) {
        tree.insert(i);
    }

    for (int i = 0; i < m; i++) {
        scanf("%d %d", &l, &r);
        l = tree.get_kth_idx(l);
        r = tree.get_kth_idx(r+2);

        tree.move(l, 0);
        tree.move(r, l);
        tree.rev_flag(tree.get_left_child(r));
    }

    tree.get_mid_travel_list(mid_arr);
    for (int i = 1; i <= n; i++) {
        printf("%d ", mid_arr[i]);
    }
    printf("\n");
}

作者：皓首不倦
链接：https://www.acwing.com/solution/content/21689/
   。
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;
struct Node
{
    int s[2], p, v;
    int size, flag;

    void init(int _v, int _p)
    {
        v = _v, p = _p;
        size = 1;
    }
}tr[N];
int root, idx;

void pushup(int x)
{
    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;
}

void pushdown(int x)
{
    if (tr[x].flag)
    {
        swap(tr[x].s[0], tr[x].s[1]);
        tr[tr[x].s[0]].flag ^= 1;
        tr[tr[x].s[1]].flag ^= 1;
        tr[x].flag = 0;
    }
}

void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;  // k=0表示x是y的左儿子；k=1表示x是y的右儿子
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay(int x, int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
    if (!k) root = x;
}

void insert(int v)
{
    int u = root, p = 0;
    while (u) p = u, u = tr[u].s[v > tr[u].v];
    u = ++ idx;
    if (p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(v, p);
    splay(u, 0);
}

int get_k(int k)
{
    int u = root;
    while (true)
    {
        pushdown(u);
        if (tr[tr[u].s[0]].size >= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].size + 1 == k) return u;
        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
    }
    return -1;
}

void output(int u)
{
    pushdown(u);
    if (tr[u].s[0]) output(tr[u].s[0]);
    if (tr[u].v >= 1 && tr[u].v <= n) printf("%d ", tr[u].v);
    if (tr[u].s[1]) output(tr[u].s[1]);
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i <= n + 1; i ++ ) insert(i);
    while (m -- )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        l = get_k(l), r = get_k(r + 2);
        splay(l, 0), splay(r, l);
        tr[tr[r].s[0]].flag ^= 1;
    }
    output(root);
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/478319/
   。
#include <string.h>
#include <stdio.h>
#include <algorithm>
using namespace std;

#define MAX_NODE_NUM       100005

struct Node {
    int child[2];       // 左右子节点编号
    int parent;         // 父节点编号
    int val;            // 节点数值
    int size;           // 子树大小
    int flag;           // 懒标记
} pool[MAX_NODE_NUM];


class SplayTree {
private:
    int __root;           // 根节点编号
    int __pool_pos;       // 对象池最后一个分配位置

public:
    SplayTree(int node_num) {
        __root = 0;
        __pool_pos = 1;
        memset(pool, 0, sizeof(Node) * (node_num+1));
    }

    // 翻转懒标记
    void rev_flag(int idx) {
        pool[idx].flag ^= 1;
    }

    int get_left_child(int idx) {
        return pool[idx].child[0];
    }

    int get_right_child(int idx) {
        return pool[idx].child[1];
    }

    int get_root() {
        return __root;
    }

    // 搬移函数，将编号为x的节点通过旋转搬移到k号节点的下面
    void move(int x, int k) {
        __move(x, k);
    }

    // 插入数值是val的节点
    void insert(int val) {
        int u = __root, p = 0;
        while (u != 0) {
            p = u;
            u = pool[u].child[val > pool[u].val];
        }

        u = __pool_pos++;
        if (p != 0) {
            pool[p].child[val > pool[p].val] = u;
        }

        pool[u].parent = p;
        pool[u].val = val;

        __move(u, 0);
    }

    // 获取第k大的节点编号，返回0表示无解
    int get_kth_idx(int k) {
        int u = __root;
        while (u) {
            __push_down(u);

            if (pool[pool[u].child[0]].size >= k) {
                u = pool[u].child[0];
            } else if (pool[pool[u].child[0]].size + 1 == k) {
                return u;
            } else {
                k -= pool[pool[u].child[0]].size + 1;
                u = pool[u].child[1];
            }
        }

        return 0;
    }

    void get_mid_travel_list(int* ans) {
        int pos = 0;
        __get_mid_travel_list(__root, pos, ans);
    }

    // 返回第一个数值大于等于val的节点编号, 返回0无解
    int lower_bound(int node, int val) {
        if (node == 0) {
            return 0;
        }

        if (val <= pool[node].val) {
            int idx = lower_bound(pool[node].child[0], val);
            if (idx != 0) {
                return idx;
            }
            return node;
        } else {
            return lower_bound(pool[node].child[1], val);
        }
    }

    // 删除子树
    void del_sub_tree(int node) {
        Node& parent_node = pool[pool[node].parent];
        int p = pool[node].parent;

        if (parent_node.child[0] == node) {
            parent_node.child[0] = 0;
        } else {
            parent_node.child[1] = 0;
        }

        while (p) {
            __push_up(p);
            p = pool[p].parent;
        }
    }

    // 获取数值
    int get_val(int idx) {
        return pool[idx].val;
    }

    // 获取树大小
    int get_tree_size() {
        return pool[__root].size;
    }



private:
    // 信息上传函数(即根据子节点信息更新序号是idx的节点的信息)
    void __push_up(int idx) {
        Node& node = pool[idx];
        node.size = 1 + pool[node.child[0]].size + pool[node.child[1]].size;
    }

    /******* 此处 __flag_oper  __push_down_child_flag 两个函数的逻辑需要根据不同的问题场景进行修改 **********/

    // 懒标记对应的操作，默认什么操作也没有，具体使用时候在此处添加操作
    void __flag_oper(int idx) {

    }

    // 修改子节点的标记函数，默认就是将标记下传，不同问题可能有不同处理方式，这里把逻辑提出来
    void __push_down_child_flag(int idx) {

    }

    // 懒标记下移操作
    void __push_down(int idx) {
        if (pool[idx].flag) {
            __flag_oper(idx);
            __push_down_child_flag(idx);
            pool[idx].flag = 0;
        }
    }

    // 统一的左旋和右旋函数，将编号为x对应的节点网上一层旋转
    void __rotate(int x) {
        int y = pool[x].parent, z = pool[y].parent;
        int k1 = pool[y].child[1] == x, k2 = pool[z].child[1] == y;
        pool[z].child[k2] = x;
        pool[x].parent = z;
        pool[y].child[k1] = pool[x].child[k1^1];
        pool[pool[x].child[k1^1]].parent = y;
        pool[x].child[k1^1] = y;
        pool[y].parent = x;

        __push_up(y);
        __push_up(x);
    }

    // 搬移函数，将编号为x的节点通过旋转搬移到k号节点的下面
    // k = 0 表示将x节点搬移到根节点位置
    void __move(int x, int k) {
        while (pool[x].parent != k) {
            int y = pool[x].parent, z = pool[y].parent;
            if (z != k) {
                if ( (pool[y].child[1] == x) != (pool[z].child[1] == y) ) {
                    __rotate(x);
                } else {
                    __rotate(y);
                }
            }
            __rotate(x);
        }

        if (k == 0) {
            __root = x;
        }
    }

    void __get_mid_travel_list(int cur, int& pos, int* ans) {
        if (cur == 0) {
            return;
        }

        __push_down(cur);

        __get_mid_travel_list(pool[cur].child[0], pos, ans);
        ans[pos++] = pool[cur].val;
        __get_mid_travel_list(pool[cur].child[1], pos, ans);
    }
};



int main(void) {
    //freopen("/Users/grh/Programming/CLionProjects/Test/data.txt", "r", stdin);

    int min_bound, cmd_num;
    char s[2];
    int val;

    scanf("%d %d", &cmd_num, &min_bound);

    SplayTree tree(MAX_NODE_NUM-3);
    tree.insert(-0x7fffffff);
    tree.insert(0x7fffffff);
    int delta = 0;
    int cnt = 0;        // 加入过公司的员工数

    for (int i = 0; i < cmd_num; i++) {
        scanf("%s %d", s, &val);

        if (s[0] == 'I') {
            if (val >= min_bound) {
                tree.insert(val - delta);
                cnt += 1;
            }
        } else if (s[0] == 'A' || s[0] == 'S') {
            delta += s[0] == 'A' ? val : -val;
            int idx = tree.lower_bound(tree.get_root(), min_bound - delta);
            if (idx != 0) {
                // 把工资小于最小值的区段全部删掉
                tree.move(idx, 0);
                tree.move(1, idx);
                tree.del_sub_tree(tree.get_right_child(1));
            }
        } else {
            int idx = tree.get_kth_idx((tree.get_tree_size()-2 - val + 1)+1);
            if (idx == 0 || tree.get_val(idx) == 0x7fffffff || tree.get_val(idx) == -0x7fffffff) {
                printf("-1\n");
            } else {
                printf("%d\n", tree.get_val(idx)+delta, tree.get_val(idx));
            }
        }
    }

    printf("%d\n", cnt - (tree.get_tree_size()-2));
    return 0;
}


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21706/
   。

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, INF = 1e9;

int n, m, delta;
struct Node
{
    int s[2], p, v;
    int size;

    void init(int _v, int _p)
    {
        v = _v, p = _p;
        size = 1;
    }
}tr[N];
int root, idx;

void pushup(int x)
{
    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;
}

void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay(int x, int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
    if (!k) root = x;
}

int insert(int v)
{
    int u = root, p = 0;
    while (u) p = u, u = tr[u].s[v > tr[u].v];
    u = ++ idx;
    if (p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(v, p);
    splay(u, 0);
    return u;
}

int get(int v)
{
    int u = root, res;
    while (u)
    {
        if (tr[u].v >= v) res = u, u = tr[u].s[0];
        else u = tr[u].s[1];
    }
    return res;
}

int get_k(int k)
{
    int u = root;
    while (u)
    {
        if (tr[tr[u].s[0]].size >= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].size + 1 == k) return tr[u].v;
        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
    }
    return -1;
}

int main()
{
    scanf("%d%d", &n, &m);
    int L = insert(-INF), R = insert(INF);

    int tot = 0;
    while (n -- )
    {
        char op[2];
        int k;
        scanf("%s%d", op, &k);
        if (*op == 'I')
        {
            if (k >= m) k -= delta, insert(k), tot ++ ;
        }
        else if (*op == 'A') delta += k;
        else if (*op == 'S')
        {
            delta -= k;
            R = get(m - delta);
            splay(R, 0), splay(L, R);
            tr[L].s[1] = 0;
            pushup(L), pushup(R);
        }
        else
        {
            if (tr[root].size - 2 < k) puts("-1");
            else printf("%d\n", get_k(tr[root].size - k) + delta);
        }
    }

    printf("%d\n", tot - (tr[root].size - 2));

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/478395/
   。

AcWing 1063. 永无乡    原题链接    中等
作者：    whsstory ,  2019-10-03 21:50:24 ,  阅读 207

3


出处

永无乡solution
(尚未讲解)
前置技能：并查集及其“代表”思想；权值线段树（会讲解）；权值线段树上二分求k-th（会讲解）；动态开点（会讲解）;线段树合并(会讲解)

PS1：此题是有平衡树的解法的，但其实麻烦了（其实是我不太会）
PS2：如果你不会并查集，那你有必要先去学一下

先关注“联通”二字，即要维护图上的联通性。而并查集非常适合解决此类问题。
由此，我们得到一个暴力做法：
对于合并操作，直接在并查集上合并x,y即可，每次O(1)O(1)；
对于查询操作，直接找出所有与x同一集合的点，按重要度排序后第k小即为所求，最坏每次O(nlogn)O(nlogn);
总时间复杂度最坏O(q×nlogn)O(q×nlogn)。

看到查询居然要最坏每次O(nlogn)O(nlogn)的复杂度，有很大的优化空间。
如何动态求k-th?
如果您想到了平衡树,那么您就已经可以解决此题了,不用继续往下了.
而如果您不是很会平衡树:
权值线段树也能(通过线段树上二分)O(logn)O(logn)动态维护k-th可以参见这里
也就是说,我们要查询与x联通的点里面第k重要的,就可以这样实现O(logn)O(logn)的查询
但这样有两个问题:
1. 空间开销大.对于每个点都开一个大小为O(n)O(n)的线段树,总空间复杂度O(n2)O(n2),无法承受.考虑到每次询问实际用到的点仅O(logn)O(logn)个,总共也就最多访问O(qlogn)O(qlogn)个节点,使用动态开点 (没错,还是同一篇blog),将空间降为O(min(n2,qlogn))O(min(n2,qlogn))
2. 每次合并x,y时,要将与其联通的所有点都插入它们,每次最坏甚至可能超越O(n)O(n).考虑并查集的”代表”思想:设sgt(i)表示与点i联通的点构成的线段树,由于联通是双向的,有:
sgt(x)=sgt(y) if(x,y联通)
sgt(x)=sgt(y) if(x,y联通)
也就是说,在并查集上合并(x,y)的同时,把sgt(x)也与sgt(y)合并,查询时在find(x)上查询.
这带来了新的问题:普通的合并,复杂度不会低于O(n)O(n).可以使用启发式合并,这样大概是两个log.但更优的做法是使用线段树合并
权值线段树的线段树合并代码大概是这样的:

typedef long long ll;
typedef unsigned un;
ll uni(ll a,ll b,un l=1,un r=n)//把sgt(a)合并到sgt(b)上,并返回合并后点的编号
{
    if(!a)return b;//有一个为空,返回
    if(!b)return a;
    if(l==r)//叶子节点,直接合并
    {
        t[b].v+=t[a].v;
        return b;
    }
    un mid=(l+r)>>1;
    t[b].ls=uni(t[a].ls,t[b].ls,l,mid);//递归合并子节点
    t[b].rs=uni(t[a].rs,t[b].rs,mid+1,r);
    pushup(b);//更新当前点
    return b;
}
每个点至多被合并一次,总复杂度O((m+q)logn)O((m+q)logn)
再讲解一下几个细节:初始化并查集;每个点先把自己的重要度插入自己的线段树里;合并的时候都是对find(x),find(y)进行合并;
最后,总时间复杂度O((n+m+q)logn)O((n+m+q)logn),空间复杂度O(min(n2,qlogn))O(min(n2,qlogn))
//Wan Hong 3.0
//notebook
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include <cmath>
typedef int ll;//long long makes MLE.
typedef unsigned un;
typedef std::pair<ll,ll> pll;
typedef std::string str;
#define INF (1ll<<58)
ll read()
{
    ll f=1,x=0;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return f*x;
}
ll max(ll a,ll b)
{
    return a>b?a:b;
}
ll min(ll a,ll b)
{
    return a<b?a:b;
}
bool umax(ll& a,ll b)
{
    if(b>a)return a=b,1;
    return 0;
}
bool umin(ll& a,ll b)
{
    if(b<a)return a=b,1;
    return 0;
}

/**********/
#define MAXN 300011
struct ufs//Union_Find_Set
{
    ll fa[MAXN];
    void build(ll n)
    {
        for(ll i=1;i<=n;++i)fa[i]=i;
    }
    ll find(ll x)
    {
        if(fa[x]==x)return x;
        return fa[x]=find(fa[x]);
    }
    void uni(ll u,ll v)
    {
        u=find(u),v=find(v);
        fa[u]=v;
    }
}s;
ll n,m,q;

struct node//线段树的节点(动态开点的)
{
    ll v,ls,rs;
    node()
    {
        v=ls=rs=0;
    }
    node(ll _v,ll _ls,ll _rs)
    {
        v=_v,ls=_ls,rs=_rs;
    }
}t[MAXN*18+1];
ll cnt=0;

void pushup(un num)
{
    t[num].v=t[t[num].ls].v+t[t[num].rs].v;
}
void modify(ll x,ll k,un num,un l=1,un r=n)在sgt(num)上将x的出现次数加上k
{
    if(l==r)
    {
        if(l==x)t[num].v+=k;
        return;
    }
    un mid=(l+r)>>1;
    if(x<=mid)
    {
        if(!t[num].ls)t[num].ls=++cnt;//动态开点
        modify(x,k,t[num].ls,l,mid);
    }
    else
    {
        if(!t[num].rs)t[num].rs=++cnt;
        modify(x,k,t[num].rs,mid+1,r);
    }
    pushup(num);
}
ll uni(ll a,ll b,un l=1,un r=n)//线段树合并
{
    if(!a)return b;
    if(!b)return a;
    if(l==r)
    {
        t[b].v+=t[a].v;
        return b;
    }
    un mid=(l+r)>>1;
    t[b].ls=uni(t[a].ls,t[b].ls,l,mid);
    t[b].rs=uni(t[a].rs,t[b].rs,mid+1,r);
    pushup(b);
    return b;
}
ll Qkth(ll k,un num,un l=1,un r=n)//权值线段树上求k-th
{
    if(l==r)return l;
    un mid=(l+r)>>1;
    if(k<=t[t[num].ls].v)return Qkth(k,t[num].ls,l,mid);
    else return Qkth(k-t[t[num].ls].v,t[num].rs,mid+1,r);
}
ll v[MAXN],num[MAXN];//重要度排名;重要度排名所对应的点的编号
//main内有一些debug语句,忽略即可
int main()
{
    //freopen("out.out","w",stdout);
    n=read(),m=read();
    s.build(n);
    cnt=n;//我这里用了一个技巧,把i表示的线段树的编号就设为i
    for(ll i=1;i<=n;++i)
    {
        v[i]=read();
        num[v[i]]=i;
        modify(v[i],1,i);//插入自己的重要度
    }
    for(ll i=1;i<=m;++i)
    {
        ll a=s.find(read()),b=s.find(read());//合并的是并查集上的根节点
        if(a==b)continue;//同一集合内不用合并
        s.uni(a,b);//并查集上合并
        uni(a,b);//线段树上合并
    }
    q=read();
    for(ll i=1;i<=q;++i)
    {
        char op=getchar();
        while(op!='B'&&op!='Q')op=getchar();
        //printf("task %d:",i);
        if(op=='B')
        {
            ll a=s.find(read()),b=s.find(read());
            //printf("a=%d,size=%d;b=%d,size=%d\n",a,t[a].v,b,t[b].v);
            if(a==b)continue;//同一集合内不用合并
            s.uni(a,b);//并查集上合并
            uni(a,b);//线段树上合并
            //printf("unisize=%d\n",t[b].v);
        }
        else
        {
            ll a=s.find(read()),k=read();//权值线段树上求k-th
            //printf("Query %d,size=%d\n",a,t[a].v);
            if(k>t[a].v)printf("-1\n");
            else printf("%d\n",num[Qkth(k,a)]);
        }
        //printf("pass %lld...\n",i);
    }
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/5020/
   。

/*
 *
 * 用并查集维护节点之间的连通关系，同一个连通块中的节点全部用
 * 一个Splay实例维护，利用Splay来获取第k小数据
 * 合并两个Splay的数据时候，注意小的树往大的树上合并
 *
 */

#include <string.h>
#include <iostream>
#include <stdio.h>
#include <algorithm>
using namespace std;

class MergeSet {
private:
    int __max_node_num;
    int* __buf;

public:
    MergeSet(int max_node_num) : __max_node_num(max_node_num) {
        __buf = new int[__max_node_num+1];
        memset(__buf, 0, sizeof(int) * (__max_node_num+1));
        for (int node = 1; node <= max_node_num; node++) {
            __buf[node] = node;
        }
    }

    ~MergeSet() {
        delete[] __buf;
        __buf = nullptr;
    }

    bool check_in_same_set(int a, int b) {
        return __find(a) != 0 && __find(a) == __find(b);
    }

    void merge(int a, int b) {
        __buf[__find(a)] = __find(b);
    }

    // 返回节点的最高层祖先编号
    int get_root(int node) {
        return __find(node);
    }

private:
    // 找x的祖先节点编号
    int __find(int x) {
        if (__buf[x] == x) {
            return x;
        }

        __buf[x] = __find(__buf[x]);
        return __buf[x];
    }
};

#define     MAX_SPLAY_NODE_NUM      2000000
struct Node {
    int child[2];       // 左右子节点编号
    int parent;         // 父节点编号
    int val;            // 节点数值
    int size;           // 子树大小
    int flag;           // 懒标记

    void init(int p, int v) {
        child[0] = child[1] = 0;
        parent = p;
        val = v;
        size = 1;
        flag = 0;
    }
} __splay_node_pool[MAX_SPLAY_NODE_NUM];
int __splay_pool_pos = 1;


class SplayTree {
private:
    int __root;             // 根节点编号
    Node* __pool;           // 对象池
    int& __pool_pos;        // 对象池最后一个分配位置

    class __init_guard {
    public:
        __init_guard() {
            __splay_node_pool[0].init(0, 0);
            __splay_node_pool[0].size = 0;
        }
    };

    static __init_guard __guard;

public:
    SplayTree() : __pool_pos(__splay_pool_pos), __root(0), __pool(__splay_node_pool) {

    }

    // 翻转懒标记
    void rev_flag(int idx) {
        __pool[idx].flag ^= 1;
    }

    int get_left_child(int idx) {
        return __pool[idx].child[0];
    }

    int get_right_child(int idx) {
        return __pool[idx].child[1];
    }

    int get_root() {
        return __root;
    }

    // 搬移函数，将编号为x的节点通过旋转搬移到k号节点的下面
    void move(int x, int k) {
        __move(x, k);
    }

    // 插入数值是val的节点
    void insert(int val) {
        int u = __root, p = 0;
        while (u != 0) {
            p = u;
            u = __pool[u].child[val > __pool[u].val];
        }

        u = __pool_pos++;

        if (p != 0) {
            __pool[p].child[val > __pool[p].val] = u;
        }

        __pool[u].init(p, val);

        while (p) {
            __push_up(p);
            p = __pool[p].parent;
        }

        __move(u, 0);
    }

    // 获取排名k的节点编号，返回0表示无解
    int get_kth_idx(int k) {
        int u = __root;
        while (u) {
            __push_down(u);

            if (__pool[__pool[u].child[0]].size >= k) {
                u = __pool[u].child[0];
            } else if (__pool[__pool[u].child[0]].size + 1 == k) {
                return u;
            } else {
                k -= __pool[__pool[u].child[0]].size + 1;
                u = __pool[u].child[1];
            }
        }

        return 0;
    }

    void get_mid_travel_list(int* ans) {
        int pos = 0;
        __get_mid_travel_list(__root, pos, ans);
    }

    // 返回第一个数值大于等于val的节点编号, 返回0无解
    int lower_bound(int node, int val) {
        if (node == 0) {
            return 0;
        }

        if (val <= __pool[node].val) {
            int idx = lower_bound(__pool[node].child[0], val);
            if (idx != 0) {
                return idx;
            }
            return node;
        } else {
            return lower_bound(__pool[node].child[1], val);
        }
    }

    // 删除子树
    void del_sub_tree(int node) {
        Node& parent_node = __pool[__pool[node].parent];
        int p = __pool[node].parent;

        if (parent_node.child[0] == node) {
            parent_node.child[0] = 0;
        } else {
            parent_node.child[1] = 0;
        }

        while (p) {
            __push_up(p);
            p = __pool[p].parent;
        }
    }

    // 获取数值
    int get_val(int idx) {
        return __pool[idx].val;
    }

    // 获取树大小
    int get_tree_size() {
        return __pool[__root].size;
    }

    // 合并另外一个树所有节点，另外的树不变
    void merge(SplayTree& other) {
        __merge(other.__pool, other.__root);
    }


private:
    // 信息上传函数(即根据子节点信息更新序号是idx的节点的信息)
    void __push_up(int idx) {
        Node& node = __pool[idx];
        node.size = 1 + __pool[node.child[0]].size + __pool[node.child[1]].size;
    }

    /******* 此处 __flag_oper  __push_down_child_flag 两个函数的逻辑需要根据不同的问题场景进行修改 **********/

    // 懒标记对应的操作，默认什么操作也没有，具体使用时候在此处添加操作
    void __flag_oper(int idx) {

    }

    // 修改子节点的标记函数，默认就是将标记下传，不同问题可能有不同处理方式，这里把逻辑提出来
    void __push_down_child_flag(int idx) {

    }

    // 懒标记下移操作
    void __push_down(int idx) {
        if (__pool[idx].flag) {
            __flag_oper(idx);
            __push_down_child_flag(idx);
            __pool[idx].flag = 0;
        }
    }

    // 统一的左旋和右旋函数，将编号为x对应的节点网上一层旋转
    void __rotate(int x) {
        int y = __pool[x].parent, z = __pool[y].parent;
        int k1 = __pool[y].child[1] == x, k2 = __pool[z].child[1] == y;
        __pool[z].child[k2] = x;
        __pool[x].parent = z;
        __pool[y].child[k1] = __pool[x].child[k1^1];
        __pool[__pool[x].child[k1^1]].parent = y;
        __pool[x].child[k1^1] = y;
        __pool[y].parent = x;

        __push_up(y);
        __push_up(x);
    }

    // 搬移函数，将编号为x的节点通过旋转搬移到k号节点的下面
    // k = 0 表示将x节点搬移到根节点位置
    void __move(int x, int k) {
        while (__pool[x].parent != k) {
            int y = __pool[x].parent, z = __pool[y].parent;
            if (z != k) {
                if ( (__pool[y].child[1] == x) != (__pool[z].child[1] == y) ) {
                    __rotate(x);
                } else {
                    __rotate(y);
                }
            }
            __rotate(x);
        }

        if (k == 0) {
            __root = x;
        }
    }

    void __get_mid_travel_list(int cur, int& pos, int* ans) {
        if (cur == 0) {
            return;
        }

        __push_down(cur);

        __get_mid_travel_list(__pool[cur].child[0], pos, ans);
        ans[pos++] = __pool[cur].val;
        __get_mid_travel_list(__pool[cur].child[1], pos, ans);
    }

    // 合并另外一棵树的子树的所有节点
    void __merge(Node* pool, int node) {
        if (node == 0) {
            return;
        }

        insert(pool[node].val);
        __merge(pool, pool[node].child[0]);
        __merge(pool, pool[node].child[1]);
    }
};
SplayTree::__init_guard SplayTree::__guard;


int node2imp[300005];       // 节点到重要度映射
int imp2node[300005];       // 重要度到节点映射
SplayTree* tree_ptr_buf[300005];

void build_bridge(MergeSet& merge_set, int a, int b) {
    int imp_a = node2imp[a], imp_b = node2imp[b];

    if (!merge_set.check_in_same_set(imp_a, imp_b)) {
        int size_a = tree_ptr_buf[merge_set.get_root(imp_a)]->get_tree_size();
        int size_b = tree_ptr_buf[merge_set.get_root(imp_b)]->get_tree_size();

        if (size_a < size_b) {
            tree_ptr_buf[merge_set.get_root(imp_b)]->merge(*tree_ptr_buf[merge_set.get_root(imp_a)]);
            merge_set.merge(imp_a, imp_b);

        } else {
            tree_ptr_buf[merge_set.get_root(imp_a)]->merge(*tree_ptr_buf[merge_set.get_root(imp_b)]);
            merge_set.merge(imp_b, imp_a);
        }
    }
}

int main() {
    //freopen("/Users/grh/Programming/CLionProjects/Test/data.txt", "r", stdin);

    int n, m, imp;
    scanf("%d %d", &n, &m);

    for (int i = 1; i <= n; i++) {
        scanf("%d", &imp);
        imp2node[imp] = i;
        node2imp[i] = imp;

        tree_ptr_buf[imp] = new SplayTree();
        tree_ptr_buf[imp]->insert(imp);
    }

    int a, b;
    MergeSet merge_set(n);

    for (int i = 0; i < m; i++) {
        scanf("%d %d", &a, &b);
        if (! (a >= 1 and b >= 1 and a <= n and b <= n) ) {
            continue;
        }

        build_bridge(merge_set, a, b);

    }

    int cmd_num;
    char cmd[2];
    scanf("%d", &cmd_num);
    for (int i = 0; i < cmd_num; i++) {
        scanf("%s %d %d", cmd, &a, &b);
        if (cmd[0] == 'B') {
            if (! (a >= 1 and b >= 1 and a <= n and b <= n) ) {
                continue;
            }
            build_bridge(merge_set, a, b);
        } else {
            imp = node2imp[a];

            int idx = tree_ptr_buf[merge_set.get_root(imp)]->get_kth_idx(b);

            if (idx != 0) {
                imp = tree_ptr_buf[merge_set.get_root(imp)]->get_val(idx);

                printf("%d\n", imp2node[imp]);
            } else {
                printf("-1\n");
            }
        }
    }

    for (int i = 1; i <= n; i++) {
        delete tree_ptr_buf[i];
        tree_ptr_buf[i] = nullptr;
    }

    return 0;
}


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21752/
   。
#include <string.h>
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <queue>
using namespace std;


#define     MAX_SPLAY_NODE_NUM      (500000*10)
#define     INVALID                 0x7fffffff

struct Node {
    int child[2];       // 左右子节点编号
    int parent;         // 父节点编号
    int val;            // 节点数值
    int size;           // 子树大小
    int rev_flag;       // 懒标记用于翻转
    int val_flag;       // 赋值标记，用于批量赋值

    int lsum;           // 子树对应序列的最大前缀和
    int rsum;           // 子树对应序列的最大后缀和
    int sum;            // 子树对应的序列的总和
    int max_sum;        // 最大子段和

    void init(int p, int v) {
        child[0] = child[1] = 0;
        parent = p;
        val = v;
        size = 1;

        rev_flag = 0;
        val_flag = INVALID;
        sum = v;
        lsum = rsum = max_sum = v;
    }
} __splay_node_pool[MAX_SPLAY_NODE_NUM];
int __splay_pool_pos = 1;


class SplayTree {
private:
    int __root;             // 根节点编号
    Node* __pool;           // 对象池
    int& __pool_pos;        // 对象池最后一个分配位置

    class __init_guard {
    public:
        __init_guard() {
            __splay_node_pool[0].init(0, 0);
            __splay_node_pool[0].size = 0;
            __splay_node_pool[0].sum = 0;
            __splay_node_pool[0].lsum = __splay_node_pool[0].rsum = __splay_node_pool[0].max_sum = -1e9;
        }
    };

    static __init_guard __guard;

public:
    SplayTree() : __pool_pos(__splay_pool_pos), __root(0), __pool(__splay_node_pool) {

    }

    SplayTree(int* data, int data_len) : __pool_pos(__splay_pool_pos), __root(0), __pool(__splay_node_pool) {
        __root = __build_tree(data, 0, data_len-1, 0);
    }

    // 在第k个节点后面插入序列
    void insert(int k, int* data, int data_len) {
        if (k > get_tree_size() || k <= 0 || data == nullptr || data_len == 0) {
            return;
        }

        int idx1 = get_kth_idx(k), idx2 = get_kth_idx(k + 1);
        int sub_root = __build_tree(data, 0, data_len-1, 0);
        __move(idx1, 0);
        __move(idx2, idx1);
        __pool[idx2].child[0] = sub_root;
        __pool[sub_root].parent = idx2;
        __push_up(idx2);
        __push_up(idx1);
    }

    // 从第k1个节点开始到第k2个节点删掉
    void delete_nodes(int k1, int k2) {
        if (k1 <= 0 || k1 > get_tree_size() || k2 <= 0 || k2 > get_tree_size()) {
            return;
        }

        int idx1 = get_kth_idx(k1-1), idx2 = get_kth_idx(k2+1);
        __move(idx1, 0);
        __move(idx2, idx1);
        __pool[idx2].child[0] = 0;
        __push_up(idx2);
        __push_up(idx1);
    }

    // 从第k1个节点到第k2个节点赋值为val
    void set_ndoes_val(int k1, int k2, int val) {
        if (k1 <= 0 || k1 > get_tree_size() || k2 <= 0 || k2 > get_tree_size()) {
            return;
        }

        int idx1 = get_kth_idx(k1-1), idx2 = get_kth_idx(k2+1);
        __move(idx1, 0);
        __move(idx2, idx1);

        Node& node = __pool[__pool[idx2].child[0]];
        node.val_flag = val;
        node.val = val;
        node.sum = val * node.size;

        if (val >= 0) {
            node.max_sum = node.lsum = node.rsum = val * node.size;
        } else {
            node.max_sum = node.lsum = node.rsum = val;
        }

        __push_up(idx2);
        __push_up(idx1);
    }

    // 从第k1节点到第k2节点翻转
    void rev_nodes(int k1, int k2) {
        if (k1 <= 0 || k1 > get_tree_size() || k2 <= 0 || k2 > get_tree_size()) {
            return;
        }

        int idx1 = get_kth_idx(k1-1), idx2 = get_kth_idx(k2+1);
        __move(idx1, 0);
        __move(idx2, idx1);
        Node& node = __pool[__pool[idx2].child[0]];

        node.rev_flag ^= 1;
        swap(node.child[0], node.child[1]);
        swap(node.lsum, node.rsum);


        __push_up(idx2);
        __push_up(idx1);
    }

    // 从第k1个节点到第k2个节点求和
    int get_sum(int k1, int k2){
        if (k1 <= 0 || k1 > get_tree_size() || k2 <= 0 || k2 > get_tree_size()) {
            return 0;
        }

        int idx1 = get_kth_idx(k1-1), idx2 = get_kth_idx(k2+1);
        __move(idx1, 0);
        __move(idx2, idx1);
        return __pool[__pool[idx2].child[0]].sum;
    }

    // 最大子段和
    int get_max_sum(int k1, int k2) {
        if (k1 <= 0 || k1 > get_tree_size() || k2 <= 0 || k2 > get_tree_size()) {
            return 0;
        }

        int idx1 = get_kth_idx(k1-1), idx2 = get_kth_idx(k2+1);
        __move(idx1, 0);
        __move(idx2, idx1);
        return __pool[__pool[idx2].child[0]].max_sum;
    }

    // 获取排名k的节点编号，返回0表示无解
    int get_kth_idx(int k) {
        int u = __root;
        while (u) {
            __push_down(u);

            if (__pool[__pool[u].child[0]].size >= k) {
                u = __pool[u].child[0];
            } else if (__pool[__pool[u].child[0]].size + 1 == k) {
                return u;
            } else {
                k -= __pool[__pool[u].child[0]].size + 1;
                u = __pool[u].child[1];
            }
        }

        return 0;
    }

    // 获取树大小
    int get_tree_size() {
        return __pool[__root].size;
    }

private:
    // 信息上传函数, 用子节点最新属性更新idx节点最新属性
    void __push_up(int idx) {
        Node& node = __pool[idx];
        int l = node.child[0], r = node.child[1];

        node.size = 1 + __pool[l].size + __pool[r].size;
        node.lsum = max(__pool[l].lsum, __pool[l].sum + node.val + __pool[r].lsum);
        node.lsum = max(node.lsum, __pool[l].sum + node.val);
        node.rsum = max(__pool[r].rsum, __pool[r].sum + node.val + __pool[l].rsum);
        node.rsum = max(node.rsum, __pool[r].sum + node.val);
        node.sum = __pool[l].sum + node.val + __pool[r].sum;

        node.max_sum = node.val;
        node.max_sum = max(node.max_sum, __pool[l].max_sum);
        node.max_sum = max(node.max_sum, __pool[r].max_sum);
        node.max_sum = max(node.max_sum, __pool[l].rsum + node.val);
        node.max_sum = max(node.max_sum, __pool[r].lsum + node.val);
        node.max_sum = max(node.max_sum, __pool[l].rsum + node.val + __pool[r].lsum);
    }


    // 清空标记
    void __clear_flag(int idx) {
        __pool[idx].rev_flag = 0;
        __pool[idx].val_flag = INVALID;
    }

    // 懒标记下移操作
    void __push_down(int idx) {
        Node& lnode = __pool[__pool[idx].child[0]];
        Node& rnode = __pool[__pool[idx].child[1]];
        Node& node = __pool[idx];
        int val = __pool[idx].val_flag;

        int lidx = __pool[idx].child[0], ridx = __pool[idx].child[1];
        if (node.val_flag != INVALID) {
            node.val_flag = INVALID;
            node.rev_flag = 0;

            if (lidx) {
                lnode.val_flag = val; lnode.val = val; lnode.sum = val * lnode.size;
                if (val >= 0) {
                    lnode.max_sum = lnode.lsum = lnode.rsum = lnode.sum;
                } else {
                    lnode.max_sum = lnode.lsum = lnode.rsum = lnode.val;
                }
            }

            if (ridx) {
                rnode.val_flag = val; rnode.val = val; rnode.sum = val * rnode.size;
                if (val >= 0) {
                    rnode.max_sum = rnode.lsum = rnode.rsum = rnode.sum;
                } else {
                    rnode.max_sum = rnode.lsum = rnode.rsum = rnode.val;
                }
            }
        } else if (node.rev_flag) {
            node.rev_flag = 0;
            if (lidx) {
                lnode.rev_flag ^= 1;
                swap(lnode.child[0], lnode.child[1]);
                swap(lnode.lsum, lnode.rsum);
            }

            if (ridx) {
                rnode.rev_flag ^= 1;
                swap(rnode.child[0], rnode.child[1]);
                swap(rnode.lsum, rnode.rsum);
            }
        }
    }

    // 统一的左旋和右旋函数，将编号为x对应的节点往上一层旋转
    void __rotate(int x) {
        int y = __pool[x].parent, z = __pool[y].parent;
        int k1 = __pool[y].child[1] == x, k2 = __pool[z].child[1] == y;
        __pool[z].child[k2] = x;
        __pool[x].parent = z;
        __pool[y].child[k1] = __pool[x].child[k1^1];
        __pool[__pool[x].child[k1^1]].parent = y;
        __pool[x].child[k1^1] = y;
        __pool[y].parent = x;

        __push_up(y);
        __push_up(x);
    }

    // 搬移函数，将编号为x的节点通过旋转搬移到k号节点的下面
    // k = 0 表示将x节点搬移到根节点位置
    void __move(int x, int k) {
        while (__pool[x].parent != k) {
            int y = __pool[x].parent, z = __pool[y].parent;
            if (z != k) {
                if ( (__pool[y].child[1] == x) != (__pool[z].child[1] == y) ) {
                    __rotate(x);
                } else {
                    __rotate(y);
                }
            }
            __rotate(x);
        }

        if (k == 0) {
            __root = x;
        }
    }

    // 根据序列构建树, 返回树根的序号
    int __build_tree(int* data, int start, int end, int parent) {
        if (data == nullptr || end < start) {
            return 0;
        }

        Node* pool = __splay_node_pool;
        int& pool_pos = __splay_pool_pos;

        if (start == end) {
            int u = pool_pos++;
            pool[u].init(parent, data[start]);

            pool[u].sum = data[start];
            pool[u].lsum = pool[u].rsum = pool[u].max_sum = data[start];

            return u;
        }

        int u = pool_pos++;
        int mid = (start + end) >> 1;
        pool[u].init(parent, data[mid]);

        pool[u].child[0] = __build_tree(data, start, mid - 1, u);
        pool[u].child[1] = __build_tree(data, mid+1, end, u);

        __push_up(u);

        return u;
    }

};
SplayTree::__init_guard SplayTree::__guard;

int buf[500005];

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    for (int i = 1; i < n+1; i++) {
        scanf("%d", buf + i);
    }

    // 前后两个哨兵
    buf[0] = -1e9;
    buf[n+1] = -1e9;

    SplayTree tree(buf, n+2);

    char cmd[100];
    for (int i = 0; i < m; i++) {
        scanf("%s", cmd);
        if (strcmp(cmd, "INSERT") == 0) {
            int k, num;
            scanf("%d %d", &k, &num);
            for (int j = 0; j < num; j++) {
                scanf("%d", buf + j);
            }

            if (k+1 >= 1 and k+1 <= tree.get_tree_size()-1) {
                tree.insert(k + 1, buf, num);
            }

        } else if (strcmp(cmd, "DELETE") == 0) {
            int k, num;
            scanf("%d %d", &k, &num);
            int start = k+1;
            int end = min(start + num - 1, tree.get_tree_size()-1);

            if (start <= end) {
                tree.delete_nodes(start, end);
            }

        } else if (strcmp(cmd, "MAKE-SAME") == 0) {
            int k, num, val;
            scanf("%d %d %d", &k, &num, &val);
            int start = k+1;
            int end = min(start + num - 1, tree.get_tree_size()-1);

            if (start <= end) {
                tree.set_ndoes_val(start, end, val);
            }


        } else if (strcmp(cmd, "REVERSE") == 0) {
            int k, num;
            scanf("%d %d", &k, &num);
            int start = k+1;
            int end = min(start + num - 1, tree.get_tree_size()-1);

            if (start <= end) {
                tree.rev_nodes(start, end);
            }

        } else if (strcmp(cmd, "GET-SUM") == 0) {
            int k, num;
            scanf("%d %d", &k, &num);
            int start = k+1;
            int end = min(start + num - 1, tree.get_tree_size()-1);

            printf("%d\n", tree.get_sum(start, end));

        } else if (strcmp(cmd, "MAX-SUM") == 0) {
            printf("%d\n", tree.get_max_sum(2, tree.get_tree_size()-1));
        }
    }

    return 0;
}


作者：皓首不倦
链接：https://www.acwing.com/solution/content/21847/
   。

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 500010, INF = 1e9;

int n, m;
struct Node
{
    int s[2], p, v;
    int rev, same;
    int size, sum, ms, ls, rs;

    void init(int _v, int _p)
    {
        s[0] = s[1] = 0, p = _p, v = _v;
        rev = same = 0;
        size = 1, sum = ms = v;
        ls = rs = max(v, 0);
    }
}tr[N];
int root, nodes[N], tt;
int w[N];

void pushup(int x)
{
    auto &u = tr[x], &l = tr[u.s[0]], &r = tr[u.s[1]];
    u.size = l.size + r.size + 1;
    u.sum = l.sum + r.sum + u.v;
    u.ls = max(l.ls, l.sum + u.v + r.ls);
    u.rs = max(r.rs, r.sum + u.v + l.rs);
    u.ms = max(max(l.ms, r.ms), l.rs + u.v + r.ls);
}

void pushdown(int x)
{
    auto &u = tr[x], &l = tr[u.s[0]], &r = tr[u.s[1]];
    if (u.same)
    {
        u.same = u.rev = 0;
        if (u.s[0]) l.same = 1, l.v = u.v, l.sum = l.v * l.size;
        if (u.s[1]) r.same = 1, r.v = u.v, r.sum = r.v * r.size;
        if (u.v > 0)
        {
            if (u.s[0]) l.ms = l.ls = l.rs = l.sum;
            if (u.s[1]) r.ms = r.ls = r.rs = r.sum;
        }
        else
        {
            if (u.s[0]) l.ms = l.v, l.ls = l.rs = 0;
            if (u.s[1]) r.ms = r.v, r.ls = r.rs = 0;
        }
    }
    else if (u.rev)
    {
        u.rev = 0, l.rev ^= 1, r.rev ^= 1;
        swap(l.ls, l.rs), swap(r.ls, r.rs);
        swap(l.s[0], l.s[1]), swap(r.s[0], r.s[1]);
    }
}

void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay(int x, int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
    if (!k) root = x;
}

int get_k(int k)
{
    int u = root;
    while (u)
    {
        pushdown(u);
        if (tr[tr[u].s[0]].size >= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].size + 1 == k) return u;
        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
    }
}

int build(int l, int r, int p)
{
    int mid = l + r >> 1;
    int u = nodes[tt -- ];
    tr[u].init(w[mid], p);
    if (l < mid) tr[u].s[0] = build(l, mid - 1, u);
    if (mid < r) tr[u].s[1] = build(mid + 1, r, u);
    pushup(u);
    return u;
}

void dfs(int u)
{
    if (tr[u].s[0]) dfs(tr[u].s[0]);
    if (tr[u].s[1]) dfs(tr[u].s[1]);
    nodes[ ++ tt] = u;
}

int main()
{
    for (int i = 1; i < N; i ++ ) nodes[ ++ tt] = i;
    scanf("%d%d", &n, &m);
    tr[0].ms = w[0] = w[n + 1] = -INF;
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    root = build(0, n + 1, 0);

    char op[20];
    while (m -- )
    {
        scanf("%s", op);
        if (!strcmp(op, "INSERT"))
        {
            int posi, tot;
            scanf("%d%d", &posi, &tot);
            for (int i = 0; i < tot; i ++ ) scanf("%d", &w[i]);
            int l = get_k(posi + 1), r = get_k(posi + 2);
            splay(l, 0), splay(r, l);
            int u = build(0, tot - 1, r);
            tr[r].s[0] = u;
            pushup(r), pushup(l);
        }
        else if (!strcmp(op, "DELETE"))
        {
            int posi, tot;
            scanf("%d%d", &posi, &tot);
            int l = get_k(posi), r = get_k(posi + tot + 1);
            splay(l, 0), splay(r, l);
            dfs(tr[r].s[0]);
            tr[r].s[0] = 0;
            pushup(r), pushup(l);
        }
        else if (!strcmp(op, "MAKE-SAME"))
        {
            int posi, tot, c;
            scanf("%d%d%d", &posi, &tot, &c);
            int l = get_k(posi), r = get_k(posi + tot + 1);
            splay(l, 0), splay(r, l);
            auto& son = tr[tr[r].s[0]];
            son.same = 1, son.v = c, son.sum = c * son.size;
            if (c > 0) son.ms = son.ls = son.rs = son.sum;
            else son.ms = c, son.ls = son.rs = 0;
            pushup(r), pushup(l);
        }
        else if (!strcmp(op, "REVERSE"))
        {
            int posi, tot;
            scanf("%d%d", &posi, &tot);
            int l = get_k(posi), r = get_k(posi + tot + 1);
            splay(l, 0), splay(r, l);
            auto& son = tr[tr[r].s[0]];
            son.rev ^= 1;
            swap(son.ls, son.rs);
            swap(son.s[0], son.s[1]);
            pushup(r), pushup(l);
        }
        else if (!strcmp(op, "GET-SUM"))
        {
            int posi, tot;
            scanf("%d%d", &posi, &tot);
            int l = get_k(posi), r = get_k(posi + tot + 1);
            splay(l, 0), splay(r, l);
            printf("%d\n", tr[tr[r].s[0]].sum);
        }
        else printf("%d\n", tr[root].ms);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/479402/
   。

#include <stdio.h>
#include <algorithm>
#include <set>
#include <iostream>
using namespace std;


struct Data {
    multiset<long long> s;          // 区间总和
};

struct Node {
    int start;          // 区间开始位置
    int end;            // 区间结束位置
    Data data;          // 区间数据
}__global_nodes[100005*4] ;


class SegmentTree {
private:
    Node* __nodes;      // 节点数组
    int __n;            // 区间为0到n-1

    // 下沉lazy标记
    void __push_down_lazy(int node_idx) {

    }

    // 更新单个位置的数值
    void __update_single(int node_idx, int pos, long long val, long long old_val) {
        Node& node = __nodes[node_idx];

        auto itr = node.data.s.find(old_val);
        if (itr != node.data.s.end()) {
            node.data.s.erase(itr);
        }
        node.data.s.insert(val);

        if (node.start == node.end) {
            return;
        }

        __push_down_lazy(node_idx);

        int mid = (node.start + node.end) >> 1;
        if (pos <= mid) {
            __update_single(node_idx*2+1, pos, val, old_val);
        } else {
            __update_single(node_idx*2+2, pos, val, old_val);
        }
    }

    // 获取区间统计信息
    long long __get_val(int node_idx, int start, int end, int val) {
        Node& node = __nodes[node_idx];
        if (node.start == start && node.end == end) {
            auto itr = node.data.s.lower_bound(val);
            if (itr != node.data.s.begin()) {
                --itr;
                return *itr;
            }

            return -0x7fffffff;
        }

        __push_down_lazy(node_idx);

        int mid = (node.start + node.end) >> 1;
        if (end <= mid) {
            return __get_val(node_idx*2+1, start, end, val);
        } else if (start >= mid+1) {
            return __get_val(node_idx*2+2, start, end, val);
        } else {
            long long val1 = __get_val(node_idx*2+1, start, mid, val);
            long long val2 = __get_val(node_idx*2+2, mid+1, end, val);
            return max(val1, val2);
        }
    }

public:
    SegmentTree(int n, Node* pnodes, int* data) {
        __n = n;
        __nodes = pnodes;
        __nodes[0] = {0, n-1, {}};
        for (int i = 0; i < n; i++) {
            __nodes[0].data.s.insert(data[i]);
        }

        for (int i = 0; i < __n << 2; i++) {
            if (__nodes[i].start == __nodes[i].end and __nodes[i].end == __n-1) {
                break;
            }

            int mid = (__nodes[i].start + __nodes[i].end) / 2;
            __nodes[i*2+1] = {__nodes[i].start, mid, {}};
            for (int j = __nodes[i*2+1].start; j <= __nodes[i*2+1].end; j++) {
                __nodes[i*2+1].data.s.insert(data[j]);
            }

            __nodes[i*2+2] = {mid+1, __nodes[i].end, {}};
            for (int j = __nodes[i*2+2].start; j <= __nodes[i*2+2].end; j++) {
                __nodes[i*2+2].data.s.insert(data[j]);
            }

        }
    }

    // 更新单个数据接口
    void update_single(int pos, long long val, long long old_val) {
        __update_single(0, pos, val, old_val);
    }

    // 获取区间统计数据接口
    long long get_val(int start, int end, int val) {
        return __get_val(0, start, end, val);
    }
};


int arr[50005];


int main(void) {

    //freopen("/Users/grh/Programming/CLionProjects/Test/data.txt", "r", stdin);

    int n, m;
    scanf("%d %d", &n, &m);

    for (int i = 0; i < n; i++) {
        scanf("%d", arr + i);
    }
    SegmentTree tree(n, __global_nodes, arr);

    int cmd, l, r, pos, x, old_val;
    while (m--) {
        scanf("%d", &cmd);
        if (cmd == 1) {
            scanf("%d %d", &pos, &x);
            old_val = arr[pos-1];
            arr[pos-1] = x;
            tree.update_single(pos-1, x, old_val);
        } else {
            scanf("%d %d %d", &l, &r, &x);
            printf("%lld\n", tree.get_val(l-1, r-1, x));
        }

    }

    return 0;
}



作者：皓首不倦
链接：https://www.acwing.com/solution/content/21870/
   。

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <set>

using namespace std;

const int N = 50010, M = N * 4, INF = 1e9;

int n, m;
struct Tree
{
    int l, r;
    multiset<int> s;
}tr[M];
int w[N];

void build(int u, int l, int r)
{
    tr[u] = {l, r};
    tr[u].s.insert(-INF), tr[u].s.insert(INF);
    for (int i = l; i <= r; i ++ ) tr[u].s.insert(w[i]);
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

void change(int u, int p, int x)
{
    tr[u].s.erase(tr[u].s.find(w[p]));
    tr[u].s.insert(x);
    if (tr[u].l == tr[u].r) return;
    int mid = tr[u].l + tr[u].r >> 1;
    if (p <= mid) change(u << 1, p, x);
    else change(u << 1 | 1, p, x);
}

int query(int u, int a, int b, int x)
{
    if (tr[u].l >= a && tr[u].r <= b)
    {
        auto it = tr[u].s.lower_bound(x);
        --it;
        return *it;
    }
    int mid = tr[u].l + tr[u].r >> 1, res = -INF;
    if (a <= mid) res = max(res, query(u << 1, a, b, x));
    if (b > mid) res = max(res, query(u << 1 | 1, a, b, x));
    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    build (1, 1, n);

    while (m -- )
    {
        int op, a, b, x;
        scanf("%d", &op);
        if (op == 1)
        {
            scanf("%d%d", &a, &x);
            change(1, a, x);
            w[a] = x;
        }
        else
        {
            scanf("%d%d%d", &a, &b, &x);
            printf("%d\n", query(1, a, b, x));
        }
    }
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/488897/
   。

AcWing 2476. 树套树
作者：    yxc ,  2020-09-18 20:08:00 ,  阅读 60

4


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1500010, INF = 1e9;

int n, m;
struct Node
{
    int s[2], p, v;
    int size;

    void init(int _v, int _p)
    {
        v = _v, p = _p;
        size = 1;
    }
}tr[N];
int L[N], R[N], T[N], idx;
int w[N];

void pushup(int x)
{
    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;
}

void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay(int& root, int x, int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
    if (!k) root = x;
}

void insert(int& root, int v)
{
    int u = root, p = 0;
    while (u) p = u, u = tr[u].s[v > tr[u].v];
    u = ++ idx;
    if (p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(v, p);
    splay(root, u, 0);
}

int get_k(int root, int v)
{
    int u = root, res = 0;
    while (u)
    {
        if (tr[u].v < v) res += tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    return res;
}

void update(int& root, int x, int y)
{
    int u = root;
    while (u)
    {
        if (tr[u].v == x) break;
        if (tr[u].v < x) u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    splay(root, u, 0);
    int l = tr[u].s[0], r = tr[u].s[1];
    while (tr[l].s[1]) l = tr[l].s[1];
    while (tr[r].s[0]) r = tr[r].s[0];
    splay(root, l, 0), splay(root, r, l);
    tr[r].s[0] = 0;
    pushup(r), pushup(l);
    insert(root, y);
}

void build(int u, int l, int r)
{
    L[u] = l, R[u] = r;
    insert(T[u], -INF), insert(T[u], INF);
    for (int i = l; i <= r; i ++ ) insert(T[u], w[i]);
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

int query(int u, int a, int b, int x)
{
    if (L[u] >= a && R[u] <= b) return get_k(T[u], x) - 1;
    int mid = L[u] + R[u] >> 1, res = 0;
    if (a <= mid) res += query(u << 1, a, b, x);
    if (b > mid) res += query(u << 1 | 1, a, b, x);
    return res;
}

void change(int u, int p, int x)
{
    update(T[u], w[p], x);
    if (L[u] == R[u]) return;
    int mid = L[u] + R[u] >> 1;
    if (p <= mid) change(u << 1, p, x);
    else change(u << 1 | 1, p, x);
}

int get_pre(int root, int v)
{
    int u = root, res = -INF;
    while (u)
    {
        if (tr[u].v < v) res = max(res, tr[u].v), u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    return res;
}

int get_suc(int root, int v)
{
    int u = root, res = INF;
    while (u)
    {
        if (tr[u].v > v) res = min(res, tr[u].v), u = tr[u].s[0];
        else u = tr[u].s[1];
    }
    return res;
}

int query_pre(int u, int a, int b, int x)
{
    if (L[u] >= a && R[u] <= b) return get_pre(T[u], x);
    int mid = L[u] + R[u] >> 1, res = -INF;
    if (a <= mid) res = max(res, query_pre(u << 1, a, b, x));
    if (b > mid) res = max(res, query_pre(u << 1 | 1, a, b, x));
    return res;
}

int query_suc(int u, int a, int b, int x)
{
    if (L[u] >= a && R[u] <= b) return get_suc(T[u], x);
    int mid = L[u] + R[u] >> 1, res = INF;
    if (a <= mid) res = min(res, query_suc(u << 1, a, b, x));
    if (b > mid) res = min(res, query_suc(u << 1 | 1, a, b, x));
    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    build(1, 1, n);

    while (m -- )
    {
        int op, a, b, x;
        scanf("%d", &op);
        if (op == 1)
        {
            scanf("%d%d%d", &a, &b, &x);
            printf("%d\n", query(1, a, b, x) + 1);
        }
        else if (op == 2)
        {
            scanf("%d%d%d", &a, &b, &x);
            int l = 0, r = 1e8;
            while (l < r)
            {
                int mid = l + r + 1 >> 1;
                if (query(1, a, b, mid) + 1 <= x) l = mid;
                else r = mid - 1;
            }
            printf("%d\n", r);
        }
        else if (op == 3)
        {
            scanf("%d%d", &a, &x);
            change(1, a, x);
            w[a] = x;
        }
        else if (op == 4)
        {
            scanf("%d%d%d", &a, &b, &x);
            printf("%d\n", query_pre(1, a, b, x));
        }
        else
        {
            scanf("%d%d%d", &a, &b, &x);
            printf("%d\n", query_suc(1, a, b, x));
        }
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/488964/
   。

AcWing 2306. K大数查询
作者：    yxc ,  2020-09-18 20:50:57 ,  阅读 56

1


#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 50010, P = N * 17 * 17, M = N * 4;

int n, m;
struct Tree
{
    int l, r, sum, add;
}tr[P];
int L[M], R[M], T[M], idx;
struct Query
{
    int op, a, b, c;
}q[N];
vector<int> nums;

int get(int x)
{
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
}

void build(int u, int l, int r)
{
    L[u] = l, R[u] = r, T[u] = ++ idx;
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

int intersection(int a, int b, int c, int d)
{
    return min(b, d) - max(a, c) + 1;
}

void update(int u, int l, int r, int pl, int pr)
{
    tr[u].sum += intersection(l, r, pl, pr);
    if (l >= pl && r <= pr)
    {
        tr[u].add ++ ;
        return;
    }
    int mid = l + r >> 1;
    if (pl <= mid)
    {
        if (!tr[u].l) tr[u].l = ++ idx;
        update(tr[u].l, l, mid, pl, pr);
    }
    if (pr > mid)
    {
        if (!tr[u].r) tr[u].r = ++ idx;
        update(tr[u].r, mid + 1, r, pl, pr);
    }
}

void change(int u, int a, int b, int c)
{
    update(T[u], 1, n, a, b);
    if (L[u] == R[u]) return;
    int mid = L[u] + R[u] >> 1;
    if (c <= mid) change(u << 1, a, b, c);
    else change(u << 1 | 1, a, b, c);
}

int get_sum(int u, int l, int r, int pl, int pr, int add)
{
    if (l >= pl && r <= pr) return tr[u].sum + (r - l + 1) * add;
    int mid = l + r >> 1, res = 0;
    add += tr[u].add;
    if (pl <= mid)
    {
        if (tr[u].l) res += get_sum(tr[u].l, l, mid, pl, pr, add);
        else res += intersection(l, mid, pl, pr) * add;
    }
    if (pr > mid)
    {
        if (tr[u].r) res += get_sum(tr[u].r, mid + 1, r, pl, pr, add);
        else res += intersection(mid + 1, r, pl, pr) * add;
    }
    return res;
}

int query(int u, int a, int b, int c)
{
    if (L[u] == R[u]) return R[u];
    int mid = L[u] + R[u] >> 1;
    int k = get_sum(T[u << 1 | 1], 1, n, a, b, 0);
    if (k >= c) return query(u << 1 | 1, a, b, c);
    return query(u << 1, a, b, c - k);
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i ++ )
    {
        scanf("%d%d%d%d", &q[i].op, &q[i].a, &q[i].b, &q[i].c);
        if (q[i].op == 1) nums.push_back(q[i].c);
    }
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    build(1, 0, nums.size() - 1);

    for (int i = 0; i < m; i ++ )
    {
        int op = q[i].op, a = q[i].a, b = q[i].b, c = q[i].c;
        if (op == 1) change(1, a, b, get(c));
        else printf("%d\n", nums[query(1, a, b, c)]);
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/489058/
   。

AcWing 243. 一个简单的整数问题2    原题链接    困难
作者：    秦淮岸灯火阑珊 ,  2019-02-13 20:39:27 ,  阅读 1445

5


2
题目描述
给定一个长度为N的数列A，以及M条指令，每条指令可能是以下两种之一：

1、“C l r d”，表示把 A[l],A[l+1],…,A[r] 都加上 d。

2、“Q l r”，表示询问 数列中第 l~r 个数的和。

对于每个询问，输出一个整数表示答案。

输入格式
第一行两个整数N,M。

第二行N个整数A[i]。

接下来M行表示M条指令，每条指令的格式如题目描述所示。

输出格式
对于每个询问，输出一个整数表示答案。

每个答案占一行。

数据范围
1≤N,M≤1051≤N,M≤105,
|d|≤10000|d|≤10000,
|A[i]|≤1000000000|A[i]|≤1000000000
样例
输入样例：
10 5
1 2 3 4 5 6 7 8 9 10
Q 4 4
Q 1 10
Q 2 4
C 3 6 3
Q 2 4
输出样例：
4
55
9
15
树状数组(区间修改+区间查询)
首先我们可以开一个数组B,然后对于每条C操作,我们直接利用前缀和的思想.
把b[l]+=d;
把b[r+1]-=d;
然后我们就成功达成成就,把维护序列的具体值,转化为维护指令的累计影响,每次操作的影响,在l处开始,然后在r+1处消除.然后就让单点修改可以维护区间修改.
现在b数组的前缀和就是∑xi=1b[i]∑i=1xb[i] 就是经过指令后a[x]增加的值,那么序列a的前缀和a[1~x]增加的值就是:
∑i=1x∑j=1ib[j]
∑i=1x∑j=1ib[j]
然后上式就可以转换为
∑i=1x∑j=1ib[j]=∑i=1x(x−i+1)×b[i]=(x+1)∑i=1xb[i]−∑i=1xi×b[i]
∑i=1x∑j=1ib[j]=∑i=1x(x−i+1)×b[i]=(x+1)∑i=1xb[i]−∑i=1xi×b[i]
然后通过上面这个式子,我们就把原来的数组,经过差分操作去维护两个树状数组，一个维护didi，一个维护di×idi×i这样的话,我们在区间修改的过程中,就可以在两个树状数组中去查询得到前缀和，然后同理,区间修改操作就是差分数组的修改,每次只需要修改两个点,完美的将区间再次转换为单调修改。
C++ 代码
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define lowbit(x) x&(-x)
const int N=2e5;
ll c1[N],c2[N],n,m,a[N];
ll add(ll x,ll y)
{
    for(ll i=x;i<=n;i+=lowbit(i))
    {
        c1[i]+=y;
        c2[i]+=x*y;
    }
}
ll ask(ll x)
{
    ll ans=0;
    for(ll i=x;i;i-=lowbit(i))
        ans+=(x+1)*c1[i]-c2[i];
    return ans;
}
int main()
{
    scanf("%lld%lld\n",&n,&m);
    for(ll i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        add(i,a[i]-a[i-1]);
    }
    getchar();
    while(m--)
    {
        char ch=getchar();
        if (ch=='Q')
        {
            ll x,y;
            scanf("%lld%lld\n",&x,&y);
            cout<<ask(y)-ask(x-1)<<endl;
        }
        if (ch=='C')
        {
            ll x,y,d;
            scanf("%lld%lld%lld\n",&x,&y,&d);
            add(x,d);
            add(y+1,-d);
        }
    }
    return 0;
}
感谢lcf大佬的博客
感谢lyd大佬的蓝书

作者：秦淮岸灯火阑珊
链接：https://www.acwing.com/solution/content/1011/
   。
AcWing 947. 文本编辑器    原题链接    中等
作者：    whsstory ,  2020-09-22 16:02:51 ,  阅读 52

7


题意就是要写一个支持一个能插入一堆数，删除一堆数，且可以随机访问的数据结构。

块状链表是很好的工具，大体思路是维护L‾‾√L个块，块内用数组，块之间用链表连接。

具体做法：

维护两个变量pos1,pos2pos1,pos2表示当前光标在第pos1pos1个块的第pos2pos2个元素后面

对于Insert操作，暴力在pos2pos2后面加入这个字符，但如果现在的块长超过了L‾‾√L(我取了2000)，就拆出一个新的块，在链表上修改前驱后继，然后在这个块里面继续插入字符（注意不能改pos1,pos2pos1,pos2)

对于delete操作，从pos2pos2后面开始删除，删完了就通过链表找到下一个块，继续。

对于get操作，从pos2pos2后面开始输出，输完了就通过链表找到下一个块，继续。

对于Move操作，从第一个块开始，顺着链表往后走就好了。

Prev,Nxt就就从现在的位置往前/往后走就好了，注意如果走到了空的块要跳过

分析一下复杂度：

先分析块的规模：首先每个块长度不超过2000.Insert的字符数量不超过2097152,且次数不超过4000，因此块的数量不超过6000.

Insert操作：总字符不超过2097152，次数不超过4000，没有问题。

delete操作：次数不超过4000，至多删掉所有字符，没有问题；又因为我们对delete的处理不增加新的块，所以块的规模不增大。

get操作：至多输出3M个字符，没有问题。

Move操作：代价不超过块的数量，即6000.

Prev，Nxt代价不超过块的数量，即6000。

因此复杂度没有问题。（因此本题甚至不需要将小的块合并也是可以的）

代码细节较多，要耐心写。

#define MAXN 4000011
#define MAXC 400011
int lim=2000, T,n,len;
int pre[MAXC],nxt[MAXC],pos1,pos2;
std::vector<char>ch[MAXC],tp;
char s[MAXC],a[MAXN];
int newnode(int x)
{
    ++n;
    pre[n]=x,nxt[n]=nxt[x];
    pre[nxt[x]]=n,nxt[x]=n;
    return n;
}

void Move(int x)
{
    ++x;
    for(int i=1;i;i=nxt[i])
        if(ch[i].size()>=x){pos1=i, pos2=x;return;}
        else x-=ch[i].size();
    puts("???");
}
void Insert()
{
    tp.clear();
    for(int i=pos2;i<ch[pos1].size();++i)tp.push_back(ch[pos1][i]);
    ch[pos1].resize(pos2);
    int p=pos1;
    for(int i=1;i<=len;++i)
    {
        if(ch[p].size()>=lim)p=newnode(p);
        ch[p].push_back(a[i]);
    }
    for(char x:tp)
    {
        if(ch[p].size()>=lim)p=newnode(p);
        ch[p].push_back(x);
    }
}
void Remove()
{
    int p=pos1,it=pos2;
    while(len)
    {
        int rest=int(ch[p].size())-it;
        if(rest<=len)ch[p].resize(it),len-=rest;
        else
        {
            for(int i=it+1;i<=it+rest-len;++i)ch[p][i-1]=ch[p][i+len-1];
            ch[p].resize(it+rest-len);
            len=0;
        }
        it=0,p=nxt[p];
    }
}
void Get(int x)
{
    int p=pos1,it=pos2;
    while(x)
    {
        int rest=int(ch[p].size())-it;
        if(rest<=x)
        {
            for(int i=it;i<ch[p].size();++i)putchar(ch[p][i]);
            x-=rest;
        }
        else
        {
            for(int i=it;i<it+x;++i)putchar(ch[p][i]);
            x=0;
        }
        it=0,p=nxt[p];
    }
    puts("");
}
void Prev()
{
    --pos2;
    while(pos2==0)pos1=pre[pos1],pos2=ch[pos1].size();
}
void Nextv()
{
    ++pos2;
    while(pos2>ch[pos1].size())pos1=nxt[pos1],pos2=1;
}
int main()
{
    T=read();
    pos1=n=1;
    ch[pos1].push_back(32),pos2=1;
    while(T--)
    {
        scanf("%s",s+1);
        if(s[1]=='M')Move(read());
        else if(s[1]=='I')
        {
            len=read();
            for(int i=1;i<=len;++i)
            {
                char c=getchar();
                while(c=='\n'||c=='\r')c=getchar();
                a[i]=c;
            }
            Insert();
        }
        else if(s[1]=='D'){len=read();Remove();}
        else if(s[1]=='G')Get(read());
        else if(s[1]=='P')Prev();
        else Nextv();
    }
    return 0;
}

作者：whsstory
链接：https://www.acwing.com/solution/content/21163/
   。
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 2000, M = 2010;

int n, x, y;
struct Node
{
    char s[N + 1];
    int c, l, r;
}p[M];
char str[2000010];
int q[M], tt;  // 内存回收

void move(int k)  // 移到第k个字符后面
{
    x = p[0].r;
    while (k > p[x].c) k -= p[x].c, x = p[x].r;
    y = k - 1;
}

void add(int x, int u)  // 将节点u插到节点x的右边
{
    p[u].r = p[x].r, p[p[u].r].l = u;
    p[x].r = u, p[u].l = x;
}

void del(int u)  // 删除节点u
{
    p[p[u].l].r = p[u].r;
    p[p[u].r].l = p[u].l;
    p[u].l = p[u].r = p[u].c = 0;  // 清空节点u
    q[ ++ tt] = u;  // 回收节点u
}

void insert(int k)  // 在光标后插入k个字符
{
    if (y < p[x].c - 1)  // 从光标处分裂
    {
        int u = q[tt -- ];  // 新建一个节点
        for (int i = y + 1; i < p[x].c; i ++ )
            p[u].s[p[u].c ++ ] = p[x].s[i];
        p[x].c = y + 1;
        add(x, u);
    }
    int cur = x;
    for (int i = 0; i < k;)
    {
        int u = q[tt -- ];  // 创建一个新的块
        while (p[u].c < N && i < k)
            p[u].s[p[u].c ++ ] = str[i ++ ];
        add(cur, u);
        cur = u;
    }
}

void remove(int k)  // 删除光标后的k个字符
{
    if (p[x].c - 1 - y >= k)  // 节点内删
    {
        for (int i = y + k + 1, j = y + 1; i < p[x].c; i ++, j ++ ) p[x].s[j] = p[x].s[i];
        p[x].c -= k;
    }
    else
    {
        k -= p[x].c - y - 1;  // 删除当前节点的剩余部分
        p[x].c = y + 1;
        while (p[x].r && k >= p[p[x].r].c)
        {
            int u = p[x].r;
            k -= p[u].c;
            del(u);
        }
        int u = p[x].r;  // 删除结尾节点的前半部分
        for (int i = 0, j = k; j < p[u].c; i ++, j ++ ) p[u].s[i] = p[u].s[j];
        p[u].c -= k;
    }
}

void get(int k)  // 返回从光标开始的k个字符
{
    if (p[x].c - 1 - y >= k)  // 节点内返回
    {
        for (int i = 0, j = y + 1; i < k; i ++, j ++ ) putchar(p[x].s[j]);
    }
    else
    {
        k -= p[x].c - y - 1;
        for (int i = y + 1; i < p[x].c; i ++ ) putchar(p[x].s[i]);  // 输出当前节点的剩余部分
        int cur = x;
        while (p[cur].r && k >= p[p[cur].r].c)
        {
            int u = p[cur].r;
            for (int i = 0; i < p[u].c; i ++ ) putchar(p[u].s[i]);
            k -= p[u].c;
            cur = u;
        }
        int u = p[cur].r;
        for (int i = 0; i < k; i ++ ) putchar(p[u].s[i]);
    }
    puts("");
}

void prev()  // 光标向前移动一位
{
    if (!y)
    {
        x = p[x].l;
        y = p[x].c - 1;
    }
    else y -- ;
}

void next()  // 光标向后移动一位
{
    if (y < p[x].c - 1) y ++ ;
    else
    {
        x = p[x].r;
        y = 0;
    }
}

void merge()  // 将长度较短的相邻节点合并，保证块状链表时间复杂度的核心
{
    for (int i = p[0].r; i; i = p[i].r)
    {
        while (p[i].r && p[i].c + p[p[i].r].c < N)
        {
            int r = p[i].r;
            for (int j = p[i].c, k = 0; k < p[r].c; j ++, k ++ )
                p[i].s[j] = p[r].s[k];
            if (x == r) x = i, y += p[i].c;  // 更新光标的位置
            p[i].c += p[r].c;
            del(r);
        }
    }
}

int main()
{
    for (int i = 1; i < M; i ++ ) q[ ++ tt] = i;
    scanf("%d", &n);
    char op[10];

    str[0] = '>';
    insert(1);  // 插入哨兵
    move(1);  // 将光标移动到哨兵后面

    while (n -- )
    {
        int a;
        scanf("%s", op);
        if (!strcmp(op, "Move"))
        {
            scanf("%d", &a);
            move(a + 1);
        }
        else if (!strcmp(op, "Insert"))
        {
            scanf("%d", &a);
            int i = 0, k = a;
            while (a)
            {
                str[i] = getchar();
                if (str[i] >= 32 && str[i] <= 126) i ++, a -- ;
            }
            insert(k);
            merge();
        }
        else if (!strcmp(op, "Delete"))
        {
            scanf("%d", &a);
            remove(a);
            merge();
        }
        else if (!strcmp(op, "Get"))
        {
            scanf("%d", &a);
            get(a);
        }
        else if (!strcmp(op, "Prev")) prev();
        else next();
    }

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/489888/
   。

AcWing 2492. HH的项链
作者：    yxc ,  2020-09-25 19:43:25 ,  阅读 46

2


#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 50010, M = 200010, S = 1000010;

int n, m, len;
int w[N], ans[M];
struct Query
{
    int id, l, r;
}q[M];
int cnt[S];

int get(int x)
{
    return x / len;
}

bool cmp(const Query& a, const Query& b)
{
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    return a.r < b.r;
}

void add(int x, int& res)
{
    if (!cnt[x]) res ++ ;
    cnt[x] ++ ;
}

void del(int x, int& res)
{
    cnt[x] -- ;
    if (!cnt[x]) res -- ;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    scanf("%d", &m);
    len = sqrt((double)n * n / m);

    for (int i = 0; i < m; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        q[i] = {i, l, r};
    }
    sort(q, q + m, cmp);

    for (int k = 0, i = 0, j = 1, res = 0; k < m; k ++ )
    {
        int id = q[k].id, l = q[k].l, r = q[k].r;
        while (i < r) add(w[ ++ i], res);
        while (i > r) del(w[i -- ], res);
        while (j < l) del(w[j ++ ], res);
        while (j > l) add(w[ -- j], res);
        ans[id] = res;
    }

    for (int i = 0; i < m; i ++ ) printf("%d\n", ans[i]);
    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/499980/
   。
AcWing 2521. 数颜色（不用莫队，可区间修改）    原题链接    困难
作者：    whsstory ,  2020-09-26 14:58:54 ,  阅读 30

5


数颜色（不用莫队，可区间修改）
注意到修改操作很少，那么以修改操作为划分点，我们得到若干个只有询问的区间。对于这些区间，直接做静态区间元素种类计数（就是按右端点排序然后树状数组的那个解法），做完一个区间后暴力执行修改。

记询问次数是QQ,修改操作是MM,则复杂度上界为(NM+Q(logn+logQ))O(NM+Q(log⁡n+log⁡Q)).

拓展：

区间修改：反正我们的修改都是暴力修改，区间修改不会增大复杂度

此外，还可以通过根号重构做到大约O((M+Q)(M+Q‾‾‾‾‾‾‾√)O((M+Q)(M+Q),但似乎不好写。

#define MAXN 20011
int fx[MAXN], diff;
int place(int val){return std::lower_bound(fx+1,fx+diff+1,val)-fx;}
struct BIT
{
    int t[MAXN];
    #define lowb (i&-i)
    void modify(int i,int k)
    {
        while(i<=diff)t[i]+=k,i+=lowb;
    }
    int Qsum(int i)
    {
        int res=0;
        while(i)res+=t[i],i-=lowb;
        return res;
    }
}t;
struct one
{
    int type,x,y,dex;
    bool operator <(const one& you)const{return y<you.y;}
}q[MAXN];
int a[MAXN],last[MAXN],ans[MAXN];
int Get(){char c=getchar();while(c<'A'||c>'Z')c=getchar();return c=='Q'?1:0;}
int main()
{
    int n=read(),m=read();
    for(int i=1;i<=n;++i)fx[++diff]=a[i]=read();
    for(int i=1;i<=m;++i)
    {
        q[i].type=Get(),q[i].x=read(),q[i].y=read(),q[i].dex=i;
        if(!q[i].type)fx[++diff]=q[i].y;
    }
    std::sort(fx+1,fx+diff+1),diff=std::unique(fx+1,fx+diff+1)-fx-1;
    for(int i=1;i<=n;++i)a[i]=place(a[i]);
    for(int i=1,j;i<=m;i=j)
    {
        j=i;
        while(j<=m&&q[j].type)++j;
        std::sort(q+i,q+j);
        int all=0;
        for(int x=1;x<=n;++x)
        {
            if(last[a[x]])t.modify(last[a[x]],-1),--all;
            t.modify(last[a[x]]=x,1),++all;
            while(i<j&&q[i].y==x){ans[q[i].dex]=all-t.Qsum(q[i].x-1);++i;}
        }
        for(int x=1;x<=diff;++x)
            if(last[x])t.modify(last[x],-1),last[x]=0;
        while(j<=m&&!q[j].type)a[q[j].x]=place(q[j].y),++j;
    }
    for(int i=1;i<=m;++i)
        if(q[i].type)printf("%d\n",ans[i]);
    return 0;

作者：whsstory
链接：https://www.acwing.com/solution/content/21419/
   。
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <vector>

using namespace std;

typedef long long LL;
const int N = 100010;

int n, m, len;
int w[N], cnt[N];
LL ans[N];
struct Query
{
    int id, l, r;
}q[N];
vector<int> nums;

int get(int x)
{
    return x / len;
}

bool cmp(const Query& a, const Query& b)
{
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    return a.r < b.r;
}

void add(int x, LL& res)
{
    cnt[x] ++ ;
    res = max(res, (LL)cnt[x] * nums[x]);
}

int main()
{
    scanf("%d%d", &n, &m);
    len = sqrt(n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]), nums.push_back(w[i]);
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    for (int i = 1; i <= n; i ++ )
        w[i] = lower_bound(nums.begin(), nums.end(), w[i]) - nums.begin();

    for (int i = 0; i < m; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        q[i] = {i, l, r};
    }
    sort(q, q + m, cmp);

    for (int x = 0; x < m;)
    {
        int y = x;
        while (y < m && get(q[y].l) == get(q[x].l)) y ++ ;
        int right = get(q[x].l) * len + len - 1;

        // 暴力求块内的询问
        while (x < y && q[x].r <= right)
        {
            LL res = 0;
            int id = q[x].id, l = q[x].l, r = q[x].r;
            for (int k = l; k <= r; k ++ ) add(w[k], res);
            ans[id] = res;
            for (int k = l; k <= r; k ++ ) cnt[w[k]] -- ;
            x ++ ;
        }

        // 求块外的询问
        LL res = 0;
        int i = right, j = right + 1;
        while (x < y)
        {
            int id = q[x].id, l = q[x].l, r = q[x].r;
            while (i < r) add(w[ ++ i], res);
            LL backup = res;
            while (j > l) add(w[ -- j], res);
            ans[id] = res;
            while (j < right + 1) cnt[w[j ++ ]] -- ;
            res = backup;
            x ++ ;
        }
        memset(cnt, 0, sizeof cnt);
    }

    for (int i = 0; i < m; i ++ ) printf("%lld\n", ans[i]);
    return 0;
}


作者：yxc
链接：https://www.acwing.com/activity/content/code/content/500112/
   。
AcWing 2534. 树上计数2
作者：    yxc ,  2020-09-28 19:46:10 ,  阅读 31

6


#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <vector>

using namespace std;

const int N = 100010;

int n, m, len;
int w[N];
int h[N], e[N], ne[N], idx;
int depth[N], f[N][16];
int seq[N], top, first[N], last[N];
int cnt[N], st[N], ans[N];
int que[N];
struct Query
{
    int id, l, r, p;
}q[N];
vector<int> nums;

void add_edge(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u, int father)
{
    seq[ ++ top] = u;
    first[u] = top;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j != father) dfs(j, u);
    }
    seq[ ++ top] = u;
    last[u] = top;
}

void bfs()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    int hh = 0, tt = 0;
    que[0] = 1;
    while (hh <= tt)
    {
        int t = que[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] > depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                f[j][0] = t;
                for (int k = 1; k <= 15; k ++ )
                    f[j][k] = f[f[j][k - 1]][k - 1];
                que[ ++ tt] = j;
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 15; k >= 0; k -- )
        if (depth[f[a][k]] >= depth[b])
            a = f[a][k];
    if (a == b) return a;
    for (int k = 15; k >= 0; k -- )
        if (f[a][k] != f[b][k])
        {
            a = f[a][k];
            b = f[b][k];
        }
    return f[a][0];
}

int get(int x)
{
    return x / len;
}

bool cmp(const Query& a, const Query& b)
{
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    return a.r < b.r;
}

void add(int x, int& res)
{
    st[x] ^= 1;
    if (st[x] == 0)
    {
        cnt[w[x]] -- ;
        if (!cnt[w[x]]) res -- ;
    }
    else
    {
        if (!cnt[w[x]]) res ++ ;
        cnt[w[x]] ++ ;
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]), nums.push_back(w[i]);
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    for (int i = 1; i <= n; i ++ )
        w[i] = lower_bound(nums.begin(), nums.end(), w[i]) - nums.begin();

    memset(h, -1, sizeof h);
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add_edge(a, b), add_edge(b, a);
    }

    dfs(1, -1);
    bfs();

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        if (first[a] > first[b]) swap(a, b);
        int p = lca(a, b);
        if (a == p) q[i] = {i, first[a], first[b]};
        else q[i] = {i, last[a], first[b], p};
    }

    len = sqrt(top);
    sort(q, q + m, cmp);

    for (int i = 0, L = 1, R = 0, res = 0; i < m; i ++ )
    {
        int id = q[i].id, l = q[i].l, r = q[i].r, p = q[i].p;
        while (R < r) add(seq[ ++ R], res);
        while (R > r) add(seq[R -- ], res);
        while (L < l) add(seq[L ++ ], res);
        while (L > l) add(seq[ -- L], res);
        if (p) add(p, res);
        ans[id] = res;
        if (p) add(p, res);
    }

    for (int i = 0; i < m; i ++ ) printf("%d\n", ans[i]);

    return 0;
}

作者：yxc
链接：https://www.acwing.com/activity/content/code/content/504559/
   。
AcWing 2535. 二次离线莫队
作者：    yxc ,  2020-09-28 20:38:35 ,  阅读 43

3


#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <vector>

using namespace std;

typedef long long LL;
const int N = 100010;

int n, m, k, len;
int w[N];
LL ans[N];
struct Query
{
    int id, l, r;
    LL res;
}q[N];
struct Range
{
    int id, l, r, t;
};
vector<Range> range[N];
int f[N], g[N];

inline int get_count(int x)
{
    int res = 0;
    while (x) res += x & 1, x >>= 1;
    return res;
}

inline int get(int x)
{
    return x / len;
}

bool cmp(const Query& a, const Query& b)
{
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    return a.r < b.r;
}

int main()
{
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    vector<int> nums;
    for (int i = 0; i < 1 << 14; i ++ )
        if (get_count(i) == k)
            nums.push_back(i);
    for (int i = 1; i <= n; i ++ )
    {
        for (auto y: nums) ++ g[w[i] ^ y];
        f[i] = g[w[i + 1]];
    }
    for (int i = 0; i < m; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        q[i] = {i, l, r};
    }
    len = sqrt(n);
    sort(q, q + m, cmp);

    for (int i = 0, L = 1, R = 0; i < m; i ++ )
    {
        int l = q[i].l, r = q[i].r;
        if (R < r) range[L - 1].push_back({i, R + 1, r, -1});
        while (R < r) q[i].res += f[R ++ ];
        if (R > r) range[L - 1].push_back({i, r + 1, R, 1});
        while (R > r) q[i].res -= f[ -- R];
        if (L < l) range[R].push_back({i, L, l - 1, -1});
        while (L < l) q[i].res += f[L - 1] + !k, L ++ ;
        if (L > l) range[R].push_back({i, l, L - 1, 1});
        while (L > l) q[i].res -= f[L - 2] + !k, L -- ;
    }

    memset(g, 0, sizeof g);
    for (int i = 1; i <= n; i ++ )
    {
        for (auto y: nums) ++ g[w[i] ^ y];
        for (auto& rg: range[i])
        {
            int id = rg.id, l = rg.l, r = rg.r, t = rg.t;
            for (int x = l; x <= r; x ++ )
                q[id].res += g[w[x]] * t;
        }
    }

    for (int i = 1; i < m; i ++ ) q[i].res += q[i - 1].res;
    for (int i = 0; i < m; i ++ ) ans[q[i].id] = q[i].res;
    for (int i = 0; i < m; i ++ ) printf("%lld\n", ans[i]);

    return 0;
}


作者：yxc
链接：https://www.acwing.com/activity/content/code/content/504670/
   。